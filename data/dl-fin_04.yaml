- en: Chapter 4\. Linear Algebra and Calculus for Deep Learning
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。深度学习的线性代数与微积分
- en: Algebra and calculus are integral parts of data science. Machine learning and
    deep learning algorithms are mostly based on algebra and calculus techniques.
    This chapter introduces some key topics in a way that everyone can understand.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 代数和微积分是数据科学的重要组成部分。机器学习和深度学习算法大部分基于代数和微积分技术。本章以易懂的方式介绍了一些关键主题。
- en: '*Algebra *is the study of operations and relational rules, as well as the constructions
    and ideas that result from them. Algebra covers topics such as linear equations
    and matrices. You can consider algebra as the first step toward calculus.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*代数*是研究运算和关系规则，以及由此产生的构造和思想的学科。代数涵盖了诸如线性方程和矩阵等主题。你可以将代数视为通向微积分的第一步。'
- en: '*Calculus *is the study of curve slopes and rates of change. Calculus covers
    topics such as derivatives and integrals. It is heavily used in many fields such
    as economics and engineering. Many learning algorithms rely on the concepts of
    calculus to perform their complex operations.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*微积分*是研究曲线斜率和变化率的学科。微积分涵盖了诸如导数和积分之类的主题。它在许多领域如经济学和工程学中被广泛应用。许多学习算法依赖微积分的概念来执行复杂的操作。'
- en: The distinction between the two is that while calculus works with ideas of change,
    motion, and accumulation, algebra deals with mathematical symbols and the rules
    for manipulating those symbols. Calculus focuses on the characteristics and behavior
    of changing functions, while algebra offers the foundation for solving equations
    and comprehending functions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间的区别在于，微积分处理变化、运动和累积的概念，而代数处理数学符号以及操纵这些符号的规则。微积分关注于变化函数的特性和行为，而代数则提供了解方程和理解函数的基础。
- en: Linear Algebra
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性代数
- en: Algebra encompasses various mathematical structures, including numbers, variables,
    and operations like addition, subtraction, multiplication, and division. *Linear
    algebra* is a fundamental branch of algebra that deals with vector spaces and
    linear transformations. It is heavily used in machine learning and deep learning
    for tasks such as data preprocessing, dimensionality reduction, and solving systems
    of linear equations. Matrices and vectors are central data structures in linear
    algebra, and operations like matrix multiplication are common in various algorithms.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 代数包含了各种数学结构，包括数字、变量以及加法、减法、乘法和除法等运算。*线性代数*是代数的一个基本分支，处理向量空间和线性变换。它在机器学习和深度学习中被广泛用于数据预处理、降维以及解线性方程组等任务。矩阵和向量是线性代数中的核心数据结构，矩阵乘法等操作在各种算法中很常见。
- en: Vectors and Matrices
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量和矩阵
- en: A *vector* is an object that has a magnitude (length) and a direction (arrowhead).
    The basic representation of a vector is an arrow with coordinates on the axis.
    But first, let’s see what an axis is.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*向量*是一个具有大小（长度）和方向（箭头）的对象。向量的基本表示是带有坐标的箭头。但首先，让我们看看什么是轴。
- en: The *x*-axis and *y*-axis are perpendicular lines that specify a plane’s boundaries
    and the locations of different points within them in a two-dimensional Cartesian
    coordinate system. The *x*-axis is horizontal and the *y*-axis is vertical.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*轴和*y*轴是垂直线，用于指定平面的边界以及其中不同点的位置，在二维笛卡尔坐标系中。*x*轴是水平的，*y*轴是垂直的。'
- en: These axes may represent vectors, with the *x*-axis representing the vector’s
    horizontal component and the *y*-axis representing its vertical component.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些轴可以表示向量，其中*x*轴代表向量的水平分量，*y*轴代表其垂直分量。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In time series analysis, the *x*-axis is typically the time step (hours, days,
    etc.), and the *y*-axis is the value at the respective time step (price, return,
    etc.).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间序列分析中，*x*轴通常是时间步长（小时、天等），而*y*轴是在相应时间步长（价格、收益等）处的值。
- en: '[Figure 4-1](#figure-4-1) shows a simple two-dimensional Cartesian coordinate
    system with both axes.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-1](#figure-4-1)展示了一个简单的二维笛卡尔坐标系，包括两个轴。'
- en: 'The two-dimensional Cartesian coordinate system uses simple parentheses to
    show the location of different points following this order:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 二维笛卡尔坐标系使用简单的括号来显示不同点的位置，遵循这个顺序：
- en: Point coordinates = (`x`, `y`)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点的坐标 = (`x`, `y`)
- en: The variable `x` represents the horizontal location
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量`x`代表水平位置
- en: The variable `y` represents the horizontal location
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量`y`代表水平位置
- en: '![](assets/dlff_0401.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dlff_0401.png)'
- en: Figure 4-1\. A two-dimensional Cartesian coordinate system
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-1\. 二维笛卡尔坐标系
- en: Therefore, if you want to draw point A, which has (2, 3) as coordinates, you
    are likely to look at a graph from point zero, move two points to the right, and
    from there, move three points upward. The result of the point should look like
    [Figure 4-2](#figure-4-2).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想要画出坐标为 (2, 3) 的点 A，你可能会从零点看一个图表，向右移动两个点，然后向上移动三个点。点的结果应该看起来像[图 4-2](#figure-4-2)。
- en: '![](assets/dlff_0402.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dlff_0402.png)'
- en: Figure 4-2\. The location of A on the coordinate system
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-2\. 点 A 在坐标系中的位置
- en: Let’s now add another point and draw a vector between them. Suppose you have
    point B with (4, 5) as coordinates. Naturally, as the coordinates of B are higher
    than the coordinates of A, you would expect vector AB to be upward sloping. [Figure 4-3](#figure-4-3)
    shows the new point B and vector AB.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加另一个点，并在它们之间画一个向量。假设你有坐标为 (4, 5) 的点 B。由于点 B 的坐标高于点 A 的坐标，你会预期向量 AB 呈现向上斜坡。[图 4-3](#figure-4-3)
    显示了新点 B 和向量 AB。
- en: '![](assets/dlff_0403.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dlff_0403.png)'
- en: Figure 4-3\. Vector AB joining points A and B together in magnitude and direction
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-3\. 向量 AB 在大小和方向上连接点 A 和点 B
- en: 'However, having drawn the vector using the coordinates of both points, how
    would you refer to the vector? Simply put, vector AB has its own coordinates that
    represent it. Remember that the vector is a representation of the movement from
    point A to point B. This means the two-point movement along the *x*-axis and the
    *y*-axis is the vector. Mathematically, to find the vector, you should subtract
    the two coordinate points from each other while respecting the direction. Here’s
    how to do that:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过使用两点的坐标画出向量后，你如何引用这个向量呢？简单地说，向量 AB 有其自己的坐标来表示它。请记住，向量是从点 A 到点 B 的移动表示。这意味着沿
    *x* 轴和 *y* 轴的双点移动就是向量。在数学上，为了找到向量，你应该从彼此的两个坐标点中减去它们，并尊重方向。以下是如何做到这一点的：
- en: '*Vector AB* means that you are going from A to B; therefore, you need to subtract
    the coordinates of point B from the coordinates of point A:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*向量 AB* 意味着你从点 A 到点 B；因此，你需要从点 B 的坐标中减去点 A 的坐标：'
- en: <math alttext="StartLayout 1st Row  ModifyingAbove upper A upper B With right-arrow
    equals mathematical left-angle 4 minus 2 comma 5 minus 3 mathematical right-angle
    2nd Row  ModifyingAbove upper A upper B With right-arrow equals mathematical left-angle
    2 comma 2 mathematical right-angle EndLayout"><mtable><mtr><mtd columnalign="left"><mrow><mover
    accent="true"><mrow><mi>A</mi><mi>B</mi></mrow> <mo>→</mo></mover> <mo>=</mo>
    <mrow><mo>〈</mo> <mn>4</mn> <mo>-</mo> <mn>2</mn> <mo>,</mo> <mn>5</mn> <mo>-</mo>
    <mn>3</mn> <mo>〉</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mover
    accent="true"><mrow><mi>A</mi><mi>B</mi></mrow> <mo>→</mo></mover> <mo>=</mo>
    <mrow><mo>〈</mo> <mn>2</mn> <mo>,</mo> <mn>2</mn> <mo>〉</mo></mrow></mrow></mtd></mtr></mtable></math>
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row  ModifyingAbove upper A upper B With right-arrow
    equals mathematical left-angle 4 minus 2 comma 5 minus 3 mathematical right-angle
    2nd Row  ModifyingAbove upper A upper B With right-arrow equals mathematical left-angle
    2 comma 2 mathematical right-angle EndLayout"><mtable><mtr><mtd columnalign="left"><mrow><mover
    accent="true"><mrow><mi>A</mi><mi>B</mi></mrow> <mo>→</mo></mover> <mo>=</mo>
    <mrow><mo>〈</mo> <mn>4</mn> <mo>-</mo> <mn>2</mn> <mo>,</mo> <mn>5</mn> <mo>-</mo>
    <mn>3</mn> <mo>〉</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mover
    accent="true"><mrow><mi>A</mi><mi>B</mi></mrow> <mo>→</mo></mover> <mo>=</mo>
    <mrow><mo>〈</mo> <mn>2</mn> <mo>,</mo> <mn>2</mn> <mo>〉</mo></mrow></mrow></mtd></mtr></mtable></math>
- en: '*Vector BA* means that you are going from B to A; therefore, you need to subtract
    the coordinates of point A from the coordinates of point B:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*向量 BA* 意味着你从点 B 到点 A；因此，你需要从点 A 的坐标中减去点 B 的坐标：'
- en: <math alttext="StartLayout 1st Row  ModifyingAbove upper B upper A With right-arrow
    equals mathematical left-angle 2 minus 4 comma 3 minus 5 mathematical right-angle
    2nd Row  ModifyingAbove upper B upper A With right-arrow equals mathematical left-angle
    negative 2 comma negative 2 mathematical right-angle EndLayout"><mtable><mtr><mtd
    columnalign="left"><mrow><mover accent="true"><mrow><mi>B</mi><mi>A</mi></mrow>
    <mo>→</mo></mover> <mo>=</mo> <mrow><mo>〈</mo> <mn>2</mn> <mo>-</mo> <mn>4</mn>
    <mo>,</mo> <mn>3</mn> <mo>-</mo> <mn>5</mn> <mo>〉</mo></mrow></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mover accent="true"><mrow><mi>B</mi><mi>A</mi></mrow>
    <mo>→</mo></mover> <mo>=</mo> <mrow><mo>〈</mo> <mo>-</mo> <mn>2</mn> <mo>,</mo>
    <mo>-</mo> <mn>2</mn> <mo>〉</mo></mrow></mrow></mtd></mtr></mtable></math>
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row  ModifyingAbove upper B upper A With right-arrow
    equals mathematical left-angle 2 minus 4 comma 3 minus 5 mathematical right-angle
    2nd Row  ModifyingAbove upper B upper A With right-arrow equals mathematical left-angle
    negative 2 comma negative 2 mathematical right-angle EndLayout"><mtable><mtr><mtd
    columnalign="left"><mrow><mover accent="true"><mrow><mi>B</mi><mi>A</mi></mrow>
    <mo>→</mo></mover> <mo>=</mo> <mrow><mo>〈</mo> <mn>2</mn> <mo>-</mo> <mn>4</mn>
    <mo>,</mo> <mn>3</mn> <mo>-</mo> <mn>5</mn> <mo>〉</mo></mrow></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mover accent="true"><mrow><mi>B</mi><mi>A</mi></mrow>
    <mo>→</mo></mover> <mo>=</mo> <mrow><mo>〈</mo> <mo>-</mo> <mn>2</mn> <mo>,</mo>
    <mo>-</mo> <mn>2</mn> <mo>〉</mo></mrow></mrow></mtd></mtr></mtable></math>
- en: To interpret the AB and BA vectors, you need to think in terms of movement.
    Vector AB represents going from point A to point B, two positive points horizontally
    and vertically (to the right and upward, respectively). Vector BA represents going
    from point B to point A, two negative points horizontally and vertically (to the
    left and downward, respectively).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要解释 AB 和 BA 向量，你需要从移动的角度思考。向量 AB 表示从点 A 到点 B，水平和垂直分别移动两个正向点（向右和向上）。向量 BA 表示从点
    B 到点 A，水平和垂直分别移动两个负向点（向左和向下）。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Vectors AB and BA are not the same thing even though they share the same slope.
    But what is a slope anyway?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 AB 向量和 BA 向量具有相同的斜率，但它们并不是同一物体。那么斜率到底是什么呢？
- en: 'The *slope* is the ratio of the vertical change between two points on the line
    to the horizontal change between the same two points. You calculate the slope
    using this mathematical formula:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*斜率* 是直线上两点之间的垂直变化与水平变化之比。你可以使用以下数学公式计算斜率：'
- en: <math alttext="StartLayout 1st Row  upper S l o p e equals StartFraction left-parenthesis
    normal upper Delta upper Y right-parenthesis Over left-parenthesis normal upper
    Delta upper X right-parenthesis EndFraction 2nd Row  upper S l o p e o f ModifyingAbove
    upper A upper B With right-arrow equals two-halves equals 1 3rd Row  upper S l
    o p e o f ModifyingAbove upper B upper A With right-arrow equals StartFraction
    negative 2 Over negative 2 EndFraction equals 1 EndLayout"><mtable><mtr><mtd columnalign="left"><mrow><mi>S</mi>
    <mi>l</mi> <mi>o</mi> <mi>p</mi> <mi>e</mi> <mo>=</mo> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><mrow><mo>(</mo><mi>Δ</mi><mi>Y</mi><mo>)</mo></mrow> <mrow><mo>(</mo><mi>Δ</mi><mi>X</mi><mo>)</mo></mrow></mfrac></mstyle></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>S</mi> <mi>l</mi> <mi>o</mi> <mi>p</mi>
    <mi>e</mi> <mi>o</mi> <mi>f</mi> <mover accent="true"><mrow><mi>A</mi><mi>B</mi></mrow>
    <mo>→</mo></mover> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mn>2</mn>
    <mn>2</mn></mfrac></mstyle> <mo>=</mo> <mn>1</mn></mrow></mtd></mtr> <mtr><mtd
    columnalign="left"><mrow><mi>S</mi> <mi>l</mi> <mi>o</mi> <mi>p</mi> <mi>e</mi>
    <mi>o</mi> <mi>f</mi> <mover accent="true"><mrow><mi>B</mi><mi>A</mi></mrow> <mo>→</mo></mover>
    <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mo>-</mo><mn>2</mn></mrow>
    <mrow><mo>-</mo><mn>2</mn></mrow></mfrac></mstyle> <mo>=</mo> <mn>1</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row  upper S l o p e equals StartFraction left-parenthesis
    normal upper Delta upper Y right-parenthesis Over left-parenthesis normal upper
    Delta upper X right-parenthesis EndFraction 2nd Row  upper S l o p e o f ModifyingAbove
    upper A upper B With right-arrow equals two-halves equals 1 3rd Row  upper S l
    o p e o f ModifyingAbove upper B upper A With right-arrow equals StartFraction
    negative 2 Over negative 2 EndFraction equals 1 EndLayout"><mtable><mtr><mtd columnalign="left"><mrow><mi>S</mi>
    <mi>l</mi> <mi>o</mi> <mi>p</mi> <mi>e</mi> <mo>=</mo> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><mrow><mo>(</mo><mi>Δ</mi><mi>Y</mi><mo>)</mo></mrow> <mrow><mo>(</mo><mi>Δ</mi><mi>X</mi><mo>)</mo></mrow></mfrac></mstyle></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>S</mi> <mi>l</mi> <mi>o</mi> <mi>p</mi>
    <mi>e</mi> <mi>o</mi> <mi>f</mi> <mover accent="true"><mrow><mi>A</mi><mi>B</mi></mrow>
    <mo>→</mo></mover> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mn>2</mn>
    <mn>2</mn></mfrac></mstyle> <mo>=</mo> <mn>1</mn></mrow></mtd></mtr> <mtr><mtd
    columnalign="left"><mrow><mi>S</mi> <mi>l</mi> <mi>o</mi> <mi>p</mi> <mi>e</mi>
    <mi>o</mi> <mi>f</mi> <mover accent="true"><mrow><mi>B</mi><mi>A</mi></mrow> <mo>→</mo></mover>
    <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mo>-</mo><mn>2</mn></mrow>
    <mrow><mo>-</mo><mn>2</mn></mrow></mfrac></mstyle> <mo>=</mo> <mn>1</mn></mrow></mtd></mtr></mtable></math>
- en: If the two vectors were simply lines (with no direction), then they would be
    the same object. However, adding the directional component makes them two distinguishable
    mathematical objects.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两个向量仅仅是线段（没有方向），那么它们将是相同的对象。然而，加上方向分量使它们成为两个可以区分的数学对象。
- en: '[Figure 4-4](#figure-4-4) sheds more light on the concept of the slope, as
    *x* has shifted two points to the right and *y* has shifted two points to the
    left.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-4](#figure-4-4) 更详细地解释了斜率的概念，*x* 向右移动了两个点，*y* 向左移动了两个点。'
- en: '![](assets/dlff_0404.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dlff_0404.png)'
- en: Figure 4-4\. The change in *x* and the change in *y* for vector AB
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-4\. 向量 AB 的 *x* 变化和 *y* 变化
- en: Note
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A vector that has a magnitude of 1 is referred to as a *unit vector*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 具有大小为 1 的向量被称为*单位向量*。
- en: '[Figure 4-5](#figure-4-5) shows the change in *x* and the change in *y* in
    the case of vector BA.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-5](#figure-4-5) 显示了向量 BA 的 *x* 变化和 *y* 变化情况。'
- en: '![](assets/dlff_0405.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dlff_0405.png)'
- en: Figure 4-5\. The change in *x* and the change in *y* for vector BA
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-5\. 向量 BA 的 *x* 变化和 *y* 变化
- en: Researchers typically use vectors as representations of speed, especially in
    engineering. Navigation is one field that heavily relies on vectors. It allows
    navigators to determine their positions and plan their destinations. Naturally,
    magnitude represents speed and the direction represents the destination.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员通常将向量用作速度的表示，尤其是在工程领域。导航是一个严重依赖向量的领域。它允许航海员确定其位置并规划其目的地。自然地，大小表示速度，方向表示目的地。
- en: You can add and subtract vectors from each other and from scalars. This allows
    for a shift in direction and magnitude. What you should retain from the previous
    discussion is that vectors indicate directions between different points on the
    axis.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以相互添加和减去向量，也可以与标量相加和减去向量。这允许在方向和大小上进行移动。您应该从前面的讨论中了解到，向量指示轴上不同点之间的方向。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A *scalar *is a value with magnitude but no direction. Scalars, as opposed to
    vectors, are used to represent elements, like temperature and prices. Basically,
    scalars are numbers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*标量*是具有大小但没有方向的值。与向量相反，标量用于表示元素，如温度和价格。基本上，标量就是数字。'
- en: 'A *matrix* is a rectangular array containing numbers and organized in rows
    and columns.^([1](ch04.html#id453)) Matrices are useful in computer graphics and
    other domains as well as to define and manipulate linear systems of equations.
    What differentiates a matrix from a vector? The simplest answer is that a vector
    is a matrix with a single column or a single row. Here’s a basic example of a
    3 × 3 matrix:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*矩阵*是一个包含数字并以行和列组织的矩形数组。[^1] 矩阵在计算机图形学和其他领域中都很有用，用来定义和操作线性方程组。矩阵与向量的区别是什么？最简单的答案是，向量是具有单列或单行的矩阵。这里是一个
    3 × 3 矩阵的基本示例：'
- en: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 5 2nd Column 2 3rd Column
    9 2nd Row 1st Column negative 8 2nd Column 10 3rd Column 13 3rd Row 1st Column
    1 2nd Column 5 3rd Column 12 EndMatrix"><mfenced close="]" open="["><mtable><mtr><mtd><mn>5</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>9</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>8</mn></mrow></mtd>
    <mtd><mn>10</mn></mtd> <mtd><mn>13</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>5</mn></mtd> <mtd><mn>12</mn></mtd></mtr></mtable></mfenced></math>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 5 2nd Column 2 3rd Column
    9 2nd Row 1st Column negative 8 2nd Column 10 3rd Column 13 3rd Row 1st Column
    1 2nd Column 5 3rd Column 12 EndMatrix"><mfenced close="]" open="["><mtable><mtr><mtd><mn>5</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>9</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>8</mn></mrow></mtd>
    <mtd><mn>10</mn></mtd> <mtd><mn>13</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>5</mn></mtd> <mtd><mn>12</mn></mtd></mtr></mtable></mfenced></math>
- en: 'The size of a matrix is the number of rows and columns it contains. A row is
    a horizontal line, and a column is a vertical line. The following representation
    is a 2 × 4 matrix (i.e., two rows by four columns):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的大小是它包含的行数和列数。行是水平线，列是垂直线。以下是一个 2 × 4 矩阵的表示（即两行四列）：
- en: <math alttext="Start 2 By 4 Matrix 1st Row 1st Column 5 2nd Column 2 3rd Column
    1 4th Column 3 2nd Row 1st Column negative 8 2nd Column 10 3rd Column 9 4th Column
    4 EndMatrix"><mfenced close="]" open="["><mtable><mtr><mtd><mn>5</mn></mtd> <mtd><mn>2</mn></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>8</mn></mrow></mtd>
    <mtd><mn>10</mn></mtd> <mtd><mn>9</mn></mtd> <mtd><mn>4</mn></mtd></mtr></mtable></mfenced></math>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 4 Matrix 1st Row 1st Column 5 2nd Column 2 3rd Column
    1 4th Column 3 2nd Row 1st Column negative 8 2nd Column 10 3rd Column 9 4th Column
    4 EndMatrix"><mfenced close="]" open="["><mtable><mtr><mtd><mn>5</mn></mtd> <mtd><mn>2</mn></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>8</mn></mrow></mtd>
    <mtd><mn>10</mn></mtd> <mtd><mn>9</mn></mtd> <mtd><mn>4</mn></mtd></mtr></mtable></mfenced></math>
- en: 'The following representation is a 4 × 2 matrix (i.e., four rows by two columns):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 4 × 2 矩阵的表示（即四行两列）：
- en: <math alttext="Start 4 By 2 Matrix 1st Row 1st Column 5 2nd Column 2 2nd Row
    1st Column negative 8 2nd Column 10 3rd Row 1st Column 8 2nd Column 22 4th Row
    1st Column 7 2nd Column 3 EndMatrix"><mfenced close="]" open="["><mtable><mtr><mtd><mn>5</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>8</mn></mrow></mtd>
    <mtd><mn>10</mn></mtd></mtr> <mtr><mtd><mn>8</mn></mtd> <mtd><mn>22</mn></mtd></mtr>
    <mtr><mtd><mn>7</mn></mtd> <mtd><mn>3</mn></mtd></mtr></mtable></mfenced></math>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 4 By 2 Matrix 1st Row 1st Column 5 2nd Column 2 2nd Row
    1st Column negative 8 2nd Column 10 3rd Row 1st Column 8 2nd Column 22 4th Row
    1st Column 7 2nd Column 3 EndMatrix"><mfenced close="]" open="["><mtable><mtr><mtd><mn>5</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>8</mn></mrow></mtd>
    <mtd><mn>10</mn></mtd></mtr> <mtr><mtd><mn>8</mn></mtd> <mtd><mn>22</mn></mtd></mtr>
    <mtr><mtd><mn>7</mn></mtd> <mtd><mn>3</mn></mtd></mtr></mtable></mfenced></math>
- en: Note
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Matrices are heavily used in machine learning. Rows generally represent time
    and columns represent features.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵在机器学习中被广泛使用。行通常表示时间，列表示特征。
- en: 'The summation of different matrices is straightforward but must be used only
    when the matrices match in size (which means they have the same number of columns
    and rows). For instance, let’s add the following two matrices:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 不同矩阵的加法很简单，但只能在矩阵大小相同时使用（即它们具有相同的列数和行数）。例如，让我们来加下面这两个矩阵：
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 2 2nd Row
    1st Column 5 2nd Column 8 EndMatrix plus Start 2 By 2 Matrix 1st Row 1st Column
    3 2nd Column 9 2nd Row 1st Column 1 2nd Column 5 EndMatrix equals Start 2 By 2
    Matrix 1st Row 1st Column 4 2nd Column 11 2nd Row 1st Column 6 2nd Column 13 EndMatrix"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>5</mn></mtd> <mtd><mn>8</mn></mtd></mtr></mtable></mfenced> <mo>+</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>9</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd> <mtd><mn>11</mn></mtd></mtr>
    <mtr><mtd><mn>6</mn></mtd> <mtd><mn>13</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 2 2nd Row
    1st Column 5 2nd Column 8 EndMatrix plus Start 2 By 2 Matrix 1st Row 1st Column
    3 2nd Column 9 2nd Row 1st Column 1 2nd Column 5 EndMatrix equals Start 2 By 2
    Matrix 1st Row 1st Column 4 2nd Column 11 2nd Row 1st Column 6 2nd Column 13 EndMatrix"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>5</mn></mtd> <mtd><mn>8</mn></mtd></mtr></mtable></mfenced> <mo>+</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>9</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd> <mtd><mn>11</mn></mtd></mtr>
    <mtr><mtd><mn>6</mn></mtd> <mtd><mn>13</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'You can see that to add two matrices, you simply have to add the numbers in
    the same positions. Now, if you try to add the next pair of matrices, you won’t
    be able to do it as there is a mismatch in what to add:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，要将两个矩阵相加，只需将相同位置的数字相加即可。现在，如果你试图添加下一对矩阵，你将无法做到，因为要添加的内容不匹配：
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 8 2nd Column 3 2nd Row
    1st Column 3 2nd Column 2 EndMatrix plus Start 3 By 2 Matrix 1st Row 1st Column
    3 2nd Column 9 2nd Row 1st Column 1 2nd Column 5 3rd Row 1st Column 5 2nd Column
    4 EndMatrix"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>8</mn></mtd>
    <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mo>+</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>9</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>5</mn></mtd></mtr> <mtr><mtd><mn>5</mn></mtd>
    <mtd><mn>4</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 8 2nd Column 3 2nd Row
    1st Column 3 2nd Column 2 EndMatrix plus Start 3 By 2 Matrix 1st Row 1st Column
    3 2nd Column 9 2nd Row 1st Column 1 2nd Column 5 3rd Row 1st Column 5 2nd Column
    4 EndMatrix"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>8</mn></mtd>
    <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mo>+</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>9</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>5</mn></mtd></mtr> <mtr><mtd><mn>5</mn></mtd>
    <mtd><mn>4</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'The subtraction of matrices is also straightforward and follows the same rules
    as the summation of matrices. Let’s take the following example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的减法也很简单，遵循与矩阵加法相同的规则。让我们来看一个例子：
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 5 2nd Column 2 2nd Row
    1st Column negative 8 2nd Column 10 EndMatrix minus Start 2 By 2 Matrix 1st Row
    1st Column 3 2nd Column 9 2nd Row 1st Column negative 1 2nd Column negative 5
    EndMatrix equals Start 2 By 2 Matrix 1st Row 1st Column 2 2nd Column negative
    7 2nd Row 1st Column negative 9 2nd Column 15 EndMatrix"><mrow><mfenced close="]"
    open="["><mtable><mtr><mtd><mn>5</mn></mtd> <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>8</mn></mrow></mtd> <mtd><mn>10</mn></mtd></mtr></mtable></mfenced> <mo>-</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>9</mn></mtd></mtr>
    <mtr><mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd> <mtd><mrow><mo>-</mo> <mn>5</mn></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>7</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>9</mn></mrow></mtd>
    <mtd><mn>15</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 5 2nd Column 2 2nd Row
    1st Column negative 8 2nd Column 10 EndMatrix minus Start 2 By 2 Matrix 1st Row
    1st Column 3 2nd Column 9 2nd Row 1st Column negative 1 2nd Column negative 5
    EndMatrix equals Start 2 By 2 Matrix 1st Row 1st Column 2 2nd Column negative
    7 2nd Row 1st Column negative 9 2nd Column 15 EndMatrix"><mrow><mfenced close="]"
    open="["><mtable><mtr><mtd><mn>5</mn></mtd> <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>8</mn></mrow></mtd> <mtd><mn>10</mn></mtd></mtr></mtable></mfenced> <mo>-</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>9</mn></mtd></mtr>
    <mtr><mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd> <mtd><mrow><mo>-</mo> <mn>5</mn></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>7</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>9</mn></mrow></mtd>
    <mtd><mn>15</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: Evidently, subtraction of matrices is also a summation of matrices with a change
    of signs in one of them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，矩阵的减法也是矩阵加法，只是其中一个矩阵中的数字变为相反数。
- en: 'Matrix multiplication by a scalar is quite simple. Let’s take the following
    example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 标量乘以矩阵非常简单。让我们看一个例子：
- en: <math alttext="3 times Start 2 By 2 Matrix 1st Row 1st Column 5 2nd Column 2
    2nd Row 1st Column 8 2nd Column 22 EndMatrix equals Start 2 By 2 Matrix 1st Row
    1st Column 15 2nd Column 6 2nd Row 1st Column 24 2nd Column 66 EndMatrix"><mrow><mn>3</mn>
    <mo>×</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>5</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>8</mn></mtd> <mtd><mn>22</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>15</mn></mtd> <mtd><mn>6</mn></mtd></mtr>
    <mtr><mtd><mn>24</mn></mtd> <mtd><mn>66</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="3 times Start 2 By 2 Matrix 1st Row 1st Column 5 2nd Column 2
    2nd Row 1st Column 8 2nd Column 22 EndMatrix equals Start 2 By 2 Matrix 1st Row
    1st Column 15 2nd Column 6 2nd Row 1st Column 24 2nd Column 66 EndMatrix"><mrow><mn>3</mn>
    <mo>×</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>5</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>8</mn></mtd> <mtd><mn>22</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>15</mn></mtd> <mtd><mn>6</mn></mtd></mtr>
    <mtr><mtd><mn>24</mn></mtd> <mtd><mn>66</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'So basically, you are multiplying every cell in the matrix by the scalar. Multiplying
    one matrix by another matrix is a bit more complicated as it uses the *dot product*
    method. First of all, to multiply two matrices together, they must satisfy this
    condition:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上是将矩阵中的每个单元格乘以标量。将一个矩阵乘以另一个矩阵稍微复杂一些，因为它使用*点积*方法。首先，要将两个矩阵相乘，它们必须满足以下条件：
- en: <math alttext="Matrix Subscript x y Baseline times Matrix Subscript y z Baseline
    equals Matrix Subscript x z"><mrow><msub><mtext>Matrix</mtext> <mrow><mi>x</mi><mi>y</mi></mrow></msub>
    <mo>×</mo> <msub><mtext>Matrix</mtext> <mrow><mi>y</mi><mi>z</mi></mrow></msub>
    <mo>=</mo> <msub><mtext>Matrix</mtext> <mrow><mi>x</mi><mi>z</mi></mrow></msub></mrow></math>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Matrix Subscript x y Baseline times Matrix Subscript y z Baseline
    equals Matrix Subscript x z"><mrow><msub><mtext>Matrix</mtext> <mrow><mi>x</mi><mi>y</mi></mrow></msub>
    <mo>×</mo> <msub><mtext>Matrix</mtext> <mrow><mi>y</mi><mi>z</mi></mrow></msub>
    <mo>=</mo> <msub><mtext>Matrix</mtext> <mrow><mi>x</mi><mi>z</mi></mrow></msub></mrow></math>
- en: 'This means that the first matrix must have a number of columns equal to the
    number of rows in the second matrix, and the resulting matrix from the dot product
    is a matrix that has the number of rows of the first matrix and the number of
    columns of the second matrix. The dot product is explained in the following example
    representation of a 1 × 3 and 3 × 1 matrix multiplication (notice the equal number
    of columns and rows):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着第一个矩阵的列数必须等于第二个矩阵的行数，并且点积的结果矩阵是第一个矩阵的行数和第二个矩阵的列数。点积在以下示例中表示为1 × 3和3 × 1矩阵乘法的例子（注意列数和行数相等）：
- en: <math alttext="Start 1 By 3 Matrix 1st Row 1st Column 1 2nd Column 2 3rd Column
    3 EndMatrix times Start 3 By 1 Matrix 1st Row  3 2nd Row  2 3rd Row  1 EndMatrix
    equals Start 1 By 1 Matrix 1st Row  left-parenthesis 1 times 3 right-parenthesis
    plus left-parenthesis 2 times 2 right-parenthesis plus left-parenthesis 3 times
    1 right-parenthesis EndMatrix equals Start 1 By 1 Matrix 1st Row  10 EndMatrix"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>3</mn></mtd></mtr></mtable></mfenced>
    <mo>×</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mo>(</mo> <mn>1</mn>
    <mo>×</mo> <mn>3</mn> <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>2</mn> <mo>×</mo> <mn>2</mn>
    <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>3</mn> <mo>×</mo> <mn>1</mn> <mo>)</mo></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>10</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 1 By 3 Matrix 1st Row 1st Column 1 2nd Column 2 3rd Column
    3 EndMatrix times Start 3 By 1 Matrix 1st Row  3 2nd Row  2 3rd Row  1 EndMatrix
    equals Start 1 By 1 Matrix 1st Row  left-parenthesis 1 times 3 right-parenthesis
    plus left-parenthesis 2 times 2 right-parenthesis plus left-parenthesis 3 times
    1 right-parenthesis EndMatrix equals Start 1 By 1 Matrix 1st Row  10 EndMatrix"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>3</mn></mtd></mtr></mtable></mfenced>
    <mo>×</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mo>(</mo> <mn>1</mn>
    <mo>×</mo> <mn>3</mn> <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>2</mn> <mo>×</mo> <mn>2</mn>
    <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>3</mn> <mo>×</mo> <mn>1</mn> <mo>)</mo></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>10</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'Now let’s take an example of a 2 × 2 matrix multiplication:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一个2 × 2矩阵乘法的例子：
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 2 2nd Row
    1st Column 0 2nd Column 1 EndMatrix times Start 2 By 2 Matrix 1st Row 1st Column
    3 2nd Column 0 2nd Row 1st Column 2 2nd Column 1 EndMatrix equals Start 2 By 2
    Matrix 1st Row 1st Column 7 2nd Column 2 2nd Row 1st Column 2 2nd Column 1 EndMatrix"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced> <mo>×</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>7</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 2 2nd Row
    1st Column 0 2nd Column 1 EndMatrix times Start 2 By 2 Matrix 1st Row 1st Column
    3 2nd Column 0 2nd Row 1st Column 2 2nd Column 1 EndMatrix equals Start 2 By 2
    Matrix 1st Row 1st Column 7 2nd Column 2 2nd Row 1st Column 2 2nd Column 1 EndMatrix"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced> <mo>×</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>7</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'There is a special type of matrix called the *identity matrix*, which is basically
    the number 1 for matrices. It is defined as follows for a 2 × 2 dimension:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊类型的矩阵称为*单位矩阵*，它基本上是矩阵的数字1。对于2 × 2维度，它定义如下：
- en: <math alttext="upper I equals Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column
    0 2nd Row 1st Column 0 2nd Column 1 EndMatrix"><mrow><mi>I</mi> <mo>=</mo> <mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper I equals Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column
    0 2nd Row 1st Column 0 2nd Column 1 EndMatrix"><mrow><mi>I</mi> <mo>=</mo> <mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'and as follows for a 3 × 3 dimension:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于3 × 3维度如下：
- en: <math alttext="upper I equals Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column
    0 3rd Column 0 2nd Row 1st Column 0 2nd Column 1 3rd Column 0 3rd Row 1st Column
    0 2nd Column 0 3rd Column 1 EndMatrix"><mrow><mi>I</mi> <mo>=</mo> <mfenced close="]"
    open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper I equals Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column
    0 3rd Column 0 2nd Row 1st Column 0 2nd Column 1 3rd Column 0 3rd Row 1st Column
    0 2nd Column 0 3rd Column 1 EndMatrix"><mrow><mi>I</mi> <mo>=</mo> <mfenced close="]"
    open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'Multiplying any matrix by the identity matrix yields the same original matrix.
    This is why it can be referred to as the 1 of matrices (multiplying any number
    by 1 yields the same number). It is worth noting that matrix multiplication is
    not commutative, which means that the order of multiplication changes the result:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何矩阵乘以单位矩阵会产生相同的原始矩阵。这就是为什么它可以被称为矩阵的单位元（将任何数字乘以1会得到相同的数字）。值得注意的是矩阵乘法不是可交换的，这意味着乘法顺序改变结果：
- en: <math alttext="upper A upper B not-equals upper B upper A"><mrow><mi>A</mi>
    <mi>B</mi> <mo>≠</mo> <mi>B</mi> <mi>A</mi></mrow></math>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper A upper B not-equals upper B upper A"><mrow><mi>A</mi>
    <mi>B</mi> <mo>≠</mo> <mi>B</mi> <mi>A</mi></mrow></math>
- en: '*Matrix transposing* is a process that involves changing the rows into columns
    and vice versa. The transpose of a matrix is obtained by reflecting the matrix
    along its main diagonal:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*矩阵转置*是一个过程，涉及将行变为列，反之亦然。矩阵的转置是通过沿其主对角线反射矩阵而获得的：'
- en: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 4 2nd Column 6 3rd Column
    1 2nd Row 1st Column 1 2nd Column 4 3rd Column 2 EndMatrix Superscript upper T
    Baseline equals Start 3 By 2 Matrix 1st Row 1st Column 4 2nd Column 1 2nd Row
    1st Column 6 2nd Column 4 3rd Row 1st Column 1 2nd Column 2 EndMatrix"><mrow><msup><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd><mtd><mn>6</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><mn>4</mn></mtd><mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mi>T</mi></msup> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>6</mn></mtd> <mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 4 2nd Column 6 3rd Column
    1 2nd Row 1st Column 1 2nd Column 4 3rd Column 2 EndMatrix Superscript upper T
    Baseline equals Start 3 By 2 Matrix 1st Row 1st Column 4 2nd Column 1 2nd Row
    1st Column 6 2nd Column 4 3rd Row 1st Column 1 2nd Column 2 EndMatrix"><mrow><msup><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd><mtd><mn>6</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><mn>4</mn></mtd><mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mi>T</mi></msup> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>6</mn></mtd> <mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'Transposing is used in some machine learning algorithms and is not an uncommon
    operation when dealing with such models. If you are wondering about the role of
    matrices in data science and machine learning, you can refer to this nonexhaustive
    list:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些机器学习算法中使用了转置操作，处理这些模型时不是一个罕见的操作。如果你想了解矩阵在数据科学和机器学习中的角色，可以参考这个非详尽的列表：
- en: Representation of data
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 数据表示
- en: Matrices often represent data with rows representing samples and columns representing
    features. For example, a row in a matrix can present OHLC data in one time step.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵通常用来表示数据，其中行代表样本，列代表特征。例如，矩阵中的一行可以表示一个时间步中的OHLC数据。
- en: Linear algebra
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数
- en: Matrices and linear algebra are intertwined, and many learning algorithms use
    the concepts of matrices in their operations. Having a basic understanding of
    these mathematical concepts helps smooth the learning curve when dealing with
    machine learning algorithms.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵和线性代数是紧密相关的，许多学习算法在其操作中使用了矩阵的概念。对这些数学概念有基本的理解有助于在处理机器学习算法时平滑学习曲线。
- en: Data relationship matrices
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 数据关系矩阵
- en: Covariance and correlation measures are often represented as matrices. These
    relationship calculations are important concepts in time series analysis.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 协方差和相关性度量通常表示为矩阵。这些关系计算是时间序列分析中的重要概念。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The key takeaways from this section are as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的关键要点如下：
- en: A vector is an object that has a magnitude (length) and a direction (arrowhead).
    Multiple vectors grouped together form a matrix.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量是一个具有大小（长度）和方向（箭头）的对象。多个向量组合在一起形成一个矩阵。
- en: A matrix can be used to store data. It has its special ways of performing operations.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵可以用来存储数据。它有其特殊的执行操作方式。
- en: Matrix multiplication uses the dot product method.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵乘法使用点积方法。
- en: Transposing a matrix means to swap its rows and its columns.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转置矩阵意味着交换其行和列。
- en: Introduction to Linear Equations
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性方程介绍
- en: You saw an example of a linear equation in [“Regression Analysis and Statistical
    Inference”](ch03.html#regression_analysis). *Linear equations* are basically formulas
    that present an equality relationship between different variables and constants.
    In the case of machine learning, it is often a relationship between a dependent
    variable (the output) and an independent variable (the input). The best way to
    understand linear equations is through examples.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[“回归分析和统计推断”](ch03.html#regression_analysis)中看到了线性方程的一个例子。*线性方程*基本上是介绍不同变量和常数之间平等关系的公式。在机器学习中，它通常是依赖变量（输出）和自变量（输入）之间的关系。理解线性方程的最佳方法是通过示例。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The aim of linear equations is to find an unknown variable, usually denoted
    by the letter *x*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 线性方程的目标是找到一个未知变量，通常用字母*x*表示。
- en: 'We’ll start with a very basic example that you can consider as a first building
    block toward the more advanced concepts you will see later on. The following example
    requires finding the value of *x* that satisfies the equation:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个非常基础的例子开始，你可以将其视为以后将要看到的更高级概念的第一个构建块。 下面的例子要求找到满足方程的*x*的值：
- en: <math alttext="10 x equals 20"><mrow><mn>10</mn> <mi>x</mi> <mo>=</mo> <mn>20</mn></mrow></math>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="10 x equals 20"><mrow><mn>10</mn> <mi>x</mi> <mo>=</mo> <mn>20</mn></mrow></math>
- en: You should understand the equation as “*10 times which number equals 20?*” When
    a constant is directly attached to a variable such as *x*, it refers to a multiplication
    operation. Now, to solve for *x* (i.e., finding the value of *x* that equalizes
    the equation), you have an obvious solution, which is to get rid of 10 so that
    you have *x* on one side of the equation and the rest on the other side.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该理解方程为“*10乘以哪个数等于20？*” 当一个常数直接附加到变量（比如*x*）上时，它指的是一个乘法操作。现在，要解出*x*（即找到使方程相等的*x*的值），你有一个明显的解决方案，就是去掉10，这样你就在方程的一边得到*x*，另一边得到剩下的部分。
- en: 'Naturally, to get rid of 10, you divide by 10 so that what remains is 1, which
    if multiplied by the variable *x* does nothing. However, keep in mind two important
    things:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，要摆脱10，你需要除以10，这样剩下的就是1，如果与变量*x*相乘则无效。 但请记住两件重要的事情：
- en: If you do a mathematical operation on one side of an equation, you must do it
    on the other side as well. This is why they are called equations.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在方程的一边进行数学运算，那么你必须在另一边也这样做。 这就是它们被称为方程的原因。
- en: For simplicity, instead of dividing by the constant to get rid of it, you should
    multiply it by its reciprocal.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了简单起见，不要除以常数以摆脱它，你应该乘以它的倒数。
- en: 'The *reciprocal* of a number is 1 divided by that number. Here’s the mathematical
    representation of it:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数的*倒数*是1除以该数。 这是它的数学表示：
- en: <math alttext="upper R e c i p r o c a l left-parenthesis x right-parenthesis
    equals StartFraction 1 Over x EndFraction"><mrow><mi>R</mi> <mi>e</mi> <mi>c</mi>
    <mi>i</mi> <mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>c</mi> <mi>a</mi> <mi>l</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <mi>x</mi></mfrac></mrow></math>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper R e c i p r o c a l left-parenthesis x right-parenthesis
    equals StartFraction 1 Over x EndFraction"><mrow><mi>R</mi> <mi>e</mi> <mi>c</mi>
    <mi>i</mi> <mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>c</mi> <mi>a</mi> <mi>l</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <mi>x</mi></mfrac></mrow></math>
- en: 'Now, back to the example, to find *x* you can do the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到例子中，要找到*x*，你可以这样做：
- en: <math alttext="left-parenthesis one-tenth right-parenthesis 10 x equals 20 left-parenthesis
    one-tenth right-parenthesis"><mrow><mrow><mo>(</mo> <mfrac><mn>1</mn> <mn>10</mn></mfrac>
    <mo>)</mo></mrow> <mn>10</mn> <mi>x</mi> <mo>=</mo> <mn>20</mn> <mrow><mo>(</mo>
    <mfrac><mn>1</mn> <mn>10</mn></mfrac> <mo>)</mo></mrow></mrow></math>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="left-parenthesis one-tenth right-parenthesis 10 x equals 20 left-parenthesis
    one-tenth right-parenthesis"><mrow><mrow><mo>(</mo> <mfrac><mn>1</mn> <mn>10</mn></mfrac>
    <mo>)</mo></mrow> <mn>10</mn> <mi>x</mi> <mo>=</mo> <mn>20</mn> <mrow><mo>(</mo>
    <mfrac><mn>1</mn> <mn>10</mn></mfrac> <mo>)</mo></mrow></mrow></math>
- en: 'Performing the multiplication and simplifying gives the following result:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 进行乘法并简化后得到以下结果：
- en: <math alttext="x equals 2"><mrow><mi>x</mi> <mo>=</mo> <mn>2</mn></mrow></math>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x equals 2"><mrow><mi>x</mi> <mo>=</mo> <mn>2</mn></mrow></math>
- en: 'This means that the solution of the equation is 2\. To verify this, you just
    need to plug 2 into the original equation as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着方程的解为2。 要验证这一点，你只需将2插入到原始方程中如下所示：
- en: <math alttext="10 times 2 equals 20"><mrow><mn>10</mn> <mo>×</mo> <mn>2</mn>
    <mo>=</mo> <mn>20</mn></mrow></math>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="10 times 2 equals 20"><mrow><mn>10</mn> <mo>×</mo> <mn>2</mn>
    <mo>=</mo> <mn>20</mn></mrow></math>
- en: Therefore, it takes two 10s to get 20.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，需要两个10才能得到20。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Dividing the number by itself is the same thing as multiplying it by its reciprocal.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字除以它本身等同于乘以它的倒数。
- en: 'Let’s take another example of how to solve *x* through linear techniques. Consider
    the following problem:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个如何通过线性技术解决*x*的例子。 考虑以下问题：
- en: <math alttext="eight-sixths x equals 24"><mrow><mfrac><mn>8</mn> <mn>6</mn></mfrac>
    <mi>x</mi> <mo>=</mo> <mn>24</mn></mrow></math>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="eight-sixths x equals 24"><mrow><mfrac><mn>8</mn> <mn>6</mn></mfrac>
    <mi>x</mi> <mo>=</mo> <mn>24</mn></mrow></math>
- en: 'Performing the multiplication and simplifying gives the following result:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 进行乘法并简化后得到以下结果：
- en: <math alttext="left-parenthesis six-eighths right-parenthesis eight-sixths x
    equals 24 left-parenthesis six-eighths right-parenthesis"><mrow><mrow><mo>(</mo>
    <mfrac><mn>6</mn> <mn>8</mn></mfrac> <mo>)</mo></mrow> <mfrac><mn>8</mn> <mn>6</mn></mfrac>
    <mi>x</mi> <mo>=</mo> <mn>24</mn> <mrow><mo>(</mo> <mfrac><mn>6</mn> <mn>8</mn></mfrac>
    <mo>)</mo></mrow></mrow></math>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="left-parenthesis six-eighths right-parenthesis eight-sixths x
    equals 24 left-parenthesis six-eighths right-parenthesis"><mrow><mrow><mo>(</mo>
    <mfrac><mn>6</mn> <mn>8</mn></mfrac> <mo>)</mo></mrow> <mfrac><mn>8</mn> <mn>6</mn></mfrac>
    <mi>x</mi> <mo>=</mo> <mn>24</mn> <mrow><mo>(</mo> <mfrac><mn>6</mn> <mn>8</mn></mfrac>
    <mo>)</mo></mrow></mrow></math>
- en: <math alttext="x equals 18"><mrow><mi>x</mi> <mo>=</mo> <mn>18</mn></mrow></math>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x equals 18"><mrow><mi>x</mi> <mo>=</mo> <mn>18</mn></mrow></math>
- en: 'This means that the solution of the equation is 18\. To verify this, you just
    need to plug 18 into the original equation as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着方程的解为18。 要验证这一点，你只需将18插入到原始方程中如下所示：
- en: <math alttext="eight-sixths times 18 equals 24"><mrow><mfrac><mn>8</mn> <mn>6</mn></mfrac>
    <mo>×</mo> <mn>18</mn> <mo>=</mo> <mn>24</mn></mrow></math>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="eight-sixths times 18 equals 24"><mrow><mfrac><mn>8</mn> <mn>6</mn></mfrac>
    <mo>×</mo> <mn>18</mn> <mo>=</mo> <mn>24</mn></mrow></math>
- en: 'Typically, linear equations are not this simple. Sometimes they contain more
    variables and more constants, which need more detailed solutions, but let’s keep
    taking it step by step. Consider the following example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，线性方程不会这么简单。 有时它们包含更多的变量和常数，需要更详细的解决方案，但让我们一步一步地进行。 考虑以下例子：
- en: <math alttext="3 x minus 6 equals 12"><mrow><mn>3</mn> <mi>x</mi> <mo>-</mo>
    <mn>6</mn> <mo>=</mo> <mn>12</mn></mrow></math>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="3 x minus 6 equals 12"><mrow><mn>3</mn> <mi>x</mi> <mo>-</mo>
    <mn>6</mn> <mo>=</mo> <mn>12</mn></mrow></math>
- en: 'Solving for *x* requires rearranging the equation a little bit. Remember, the
    aim is to leave *x* on one side and the rest on the other. Here, you have to get
    rid of the constant 6 before taking care of 3\. The first part of the solution
    is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 解出*x*需要稍微重新排列方程。 记住，目标是将*x*留在一边，其余部分留在另一边。 在这里，你必须在处理3之前去掉常数6。 解决方案的第一部分如下：
- en: <math alttext="3 x minus 6 left-parenthesis plus 6 right-parenthesis equals
    12 left-parenthesis plus 6 right-parenthesis"><mrow><mn>3</mn> <mi>x</mi> <mo>-</mo>
    <mn>6</mn> <mo>(</mo> <mo>+</mo> <mn>6</mn> <mo>)</mo> <mo>=</mo> <mn>12</mn>
    <mo>(</mo> <mo>+</mo> <mn>6</mn> <mo>)</mo></mrow></math>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="3 x minus 6 left-parenthesis plus 6 right-parenthesis equals
    12 left-parenthesis plus 6 right-parenthesis"><mrow><mn>3</mn> <mi>x</mi> <mo>-</mo>
    <mn>6</mn> <mo>(</mo> <mo>+</mo> <mn>6</mn> <mo>)</mo> <mo>=</mo> <mn>12</mn>
    <mo>(</mo> <mo>+</mo> <mn>6</mn> <mo>)</mo></mrow></math>
- en: 'Notice how you have to add 6 to both parts of the equation. The part on the
    left will cancel itself out, while the part on the right will add up to 18:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意如何在方程的两边都加上6。左边的部分将自行抵消，而右边的部分将加起来得到18：
- en: <math alttext="3 x equals 18"><mrow><mn>3</mn> <mi>x</mi> <mo>=</mo> <mn>18</mn></mrow></math>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="3 x equals 18"><mrow><mn>3</mn> <mi>x</mi> <mo>=</mo> <mn>18</mn></mrow></math>
- en: 'Finally, you’re all set to multiply by the reciprocal of the constant attached
    to the variable *x*:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要将变量*x*附加的常数的倒数相乘：
- en: <math alttext="left-parenthesis one-third right-parenthesis 3 x equals 18 left-parenthesis
    one-third right-parenthesis"><mrow><mrow><mo>(</mo> <mfrac><mn>1</mn> <mn>3</mn></mfrac>
    <mo>)</mo></mrow> <mn>3</mn> <mi>x</mi> <mo>=</mo> <mn>18</mn> <mrow><mo>(</mo>
    <mfrac><mn>1</mn> <mn>3</mn></mfrac> <mo>)</mo></mrow></mrow></math>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="left-parenthesis one-third right-parenthesis 3 x equals 18 left-parenthesis
    one-third right-parenthesis"><mrow><mrow><mo>(</mo> <mfrac><mn>1</mn> <mn>3</mn></mfrac>
    <mo>)</mo></mrow> <mn>3</mn> <mi>x</mi> <mo>=</mo> <mn>18</mn> <mrow><mo>(</mo>
    <mfrac><mn>1</mn> <mn>3</mn></mfrac> <mo>)</mo></mrow></mrow></math>
- en: 'Simplifying and solving for *x* leaves the following solution:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 简化并解出*x*得到以下解决方案：
- en: <math alttext="x equals 6"><mrow><mi>x</mi> <mo>=</mo> <mn>6</mn></mrow></math>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x equals 6"><mrow><mi>x</mi> <mo>=</mo> <mn>6</mn></mrow></math>
- en: 'This means that the solution of the equation is 6\. To verify this, just plug
    6 into the original equation as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着方程的解为6。 要验证这一点，只需将6插入到原始方程中如下所示：
- en: <math alttext="left-parenthesis 3 times 6 right-parenthesis minus 6 equals 12"><mrow><mo>(</mo>
    <mn>3</mn> <mo>×</mo> <mn>6</mn> <mo>)</mo> <mo>-</mo> <mn>6</mn> <mo>=</mo> <mn>12</mn></mrow></math>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="left-parenthesis 3 times 6 right-parenthesis minus 6 equals 12"><mrow><mo>(</mo>
    <mn>3</mn> <mo>×</mo> <mn>6</mn> <mo>)</mo> <mo>-</mo> <mn>6</mn> <mo>=</mo> <mn>12</mn></mrow></math>
- en: 'By now, you should have noticed that linear algebra is all about using shortcuts
    and quick techniques to simplify equations and find unknown variables. The next
    example shows how sometimes the variable *x* can occur in multiple places:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经注意到，线性代数主要是关于使用快捷和快速的技巧简化方程并找到未知变量。下一个例子显示有时变量*x*可能出现在多个地方：
- en: <math alttext="6 x plus x equals 27 minus 2 x"><mrow><mn>6</mn> <mi>x</mi> <mo>+</mo>
    <mi>x</mi> <mo>=</mo> <mn>27</mn> <mo>-</mo> <mn>2</mn> <mi>x</mi></mrow></math>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="6 x plus x equals 27 minus 2 x"><mrow><mn>6</mn> <mi>x</mi> <mo>+</mo>
    <mi>x</mi> <mo>=</mo> <mn>27</mn> <mo>-</mo> <mn>2</mn> <mi>x</mi></mrow></math>
- en: 'Remember, the main focus is to have *x* on one side of the equation and the
    rest on the other side:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，主要重点是让*x*在方程的一边，其余部分在另一边：
- en: <math alttext="6 x plus x plus 2 x equals 27"><mrow><mn>6</mn> <mi>x</mi> <mo>+</mo>
    <mi>x</mi> <mo>+</mo> <mn>2</mn> <mi>x</mi> <mo>=</mo> <mn>27</mn></mrow></math>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="6 x plus x plus 2 x equals 27"><mrow><mn>6</mn> <mi>x</mi> <mo>+</mo>
    <mi>x</mi> <mo>+</mo> <mn>2</mn> <mi>x</mi> <mo>=</mo> <mn>27</mn></mrow></math>
- en: 'Adding the constants of *x* gives you the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在*x*的常数上加给你以下结果：
- en: <math alttext="9 x equals 27"><mrow><mn>9</mn> <mi>x</mi> <mo>=</mo> <mn>27</mn></mrow></math>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="9 x equals 27"><mrow><mn>9</mn> <mi>x</mi> <mo>=</mo> <mn>27</mn></mrow></math>
- en: 'The final step is dividing by 9 so that you only have *x* remaining:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是除以9，这样你就只剩下*x*：
- en: <math alttext="x equals 3"><mrow><mi>x</mi> <mo>=</mo> <mn>3</mn></mrow></math>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x equals 3"><mrow><mi>x</mi> <mo>=</mo> <mn>3</mn></mrow></math>
- en: You may now verify this by plugging 3 in the place of *x* in the original equation.
    You will notice that both sides of the equation will be equal.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过在原方程中将3代入*x*的位置来验证这一点。你会注意到方程两边是相等的。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Even though this section is quite simple, it contains the basic foundations
    you need to start advancing in algebra and calculus. The key takeaways from this
    section are as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本节内容很简单，但它包含了你在代数和微积分中开始进阶所需的基础。本节的关键要点如下：
- en: A linear equation is a representation in which the highest exponent on any variable
    is one. This means that there are no variables that are raised to the power of
    two and above.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性方程是一种表示，其中任何变量的最高指数为一。这意味着没有变量被提升到二次及以上的幂次。
- en: A linear equation line is straight when plotted on a chart.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图表上绘制时，线性方程的直线是直的。
- en: The application of linear equations in modeling a wide range of real-world occurrences
    makes them crucial in many branches of mathematics and research. They are also
    widely utilized in machine learning.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在建模各种真实世界事件中应用线性方程的重要性使其在许多数学和研究领域至关重要。它们在机器学习中也被广泛应用。
- en: Solving for *x* is the process of finding for it a value that equalizes both
    sides of the equation.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决*x*的过程是找到一个值，使得方程两边相等。
- en: When performing an operation (such as adding a constant or multiplying by a
    constant) on one side of the equation, you have to do it on the other side as
    well.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对方程的一侧进行操作（例如加上常数或乘以常数）时，你也必须对另一侧进行相同的操作。
- en: Systems of Equations
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方程组
- en: 'A *system of equations* is when there are two or more equations working together
    to solve one or more variables. Therefore, instead of the usual single equation:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*方程组*是指有两个或更多个方程共同工作来解决一个或多个变量的情况。因此，不再是通常的单一方程：'
- en: <math alttext="x plus 10 equals 20"><mrow><mi>x</mi> <mo>+</mo> <mn>10</mn>
    <mo>=</mo> <mn>20</mn></mrow></math>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x plus 10 equals 20"><mrow><mi>x</mi> <mo>+</mo> <mn>10</mn>
    <mo>=</mo> <mn>20</mn></mrow></math>
- en: 'systems of equations resemble the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 方程组类似于以下形式：
- en: <math alttext="x plus 10 equals 20"><mrow><mi>x</mi> <mo>+</mo> <mn>10</mn>
    <mo>=</mo> <mn>20</mn></mrow></math>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x plus 10 equals 20"><mrow><mi>x</mi> <mo>+</mo> <mn>10</mn>
    <mo>=</mo> <mn>20</mn></mrow></math>
- en: <math alttext="y plus 2 x equals 10"><mrow><mi>y</mi> <mo>+</mo> <mn>2</mn>
    <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="y plus 2 x equals 10"><mrow><mi>y</mi> <mo>+</mo> <mn>2</mn>
    <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
- en: Systems of equations are useful in machine learning and are used in many of
    its aspects.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 方程组在机器学习中非常有用，广泛应用于其许多方面。
- en: Let’s look at the previous system of equations from the beginning of this section
    and solve it graphically. Plotting the two functions can actually give the solution
    directly. The point of intersection is the solution. Therefore, the coordinates
    of the intersection (*x, y*) refer to the solutions of *x* and *y*, respectively.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从本节开头的方程组出发，通过图形化方法来解决它。绘制这两个函数实际上可以直接给出解决方案。交点就是解决方案。因此，交点的坐标（*x, y*）分别指的是*x*和*y*的解决方案。
- en: 'From [Figure 4-6](#figure-4-6), it seems that *x* = 10 and *y* = –10\. Plugging
    these values into their respective variables gives the correct answer:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从[图4-6](#figure-4-6)可以看出，*x* = 10而*y* = –10。将这些值代入各自的变量后得到正确答案：
- en: 10 + 10 = 20
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 10 + 10 = 20
- en: (–10) + (2 × 10) = 10
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: (–10) + (2 × 10) = 10
- en: '![](assets/dlff_0406.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dlff_0406.png)'
- en: Figure 4-6\. A graph showing the two functions and their intersection (solution)
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-6\. 显示两个函数及其交点（解决方案）
- en: 'As the functions are linear, solving them can result in one of three outcomes:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数是线性的，解决它们可能导致三种结果之一：
- en: There is only one solution for each variable.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个变量只有一个解决方案。
- en: There is no solution. This occurs when the functions are *parallel* (this means
    that they never intersect).
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不存在解决方案。这发生在函数*平行*时（这意味着它们从未相交）。
- en: There are an infinite number of solutions. This occurs when, through simplification,
    both functions are the same (since all points fall on the straight line).
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在无数个解。当通过简化时，两个函数相同时（因为所有点都落在直线上）。
- en: 'Before moving on to solving systems of equations using algebra, let’s visually
    see how there can be no solution and how there can be an infinite number of solutions.
    Consider the following system:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过代数解方程组之前，让我们通过视觉方式看看如何没有解和如何有无限多个解。考虑以下系统：
- en: <math alttext="2 x equals 10"><mrow><mn>2</mn> <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="2 x equals 10"><mrow><mn>2</mn> <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
- en: <math alttext="4 x equals 20"><mrow><mn>4</mn> <mi>x</mi> <mo>=</mo> <mn>20</mn></mrow></math>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="4 x equals 20"><mrow><mn>4</mn> <mi>x</mi> <mo>=</mo> <mn>20</mn></mrow></math>
- en: '[Figure 4-7](#figure-4-7) charts the two together. Since they are exactly the
    same equation, they fall on the same line. In reality, there are two lines in
    [Figure 4-7](#figure-4-7), but since they are the same, they are indistinguishable.
    For every *x* on the line, there is a corresponding *y*.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-7](#figure-4-7) 将它们一起绘制。由于它们正好是同一方程，它们落在同一条线上。实际上，图 4-7中有两条线，但由于它们相同，它们是无法区分的。对于线上的每个*x*，都有一个对应的*y*。'
- en: '![](assets/dlff_0407.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dlff_0407.png)'
- en: Figure 4-7\. A graph showing the two functions and their infinite intersections
  id: totrans-171
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-7\. 显示两个函数及其无限交点的图表
- en: 'Now consider the following system:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑以下系统：
- en: <math alttext="3 x equals 10"><mrow><mn>3</mn> <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="3 x equals 10"><mrow><mn>3</mn> <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
- en: <math alttext="6 x equals 10"><mrow><mn>6</mn> <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="6 x equals 10"><mrow><mn>6</mn> <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
- en: '[Figure 4-8](#figure-4-8) shows how they never intersect, which is intuitive
    as you cannot multiply the same number (represented by the variable *x*) with
    different numbers and expect to get the same result.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-8](#figure-4-8) 显示它们永不相交，这是直观的，因为你不能用不同的数字（由变量*x*表示）乘以同一个数字而期望得到相同的结果。'
- en: '![](assets/dlff_0408.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dlff_0408.png)'
- en: Figure 4-8\. A graph showing the two functions and their impossible intersection
  id: totrans-177
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-8\. 显示两个函数及其不可能的交点的图表
- en: 'Algebraic methods are used when there are more than two variables since they
    cannot be solved through graphs. This mainly entails two methods: substitution
    and elimination.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 代数方法用于解决超过两个变量的情况，因为它们无法通过图表求解。主要包括两种方法：替换法和消元法。
- en: '*Substitution* is used when you can replace the value of a variable in one
    equation and plug it into the second equation. Consider the following example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*替换法* 用于可以在一个方程中替换变量值并将其插入第二个方程的情况。考虑以下例子：'
- en: <math alttext="x plus y equals 2"><mrow><mi>x</mi> <mo>+</mo> <mi>y</mi> <mo>=</mo>
    <mn>2</mn></mrow></math>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x plus y equals 2"><mrow><mi>x</mi> <mo>+</mo> <mi>y</mi> <mo>=</mo>
    <mn>2</mn></mrow></math>
- en: <math alttext="10 x plus y equals 10"><mrow><mn>10</mn> <mi>x</mi> <mo>+</mo>
    <mi>y</mi> <mo>=</mo> <mn>10</mn></mrow></math>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="10 x plus y equals 10"><mrow><mn>10</mn> <mi>x</mi> <mo>+</mo>
    <mi>y</mi> <mo>=</mo> <mn>10</mn></mrow></math>
- en: 'The easiest method is to rearrange the first equation so that you have *y*
    in terms of *x*:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是重新排列第一个方程，使得你可以用*x*来表示*y*：
- en: <math alttext="y equals 2 minus x"><mrow><mi>y</mi> <mo>=</mo> <mn>2</mn> <mo>-</mo>
    <mi>x</mi></mrow></math>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="y equals 2 minus x"><mrow><mi>y</mi> <mo>=</mo> <mn>2</mn> <mo>-</mo>
    <mi>x</mi></mrow></math>
- en: <math alttext="10 x plus left-parenthesis 2 minus x right-parenthesis equals
    10"><mrow><mn>10</mn> <mi>x</mi> <mo>+</mo> <mo>(</mo> <mn>2</mn> <mo>-</mo> <mi>x</mi>
    <mo>)</mo> <mo>=</mo> <mn>10</mn></mrow></math>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="10 x plus left-parenthesis 2 minus x right-parenthesis equals
    10"><mrow><mn>10</mn> <mi>x</mi> <mo>+</mo> <mo>(</mo> <mn>2</mn> <mo>-</mo> <mi>x</mi>
    <mo>)</mo> <mo>=</mo> <mn>10</mn></mrow></math>
- en: 'Solving for *x* in the second equation becomes simple:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个方程中解*x*变得很简单：
- en: <math alttext="StartLayout 1st Row  10 x plus left-parenthesis 2 minus x right-parenthesis
    equals 10 2nd Row  10 x plus 2 minus x equals 10 3rd Row  10 x minus x equals
    10 minus 2 4th Row  9 x equals 8 5th Row  x equals eight-ninths 6th Row  x equals
    0.8889 EndLayout"><mtable><mtr><mtd columnalign="left"><mrow><mn>10</mn> <mi>x</mi>
    <mo>+</mo> <mo>(</mo> <mn>2</mn> <mo>-</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mn>10</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mn>10</mn> <mi>x</mi> <mo>+</mo> <mn>2</mn>
    <mo>-</mo> <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mn>10</mn>
    <mi>x</mi> <mo>-</mo> <mi>x</mi> <mo>=</mo> <mn>10</mn> <mo>-</mo> <mn>2</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mn>9</mn> <mi>x</mi> <mo>=</mo> <mn>8</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>x</mi> <mo>=</mo> <mfrac><mn>8</mn> <mn>9</mn></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>x</mi> <mo>=</mo> <mn>0</mn> <mo lspace="0%"
    rspace="0%">.</mo> <mn>8889</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row  10 x plus left-parenthesis 2 minus x right-parenthesis
    equals 10 2nd Row  10 x plus 2 minus x equals 10 3rd Row  10 x minus x equals
    10 minus 2 4th Row  9 x equals 8 5th Row  x equals eight-ninths 6th Row  x equals
    0.8889 EndLayout"><mtable><mtr><mtd columnalign="left"><mrow><mn>10</mn> <mi>x</mi>
    <mo>+</mo> <mo>(</mo> <mn>2</mn> <mo>-</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mn>10</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mn>10</mn> <mi>x</mi> <mo>+</mo> <mn>2</mn>
    <mo>-</mo> <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mn>10</mn>
    <mi>x</mi> <mo>-</mo> <mi>x</mi> <mo>=</mo> <mn>10</mn> <mo>-</mo> <mn>2</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mn>9</mn> <mi>x</mi> <mo>=</mo> <mn>8</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>x</mi> <mo>=</mo> <mfrac><mn>8</mn> <mn>9</mn></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>x</mi> <mo>=</mo> <mn>0</mn> <mo lspace="0%"
    rspace="0%">.</mo> <mn>8889</mn></mrow></mtd></mtr></mtable></math>
- en: 'Now that you have found the value of *x*, you can easily find *y* by plugging
    the value of *x* into the first equation:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经找到*x*的值，通过将*x*的值代入第一个方程中，你可以轻松找到*y*的值：
- en: <math alttext="StartLayout 1st Row  0.8889 plus y equals 2 2nd Row  y equals
    2 minus 0.8889 3rd Row  y equals 1.111 EndLayout"><mtable><mtr><mtd columnalign="left"><mrow><mn>0</mn>
    <mo lspace="0%" rspace="0%">.</mo> <mn>8889</mn> <mo>+</mo> <mi>y</mi> <mo>=</mo>
    <mn>2</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mi>y</mi> <mo>=</mo>
    <mn>2</mn> <mo>-</mo> <mn>0</mn> <mo lspace="0%" rspace="0%">.</mo> <mn>8889</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>y</mi> <mo>=</mo> <mn>1</mn> <mo lspace="0%"
    rspace="0%">.</mo> <mn>111</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row  0.8889 plus y equals 2 2nd Row  y equals
    2 minus 0.8889 3rd Row  y equals 1.111 EndLayout"><mtable><mtr><mtd columnalign="left"><mrow><mn>0</mn>
    <mo lspace="0%" rspace="0%">.</mo> <mn>8889</mn> <mo>+</mo> <mi>y</mi> <mo>=</mo>
    <mn>2</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mi>y</mi> <mo>=</mo>
    <mn>2</mn> <mo>-</mo> <mn>0</mn> <mo lspace="0%" rspace="0%">.</mo> <mn>8889</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>y</mi> <mo>=</mo> <mn>1</mn> <mo lspace="0%"
    rspace="0%">.</mo> <mn>111</mn></mrow></mtd></mtr></mtable></math>
- en: 'To check if your solution is correct, you can plug in the values of *x* and
    *y* in both formulas:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查你的解是否正确，可以在两个公式中分别代入*x*和*y*的值：
- en: <math alttext="StartLayout 1st Row  0.8889 plus 1.111 equals 2 2nd Row  left-parenthesis
    10 times 0.8889 right-parenthesis plus 1.111 equals 10 EndLayout"><mtable><mtr><mtd
    columnalign="left"><mrow><mn>0</mn> <mo lspace="0%" rspace="0%">.</mo> <mn>8889</mn>
    <mo>+</mo> <mn>1</mn> <mo lspace="0%" rspace="0%">.</mo> <mn>111</mn> <mo>=</mo>
    <mn>2</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mo>(</mo> <mn>10</mn>
    <mo>×</mo> <mn>0</mn> <mo lspace="0%" rspace="0%">.</mo> <mn>8889</mn> <mo>)</mo>
    <mo>+</mo> <mn>1</mn> <mo lspace="0%" rspace="0%">.</mo> <mn>111</mn> <mo>=</mo>
    <mn>10</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row  0.8889 plus 1.111 equals 2 2nd Row  left-parenthesis
    10 times 0.8889 right-parenthesis plus 1.111 equals 10 EndLayout"><mtable><mtr><mtd
    columnalign="left"><mrow><mn>0</mn> <mo lspace="0%" rspace="0%">.</mo> <mn>8889</mn>
    <mo>+</mo> <mn>1</mn> <mo lspace="0%" rspace="0%">.</mo> <mn>111</mn> <mo>=</mo>
    <mn>2</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mo>(</mo> <mn>10</mn>
    <mo>×</mo> <mn>0</mn> <mo lspace="0%" rspace="0%">.</mo> <mn>8889</mn> <mo>)</mo>
    <mo>+</mo> <mn>1</mn> <mo lspace="0%" rspace="0%">.</mo> <mn>111</mn> <mo>=</mo>
    <mn>10</mn></mrow></mtd></mtr></mtable></math>
- en: Graphically, this means that the two equations intersect at (0.8889, 1.111).
    This technique can be used with more than two variables. Follow the same process
    until the equations are simplified enough to give you the answers. The issue with
    substitution is that it may take some time when you’re dealing with more than
    two variables.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 从图形上看，这意味着两个方程在(0.8889, 1.111)处相交。这种技术可以用于多于两个变量。按照相同的过程进行，直到方程简化到足以给出答案。替换法的问题在于处理超过两个变量时可能需要一些时间。
- en: '*Elimination* is a faster alternative. It is about eliminating variables until
    there is only one left. Consider the following example:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*消元法* 是一个更快的替代方法。它涉及消除变量，直到只剩下一个。考虑以下例子：'
- en: <math alttext="StartLayout 1st Row  2 x plus 4 y equals 20 2nd Row  3 x plus
    2 y equals 10 EndLayout"><mtable><mtr><mtd columnalign="left"><mrow><mn>2</mn>
    <mi>x</mi> <mo>+</mo> <mn>4</mn> <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mn>3</mn> <mi>x</mi> <mo>+</mo> <mn>2</mn>
    <mi>y</mi> <mo>=</mo> <mn>10</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row  2 x plus 4 y equals 20 2nd Row  3 x plus
    2 y equals 10 EndLayout"><mtable><mtr><mtd columnalign="left"><mrow><mn>2</mn>
    <mi>x</mi> <mo>+</mo> <mn>4</mn> <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mn>3</mn> <mi>x</mi> <mo>+</mo> <mn>2</mn>
    <mi>y</mi> <mo>=</mo> <mn>10</mn></mrow></mtd></mtr></mtable></math>
- en: 'Noticing that there is 4*y* and 2*y*, it is possible to multiply the second
    equation by 2 so that you can subtract the equations from each other (which will
    remove the *y* variable):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到有4*y*和2*y*，可以将第二个方程乘以2，这样你可以将两个方程相减（从而消除*y*变量）：
- en: <math alttext="StartLayout 1st Row  2 x plus 4 y equals 20 2nd Row  6 x plus
    4 y equals 20 EndLayout"><mtable><mtr><mtd columnalign="left"><mrow><mn>2</mn>
    <mi>x</mi> <mo>+</mo> <mn>4</mn> <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mn>6</mn> <mi>x</mi> <mo>+</mo> <mn>4</mn>
    <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row  2 x plus 4 y equals 20 2nd Row  6 x plus
    4 y equals 20 EndLayout"><mtable><mtr><mtd columnalign="left"><mrow><mn>2</mn>
    <mi>x</mi> <mo>+</mo> <mn>4</mn> <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mn>6</mn> <mi>x</mi> <mo>+</mo> <mn>4</mn>
    <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></mtd></mtr></mtable></math>
- en: 'Subtracting the two equations from each other gives the following result:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个方程相减得到以下结果：
- en: <math alttext="StartLayout 1st Row  minus 4 x equals 0 2nd Row  x equals 0 EndLayout"><mtable><mtr><mtd
    columnalign="left"><mrow><mo>-</mo> <mn>4</mn> <mi>x</mi> <mo>=</mo> <mn>0</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>x</mi> <mo>=</mo> <mn>0</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row  minus 4 x equals 0 2nd Row  x equals 0 EndLayout"><mtable><mtr><mtd
    columnalign="left"><mrow><mo>-</mo> <mn>4</mn> <mi>x</mi> <mo>=</mo> <mn>0</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>x</mi> <mo>=</mo> <mn>0</mn></mrow></mtd></mtr></mtable></math>
- en: 'Therefore, *x* = 0\. Graphically, this means that they intersect whenever *x*
    = 0 (exactly at the vertical *y* line). Plugging the value of *x* into the first
    formula gives *y*  = 5:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*x* = 0\. 从图形上看，这意味着它们在*x* = 0时相交（正好在垂直的*y*线上）。将*x*的值代入第一个公式中得到*y* = 5：
- en: <math alttext="StartLayout 1st Row  left-parenthesis 2 times 0 right-parenthesis
    plus 4 y equals 20 2nd Row  4 y equals 20 3rd Row  y equals 5 EndLayout"><mtable><mtr><mtd
    columnalign="left"><mrow><mo>(</mo> <mn>2</mn> <mo>×</mo> <mn>0</mn> <mo>)</mo>
    <mo>+</mo> <mn>4</mn> <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></mtd></mtr> <mtr><mtd
    columnalign="left"><mrow><mn>4</mn> <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>y</mi> <mo>=</mo> <mn>5</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row  left-parenthesis 2 times 0 right-parenthesis
    plus 4 y equals 20 2nd Row  4 y equals 20 3rd Row  y equals 5 EndLayout"><mtable><mtr><mtd
    columnalign="left"><mrow><mo>(</mo> <mn>2</mn> <mo>×</mo> <mn>0</mn> <mo>)</mo>
    <mo>+</mo> <mn>4</mn> <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></mtd></mtr> <mtr><mtd
    columnalign="left"><mrow><mn>4</mn> <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>y</mi> <mo>=</mo> <mn>5</mn></mrow></mtd></mtr></mtable></math>
- en: Similarly, elimination can also solve equations with three variables. The choice
    between substitution and elimination depends on the type of equation being solved.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，消元法也可以解决三个变量的方程。选择替换法或消元法取决于要解决的方程类型。
- en: Note
  id: totrans-201
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The key takeaways from this section are as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的主要收获如下：
- en: Systems of equations solve variables together. They are very useful in machine
    learning and are used in some algorithms.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方程组同时解决变量。它们在机器学习中非常有用，被一些算法使用。
- en: Graphical solutions are preferred for simple systems of equations.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于简单的方程组，图形解法是首选。
- en: Solving systems of equations through algebra entails the use of substitution
    and elimination methods.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过代数解方程组涉及使用代入和消元方法。
- en: Substitution is preferred when the system is simple, but elimination is the
    way to go when the system is a bit more complex.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当系统比较简单时，推荐使用代入法，但当系统稍微复杂时，则使用消元法。
- en: Trigonometry
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三角学
- en: '*Trigonometry e*xplores the behavior of what is known as *trigonometric functions*
    that relate the angles of a triangle to the lengths of its sides. The most-used
    triangle is the right-angled triangle, which has one angle at 90**°**. [Figure 4-9](#figure-4-9)
    shows an example of a right-angled triangle.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*三角学*探索被称为*三角函数*的行为，这些函数将三角形的角度与其边长关联起来。最常用的三角形是直角三角形，其中一个角为90**°**。图 4-9展示了一个直角三角形的例子。'
- en: '![](assets/dlff_0409.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dlff_0409.png)'
- en: Figure 4-9\. A right-angled triangle
  id: totrans-210
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-9\. 直角三角形
- en: 'Let’s define the main characteristics of a right-angled triangle:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义直角三角形的主要特征：
- en: The longest side of the triangle is called the *hypotenuse.*
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三角形的最长边称为*斜边*。
- en: The angle in front of the hypotenuse is the right angle (the one at 90**°**).
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 斜边对面的角是直角（90**°**的那个角）。
- en: Depending on the other angle (θ) you choose (from the two that remain), the
    line between this angle and the hypotenuse is called the *adjacent* and the other
    line is called the *opposite*.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据选择的另一个角（θ）（剩下的两个角之一），连接这个角和斜边的线称为*邻边*，另一条线称为*对边*。
- en: Note
  id: totrans-215
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Trigonometric functions are mathematical functions used to relate the angles
    of a right triangle to the ratios of its sides. They have various applications
    in fields like geometry, physics, engineering, and more. They help analyze and
    solve problems related to angles, distances, oscillations, and waveforms, among
    other things.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 三角函数是数学函数，用于将直角三角形的角度与其边长的比率关联起来。它们在几何学、物理学、工程学等领域有各种应用。它们帮助分析和解决与角度、距离、振荡和波形等相关的问题。
- en: 'Trigonometric functions are simply the division of one line by another line.
    Remember that you have three lines in a triangle (hypotenuse, opposite, and adjacent).
    The trigonometric functions are found as follow:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 三角函数简单来说就是三角形的一条线除以另一条线的比值。记住三角形有三条边（斜边、对边和邻边）。三角函数如下找到：
- en: <math alttext="s i n left-parenthesis theta right-parenthesis equals StartFraction
    Opposite Over Hypotenuse EndFraction"><mrow><mi>s</mi> <mi>i</mi> <mi>n</mi> <mrow><mo>(</mo>
    <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mtext>Opposite</mtext>
    <mtext>Hypotenuse</mtext></mfrac></mstyle></mrow></math>
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="s i n left-parenthesis theta right-parenthesis equals StartFraction
    Opposite Over Hypotenuse EndFraction"><mrow><mi>s</mi> <mi>i</mi> <mi>n</mi> <mrow><mo>(</mo>
    <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mtext>Opposite</mtext>
    <mtext>Hypotenuse</mtext></mfrac></mstyle></mrow></math>
- en: <math alttext="c o s left-parenthesis theta right-parenthesis equals StartFraction
    Adjacent Over Hypotenuse EndFraction"><mrow><mi>c</mi> <mi>o</mi> <mi>s</mi> <mrow><mo>(</mo>
    <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mtext>Adjacent</mtext>
    <mtext>Hypotenuse</mtext></mfrac></mstyle></mrow></math>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="c o s left-parenthesis theta right-parenthesis equals StartFraction
    Adjacent Over Hypotenuse EndFraction"><mrow><mi>c</mi> <mi>o</mi> <mi>s</mi> <mrow><mo>(</mo>
    <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mtext>Adjacent</mtext>
    <mtext>Hypotenuse</mtext></mfrac></mstyle></mrow></math>
- en: <math alttext="t a n left-parenthesis theta right-parenthesis equals StartFraction
    Opposite Over Adjacent EndFraction"><mrow><mi>t</mi> <mi>a</mi> <mi>n</mi> <mrow><mo>(</mo>
    <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mtext>Opposite</mtext>
    <mtext>Adjacent</mtext></mfrac></mstyle></mrow></math>
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="t a n left-parenthesis theta right-parenthesis equals StartFraction
    Opposite Over Adjacent EndFraction"><mrow><mi>t</mi> <mi>a</mi> <mi>n</mi> <mrow><mo>(</mo>
    <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mtext>Opposite</mtext>
    <mtext>Adjacent</mtext></mfrac></mstyle></mrow></math>
- en: 'From the previous three trigonometric functions, it is possible to extract
    a trigonometric identity that reaches *tan* from *sin* and *cos* using basic linear
    algebra:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的三个三角函数中，可以通过基本的线性代数得到一个三角恒等式，通过*sin*和*cos*可以得到*tan*：
- en: <math alttext="t a n left-parenthesis theta right-parenthesis equals StartFraction
    s i n left-parenthesis theta right-parenthesis Over c o s left-parenthesis theta
    right-parenthesis EndFraction"><mrow><mi>t</mi> <mi>a</mi> <mi>n</mi> <mrow><mo>(</mo>
    <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>θ</mi><mo>)</mo></mrow>
    <mrow><mi>c</mi><mi>o</mi><mi>s</mi><mo>(</mo><mi>θ</mi><mo>)</mo></mrow></mfrac></mstyle></mrow></math>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="t a n left-parenthesis theta right-parenthesis equals StartFraction
    s i n left-parenthesis theta right-parenthesis Over c o s left-parenthesis theta
    right-parenthesis EndFraction"><mrow><mi>t</mi> <mi>a</mi> <mi>n</mi> <mrow><mo>(</mo>
    <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>θ</mi><mo>)</mo></mrow>
    <mrow><mi>c</mi><mi>o</mi><mi>s</mi><mo>(</mo><mi>θ</mi><mo>)</mo></mrow></mfrac></mstyle></mrow></math>
- en: '*Hyperbolic functions *are similar to trigonometric functions but are defined
    using exponential functions. Before understanding hyperbolic functions, one must
    understand Euler’s number.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*双曲函数*类似于三角函数，但是使用指数函数来定义。在理解双曲函数之前，必须了解欧拉数。'
- en: Note
  id: totrans-224
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This part on hyperbolic functions is interesting as it forms the basis of what
    is known as *activation functions*, a key concept in neural networks, the protagonists
    of deep learning models. You will see them in detail in [Chapter 8](ch08.html#ch08).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分关于双曲函数的内容很有趣，因为它构成了所谓的*激活函数*的基础，这是神经网络中的一个关键概念，深度学习模型的主角。您将在[第8章](ch08.html#ch08)中详细了解它们。
- en: '*Euler’s number* (denoted as *e*) is one of the most important numbers in mathematics.
    It is an *irrational number*, which is a real number that cannot be expressed
    as a fraction. The word *irrational* comes from the fact that there is no *ratio*
    to express it; it has nothing to do with its personality. Euler’s numberis also
    the base of the natural logarithm *ln*, and the first digits of it are 2.71828\.
    One of the best approximations to get *e* is the following formula:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*欧拉数*（记为*e*）是数学中最重要的数之一。它是一个*无理数*，即不能用分数表示的实数。*无理*一词来自于无法用*比率*来表示它的事实；这与其性质无关。欧拉数也是自然对数*ln*的底数，其前几位数字为2.71828。一个最佳的近似值公式如下：'
- en: <math alttext="e equals left-parenthesis 1 plus StartFraction 1 Over n EndFraction
    right-parenthesis Superscript n"><mrow><mi>e</mi> <mo>=</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mi>n</mi></msup></mrow></math>
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="e equals left-parenthesis 1 plus StartFraction 1 Over n EndFraction
    right-parenthesis Superscript n"><mrow><mi>e</mi> <mo>=</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mi>n</mi></msup></mrow></math>
- en: 'By increasing *n* in the previous formula, you will approach the value of *e*.
    Euler’s number has many interesting properties, most notably the fact that its
    slope is its own value. Consider the following function (also called the *natural
    exponent function*):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在前述公式中增加*n*，您将接近*e*的值。欧拉数有许多有趣的性质，最显著的是其斜率等于其自身的值。考虑以下函数（也称为*自然指数函数*）：
- en: <math alttext="f left-parenthesis x right-parenthesis equals e Superscript x"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi> <mi>x</mi></msup></mrow></math>
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals e Superscript x"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi> <mi>x</mi></msup></mrow></math>
- en: At any point, the slope of the function is the same value. Take a look at [Figure 4-10](#figure-4-10).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何点，函数的斜率都是相同的值。看看[图 4-10](#figure-4-10)。
- en: '![](assets/dlff_0410.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dlff_0410.png)'
- en: Figure 4-10\. A graph of the natural exponent function
  id: totrans-232
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-10\. 自然指数函数的图表
- en: Note
  id: totrans-233
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'You may be wondering why I am explaining exponents and logarithms in this book.
    There are mainly two reasons for this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我在这本书中解释指数和对数。主要有两个原因：
- en: Exponents and, more importantly, Euler’s number are used in hyperbolic functions
    where *tanh(x)* is one of the main activation functions for neural networks, a
    type of machine and deep learning model.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数和更重要的是欧拉数在双曲函数中被使用，其中 *tanh(x)* 是神经网络中的主要激活函数，一种机器学习和深度学习模型。
- en: Logarithms are useful in *loss functions*, a concept that you will see in later
    chapters.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数在*损失函数*中非常有用，这是你在后面章节中会看到的概念。
- en: 'Hyperbolic functions use the natural exponent function and are defined as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 双曲函数使用自然指数函数，并定义如下：
- en: <math alttext="s i n h left-parenthesis x right-parenthesis equals StartFraction
    e Superscript x Baseline minus e Superscript negative x Baseline Over 2 EndFraction"><mrow><mi>s</mi>
    <mi>i</mi> <mi>n</mi> <mi>h</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><msup><mi>e</mi>
    <mi>x</mi></msup> <mo>-</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow>
    <mn>2</mn></mfrac></mstyle></mrow></math>
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="s i n h left-parenthesis x right-parenthesis equals StartFraction
    e Superscript x Baseline minus e Superscript negative x Baseline Over 2 EndFraction"><mrow><mi>s</mi>
    <mi>i</mi> <mi>n</mi> <mi>h</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><msup><mi>e</mi>
    <mi>x</mi></msup> <mo>-</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow>
    <mn>2</mn></mfrac></mstyle></mrow></math>
- en: <math alttext="c o s h left-parenthesis x right-parenthesis equals StartFraction
    e Superscript x Baseline plus e Superscript negative x Baseline Over 2 EndFraction"><mrow><mi>c</mi>
    <mi>o</mi> <mi>s</mi> <mi>h</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><msup><mi>e</mi>
    <mi>x</mi></msup> <mo>+</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow>
    <mn>2</mn></mfrac></mstyle></mrow></math>
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="c o s h left-parenthesis x right-parenthesis equals StartFraction
    e Superscript x Baseline plus e Superscript negative x Baseline Over 2 EndFraction"><mrow><mi>c</mi>
    <mi>o</mi> <mi>s</mi> <mi>h</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><msup><mi>e</mi>
    <mi>x</mi></msup> <mo>+</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow>
    <mn>2</mn></mfrac></mstyle></mrow></math>
- en: <math alttext="t a n h left-parenthesis x right-parenthesis equals StartFraction
    e Superscript x Baseline minus e Superscript negative x Baseline Over e Superscript
    x Baseline plus e Superscript negative x Baseline EndFraction"><mrow><mi>t</mi>
    <mi>a</mi> <mi>n</mi> <mi>h</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><msup><mi>e</mi>
    <mi>x</mi></msup> <mo>-</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow>
    <mrow><msup><mi>e</mi> <mi>x</mi></msup> <mo>+</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow></mfrac></mstyle></mrow></math>
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="t a n h left-parenthesis x right-parenthesis equals StartFraction
    e Superscript x Baseline minus e Superscript negative x Baseline Over e Superscript
    x Baseline plus e Superscript negative x Baseline EndFraction"><mrow><mi>t</mi>
    <mi>a</mi> <mi>n</mi> <mi>h</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><msup><mi>e</mi>
    <mi>x</mi></msup> <mo>-</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow>
    <mrow><msup><mi>e</mi> <mi>x</mi></msup> <mo>+</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow></mfrac></mstyle></mrow></math>
- en: Among the key characteristics of *tanh(x)* are nonlinearity, the limitation
    between [–1, 1], and the fact that it is centered at zero. [Figure 4-11](#figure-4-11)
    shows the graph of *tanh(x)*.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*tanh(x)* 的主要特征包括非线性、限制在 [–1, 1] 之间，并且其以零为中心。[图 4-11](#figure-4-11) 显示了 *tanh(x)*
    的图表。'
- en: '![](assets/dlff_0411.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dlff_0411.png)'
- en: Figure 4-11\. A graph of tanh(x) showing how it’s limited between –1 and 1
  id: totrans-243
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-11\. 显示了 *tanh(x)* 的图表，显示它在 –1 和 1 之间的限制。
- en: Note
  id: totrans-244
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The key takeaways from this section are as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的主要要点如下：
- en: Trigonometry is a field that explores the behavior of trigonometric functions
    that relate the angles of a triangle to the lengths of its sides.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三角学是一个研究三角函数行为的领域，它将三角形的角度与其边长联系起来。
- en: A trigonometric identity is a shortcut that relates the trigonometric functions
    with each other.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三角恒等式是将三角函数相互关联的快捷方式。
- en: Euler’s number *e* is irrational and is the base of the natural logarithm. It
    has many applications in exponential growth and in hyperbolic functions.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欧拉数 *e* 是无理数，是自然对数的底数。它在指数增长和双曲函数中有许多应用。
- en: The hyperbolic tangent function is used in neural networks, a deep learning
    algorithm.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双曲正切函数在神经网络中，一种深度学习算法中被使用。
- en: Calculus
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微积分
- en: 'As previously mentioned, calculus is a branch of mathematics that focuses on
    the study of rates of change and accumulation of quantities. It consists of two
    primary branches: *differential calculus* (which deals with derivatives) and *integral
    calculus* (which deals with integration). This section briefly introduces both
    types of calculus while also discussing topics such as limits and optimization.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，微积分是数学的一个分支，专注于速率变化和数量积累的研究。它包括两个主要分支：*微分学*（处理导数）和*积分学*（处理积分）。本节简要介绍了这两种微积分类型，同时讨论了诸如极限和优化等主题。
- en: Limits and Continuity
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 极限与连续性
- en: '*Calculus works by making visible the infinitesimally small.*'
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*微积分通过使微不足道的小量显现出来而起作用。*'
- en: ''
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Keith Devlin
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —Keith Devlin
- en: Limits don’t have to be nightmarish. I have always found them to be misunderstood.
    They are actually quite easy to get. But first, you need motivation, and this
    comes from knowing the added value of learning limits.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 极限并不一定是噩梦。我一直发现人们对它们有所误解。实际上，它们非常容易理解。但首先，你需要动力，这源于了解学习极限的附加价值。
- en: 'Understanding limits is important in machine learning models for many reasons:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 理解极限对于机器学习模型来说是非常重要的，原因有很多：
- en: Optimization
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 优化
- en: In optimization methods like gradient descent, limits can be used to regulate
    the step size and guarantee convergence to a local minimum.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在像梯度下降这样的优化方法中，极限可以用来调节步长并保证收敛到局部最小值。
- en: Feature selection
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 特征选择
- en: Limits can be used to rank the significance of various model features and perform
    feature selection, which can make the model simpler and perform better.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 极限可以用来排列各种模型特征的重要性并进行特征选择，这可以使模型更简单且性能更好。
- en: Sensitivity analysis
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 敏感性分析
- en: A machine learning model’s sensitivity to changes in input data and its capacity
    to generalize to new data can be used to examine a model’s behavior.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习模型对输入数据变化的敏感性以及其泛化到新数据的能力可以用来检验模型的行为。
- en: Also, limits are used in more advanced calculus concepts that you will learn
    about shortly.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，极限被用于你即将学习的更高级的微积分概念中。
- en: The main aim of limits is to know the value of a function when it’s undefined.
    But what is an *undefined function*? When you have a function that gives a solution
    that is not possible (such as dividing by zero), limits help you bypass this issue
    in order to know the value of the function at that point. So the aim of limits
    is to solve functions even when they are undefined.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 极限的主要目的是在函数未定义时知道函数的值。但是什么是*未定义函数*？当您有一个给出不可能的解决方案的函数（例如除以零）时，极限帮助您绕过此问题以了解该点处函数的值。因此，极限的目的是即使在函数未定义时也能解决函数。
- en: 'Remember that the solution to a function that takes *x* as an input is a value
    in the *y*-axis. [Figure 4-12](#figure-4-12) shows a linear graph of the following
    function:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，将 *x* 作为输入的函数的解是 *y* 轴上的一个值。 [图 4-12](#figure-4-12) 展示了以下函数的线性图形：
- en: <math alttext="f left-parenthesis x right-parenthesis equals x plus 2"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mi>x</mi> <mo>+</mo> <mn>2</mn></mrow></math>
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals x plus 2"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mi>x</mi> <mo>+</mo> <mn>2</mn></mrow></math>
- en: '![](assets/dlff_0412.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dlff_0412.png)'
- en: Figure 4-12\. A graph of the function f(x) = x + 2
  id: totrans-269
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-12\. 函数 f(x) = x + 2 的图形
- en: The solution of the function in the graph is the one that lies on the linear
    line taking into account the value of *x* every time.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图形中函数的解是每次考虑 *x* 的值时位于线性线上的解。
- en: 'What would be the solution of the function (the value of *y*) when *x* = 4?
    Clearly, the answer is 6, as substituting the value of *x* with 4 gives 6:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *x* = 4 时，函数（*y* 的值）的解将是什么？显然，答案是 6，因为将 *x* 的值替换为 4 给出 6：
- en: <math alttext="f left-parenthesis 4 right-parenthesis equals 4 plus 2 equals
    6"><mrow><mi>f</mi> <mo>(</mo> <mn>4</mn> <mo>)</mo> <mo>=</mo> <mn>4</mn> <mo>+</mo>
    <mn>2</mn> <mo>=</mo> <mn>6</mn></mrow></math>
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis 4 right-parenthesis equals 4 plus 2 equals
    6"><mrow><mi>f</mi> <mo>(</mo> <mn>4</mn> <mo>)</mo> <mo>=</mo> <mn>4</mn> <mo>+</mo>
    <mn>2</mn> <mo>=</mo> <mn>6</mn></mrow></math>
- en: Thinking of this solution in terms of limits would be like asking for the solution
    of the function as *x* approaches 4 from both sides (the negative/decreasing side
    and the positive/increasing side). [Table 4-1](#table-4-1) simplifies this dilemma.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 将此解释视为极限的解决方案就像询问函数在 *x* 从两侧（负/递减侧和正/递增侧）接近 4 时的解决方案一样。 [表 4-1](#table-4-1)
    简化了这个困境。
- en: Table 4-1\. Finding x as it approaches 4
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1\. 找到接近 4 的 *x*
- en: '| *f(x)* | *x* |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| *f(x)* | *x* |'
- en: '| --- | --- |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 5.998 | 3.998 |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 5.998 | 3.998 |'
- en: '| 5.999 | 3.999 |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 5.999 | 3.999 |'
- en: '| 6.000 | 4.000 |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 6.000 | 4.000 |'
- en: '| 6.001 | 4.001 |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 6.001 | 4.001 |'
- en: '| 6.002 | 4.002 |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 6.002 | 4.002 |'
- en: Approaching from the negative side is the equivalent of adding a fraction of
    a number while below 4 and analyzing the result every time. Similarly, approaching
    from the positive side is the equivalent of removing a fraction of a number while
    above 4 and analyzing the result every time. The solution seems to converge to
    6 as *x* approaches 4\. This is the solution to the limit.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 从负侧接近相当于在 4 以下添加一个数字的分数并每次分析结果。类似地，从正侧接近相当于在 4 以上减去一个数字的分数并每次分析结果。随着 *x* 接近
    4，解似乎收敛到 6。这是极限的解。
- en: 'Limits in the general form are written following this convention:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 一般形式的极限按照以下约定编写：
- en: <math alttext="limit Underscript x right-arrow a Endscripts f left-parenthesis
    x right-parenthesis equals upper L"><mrow><msub><mo form="prefix" movablelimits="true">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mi>a</mi></mrow></msub> <mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>L</mi></mrow></math>
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow a Endscripts f left-parenthesis
    x right-parenthesis equals upper L"><mrow><msub><mo form="prefix" movablelimits="true">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mi>a</mi></mrow></msub> <mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>L</mi></mrow></math>
- en: 'The general form of the limit is read as follows: as you approach *a* along
    the *x*-axis (whether from the positive or the negative side), the function *f(x)*
    gets closer to the value of *L*.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 极限的一般形式读作：当您沿着 *x* 轴接近 *a*（无论是从正侧还是从负侧），函数 *f(x)* 都会趋于值 *L*。
- en: Note
  id: totrans-286
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The idea of the limit states that as you lock in and approach a number from
    either side (negative or positive), the solution of the equation approaches a
    certain number, and the solution to the limit is that number.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 极限的概念表明，当您从任一侧（负或正）锁定并接近一个数字时，方程的解会接近某个数字，而极限的解就是那个数字。
- en: As mentioned previously, limits are useful when the exact point of the solution
    is undefined using the conventional way of substitution.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当使用传统的代入方法无法确定解的确切位置时，极限就变得很有用。
- en: 'A one-sided limit is different from the general limit. With a lefthand limit,
    you search for the limit going from the negative side to the positive side, and
    with a righthand limit, you search for the limit going from the positive side
    to the negative side. The general limit exists when the two one-sided limits exist
    and are equal. Therefore, the previous statements are summarized as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 单侧极限与一般极限不同。对于左侧极限，您从负侧向正侧寻找极限，而对于右侧极限，您从正侧向负侧寻找极限。当两个单侧极限存在且相等时，一般极限存在。因此，前述陈述可以总结如下：
- en: The lefthand limit exists.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左侧极限存在。
- en: The righthand limit exists.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右侧极限存在。
- en: The lefthand limit is equal to the righthand limit.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左侧极限等于右侧极限。
- en: 'The lefthand limit is defined as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧极限定义如下：
- en: <math alttext="limit Underscript x right-arrow a Superscript minus Baseline
    Endscripts f left-parenthesis x right-parenthesis equals upper L"><mrow><msub><mo
    form="prefix" movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><msup><mi>a</mi>
    <mo>-</mo></msup></mrow></msub> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>L</mi></mrow></math>
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow a Superscript minus Baseline
    Endscripts f left-parenthesis x right-parenthesis equals upper L"><mrow><msub><mo
    form="prefix" movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><msup><mi>a</mi>
    <mo>-</mo></msup></mrow></msub> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>L</mi></mrow></math>
- en: 'The righthand limit is defined as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧极限定义如下：
- en: <math alttext="limit Underscript x right-arrow a Superscript plus Baseline Endscripts
    f left-parenthesis x right-parenthesis equals upper L"><mrow><msub><mo form="prefix"
    movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><msup><mi>a</mi> <mo>+</mo></msup></mrow></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>L</mi></mrow></math>
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow a Superscript plus Baseline Endscripts
    f left-parenthesis x right-parenthesis equals upper L"><mrow><msub><mo form="prefix"
    movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><msup><mi>a</mi> <mo>+</mo></msup></mrow></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>L</mi></mrow></math>
- en: 'Consider the following equation:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下方程：
- en: <math alttext="f left-parenthesis x right-parenthesis equals StartFraction x
    cubed minus 27 Over x minus 3 EndFraction"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><msup><mi>x</mi>
    <mn>3</mn></msup> <mo>-</mo><mn>27</mn></mrow> <mrow><mi>x</mi><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle></mrow></math>
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals StartFraction x
    cubed minus 27 Over x minus 3 EndFraction"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><msup><mi>x</mi>
    <mn>3</mn></msup> <mo>-</mo><mn>27</mn></mrow> <mrow><mi>x</mi><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle></mrow></math>
- en: 'What is the solution of the function when *x* = 3? Substitution leads to the
    following issue:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *x* = 3 时，函数的解决方案是什么？代入得出以下问题：
- en: <math alttext="f left-parenthesis 3 right-parenthesis equals StartFraction 3
    cubed minus 27 Over 3 minus 3 EndFraction equals StartFraction 27 minus 27 Over
    3 minus 3 EndFraction equals StartFraction 0 Over 0 EndFraction equals Undefined"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mn>3</mn> <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><mrow><msup><mn>3</mn> <mn>3</mn></msup> <mo>-</mo><mn>27</mn></mrow>
    <mrow><mn>3</mn><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle> <mo>=</mo> <mstyle
    displaystyle="false" scriptlevel="0"><mfrac><mrow><mn>27</mn><mo>-</mo><mn>27</mn></mrow>
    <mrow><mn>3</mn><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle> <mo>=</mo> <mstyle
    displaystyle="false" scriptlevel="0"><mfrac><mn>0</mn> <mn>0</mn></mfrac></mstyle>
    <mo>=</mo> <mtext>Undefined</mtext></mrow></math>
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis 3 right-parenthesis equals StartFraction 3
    cubed minus 27 Over 3 minus 3 EndFraction equals StartFraction 27 minus 27 Over
    3 minus 3 EndFraction equals StartFraction 0 Over 0 EndFraction equals Undefined"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mn>3</mn> <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><mrow><msup><mn>3</mn> <mn>3</mn></msup> <mo>-</mo><mn>27</mn></mrow>
    <mrow><mn>3</mn><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle> <mo>=</mo> <mstyle
    displaystyle="false" scriptlevel="0"><mfrac><mrow><mn>27</mn><mo>-</mo><mn>27</mn></mrow>
    <mrow><mn>3</mn><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle> <mo>=</mo> <mstyle
    displaystyle="false" scriptlevel="0"><mfrac><mn>0</mn> <mn>0</mn></mfrac></mstyle>
    <mo>=</mo> <mtext>Undefined</mtext></mrow></math>
- en: However, thinking about this in terms of limits as shown in [Table 4-2](#table-4-2),
    it seems that as you approach *x* = 3, either from the left or right side, the
    solution tends to approach 27.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从 [表 4-2](#table-4-2) 显示的极限的角度来看，当从左侧或右侧逼近 *x* = 3 时，解决方案趋近于 27。
- en: Table 4-2\. Finding x as it approaches 3
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-2\. 寻找 *x* 逼近 3 的值
- en: '| f(x) | x |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| f(x) | x |'
- en: '| --- | --- |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 2.9998 | 26.9982 |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 2.9998 | 26.9982 |'
- en: '| 2.9999 | 26.9991 |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 2.9999 | 26.9991 |'
- en: '| 3.0000 | Undefined |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 3.0000 | 未定义 |'
- en: '| 3.0001 | 27.0009 |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 3.0001 | 27.0009 |'
- en: '| 3.0002 | 27.0018 |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 3.0002 | 27.0018 |'
- en: Graphically, this can be seen as a discontinuity in the chart along both axes.
    The discontinuity exists on the line around the coordinate (3, 27). Some functions
    do not have limits. For example, what is the limit of the following function as
    *x* approaches 5?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 从图形上看，这可以看作是图表在两个轴上的不连续性。这种不连续性存在于坐标 (3, 27) 附近的线上。一些函数没有极限。例如，当 *x* 接近 5 时，以下函数的极限是多少？
- en: <math alttext="limit Underscript x right-arrow 5 Endscripts StartFraction 1
    Over x minus 5 EndFraction"><mrow><msub><mo form="prefix" movablelimits="true">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mn>5</mn></mrow></msub> <mfrac><mn>1</mn> <mrow><mi>x</mi><mo>-</mo><mn>5</mn></mrow></mfrac></mrow></math>
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow 5 Endscripts StartFraction 1
    Over x minus 5 EndFraction"><mrow><msub><mo form="prefix" movablelimits="true">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mn>5</mn></mrow></msub> <mfrac><mn>1</mn> <mrow><mi>x</mi><mo>-</mo><mn>5</mn></mrow></mfrac></mrow></math>
- en: Looking at [Table 4-3](#table-4-3), it seems that as *x* approaches 5, the results
    highly diverge when approaching from both sides. For instance, approaching from
    the negative side, the limit of 4.9999 is –10,000, and from the positive side,
    the limit of 5.0001 is 10,000.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [表 4-3](#table-4-3)，当 *x* 接近 5 时，从两边逼近结果显著分离。例如，从负侧逼近，4.9999 的极限是 –10,000，从正侧逼近，5.0001
    的极限是 10,000。
- en: Table 4-3\. Finding x as it approaches 5
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-3\. 寻找 *x* 逼近 5 的值
- en: '| f(x) | x |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| f(x) | x |'
- en: '| --- | --- |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 4.9998 | –5000 |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 4.9998 | –5000 |'
- en: '| 4.9999 | –10000 |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 4.9999 | –10000 |'
- en: '| 5.0000 | Undefined |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| 5.0000 | 未定义 |'
- en: '| 5.0001 | 10000 |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| 5.0001 | 10000 |'
- en: '| 5.0002 | 5000 |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| 5.0002 | 5000 |'
- en: Remember that for the general limit to exist, both one-sided limits must exist
    and must be equal, which is not the case here. Graphing this gives [Figure 4-13](#figure-4-13),
    which may help you understand why the limit does not exist.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住，一般极限存在的条件是单侧极限必须存在且相等，但在这里并非如此。通过绘图可以看出，这为 [图 4-13](#figure-4-13) 说明了为何极限不存在。
- en: '![](assets/dlff_0413.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dlff_0413.png)'
- en: Figure 4-13\. A graph of the function proving that the limit does not exist
  id: totrans-323
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-13\. 证明极限不存在的函数图表
- en: 'But what if the function that you want to analyze looks like this:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '但如果你想分析的函数看起来像这样： '
- en: <math alttext="limit Underscript x right-arrow 5 Endscripts StartFraction 1
    Over StartAbsoluteValue x minus 5 EndAbsoluteValue EndFraction"><mrow><msub><mo
    form="prefix" movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>5</mn></mrow></msub>
    <mfrac><mn>1</mn> <mrow><mo>|</mo><mi>x</mi><mo>-</mo><mn>5</mn><mo>|</mo></mrow></mfrac></mrow></math>
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow 5 Endscripts StartFraction 1
    Over StartAbsoluteValue x minus 5 EndAbsoluteValue EndFraction"><mrow><msub><mo
    form="prefix" movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>5</mn></mrow></msub>
    <mfrac><mn>1</mn> <mrow><mo>|</mo><mi>x</mi><mo>-</mo><mn>5</mn><mo>|</mo></mrow></mfrac></mrow></math>
- en: 'Looking at [Table 4-3](#table-4-3), it seems that as *x* approaches 5, the
    results rapidly accelerate as they diverge to a very big number referred to as
    infinity (∞):'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [表 4-3](#table-4-3)，当 *x* 接近 5 时，结果在逼近时快速加速到被称为无穷大 (∞) 的非常大的数值：
- en: <math alttext="f left-parenthesis x right-parenthesis equals StartFraction 1
    Over StartAbsoluteValue x minus 5 EndAbsoluteValue EndFraction"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><mn>1</mn> <mrow><mo>|</mo><mi>x</mi><mo>-</mo><mn>5</mn><mo>|</mo></mrow></mfrac></mstyle></mrow></math>
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals StartFraction 1
    Over StartAbsoluteValue x minus 5 EndAbsoluteValue EndFraction"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><mn>1</mn> <mrow><mo>|</mo><mi>x</mi><mo>-</mo><mn>5</mn><mo>|</mo></mrow></mfrac></mstyle></mrow></math>
- en: 'Take a look at [Table 4-4](#table-4-4):'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [表 4-4](#table-4-4)：
- en: Table 4-4\. Another attempt at finding x as it approaches 5
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-4\. 另一种寻找 *x* 逼近 5 的尝试
- en: '| f(x) | x |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| f(x) | x |'
- en: '| --- | --- |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 4.99997 | 334333.33 |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| 4.99997 | 334333.33 |'
- en: '| 4.99998 | 50000 |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| 4.99998 | 50000 |'
- en: '| 4.99999 | 100000 |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| 4.99999 | 100000 |'
- en: '| 4.9999999 | 10000000 |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| 4.9999999 | 10000000 |'
- en: '| 5.00000 | Undefined |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 5.00000 | 未定义 |'
- en: '| 5.0000001 | 10000000 |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 5.0000001 | 10000000 |'
- en: '| 5.00001 | 100000 |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 5.00001 | 100000 |'
- en: '| 5.00002 | 50000 |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| 5.00002 | 50000 |'
- en: '| 5.00003 | 334333.33 |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| 5.00003 | 334333.33 |'
- en: At every tiny step, *x* approaches 5, and *y* approaches positive infinity.
    The answer to the limit question is therefore positive infinity (+∞). [Figure 4-14](#figure-4-14)
    shows the graph of the function. Notice how both sides rise in value as *x* approaches
    5.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一个微小的步骤中，*x* 接近 5，*y* 也逐渐接近正无穷大。因此极限的答案是正无穷大（+∞）。 [图 4-14](#figure-4-14) 显示了函数的图表。请注意，当
    *x* 接近 5 时，两边的值都在上升。
- en: '![](assets/dlff_0414.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dlff_0414.png)'
- en: Figure 4-14\. A graph of the function proving that the limit exists as x approaches
    5
  id: totrans-343
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-14\. 证明极限存在的函数图表
- en: '*Continuous* functions are ones that are drawn without gaps or holes in the
    graph, while *discontinuous* functions contain such gaps and holes. This usually
    means that the latter contain points where the solution of the functions is undefined
    and may need to be approximated by limits. Therefore, continuity and limits are
    two related concepts.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '*连续* 函数是在图表中没有间隙或空洞的函数，而 *不连续* 函数则包含这些间隙和空洞。这通常意味着后者包含函数未定义的点，并可能需要通过极限进行近似。因此，连续性和极限是两个相关的概念。'
- en: 'Let’s proceed to solving limits; after all, you are not going to create a table
    every time and analyze the results subjectively to find the limits. There are
    three ways to solve limits:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续解决极限问题；毕竟，你不会每次都创建表格并主观分析结果以找到极限。解决极限有三种方法：
- en: '*Substitution*: This is the simplest rule and is generally used first.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*替换*：这是最简单的规则，通常首先使用。'
- en: '*Factoring*: This comes after substitution does not work.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*因式分解*：这是替换失败后的下一步。'
- en: '*Conjugate methods*: This solution comes after the first two do not work.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*共轭方法*：这个解决方案是在前两个方法不起作用之后的选择。'
- en: '*Substitution* involves simply plugging in the value that *x* approaches. Basically,
    these are functions that have solutions where the limits are used. Take the following
    example:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '*替换* 简单地将*x*接近的值代入。基本上，这些是使用极限的函数解。看下面的例子：'
- en: <math alttext="limit Underscript x right-arrow 5 Endscripts x plus 10 minus
    2 x"><mrow><msub><mo form="prefix" movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>5</mn></mrow></msub>
    <mi>x</mi> <mo>+</mo> <mn>10</mn> <mo>-</mo> <mn>2</mn> <mi>x</mi></mrow></math>
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow 5 Endscripts x plus 10 minus
    2 x"><mrow><msub><mo form="prefix" movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>5</mn></mrow></msub>
    <mi>x</mi> <mo>+</mo> <mn>10</mn> <mo>-</mo> <mn>2</mn> <mi>x</mi></mrow></math>
- en: 'Using substitution, the limit of the function is found as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 使用替换，函数的极限如下找到：
- en: <math alttext="StartLayout 1st Row  limit Underscript x right-arrow 5 Endscripts
    x plus 10 minus 2 x equals 5 plus 10 minus left-parenthesis 2 times 5 right-parenthesis
    equals 5 EndLayout"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><munder><mo
    form="prefix" movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>5</mn></mrow></munder>
    <mi>x</mi> <mo>+</mo> <mn>10</mn> <mo>-</mo> <mn>2</mn> <mi>x</mi> <mo>=</mo>
    <mn>5</mn> <mo>+</mo> <mn>10</mn> <mo>-</mo> <mrow><mo>(</mo> <mn>2</mn> <mo>×</mo>
    <mn>5</mn> <mo>)</mo></mrow> <mo>=</mo> <mn>5</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row  limit Underscript x right-arrow 5 Endscripts
    x plus 10 minus 2 x equals 5 plus 10 minus left-parenthesis 2 times 5 right-parenthesis
    equals 5 EndLayout"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><munder><mo
    form="prefix" movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>5</mn></mrow></munder>
    <mi>x</mi> <mo>+</mo> <mn>10</mn> <mo>-</mo> <mn>2</mn> <mi>x</mi> <mo>=</mo>
    <mn>5</mn> <mo>+</mo> <mn>10</mn> <mo>-</mo> <mrow><mo>(</mo> <mn>2</mn> <mo>×</mo>
    <mn>5</mn> <mo>)</mo></mrow> <mo>=</mo> <mn>5</mn></mrow></mtd></mtr></mtable></math>
- en: Therefore, the answer to the limit is 5.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，极限的答案为5。
- en: '*Factoring* is the next option when substitution does not work (e.g., the limit
    is undefined after plugging the value of *x* into the function). *Factoring* is
    all about changing the form of the equation using factors in such a way that the
    equation is not undefined anymore when using substitution. Take the following
    example:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '*因式分解* 是替换不起作用时的下一步选择（例如，将*x*的值代入函数后，极限未定义）。 *因式分解* 是通过使用因子以改变方程的形式的方法，使得在使用替换时方程不再是未定义的。看下面的例子：'
- en: <math alttext="limit Underscript x right-arrow negative 6 Endscripts StartFraction
    left-parenthesis x plus 6 right-parenthesis left-parenthesis x squared minus x
    plus 1 right-parenthesis Over x plus 6 EndFraction"><mrow><msub><mo form="prefix"
    movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></msub>
    <mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mn>6</mn><mo>)</mo></mrow><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mrow>
    <mrow><mi>x</mi><mo>+</mo><mn>6</mn></mrow></mfrac></mrow></math>
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow negative 6 Endscripts StartFraction
    left-parenthesis x plus 6 right-parenthesis left-parenthesis x squared minus x
    plus 1 right-parenthesis Over x plus 6 EndFraction"><mrow><msub><mo form="prefix"
    movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></msub>
    <mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mn>6</mn><mo>)</mo></mrow><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mrow>
    <mrow><mi>x</mi><mo>+</mo><mn>6</mn></mrow></mfrac></mrow></math>
- en: 'If you try substitution, you will get an undefined value as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试替换，将得到一个未定义的值如下：
- en: <math alttext="StartLayout 1st Row  limit Underscript x right-arrow negative
    6 Endscripts StartFraction left-parenthesis x plus 6 right-parenthesis left-parenthesis
    x squared minus x plus 1 right-parenthesis Over x plus 6 EndFraction equals StartFraction
    left-parenthesis negative 6 plus 6 right-parenthesis left-parenthesis left-parenthesis
    negative 6 right-parenthesis squared minus left-parenthesis negative 6 right-parenthesis
    plus 1 right-parenthesis Over negative 6 plus 6 EndFraction equals StartFraction
    0 Over 0 EndFraction equals Undefined EndLayout"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><munder><mo form="prefix" movablelimits="true">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></munder> <mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mn>6</mn><mo>)</mo></mrow><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mrow>
    <mrow><mi>x</mi><mo>+</mo><mn>6</mn></mrow></mfrac> <mo>=</mo> <mfrac><mrow><mrow><mo>(</mo><mo>-</mo><mn>6</mn><mo>+</mo><mn>6</mn><mo>)</mo></mrow><mo>(</mo><msup><mrow><mo>(</mo><mo>-</mo><mn>6</mn><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>-</mo><mrow><mo>(</mo><mo>-</mo><mn>6</mn><mo>)</mo></mrow><mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>6</mn><mo>+</mo><mn>6</mn></mrow></mfrac> <mo>=</mo> <mfrac><mn>0</mn>
    <mn>0</mn></mfrac> <mo>=</mo> <mtext>Undefined</mtext></mrow></mtd></mtr></mtable></math>
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row  limit Underscript x right-arrow negative
    6 Endscripts StartFraction left-parenthesis x plus 6 right-parenthesis left-parenthesis
    x squared minus x plus 1 right-parenthesis Over x plus 6 EndFraction equals StartFraction
    left-parenthesis negative 6 plus 6 right-parenthesis left-parenthesis left-parenthesis
    negative 6 right-parenthesis squared minus left-parenthesis negative 6 right-parenthesis
    plus 1 right-parenthesis Over negative 6 plus 6 EndFraction equals StartFraction
    0 Over 0 EndFraction equals Undefined EndLayout"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><munder><mo form="prefix" movablelimits="true">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></munder> <mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mn>6</mn><mo>)</mo></mrow><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mrow>
    <mrow><mi>x</mi><mo>+</mo><mn>6</mn></mrow></mfrac> <mo>=</mo> <mfrac><mrow><mrow><mo>(</mo><mo>-</mo><mn>6</mn><mo>+</mo><mn>6</mn><mo>)</mo></mrow><mo>(</mo><msup><mrow><mo>(</mo><mo>-</mo><mn>6</mn><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>-</mo><mrow><mo>(</mo><mo>-</mo><mn>6</mn><mo>)</mo></mrow><mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>6</mn><mo>+</mo><mn>6</mn></mrow></mfrac> <mo>=</mo> <mfrac><mn>0</mn>
    <mn>0</mn></mfrac> <mo>=</mo> <mtext>Undefined</mtext></mrow></mtd></mtr></mtable></math>
- en: 'Factoring may help in this case. For example, the nominator is multiplied by
    (*x *+ 6) and then divided by (*x* + 6). Simplifying this by canceling the two
    terms could give a solution:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，因式分解可能有所帮助。例如，分子乘以（*x* + 6），然后除以（*x* + 6）。通过取消两个项来简化这个过程可能会得到一个解：
- en: <math alttext="limit Underscript x right-arrow negative 6 Endscripts StartFraction
    left-parenthesis x plus 6 right-parenthesis left-parenthesis x squared minus x
    plus 1 right-parenthesis Over x plus 6 EndFraction equals limit Underscript x
    right-arrow negative 6 Endscripts x squared minus x plus 1"><mrow><msub><mo form="prefix"
    movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></msub>
    <mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mn>6</mn><mo>)</mo></mrow><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mrow>
    <mrow><mi>x</mi><mo>+</mo><mn>6</mn></mrow></mfrac> <mo>=</mo> <msub><mo form="prefix"
    movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></msub>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo> <mi>x</mi> <mo>+</mo> <mn>1</mn></mrow></math>
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow negative 6 Endscripts StartFraction
    left-parenthesis x plus 6 right-parenthesis left-parenthesis x squared minus x
    plus 1 right-parenthesis Over x plus 6 EndFraction equals limit Underscript x
    right-arrow negative 6 Endscripts x squared minus x plus 1"><mrow><msub><mo form="prefix"
    movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></msub>
    <mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mn>6</mn><mo>)</mo></mrow><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mrow>
    <mrow><mi>x</mi><mo>+</mo><mn>6</mn></mrow></mfrac> <mo>=</mo> <msub><mo form="prefix"
    movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></msub>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo> <mi>x</mi> <mo>+</mo> <mn>1</mn></mrow></math>
- en: 'Now that factoring is done, you can try substitution once again:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在因式分解已完成，您可以再次尝试替换：
- en: <math alttext="limit Underscript x right-arrow negative 6 Endscripts x squared
    minus x plus 1 equals left-parenthesis negative 6 right-parenthesis squared minus
    left-parenthesis negative 6 right-parenthesis plus 1 equals 43"><mrow><msub><mo
    form="prefix" movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></msub>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo> <mi>x</mi> <mo>+</mo> <mn>1</mn>
    <mo>=</mo> <msup><mrow><mo>(</mo><mo>-</mo><mn>6</mn><mo>)</mo></mrow> <mn>2</mn></msup>
    <mo>-</mo> <mrow><mo>(</mo> <mo>-</mo> <mn>6</mn> <mo>)</mo></mrow> <mo>+</mo>
    <mn>1</mn> <mo>=</mo> <mn>43</mn></mrow></math>
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow negative 6 Endscripts x squared
    minus x plus 1 equals left-parenthesis negative 6 right-parenthesis squared minus
    left-parenthesis negative 6 right-parenthesis plus 1 equals 43"><mrow><msub><mo
    form="prefix" movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></msub>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo> <mi>x</mi> <mo>+</mo> <mn>1</mn>
    <mo>=</mo> <msup><mrow><mo>(</mo><mo>-</mo><mn>6</mn><mo>)</mo></mrow> <mn>2</mn></msup>
    <mo>-</mo> <mrow><mo>(</mo> <mo>-</mo> <mn>6</mn> <mo>)</mo></mrow> <mo>+</mo>
    <mn>1</mn> <mo>=</mo> <mn>43</mn></mrow></math>
- en: The limit of the function as *x* tends toward –6 is therefore 43.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在*x*趋向于-6时的极限因此为43。
- en: 'Forming a conjugate is the next option when substitution and factoring do not
    work. A *conjugate* is formed by simply changing signs between two variables.
    For example, the conjugate of *x* + *y* is  *x* – *y*. The way to do this in the
    case of a fraction is to multiply the nominator and the denominator by the conjugate
    of one of them (with a preference to use the conjugate of the term that has a
    square root since it will get canceled out). Consider the following example:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当替换和因式分解都不起作用时，形成共轭是下一步的选择。 *共轭* 是通过简单地改变两个变量之间的符号来形成的。例如，*x* + *y* 的共轭是 *x*
    - *y*。在分数的情况下，通过用其中一个的共轭来乘分子和分母（最好使用具有平方根的项的共轭，因为它将被取消）。考虑以下例子：
- en: <math alttext="limit Underscript x right-arrow 9 Endscripts StartFraction x
    minus 9 Over StartRoot x EndRoot minus 3 EndFraction"><mrow><msub><mo form="prefix"
    movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub>
    <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mi>x</mi><mo>-</mo><mn>9</mn></mrow>
    <mrow><msqrt><mi>x</mi></msqrt><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle></mrow></math>
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow 9 Endscripts StartFraction x
    minus 9 Over StartRoot x EndRoot minus 3 EndFraction"><mrow><msub><mo form="prefix"
    movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub>
    <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mi>x</mi><mo>-</mo><mn>9</mn></mrow>
    <mrow><msqrt><mi>x</mi></msqrt><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle></mrow></math>
- en: 'By multiplying both terms by the conjugate of the denominator, you will have
    started to use the conjugate method to solve the problem:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将分母的共轭乘以两个项，您将开始使用共轭方法来解决问题：
- en: <math alttext="limit Underscript x right-arrow 9 Endscripts StartFraction x
    minus 9 Over StartRoot x EndRoot minus 3 EndFraction left-parenthesis StartFraction
    StartRoot x EndRoot plus 3 Over StartRoot x EndRoot plus 3 EndFraction right-parenthesis"><mrow><msub><mo
    form="prefix" movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub>
    <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mi>x</mi><mo>-</mo><mn>9</mn></mrow>
    <mrow><msqrt><mi>x</mi></msqrt><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle> <mrow><mo>(</mo>
    <mfrac><mrow><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn></mrow> <mrow><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn></mrow></mfrac>
    <mo>)</mo></mrow></mrow></math>
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow 9 Endscripts StartFraction x
    minus 9 Over StartRoot x EndRoot minus 3 EndFraction left-parenthesis StartFraction
    StartRoot x EndRoot plus 3 Over StartRoot x EndRoot plus 3 EndFraction right-parenthesis"><mrow><msub><mo
    form="prefix" movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub>
    <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mi>x</mi><mo>-</mo><mn>9</mn></mrow>
    <mrow><msqrt><mi>x</mi></msqrt><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle> <mrow><mo>(</mo>
    <mfrac><mrow><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn></mrow> <mrow><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn></mrow></mfrac>
    <mo>)</mo></mrow></mrow></math>
- en: 'Taking into account the multiplication and then simplifying gives the following:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑乘法然后简化得到如下结果：
- en: <math alttext="limit Underscript x right-arrow 9 Endscripts StartFraction left-parenthesis
    x minus 9 right-parenthesis left-parenthesis StartRoot x EndRoot plus 3 right-parenthesis
    Over left-parenthesis StartRoot x EndRoot minus 3 right-parenthesis left-parenthesis
    StartRoot x EndRoot plus 3 right-parenthesis EndFraction"><mrow><msub><mo form="prefix"
    movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub>
    <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>-</mo><mn>9</mn><mo>)</mo></mrow><mrow><mo>(</mo><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn><mo>)</mo></mrow></mrow>
    <mrow><mrow><mo>(</mo><msqrt><mi>x</mi></msqrt><mo>-</mo><mn>3</mn><mo>)</mo></mrow><mrow><mo>(</mo><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn><mo>)</mo></mrow></mrow></mfrac></mstyle></mrow></math>
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow 9 Endscripts StartFraction left-parenthesis
    x minus 9 right-parenthesis left-parenthesis StartRoot x EndRoot plus 3 right-parenthesis
    Over left-parenthesis StartRoot x EndRoot minus 3 right-parenthesis left-parenthesis
    StartRoot x EndRoot plus 3 right-parenthesis EndFraction"><mrow><msub><mo form="prefix"
    movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub>
    <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>-</mo><mn>9</mn><mo>)</mo></mrow><mrow><mo>(</mo><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn><mo>)</mo></mrow></mrow>
    <mrow><mrow><mo>(</mo><msqrt><mi>x</mi></msqrt><mo>-</mo><mn>3</mn><mo>)</mo></mrow><mrow><mo>(</mo><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn><mo>)</mo></mrow></mrow></mfrac></mstyle></mrow></math>
- en: 'You will be left with the following familiar situation:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到以下熟悉的情况：
- en: <math alttext="limit Underscript x right-arrow 9 Endscripts StartFraction left-parenthesis
    x minus 9 right-parenthesis left-parenthesis StartRoot x EndRoot plus 3 right-parenthesis
    Over x minus 9 EndFraction"><mrow><msub><mo form="prefix" movablelimits="true">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub> <mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>-</mo><mn>9</mn><mo>)</mo></mrow><mrow><mo>(</mo><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn><mo>)</mo></mrow></mrow>
    <mrow><mi>x</mi><mo>-</mo><mn>9</mn></mrow></mfrac></mrow></math>
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow 9 Endscripts StartFraction left-parenthesis
    x minus 9 right-parenthesis left-parenthesis StartRoot x EndRoot plus 3 right-parenthesis
    Over x minus 9 EndFraction"><mrow><msub><mo form="prefix" movablelimits="true">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub> <mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>-</mo><mn>9</mn><mo>)</mo></mrow><mrow><mo>(</mo><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn><mo>)</mo></mrow></mrow>
    <mrow><mi>x</mi><mo>-</mo><mn>9</mn></mrow></mfrac></mrow></math>
- en: <math alttext="limit Underscript x right-arrow 9 Endscripts StartRoot x EndRoot
    plus 3"><mrow><msub><mo form="prefix" movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub>
    <msqrt><mi>x</mi></msqrt> <mo>+</mo> <mn>3</mn></mrow></math>
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow 9 Endscripts StartRoot x EndRoot
    plus 3"><mrow><msub><mo form="prefix" movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub>
    <msqrt><mi>x</mi></msqrt> <mo>+</mo> <mn>3</mn></mrow></math>
- en: 'Now the function is ready for substitution:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在函数已准备好进行替换：
- en: <math alttext="limit Underscript x right-arrow 9 Endscripts StartRoot 9 EndRoot
    plus 3 equals 3 plus 3 equals 6"><mrow><msub><mo form="prefix" movablelimits="true">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub> <msqrt><mn>9</mn></msqrt> <mo>+</mo>
    <mn>3</mn> <mo>=</mo> <mn>3</mn> <mo>+</mo> <mn>3</mn> <mo>=</mo> <mn>6</mn></mrow></math>
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow 9 Endscripts StartRoot 9 EndRoot
    plus 3 equals 3 plus 3 equals 6"><mrow><msub><mo form="prefix" movablelimits="true">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub> <msqrt><mn>9</mn></msqrt> <mo>+</mo>
    <mn>3</mn> <mo>=</mo> <mn>3</mn> <mo>+</mo> <mn>3</mn> <mo>=</mo> <mn>6</mn></mrow></math>
- en: The solution to the function is therefore 6\. As you can see, sometimes work
    needs to be done on the equations before they are ready for substitution.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，函数的解为6。如您所见，有时需要对方程进行处理，然后才能进行替换。
- en: Note
  id: totrans-375
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The key takeaways from this section are as follows:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的关键要点如下：
- en: Limits help find solutions for functions that may be undefined in certain points.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 极限帮助找到在某些点可能未定义的函数的解。
- en: For the general limit to exist, the two one-sided limits must exist and must
    be equal.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一般的极限存在，两个单侧极限必须存在且必须相等。
- en: There are ways to find the limit of a function, notably substitution, factoring,
    and forming the conjugate.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多种方法可以找到函数的极限，尤其是替换、因式分解和形成共轭。
- en: Derivatives
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导数
- en: A *derivative* measures the change in a function given a change of one or more
    of its inputs. In other words, it is the rate of change of a function at a given
    point.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '*导数* 衡量给定一个或多个输入变化时函数的变化。换句话说，它是给定点上函数变化率。'
- en: 'Having a solid understanding of derivatives is important in building machine
    learning models, for multiple reasons:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建机器学习模型中，对导数有深刻的理解是重要的，有多个原因：
- en: Optimization
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 优化
- en: To minimize the loss function, optimization methods employ derivatives to ascertain
    the direction of the steepest descent and modify the model’s parameters.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 要使损失函数最小化，优化方法利用导数确定最陡下降的方向并修改模型的参数。
- en: Backpropagation
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 反向传播
- en: To execute gradient descent in deep learning, the backpropagation technique
    uses derivatives to calculate the gradients of the loss function with respect
    to the model’s parameters.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在深度学习中执行梯度下降时，反向传播技术利用导数计算损失函数对模型参数的梯度。
- en: Hyperparameter tuning
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 超参数调优
- en: To improve the performance of the model, derivatives are used for sensitivity
    analysis and tuning of hyperparameters.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提升模型性能，导数用于敏感性分析和超参数调优。
- en: Do not forget what you learned from the previous section on limits, as you will
    need this knowledge for this section as well. Calculus mainly deals with derivatives
    and integrals. This section discusses derivatives and their uses.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记前一节关于极限的知识，因为在本节中你同样会需要这些知识。微积分主要涉及导数和积分。本节讨论了导数及其用途。
- en: You can consider derivatives to be functions that represent (or model) the slope
    of another function at some point. A *slope* is a measure of a line’s position
    relative to a horizontal line. A positive slope indicates a line moving up, while
    a negative slope indicates a line moving down.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将导数视为表示（或建模）另一函数在某点斜率的函数。*斜率*是一条线相对于水平线的位置的度量。正斜率表示线上升，而负斜率表示线下降。
- en: 'Derivatives and slopes are related concepts, but they are not the same thing.
    Here’s the main difference between the two:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 导数和斜率是相关的概念，但它们并不完全相同。以下是两者的主要区别：
- en: Slope
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 斜率
- en: The slope measures the steepness of a line. It is the ratio of the change in
    the *y*-axis to the change in the *x*-axis.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 斜率衡量了一条线的陡峭程度。它是*y*轴变化与*x*轴变化的比率。
- en: Derivative
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 导数
- en: The derivative describes the rate of change of a given function. As the distance
    between two points on a function approaches zero, the derivative of that function
    at that point is the limit of the slope of the tangent line.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 导数描述了给定函数的变化率。当函数上两点之间的距离趋近于零时，该函数在该点的导数就是切线斜率的极限。
- en: 'Before explaining derivatives in layperson’s terms and showing some examples,
    let’s see their formal definitions:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释导数的通俗术语及展示一些例子之前，让我们先看看它们的形式定义：
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts StartFraction f left-parenthesis x plus h right-parenthesis
    minus f left-parenthesis x right-parenthesis Over h EndFraction"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo
    form="prefix" movablelimits="true">lim</mo> <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub>
    <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo>)</mo><mo>-</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mi>h</mi></mfrac></mstyle></mrow></math>
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts StartFraction f left-parenthesis x plus h right-parenthesis
    minus f left-parenthesis x right-parenthesis Over h EndFraction"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo
    form="prefix" movablelimits="true">lim</mo> <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub>
    <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo>)</mo><mo>-</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mi>h</mi></mfrac></mstyle></mrow></math>
- en: 'The equation forms the basis of solving derivatives, although there are many
    shortcuts that you will learn about. Let’s try finding the derivative of a function
    using the formal definition. Consider the following equation:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程构成了求解导数的基础，尽管你将会学到许多简化的捷径。让我们尝试使用形式化定义找到函数的导数。考虑以下方程：
- en: <math alttext="f left-parenthesis x right-parenthesis equals x squared plus
    4 x minus 2"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>4</mn> <mi>x</mi> <mo>-</mo>
    <mn>2</mn></mrow></math>
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals x squared plus
    4 x minus 2"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>4</mn> <mi>x</mi> <mo>-</mo>
    <mn>2</mn></mrow></math>
- en: 'To find the derivative, plug *f(x)* into the formal definition and then solve
    the limit:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到导数，将*f(x)*代入形式化定义，然后解决极限：
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts StartFraction f left-parenthesis x plus h right-parenthesis
    minus f left-parenthesis x right-parenthesis Over h EndFraction"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo
    form="prefix" movablelimits="true">lim</mo> <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub>
    <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo>)</mo><mo>-</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mi>h</mi></mfrac></mstyle></mrow></math>
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts StartFraction f left-parenthesis x plus h right-parenthesis
    minus f left-parenthesis x right-parenthesis Over h EndFraction"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo
    form="prefix" movablelimits="true">lim</mo> <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub>
    <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo>)</mo><mo>-</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mi>h</mi></mfrac></mstyle></mrow></math>
- en: 'To simplify things, let’s find *f(x + h)* so that plugging it into the formal
    definition becomes easier:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化问题，让我们找到*f(x + h)*，这样插入形式化定义会更容易：
- en: <math alttext="f left-parenthesis x plus h right-parenthesis equals left-parenthesis
    x plus h right-parenthesis squared plus 4 left-parenthesis x plus h right-parenthesis
    minus 2"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>+</mo> <mi>h</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msup><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>+</mo> <mn>4</mn> <mrow><mo>(</mo> <mi>x</mi> <mo>+</mo>
    <mi>h</mi> <mo>)</mo></mrow> <mo>-</mo> <mn>2</mn></mrow></math>
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x plus h right-parenthesis equals left-parenthesis
    x plus h right-parenthesis squared plus 4 left-parenthesis x plus h right-parenthesis
    minus 2"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>+</mo> <mi>h</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msup><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>+</mo> <mn>4</mn> <mrow><mo>(</mo> <mi>x</mi> <mo>+</mo>
    <mi>h</mi> <mo>)</mo></mrow> <mo>-</mo> <mn>2</mn></mrow></math>
- en: <math alttext="f left-parenthesis x plus h right-parenthesis equals x squared
    plus 2 x h plus h squared plus 4 x plus 4 h minus 2"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>+</mo> <mi>h</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>2</mn> <mi>x</mi> <mi>h</mi> <mo>+</mo> <msup><mi>h</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>4</mn> <mi>x</mi> <mo>+</mo> <mn>4</mn> <mi>h</mi>
    <mo>-</mo> <mn>2</mn></mrow></math>
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x plus h right-parenthesis equals x squared
    plus 2 x h plus h squared plus 4 x plus 4 h minus 2"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>+</mo> <mi>h</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>2</mn> <mi>x</mi> <mi>h</mi> <mo>+</mo> <msup><mi>h</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>4</mn> <mi>x</mi> <mo>+</mo> <mn>4</mn> <mi>h</mi>
    <mo>-</mo> <mn>2</mn></mrow></math>
- en: 'Now let’s plug *f(x + h)* into the definition:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将*f(x + h)*代入定义中：
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts StartFraction x squared plus 2 x h plus h squared plus
    4 x plus 4 h minus 2 minus x squared minus 4 x plus 2 Over h EndFraction"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo
    form="prefix" movablelimits="true">lim</mo> <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub>
    <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo><mn>2</mn><mi>x</mi><mi>h</mi><mo>+</mo><msup><mi>h</mi> <mn>2</mn></msup>
    <mo>+</mo><mn>4</mn><mi>x</mi><mo>+</mo><mn>4</mn><mi>h</mi><mo>-</mo><mn>2</mn><mo>-</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mn>4</mn><mi>x</mi><mo>+</mo><mn>2</mn></mrow> <mi>h</mi></mfrac></mstyle></mrow></math>
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts StartFraction x squared plus 2 x h plus h squared plus
    4 x plus 4 h minus 2 minus x squared minus 4 x plus 2 Over h EndFraction"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo
    form="prefix" movablelimits="true">lim</mo> <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub>
    <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo><mn>2</mn><mi>x</mi><mi>h</mi><mo>+</mo><msup><mi>h</mi> <mn>2</mn></msup>
    <mo>+</mo><mn>4</mn><mi>x</mi><mo>+</mo><mn>4</mn><mi>h</mi><mo>-</mo><mn>2</mn><mo>-</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mn>4</mn><mi>x</mi><mo>+</mo><mn>2</mn></mrow> <mi>h</mi></mfrac></mstyle></mrow></math>
- en: 'Notice how there are many terms that can be simplified so that the formula
    becomes clearer. Remember, you are trying to find the limit for the moment, and
    the derivative is found after solving the limit:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 注意看有多少术语可以简化，这样公式会更清晰。记住，你现在是在寻找极限，而求导则是在解决了极限之后进行的：
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts StartFraction 2 x h plus h squared plus 4 h Over h
    EndFraction"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msub><mo form="prefix" movablelimits="true">lim</mo>
    <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><mrow><mn>2</mn><mi>x</mi><mi>h</mi><mo>+</mo><msup><mi>h</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>4</mn><mi>h</mi></mrow> <mi>h</mi></mfrac></mstyle></mrow></math>
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts StartFraction 2 x h plus h squared plus 4 h Over h
    EndFraction"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msub><mo form="prefix" movablelimits="true">lim</mo>
    <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><mrow><mn>2</mn><mi>x</mi><mi>h</mi><mo>+</mo><msup><mi>h</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>4</mn><mi>h</mi></mrow> <mi>h</mi></mfrac></mstyle></mrow></math>
- en: 'The division by *h* gives further potential for simplification since you can
    divide all the terms in the numerator by the denominator *h*:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 通过除以*h*，进一步简化的潜力得以释放，因为你可以将分子中的所有项除以分母*h*：
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts 2 x plus h plus 4"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo form="prefix"
    movablelimits="true">lim</mo> <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub>
    <mn>2</mn> <mi>x</mi> <mo>+</mo> <mi>h</mi> <mo>+</mo> <mn>4</mn></mrow></math>
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts 2 x plus h plus 4"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo form="prefix"
    movablelimits="true">lim</mo> <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub>
    <mn>2</mn> <mi>x</mi> <mo>+</mo> <mi>h</mi> <mo>+</mo> <mn>4</mn></mrow></math>
- en: 'It’s now time to solve the limit. Because the equation is simple, the first
    attempt is by substitution, which, as you have guessed, is possible. By substituting
    the variable *h* and making it zero (according to the limit), you are left with
    the following:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候解决极限了。由于方程简单，第一次尝试是通过代入求解，正如你所猜测的那样，这是可行的。通过代入变量*h*并使其趋向于零（根据极限），你得到如下结果：
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x plus
    4"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>4</mn></mrow></math>
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x plus
    4"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>4</mn></mrow></math>
- en: 'That is the derivative of the original function *f(x)*. If you want to find
    the derivative of the function when *x* = 2, you simply have to plug 2 into the
    derivative function:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是原始函数*f(x)*的导数。如果你想找到函数在*x* = 2时的导数，只需将2代入导数函数即可：
- en: <math alttext="f prime left-parenthesis 2 right-parenthesis equals 2 left-parenthesis
    2 right-parenthesis plus 4 equals 8"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mn>2</mn> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <mrow><mo>(</mo>
    <mn>2</mn> <mo>)</mo></mrow> <mo>+</mo> <mn>4</mn> <mo>=</mo> <mn>8</mn></mrow></math>
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis 2 right-parenthesis equals 2 left-parenthesis
    2 right-parenthesis plus 4 equals 8"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mn>2</mn> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <mrow><mo>(</mo>
    <mn>2</mn> <mo>)</mo></mrow> <mo>+</mo> <mn>4</mn> <mo>=</mo> <mn>8</mn></mrow></math>
- en: '[Figure 4-15](#figure-4-15) shows the original function’s graph with the derivative
    (the straight line). Notice how *f''(2)* lies exactly at 8\. The slope of *f(x)*
    when *x* = 2 is 8.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-15](#figure-4-15)展示了原始函数的图像及其导数（直线）。注意*f''(2)*恰好在8处。当*x* = 2时，*f(x)*的斜率为8。'
- en: '![](assets/dlff_0415.png)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dlff_0415.png)'
- en: Figure 4-15\. The original f(x) with its derivative f'(x)
  id: totrans-417
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-15\. 原始函数*f(x)*及其导数*f'(x)*
- en: Note
  id: totrans-418
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that when *f(x)* hits the bottom and starts rising, *f'(x)* crosses the
    zero line.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当*f(x)*触底并开始上升时，*f'(x)*会穿过零线。
- en: You are unlikely to use the formal definition every time you want to find a
    derivative. There are derivative rules that allow you to save a lot of time through
    shortcuts. The first rule is referred to as the *power rule,* which is a way to
    find the derivative of functions with exponents.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你想要找到导数时，可能不会使用形式化定义。有导数规则可以通过快捷方式节省大量时间。第一个规则称为*幂规则*，是找到具有指数的函数的导数的一种方法。
- en: 'It is common to also refer to derivatives using this notation (which is the
    same thing as *f''(x)*):'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种符号引用导数也很常见（这与*f'(x)*是一样的）：
- en: <math alttext="StartFraction d y Over d x EndFraction"><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></math>
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction d y Over d x EndFraction"><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></math>
- en: 'The power rule for finding derivatives is as follows:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找导数的幂规则如下：
- en: <math alttext="StartFraction d y Over d x EndFraction left-parenthesis a x Superscript
    n Baseline right-parenthesis equals left-parenthesis a period n right-parenthesis
    x Superscript n minus 1"><mrow><mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></mstyle> <mrow><mo>(</mo> <mi>a</mi>
    <msup><mi>x</mi> <mi>n</mi></msup> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo>
    <mi>a</mi> <mo lspace="0%" rspace="0%">.</mo> <mi>n</mi> <mo>)</mo></mrow> <msup><mi>x</mi>
    <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction d y Over d x EndFraction left-parenthesis a x Superscript
    n Baseline right-parenthesis equals left-parenthesis a period n right-parenthesis
    x Superscript n minus 1"><mrow><mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></mstyle> <mrow><mo>(</mo> <mi>a</mi>
    <msup><mi>x</mi> <mi>n</mi></msup> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo>
    <mi>a</mi> <mo lspace="0%" rspace="0%">.</mo> <mi>n</mi> <mo>)</mo></mrow> <msup><mi>x</mi>
    <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
- en: 'Basically, this means that the derivative is found by multiplying the constant
    by the exponent and then subtracting 1 from the exponent. Here’s an example:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这意味着导数是通过将常数乘以指数然后从指数中减去1来找到的。这里有一个例子：
- en: <math alttext="f left-parenthesis x right-parenthesis equals x Superscript 4"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>4</mn></msup></mrow></math>
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals x Superscript 4"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>4</mn></msup></mrow></math>
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals left-parenthesis
    1 times 4 right-parenthesis x Superscript left-parenthesis 4 minus 1 right-parenthesis
    Baseline equals 4 x cubed"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <mn>1</mn> <mo>×</mo>
    <mn>4</mn> <mo>)</mo></mrow> <msup><mi>x</mi> <mrow><mo>(</mo><mn>4</mn><mo>-</mo><mn>1</mn><mo>)</mo></mrow></msup>
    <mo>=</mo> <mn>4</mn> <msup><mi>x</mi> <mn>3</mn></msup></mrow></math>
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals left-parenthesis
    1 times 4 right-parenthesis x Superscript left-parenthesis 4 minus 1 right-parenthesis
    Baseline equals 4 x cubed"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <mn>1</mn> <mo>×</mo>
    <mn>4</mn> <mo>)</mo></mrow> <msup><mi>x</mi> <mrow><mo>(</mo><mn>4</mn><mo>-</mo><mn>1</mn><mo>)</mo></mrow></msup>
    <mo>=</mo> <mn>4</mn> <msup><mi>x</mi> <mn>3</mn></msup></mrow></math>
- en: 'Remember that if there is no constant attached to the variable, it means that
    the constant is equal to 1\. Here’s a more complex example with the same principle:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果变量没有附加常数，这意味着该常数等于1。这里有一个具有相同原则的更复杂的例子：
- en: <math alttext="f left-parenthesis x right-parenthesis equals 2 x squared plus
    3 x Superscript 7 Baseline minus 2 x cubed"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>3</mn> <msup><mi>x</mi> <mn>7</mn></msup> <mo>-</mo> <mn>2</mn>
    <msup><mi>x</mi> <mn>3</mn></msup></mrow></math>
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals 2 x squared plus
    3 x Superscript 7 Baseline minus 2 x cubed"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>3</mn> <msup><mi>x</mi> <mn>7</mn></msup> <mo>-</mo> <mn>2</mn>
    <msup><mi>x</mi> <mn>3</mn></msup></mrow></math>
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 4 x plus
    21 x Superscript 6 Baseline minus 6 x squared"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>4</mn> <mi>x</mi>
    <mo>+</mo> <mn>21</mn> <msup><mi>x</mi> <mn>6</mn></msup> <mo>-</mo> <mn>6</mn>
    <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals 4 x plus
    21 x Superscript 6 Baseline minus 6 x squared"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>4</mn> <mi>x</mi>
    <mo>+</mo> <mn>21</mn> <msup><mi>x</mi> <mn>6</mn></msup> <mo>-</mo> <mn>6</mn>
    <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
- en: 'It is worth noting that the rule also applies to constants even though they
    do not satisfy the general form of the power rule. The derivative of a constant
    is zero. While it helps to know why, first you must be aware of the following
    mathematical concept:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，即使常数不符合幂规则的一般形式，该规则也适用于常数。常数的导数为零。虽然知道为什么有所帮助，但首先你必须了解以下数学概念：
- en: <math alttext="x Superscript 0 Baseline equals 1"><mrow><msup><mi>x</mi> <mn>0</mn></msup>
    <mo>=</mo> <mn>1</mn></mrow></math>
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x Superscript 0 Baseline equals 1"><mrow><msup><mi>x</mi> <mn>0</mn></msup>
    <mo>=</mo> <mn>1</mn></mrow></math>
- en: 'That being said, you can imagine constants as always being multiplied by *x*
    to the power of zero (since doing so does not change their value). Now, if you
    want to find the derivative of 17, here’s how it would go:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，你可以想象常数总是乘以*x*的零次幂（因为这样做不会改变它们的值）。现在，如果你想要找到17的导数，就像这样：
- en: <math alttext="17 equals 17 x Superscript 0 Baseline equals left-parenthesis
    0 times 17 right-parenthesis x Superscript 0 minus 1 Baseline equals 0 x Superscript
    negative 1 Baseline equals 0"><mrow><mn>17</mn> <mo>=</mo> <mn>17</mn> <msup><mi>x</mi>
    <mn>0</mn></msup> <mo>=</mo> <mrow><mo>(</mo> <mn>0</mn> <mo>×</mo> <mn>17</mn>
    <mo>)</mo></mrow> <msup><mi>x</mi> <mrow><mn>0</mn><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <mn>0</mn> <msup><mi>x</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <mn>0</mn></mrow></math>
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="17 equals 17 x Superscript 0 Baseline equals left-parenthesis
    0 times 17 right-parenthesis x Superscript 0 minus 1 Baseline equals 0 x Superscript
    negative 1 Baseline equals 0"><mrow><mn>17</mn> <mo>=</mo> <mn>17</mn> <msup><mi>x</mi>
    <mn>0</mn></msup> <mo>=</mo> <mrow><mo>(</mo> <mn>0</mn> <mo>×</mo> <mn>17</mn>
    <mo>)</mo></mrow> <msup><mi>x</mi> <mrow><mn>0</mn><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <mn>0</mn> <msup><mi>x</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <mn>0</mn></mrow></math>
- en: 'As you know, anything multiplied by zero returns zero as a result. This gives
    the constants rule for derivatives as follows:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，任何乘以零的东西返回零作为结果。这为常数导数规则提供了如下定义：
- en: <math alttext="StartFraction d y Over d x EndFraction left-parenthesis a right-parenthesis
    equals 0"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>a</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>0</mn></mrow></math>
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction d y Over d x EndFraction left-parenthesis a right-parenthesis
    equals 0"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>a</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>0</mn></mrow></math>
- en: You follow the same logic when encountering fractions or negative numbers in
    the exponents.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 遇到分数或负数指数时，你要遵循相同的逻辑。
- en: 'The *product rule* of derivatives is useful when there are two functions multiplied
    by each other. The product rule is as follows:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 导数的*乘积规则*在两个函数相乘时非常有用。乘积规则如下：
- en: <math alttext="StartFraction d y Over d x EndFraction left-bracket f left-parenthesis
    x right-parenthesis g left-parenthesis x right-parenthesis right-bracket equals
    f prime left-parenthesis x right-parenthesis g left-parenthesis x right-parenthesis
    plus f left-parenthesis x right-parenthesis g prime left-parenthesis x right-parenthesis"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mrow><mo>[</mo> <mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mi>g</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>=</mo> <msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mi>g</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>+</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <msup><mi>g</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction d y Over d x EndFraction left-bracket f left-parenthesis
    x right-parenthesis g left-parenthesis x right-parenthesis right-bracket equals
    f prime left-parenthesis x right-parenthesis g left-parenthesis x right-parenthesis
    plus f left-parenthesis x right-parenthesis g prime left-parenthesis x right-parenthesis"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mrow><mo>[</mo> <mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mi>g</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>=</mo> <msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mi>g</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>+</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <msup><mi>g</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
- en: 'Let’s take an example and find the derivative using the product rule:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举个例子，并使用乘积法则找到导数：
- en: <math alttext="h left-parenthesis x right-parenthesis equals left-parenthesis
    x squared plus 2 right-parenthesis left-parenthesis x cubed plus 1 right-parenthesis"><mrow><mi>h</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>2</mn> <mo>)</mo></mrow> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mn>3</mn></msup> <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="h left-parenthesis x right-parenthesis equals left-parenthesis
    x squared plus 2 right-parenthesis left-parenthesis x cubed plus 1 right-parenthesis"><mrow><mi>h</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>2</mn> <mo>)</mo></mrow> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mn>3</mn></msup> <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
- en: 'The equation can clearly be segmented into two terms, *f(x)* and *g(x),* like
    this:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式可以明显地分成两个项，*f(x)*和*g(x)*，如下所示：
- en: <math alttext="f left-parenthesis x right-parenthesis equals left-parenthesis
    x squared plus 2 right-parenthesis"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>2</mn> <mo>)</mo></mrow></mrow></math>
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals left-parenthesis
    x squared plus 2 right-parenthesis"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>2</mn> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="g left-parenthesis x right-parenthesis equals left-parenthesis
    x cubed plus 1 right-parenthesis"><mrow><mi>g</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <msup><mi>x</mi> <mn>3</mn></msup>
    <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="g left-parenthesis x right-parenthesis equals left-parenthesis
    x cubed plus 1 right-parenthesis"><mrow><mi>g</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <msup><mi>x</mi> <mn>3</mn></msup>
    <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
- en: 'Let’s find the derivatives of the two terms before applying the product rule.
    Notice that finding the derivative of *f(x)* and *g(x)* is easy once you understand
    the power rule:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用乘积法则之前，我们来找出这两个术语的导数。请注意，一旦理解了幂规则，找到*f(x)*和*g(x)*的导数就很容易：
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn>
    <mi>x</mi></mrow></math>
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn>
    <mi>x</mi></mrow></math>
- en: <math alttext="g prime left-parenthesis x right-parenthesis equals 3 x squared"><mrow><msup><mi>g</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>3</mn>
    <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="g prime left-parenthesis x right-parenthesis equals 3 x squared"><mrow><msup><mi>g</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>3</mn>
    <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
- en: 'When applying the product rule, you should get the following:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用乘积规则时，你应该得到以下结果：
- en: <math alttext="h prime left-parenthesis x right-parenthesis equals left-parenthesis
    x squared plus 2 right-parenthesis left-parenthesis 3 x squared right-parenthesis
    plus left-parenthesis 2 x right-parenthesis left-parenthesis x cubed plus 1 right-parenthesis"><mrow><msup><mi>h</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>2</mn> <mo>)</mo></mrow> <mrow><mo>(</mo>
    <mn>3</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>)</mo></mrow> <mo>+</mo> <mrow><mo>(</mo>
    <mn>2</mn> <mi>x</mi> <mo>)</mo></mrow> <mrow><mo>(</mo> <msup><mi>x</mi> <mn>3</mn></msup>
    <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="h prime left-parenthesis x right-parenthesis equals left-parenthesis
    x squared plus 2 right-parenthesis left-parenthesis 3 x squared right-parenthesis
    plus left-parenthesis 2 x right-parenthesis left-parenthesis x cubed plus 1 right-parenthesis"><mrow><msup><mi>h</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>2</mn> <mo>)</mo></mrow> <mrow><mo>(</mo>
    <mn>3</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>)</mo></mrow> <mo>+</mo> <mrow><mo>(</mo>
    <mn>2</mn> <mi>x</mi> <mo>)</mo></mrow> <mrow><mo>(</mo> <msup><mi>x</mi> <mn>3</mn></msup>
    <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="h prime left-parenthesis x right-parenthesis equals 3 x Superscript
    4 Baseline plus 6 x squared plus 2 x Superscript 4 Baseline plus 2 x"><mrow><msup><mi>h</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>3</mn>
    <msup><mi>x</mi> <mn>4</mn></msup> <mo>+</mo> <mn>6</mn> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>2</mn> <msup><mi>x</mi> <mn>4</mn></msup> <mo>+</mo> <mn>2</mn>
    <mi>x</mi></mrow></math>
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="h prime left-parenthesis x right-parenthesis equals 3 x Superscript
    4 Baseline plus 6 x squared plus 2 x Superscript 4 Baseline plus 2 x"><mrow><msup><mi>h</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>3</mn>
    <msup><mi>x</mi> <mn>4</mn></msup> <mo>+</mo> <mn>6</mn> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>2</mn> <msup><mi>x</mi> <mn>4</mn></msup> <mo>+</mo> <mn>2</mn>
    <mi>x</mi></mrow></math>
- en: <math alttext="h prime left-parenthesis x right-parenthesis equals 5 x Superscript
    4 Baseline plus 6 x squared plus 2 x"><mrow><msup><mi>h</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>5</mn> <msup><mi>x</mi>
    <mn>4</mn></msup> <mo>+</mo> <mn>6</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo>
    <mn>2</mn> <mi>x</mi></mrow></math>
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="h prime left-parenthesis x right-parenthesis equals 5 x Superscript
    4 Baseline plus 6 x squared plus 2 x"><mrow><msup><mi>h</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>5</mn> <msup><mi>x</mi>
    <mn>4</mn></msup> <mo>+</mo> <mn>6</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo>
    <mn>2</mn> <mi>x</mi></mrow></math>
- en: '[Figure 4-16](#figure-4-16) shows the graph of *h(x)* and *h''(x)*.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-16](#figure-4-16)显示了*h(x)*和*h''(x)*的图形。'
- en: '![](assets/dlff_0416.png)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dlff_0416.png)'
- en: Figure 4-16\. The original h(x) with its derivative h'(x)
  id: totrans-454
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-16\. 原始*h(x)*及其导数*h'(x)*
- en: 'Now let’s turn our attention to the *quotient rule,* which deals with the division
    of two functions. The formal definition is as follows:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将注意力转向*商规则*，它处理两个函数的除法。形式定义如下：
- en: <math alttext="StartFraction d y Over d x EndFraction left-bracket StartFraction
    f left-parenthesis x right-parenthesis Over g left-parenthesis x right-parenthesis
    EndFraction right-bracket equals StartFraction f prime left-parenthesis x right-parenthesis
    g left-parenthesis x right-parenthesis minus f left-parenthesis x right-parenthesis
    g prime left-parenthesis x right-parenthesis Over left-bracket g left-parenthesis
    x right-parenthesis right-bracket squared EndFraction"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mrow><mo>[</mo> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow> <mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac></mstyle>
    <mo>]</mo></mrow> <mo>=</mo> <mfrac><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mi>g</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>-</mo><mi>f</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><msup><mi>g</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow> <msup><mrow><mo>[</mo><mi>g</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>]</mo></mrow>
    <mn>2</mn></msup></mfrac></mrow></math>
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction d y Over d x EndFraction left-bracket StartFraction
    f left-parenthesis x right-parenthesis Over g left-parenthesis x right-parenthesis
    EndFraction right-bracket equals StartFraction f prime left-parenthesis x right-parenthesis
    g left-parenthesis x right-parenthesis minus f left-parenthesis x right-parenthesis
    g prime left-parenthesis x right-parenthesis Over left-bracket g left-parenthesis
    x right-parenthesis right-bracket squared EndFraction"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mrow><mo>[</mo> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow> <mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac></mstyle>
    <mo>]</mo></mrow> <mo>=</mo> <mfrac><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mi>g</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>-</mo><mi>f</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><msup><mi>g</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow> <msup><mrow><mo>[</mo><mi>g</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>]</mo></mrow>
    <mn>2</mn></msup></mfrac></mrow></math>
- en: 'Let’s apply it to the following function:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其应用到以下函数中：
- en: <math alttext="f left-parenthesis x right-parenthesis equals StartFraction x
    squared minus x plus 1 Over x squared plus 1 EndFraction"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow> <mrow><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn></mrow></mfrac></mstyle></mrow></math>
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals StartFraction x
    squared minus x plus 1 Over x squared plus 1 EndFraction"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow> <mrow><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn></mrow></mfrac></mstyle></mrow></math>
- en: 'As usual, it’s better to start by finding the derivatives of *f(x)* and *g(x)*,
    which in this case are clearly separated, with *f(x)* being the nominator and
    *g(x)* being the denominator. When applying the quotient rule, you should get
    the following:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，最好先找到*f(x)*和*g(x)*的导数，在这种情况下，它们明显是分开的，*f(x)*是分子，*g(x)*是分母。在应用商规则时，你应该得到以下结果：
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals StartFraction
    left-parenthesis 2 x minus 1 right-parenthesis left-parenthesis x squared plus
    1 right-parenthesis minus left-parenthesis x squared minus x plus 1 right-parenthesis
    left-parenthesis 2 x right-parenthesis Over left-parenthesis x squared plus 1
    right-parenthesis squared EndFraction"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><mrow><mrow><mo>(</mo><mn>2</mn><mi>x</mi><mo>-</mo><mn>1</mn><mo>)</mo></mrow><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow><mo>-</mo><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mrow><mo>(</mo><mn>2</mn><mi>x</mi><mo>)</mo></mrow></mrow>
    <msup><mrow><mo>(</mo><msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mn>2</mn></msup></mfrac></mstyle></mrow></math>
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals StartFraction
    left-parenthesis 2 x minus 1 right-parenthesis left-parenthesis x squared plus
    1 right-parenthesis minus left-parenthesis x squared minus x plus 1 right-parenthesis
    left-parenthesis 2 x right-parenthesis Over left-parenthesis x squared plus 1
    right-parenthesis squared EndFraction"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><mrow><mrow><mo>(</mo><mn>2</mn><mi>x</mi><mo>-</mo><mn>1</mn><mo>)</mo></mrow><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow><mo>-</mo><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mrow><mo>(</mo><mn>2</mn><mi>x</mi><mo>)</mo></mrow></mrow>
    <msup><mrow><mo>(</mo><msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mn>2</mn></msup></mfrac></mstyle></mrow></math>
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals StartFraction
    2 x cubed plus 2 x minus x squared minus 1 minus 2 x cubed plus 2 x squared minus
    2 x Over left-parenthesis x squared plus 1 right-parenthesis squared EndFraction"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle
    displaystyle="false" scriptlevel="0"><mfrac><mrow><mn>2</mn><msup><mi>x</mi> <mn>3</mn></msup>
    <mo>+</mo><mn>2</mn><mi>x</mi><mo>-</mo><msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo><mn>1</mn><mo>-</mo><mn>2</mn><msup><mi>x</mi>
    <mn>3</mn></msup> <mo>+</mo><mn>2</mn><msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo><mn>2</mn><mi>x</mi></mrow>
    <msup><mrow><mo>(</mo><msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mn>2</mn></msup></mfrac></mstyle></mrow></math>
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals StartFraction
    2 x cubed plus 2 x minus x squared minus 1 minus 2 x cubed plus 2 x squared minus
    2 x Over left-parenthesis x squared plus 1 right-parenthesis squared EndFraction"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle
    displaystyle="false" scriptlevel="0"><mfrac><mrow><mn>2</mn><msup><mi>x</mi> <mn>3</mn></msup>
    <mo>+</mo><mn>2</mn><mi>x</mi><mo>-</mo><msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo><mn>1</mn><mo>-</mo><mn>2</mn><msup><mi>x</mi>
    <mn>3</mn></msup> <mo>+</mo><mn>2</mn><msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo><mn>2</mn><mi>x</mi></mrow>
    <msup><mrow><mo>(</mo><msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mn>2</mn></msup></mfrac></mstyle></mrow></math>
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals StartFraction
    x squared minus 1 Over left-parenthesis x squared plus 1 right-parenthesis squared
    EndFraction"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mn>1</mn></mrow> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow> <mn>2</mn></msup></mfrac></mstyle></mrow></math>
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals StartFraction
    x squared minus 1 Over left-parenthesis x squared plus 1 right-parenthesis squared
    EndFraction"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mn>1</mn></mrow> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow> <mn>2</mn></msup></mfrac></mstyle></mrow></math>
- en: '*Exponential derivatives* deal with the power rule applied to constants. Take
    a look at the following equation. How would you find its derivative?'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '*指数导数*处理应用于常数的幂规则。看看下面的方程式。你会如何找到它的导数？'
- en: <math alttext="f left-parenthesis x right-parenthesis equals a Superscript x"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>a</mi> <mi>x</mi></msup></mrow></math>
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals a Superscript x"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>a</mi> <mi>x</mi></msup></mrow></math>
- en: 'Instead of the usual variable-base-constant-exponent, it is constant-base-variable-exponent.
    This is treated differently when trying to calculate the derivative. The formal
    definition is as follows:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于通常的变量-基数-常量-指数，它是常量-基数-变量-指数。在尝试计算导数时，这种处理方式有所不同。形式化定义如下：
- en: <math alttext="StartFraction d y Over d x EndFraction a Superscript x Baseline
    equals a Superscript x Baseline left-parenthesis ln a right-parenthesis"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <msup><mi>a</mi> <mi>x</mi></msup> <mo>=</mo>
    <msup><mi>a</mi> <mi>x</mi></msup> <mrow><mo>(</mo> <mo form="prefix">ln</mo>
    <mi>a</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction d y Over d x EndFraction a Superscript x Baseline
    equals a Superscript x Baseline left-parenthesis ln a right-parenthesis"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <msup><mi>a</mi> <mi>x</mi></msup> <mo>=</mo>
    <msup><mi>a</mi> <mi>x</mi></msup> <mrow><mo>(</mo> <mo form="prefix">ln</mo>
    <mi>a</mi> <mo>)</mo></mrow></mrow></math>
- en: 'The following example shows how this is done:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例显示了如何做到这一点：
- en: <math alttext="StartFraction d y Over d x EndFraction 4 Superscript x Baseline
    equals 4 Superscript x Baseline left-parenthesis ln 4 right-parenthesis"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <msup><mn>4</mn> <mi>x</mi></msup> <mo>=</mo>
    <msup><mn>4</mn> <mi>x</mi></msup> <mrow><mo>(</mo> <mo form="prefix">ln</mo>
    <mn>4</mn> <mo>)</mo></mrow></mrow></math>
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction d y Over d x EndFraction 4 Superscript x Baseline
    equals 4 Superscript x Baseline left-parenthesis ln 4 right-parenthesis"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <msup><mn>4</mn> <mi>x</mi></msup> <mo>=</mo>
    <msup><mn>4</mn> <mi>x</mi></msup> <mrow><mo>(</mo> <mo form="prefix">ln</mo>
    <mn>4</mn> <mo>)</mo></mrow></mrow></math>
- en: 'Euler’s number, mentioned earlier, has a special derivative. When it comes
    to finding the derivative of *e*, the answer is interesting:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的欧拉数有一个特殊的导数。当涉及到找到*e*的导数时，答案很有趣：
- en: <math alttext="StartFraction d y Over d x EndFraction e Superscript x Baseline
    equals e Superscript x Baseline left-parenthesis ln e right-parenthesis equals
    e Superscript x"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <msup><mi>e</mi> <mi>x</mi></msup> <mo>=</mo> <msup><mi>e</mi> <mi>x</mi></msup>
    <mrow><mo>(</mo> <mo form="prefix">ln</mo> <mi>e</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>e</mi> <mi>x</mi></msup></mrow></math>
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction d y Over d x EndFraction e Superscript x Baseline
    equals e Superscript x Baseline left-parenthesis ln e right-parenthesis equals
    e Superscript x"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <msup><mi>e</mi> <mi>x</mi></msup> <mo>=</mo> <msup><mi>e</mi> <mi>x</mi></msup>
    <mrow><mo>(</mo> <mo form="prefix">ln</mo> <mi>e</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>e</mi> <mi>x</mi></msup></mrow></math>
- en: This is because the natural log function and the exponential function are inverses
    of each other, so the term *ln e* equals 1\. Therefore, the derivative of the
    exponential function *e* is itself.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为自然对数函数和指数函数是彼此的反函数，所以术语*ln e*等于1。因此，指数函数*e*的导数就是它本身。
- en: 'In parallel, let’s discuss logarithmic derivatives. By now, you should know
    what exponents and logarithms are. The general definition for both types of logarithms
    is as follows:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，让我们讨论一下对数导数。到现在为止，你应该知道指数和对数是什么。两种对数的一般定义如下：
- en: <math alttext="StartFraction d y Over d x EndFraction log Subscript a Baseline
    x equals StartFraction 1 Over x ln a EndFraction"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <msub><mo form="prefix">log</mo> <mi>a</mi></msub>
    <mi>x</mi> <mo>=</mo> <mfrac><mn>1</mn> <mrow><mi>x</mi><mo form="prefix">ln</mo><mi>a</mi></mrow></mfrac></mrow></math>
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction d y Over d x EndFraction log Subscript a Baseline
    x equals StartFraction 1 Over x ln a EndFraction"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <msub><mo form="prefix">log</mo> <mi>a</mi></msub>
    <mi>x</mi> <mo>=</mo> <mfrac><mn>1</mn> <mrow><mi>x</mi><mo form="prefix">ln</mo><mi>a</mi></mrow></mfrac></mrow></math>
- en: <math alttext="StartFraction d y Over d x EndFraction ln x equals log Subscript
    e Baseline x equals StartFraction 1 Over x ln e EndFraction equals StartFraction
    1 Over x EndFraction"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <mo form="prefix">ln</mo> <mi>x</mi> <mo>=</mo> <msub><mo form="prefix">log</mo>
    <mi>e</mi></msub> <mi>x</mi> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mn>1</mn>
    <mrow><mi>x</mi><mo form="prefix">ln</mo><mi>e</mi></mrow></mfrac></mstyle> <mo>=</mo>
    <mfrac><mn>1</mn> <mi>x</mi></mfrac></mrow></math>
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction d y Over d x EndFraction ln x equals log Subscript
    e Baseline x equals StartFraction 1 Over x ln e EndFraction equals StartFraction
    1 Over x EndFraction"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <mo form="prefix">ln</mo> <mi>x</mi> <mo>=</mo> <msub><mo form="prefix">log</mo>
    <mi>e</mi></msub> <mi>x</mi> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mn>1</mn>
    <mrow><mi>x</mi><mo form="prefix">ln</mo><mi>e</mi></mrow></mfrac></mstyle> <mo>=</mo>
    <mfrac><mn>1</mn> <mi>x</mi></mfrac></mrow></math>
- en: Notice how in the second derivative function of the natural logarithm, the term
    *ln e* is once again encountered, thus making simplification quite easy since
    it is equal to 1.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在自然对数的二阶导函数中，再次遇到*ln e*项，因此使得简化变得非常容易，因为它等于1。
- en: 'Take the following example:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下示例为例：
- en: <math alttext="f left-parenthesis x right-parenthesis equals 7 l o g 2 left-parenthesis
    x right-parenthesis"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>7</mn> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals 7 l o g 2 left-parenthesis
    x right-parenthesis"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>7</mn> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
- en: 'Using the formal definition, the derivative of this logarithmic function is
    as follows:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正式定义，这个对数函数的导数如下：
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 7 left-parenthesis
    StartFraction 1 Over x ln 2 EndFraction right-parenthesis equals StartFraction
    7 Over x ln 2 EndFraction"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>7</mn> <mrow><mo>(</mo> <mfrac><mn>1</mn>
    <mrow><mi>x</mi><mo form="prefix">ln</mo><mn>2</mn></mrow></mfrac> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mn>7</mn> <mrow><mi>x</mi><mo
    form="prefix">ln</mo><mn>2</mn></mrow></mfrac></mstyle></mrow></math>
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals 7 left-parenthesis
    StartFraction 1 Over x ln 2 EndFraction right-parenthesis equals StartFraction
    7 Over x ln 2 EndFraction"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>7</mn> <mrow><mo>(</mo> <mfrac><mn>1</mn>
    <mrow><mi>x</mi><mo form="prefix">ln</mo><mn>2</mn></mrow></mfrac> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mn>7</mn> <mrow><mi>x</mi><mo
    form="prefix">ln</mo><mn>2</mn></mrow></mfrac></mstyle></mrow></math>
- en: Note
  id: totrans-480
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The logarithm *log* has a base of 10, but the natural logarithm *ln* has a base
    of *e* (~2.7182).
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 对数*log*的基数是10，但自然对数*ln*的基数是*e*（~2.7182）。
- en: The natural logarithm and the log function are actually linearly related through
    simple multiplication. If you know the log of the constant *a*, you can find its
    natural logarithm *ln* by multiplying the log of *a* by 2.4303.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 自然对数和对数函数实际上是通过简单的乘法线性相关的。如果你知道常数*a*的对数，你可以通过将*a*的对数乘以2.4303来找到它的自然对数*ln*。
- en: 'One major concept in derivatives is the *chain rule*. Let’s back up to the
    power rule, which deals with exponents on variables. Remember the following formula
    to find the derivative:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 导数中的一个主要概念是*链式法则*。让我们回到幂规则，它处理变量的指数。记住以下公式找到导数：
- en: <math alttext="StartFraction d y Over d x EndFraction left-parenthesis a x Superscript
    n Baseline right-parenthesis equals left-parenthesis a period n right-parenthesis
    x Superscript n minus 1"><mrow><mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></mstyle> <mrow><mo>(</mo> <mi>a</mi>
    <msup><mi>x</mi> <mi>n</mi></msup> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo>
    <mi>a</mi> <mo lspace="0%" rspace="0%">.</mo> <mi>n</mi> <mo>)</mo></mrow> <msup><mi>x</mi>
    <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction d y Over d x EndFraction left-parenthesis a x Superscript
    n Baseline right-parenthesis equals left-parenthesis a period n right-parenthesis
    x Superscript n minus 1"><mrow><mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></mstyle> <mrow><mo>(</mo> <mi>a</mi>
    <msup><mi>x</mi> <mi>n</mi></msup> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo>
    <mi>a</mi> <mo lspace="0%" rspace="0%">.</mo> <mi>n</mi> <mo>)</mo></mrow> <msup><mi>x</mi>
    <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
- en: 'This is a simplified version because there is only *x*, but the reality is
    that you must multiply by the derivative of the term under the exponent. Until
    now, you have seen only *x* as the variable under the exponent. The derivative
    of *x* is 1, which is why it is simplified and rendered invisible. However, with
    more complex functions such as this one:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简化的版本，因为只有*x*，但现实是你必须乘以幂指数下面的项的导数。到目前为止，你只看到*x*作为幂指数下的变量。*x*的导数是1，这就是为什么它被简化和隐藏的原因。然而，对于更复杂的函数，比如这个：
- en: <math alttext="f left-parenthesis x right-parenthesis equals left-parenthesis
    4 x plus 1 right-parenthesis squared"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msup><mrow><mo>(</mo><mn>4</mn><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mn>2</mn></msup></mrow></math>
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals left-parenthesis
    4 x plus 1 right-parenthesis squared"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msup><mrow><mo>(</mo><mn>4</mn><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mn>2</mn></msup></mrow></math>
- en: 'The derivative of the function is found by following these two steps:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下两个步骤找到函数的导数：
- en: Find the derivative of the outside function without touching the inside function.
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到外部函数的导数而不触及内部函数。
- en: Find the derivative of the inside function and multiply it by the rest of the
    function.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到内部函数的导数并将其乘以函数的其余部分。
- en: 'The solution is therefore as follows (knowing that the derivative of *4x* +
    1 is just 4):'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 因此解决方案如下（知道*4x* + 1的导数只是4）：
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 left-parenthesis
    4 x plus 1 right-parenthesis .4"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <mrow><mo>(</mo> <mn>4</mn>
    <mi>x</mi> <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow> <mo lspace="0%" rspace="0%">.</mo>
    <mn>4</mn></mrow></math>
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 left-parenthesis
    4 x plus 1 right-parenthesis .4"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <mrow><mo>(</mo> <mn>4</mn>
    <mi>x</mi> <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow> <mo lspace="0%" rspace="0%">.</mo>
    <mn>4</mn></mrow></math>
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 8 left-parenthesis
    4 x plus 1 right-parenthesis"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>8</mn> <mrow><mo>(</mo> <mn>4</mn>
    <mi>x</mi> <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals 8 left-parenthesis
    4 x plus 1 right-parenthesis"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>8</mn> <mrow><mo>(</mo> <mn>4</mn>
    <mi>x</mi> <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 32 x plus
    8"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>32</mn> <mi>x</mi> <mo>+</mo> <mn>8</mn></mrow></math>
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals 32 x plus
    8"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>32</mn> <mi>x</mi> <mo>+</mo> <mn>8</mn></mrow></math>
- en: 'The same applies with the exponential functions. Take the following example:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 指数函数也是如此。接下来以以下示例为例：
- en: <math alttext="f left-parenthesis x right-parenthesis equals e Superscript x"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi> <mi>x</mi></msup></mrow></math>
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals e Superscript x"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi> <mi>x</mi></msup></mrow></math>
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals e Superscript
    x Baseline left-parenthesis 1 right-parenthesis equals e Superscript x"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi>
    <mi>x</mi></msup> <mrow><mo>(</mo> <mn>1</mn> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi>
    <mi>x</mi></msup></mrow></math>
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals e Superscript
    x Baseline left-parenthesis 1 right-parenthesis equals e Superscript x"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi>
    <mi>x</mi></msup> <mrow><mo>(</mo> <mn>1</mn> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi>
    <mi>x</mi></msup></mrow></math>
- en: The chain rule can actually be considered a master rule as it applies anywhere,
    even in the product rule and the quotient rule.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 链式法则实际上可以被认为是一条总规则，因为它适用于任何地方，即使是在乘积法则和商法则中也是如此。
- en: There are more concepts to master in derivatives, but as this book is not meant
    to be a full calculus master class, you should at least know the meaning of a
    derivative, how it is found, what it represents, and how it can be used in machine
    and deep learning.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在求导数中有更多的概念需要掌握，但是由于本书不打算成为完整的微积分大师课程，你至少应该了解导数的含义，如何找到它，它代表什么以及在机器学习和深度学习中如何使用它。
- en: Note
  id: totrans-499
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The key takeaways from this section are as follows:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的关键点如下：
- en: A derivative measures the change in a function given a change of one or more
    of its inputs.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导数衡量给定一个或多个输入变化的函数的变化。
- en: The power rule is used to find the derivative of a function raised to a power.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幂规则用于找到函数的幂的导数。
- en: The product rule is used to find the derivative of two functions that are multiplied
    together.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘积法则用于找到两个相乘的函数的导数。
- en: The quotient rule is used to find the derivative of two functions that are divided
    by each other.
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商法则用于找到两个相除的函数的导数。
- en: The chain rule is the main rule used in differentiating (which means the process
    of finding the derivative). Due to simplicity, it is often overlooked.
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链式法则是不同iating中使用的主要规则（这意味着找到导数的过程）。由于简单性，它经常被忽视。
- en: Derivatives play a crucial role in machine learning, such as enabling optimization
    techniques, aiding model training, and enhancing the interpretability of the models.
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导数在机器学习中发挥着关键作用，比如启用优化技术，帮助模型训练，并增强模型的可解释性。
- en: Integrals and the Fundamental Theorem of Calculus
  id: totrans-507
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 积分与微积分基本定理
- en: An *integral* is an operation that represents the area under a curve of a function
    given an interval. It is the inverse of a derivative, which is why it is also
    called an *antiderivative*.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '*积分* 是一种操作，表示在给定区间内函数曲线下的面积。它是导数的反操作，这也是为什么它被称为*反导数*。'
- en: The process of finding integrals is called *integration*. Integrals can be used
    to find areas below a curve, and they are heavily used in the world of finance
    in such areas as risk management, portfolio management, probabilistic methods,
    and even option pricing.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 找到积分的过程称为*积分*。积分可以用来找到曲线下的面积，在金融世界中广泛应用于风险管理、投资组合管理、概率方法，甚至期权定价等领域。
- en: The easiest way to understand an integral is to think of calculating an area
    below the curve of a function. This can be done by manually calculating the different
    changes in the *x*-axis, but adding these slices to find the area is a tedious
    process. This is where integrals come to the rescue.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 理解积分的最简单方法是考虑计算函数曲线下面积。可以通过手动计算*x*轴上的不同变化来完成这一过程，但添加这些片段以找到面积是一个繁琐的过程。这就是积分发挥作用的地方。
- en: 'Keep in mind that an integral is the inverse of a derivative. This is important
    because it implies a direct relationship between the two. The basic definition
    of an integral is as follows:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，积分是导数的反操作。这很重要，因为它意味着两者之间存在直接关系。积分的基本定义如下：
- en: <math alttext="integral f left-parenthesis x right-parenthesis d x equals upper
    F left-parenthesis upper X right-parenthesis plus upper C"><mrow><mo>∫</mo> <mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mi>F</mi> <mo>(</mo>
    <mi>X</mi> <mo>)</mo> <mo>+</mo> <mi>C</mi></mrow></math>
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral f left-parenthesis x right-parenthesis d x equals upper
    F left-parenthesis upper X right-parenthesis plus upper C"><mrow><mo>∫</mo> <mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mi>F</mi> <mo>(</mo>
    <mi>X</mi> <mo>)</mo> <mo>+</mo> <mi>C</mi></mrow></math>
- en: <math alttext="The integral symbol represents the integration process"><mrow><mtext>The</mtext>
    <mo>∫</mo> <mtext>symbol</mtext> <mtext>represents</mtext> <mtext>the</mtext>
    <mtext>integration</mtext> <mtext>process</mtext></mrow></math>
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="The integral symbol represents the integration process"><mrow><mtext>The</mtext>
    <mo>∫</mo> <mtext>symbol</mtext> <mtext>represents</mtext> <mtext>the</mtext>
    <mtext>integration</mtext> <mtext>process</mtext></mrow></math>
- en: <math alttext="f left-parenthesis x right-parenthesis is the derivative of the
    general function upper F left-parenthesis x right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mtext>is</mtext> <mtext>the</mtext> <mtext>derivative</mtext>
    <mtext>of</mtext> <mtext>the</mtext> <mtext>general</mtext> <mtext>function</mtext>
    <mi>F</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math>
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis is the derivative of the
    general function upper F left-parenthesis x right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mtext>is</mtext> <mtext>the</mtext> <mtext>derivative</mtext>
    <mtext>of</mtext> <mtext>the</mtext> <mtext>general</mtext> <mtext>function</mtext>
    <mi>F</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math>
- en: <math alttext="upper C represents the lost constant in the differentiation process"><mrow><mi>C</mi>
    <mtext>represents</mtext> <mtext>the</mtext> <mtext>lost</mtext> <mtext>constant</mtext>
    <mtext>in</mtext> <mtext>the</mtext> <mtext>differentiation</mtext> <mtext>process</mtext></mrow></math>
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper C represents the lost constant in the differentiation process"><mrow><mi>C</mi>
    <mtext>represents</mtext> <mtext>the</mtext> <mtext>lost</mtext> <mtext>constant</mtext>
    <mtext>in</mtext> <mtext>the</mtext> <mtext>differentiation</mtext> <mtext>process</mtext></mrow></math>
- en: <math alttext="d x represents slicing along x as it approaches zero"><mrow><mi>d</mi>
    <mi>x</mi> <mtext>represents</mtext> <mtext>slicing</mtext> <mtext>along</mtext>
    <mi>x</mi> <mtext>as</mtext> <mtext>it</mtext> <mtext>approaches</mtext> <mtext>zero</mtext></mrow></math>
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="d x represents slicing along x as it approaches zero"><mrow><mi>d</mi>
    <mi>x</mi> <mtext>represents</mtext> <mtext>slicing</mtext> <mtext>along</mtext>
    <mi>x</mi> <mtext>as</mtext> <mtext>it</mtext> <mtext>approaches</mtext> <mtext>zero</mtext></mrow></math>
- en: The preceding equation means that the integral of *f(x)* is the general function
    *F(x)* plus a constant *C*, which was lost in the initial differentiation process.
    Here’s an example to better explain the need to put in the constant.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方程意味着*f(x)*的积分是一般函数*F(x)*加上一个常数*C*，这个常数在初始微分过程中丢失了。以下是一个例子，更好地解释放入常数的必要性。
- en: 'Consider the following function:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下函数：
- en: <math alttext="f left-parenthesis x right-parenthesis equals x squared plus
    5"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>5</mn></mrow></math>
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals x squared plus
    5"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>5</mn></mrow></math>
- en: 'Calculating its derivative, you get the following result:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 计算其导数，得到以下结果：
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn>
    <mi>x</mi></mrow></math>
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn>
    <mi>x</mi></mrow></math>
- en: Now, what if you wanted to integrate it so that you go back to the original
    function (which in this case is represented by the capital letter *F(x)* instead
    of *f(x)*)?
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你想要积分它，以便回到原始函数（在这种情况下用大写字母*F(x)*代表而不是*f(x)*）？
- en: <math alttext="integral 2 x d x"><mrow><mo>∫</mo> <mn>2</mn> <mi>x</mi> <mi>d</mi>
    <mi>x</mi></mrow></math>
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral 2 x d x"><mrow><mo>∫</mo> <mn>2</mn> <mi>x</mi> <mi>d</mi>
    <mi>x</mi></mrow></math>
- en: 'Normally, having seen the differentiation process (which means taking the derivative),
    you would return 2 as the exponent, which gives you the following answer:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，看到差异化过程（这意味着取导数），你会返回2作为指数，这给出以下答案：
- en: <math alttext="integral 2 x d x equals x squared"><mrow><mo>∫</mo> <mn>2</mn>
    <mi>x</mi> <mi>d</mi> <mi>x</mi> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral 2 x d x equals x squared"><mrow><mo>∫</mo> <mn>2</mn>
    <mi>x</mi> <mi>d</mi> <mi>x</mi> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
- en: 'This does not look like the original function. It’s missing the constant 5\.
    But you have no way of knowing that, and even if you knew there was a constant,
    you would have no way of knowing what it is: 1? 2? 677? This is why a constant
    *C* is added in the integration process to represent the lost constant. Therefore,
    the answer to the integration problem is as follows:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来不像原始函数。它缺少常数5\. 但你无法知道这一点，即使你知道有一个常数，你也无法知道它是多少：1？2？677？这就是为什么在积分过程中添加常数*C*来表示丢失的常数的原因。因此，积分问题的答案如下：
- en: <math alttext="integral 2 x d x equals x squared plus upper C"><mrow><mo>∫</mo>
    <mn>2</mn> <mi>x</mi> <mi>d</mi> <mi>x</mi> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mi>C</mi></mrow></math>
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral 2 x d x equals x squared plus upper C"><mrow><mo>∫</mo>
    <mn>2</mn> <mi>x</mi> <mi>d</mi> <mi>x</mi> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mi>C</mi></mrow></math>
- en: Note
  id: totrans-528
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Up until now, the discussion has been limited to *indefinite integrals* where
    the integration symbol is *naked* (which means there are no boundaries to it).
    You will see what this means right after we define the necessary rules to complete
    the integration.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，讨论一直局限于*不定积分*，其中积分符号是*裸露的*（这意味着它没有边界）。我们将在定义完成积分所需的规则之后立即看到这意味着什么。
- en: 'For the power function (just like the previous function), the general rule
    for integration is as follows:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 对于幂函数（就像前面的函数一样），积分的一般规则如下：
- en: <math alttext="integral x Superscript a Baseline d x equals StartFraction x
    Superscript a plus 1 Baseline Over a plus 1 EndFraction plus upper C"><mrow><mo>∫</mo>
    <msup><mi>x</mi> <mi>a</mi></msup> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><msup><mi>x</mi> <mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow></msup>
    <mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mstyle> <mo>+</mo> <mi>C</mi></mrow></math>
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral x Superscript a Baseline d x equals StartFraction x
    Superscript a plus 1 Baseline Over a plus 1 EndFraction plus upper C"><mrow><mo>∫</mo>
    <msup><mi>x</mi> <mi>a</mi></msup> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><msup><mi>x</mi> <mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow></msup>
    <mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mstyle> <mo>+</mo> <mi>C</mi></mrow></math>
- en: 'This is much simpler than it looks. You are just reversing the power rule you
    saw earlier. Consider the following example:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 这比看上去要简单得多。你只是在反转你之前看到的幂规则。考虑以下例子：
- en: <math alttext="integral 2 x Superscript 6 d x"><mrow><mo>∫</mo> <mn>2</mn> <msup><mi>x</mi>
    <mn>6</mn></msup> <mi>d</mi> <mi>x</mi></mrow></math>
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral 2 x Superscript 6 d x"><mrow><mo>∫</mo> <mn>2</mn> <msup><mi>x</mi>
    <mn>6</mn></msup> <mi>d</mi> <mi>x</mi></mrow></math>
- en: <math alttext="integral 2 x Superscript 6 Baseline d x equals StartFraction
    2 x Superscript 7 Baseline Over 7 EndFraction plus upper C"><mrow><mo>∫</mo> <mn>2</mn>
    <msup><mi>x</mi> <mn>6</mn></msup> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><mrow><mn>2</mn><msup><mi>x</mi> <mn>7</mn></msup></mrow>
    <mn>7</mn></mfrac></mstyle> <mo>+</mo> <mi>C</mi></mrow></math>
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral 2 x Superscript 6 Baseline d x equals StartFraction
    2 x Superscript 7 Baseline Over 7 EndFraction plus upper C"><mrow><mo>∫</mo> <mn>2</mn>
    <msup><mi>x</mi> <mn>6</mn></msup> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><mrow><mn>2</mn><msup><mi>x</mi> <mn>7</mn></msup></mrow>
    <mn>7</mn></mfrac></mstyle> <mo>+</mo> <mi>C</mi></mrow></math>
- en: <math alttext="integral 2 x Superscript 6 Baseline d x equals two-sevenths x
    Superscript 7 Baseline plus upper C"><mrow><mo>∫</mo> <mn>2</mn> <msup><mi>x</mi>
    <mn>6</mn></msup> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><mn>2</mn> <mn>7</mn></mfrac></mstyle> <msup><mi>x</mi>
    <mn>7</mn></msup> <mo>+</mo> <mi>C</mi></mrow></math>
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral 2 x Superscript 6 Baseline d x equals two-sevenths x
    Superscript 7 Baseline plus upper C"><mrow><mo>∫</mo> <mn>2</mn> <msup><mi>x</mi>
    <mn>6</mn></msup> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><mn>2</mn> <mn>7</mn></mfrac></mstyle> <msup><mi>x</mi>
    <mn>7</mn></msup> <mo>+</mo> <mi>C</mi></mrow></math>
- en: 'To verify your answer, you can find the derivative of the result (using the
    power rule):'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证你的答案，你可以找到结果的导数（使用幂规则）：
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals two-sevenths
    x Superscript 7 Baseline plus upper C"><mrow><mi>F</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mn>2</mn>
    <mn>7</mn></mfrac></mstyle> <msup><mi>x</mi> <mn>7</mn></msup> <mo>+</mo> <mi>C</mi></mrow></math>
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper F left-parenthesis x right-parenthesis equals two-sevenths
    x Superscript 7 Baseline plus upper C"><mrow><mi>F</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mn>2</mn>
    <mn>7</mn></mfrac></mstyle> <msup><mi>x</mi> <mn>7</mn></msup> <mo>+</mo> <mi>C</mi></mrow></math>
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals left-parenthesis
    7 right-parenthesis two-sevenths x Superscript 7 minus 1 Baseline plus 0"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo>
    <mn>7</mn> <mo>)</mo></mrow> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mn>2</mn>
    <mn>7</mn></mfrac></mstyle> <msup><mi>x</mi> <mrow><mn>7</mn><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>+</mo> <mn>0</mn></mrow></math>
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals left-parenthesis
    7 right-parenthesis two-sevenths x Superscript 7 minus 1 Baseline plus 0"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo>
    <mn>7</mn> <mo>)</mo></mrow> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mn>2</mn>
    <mn>7</mn></mfrac></mstyle> <msup><mi>x</mi> <mrow><mn>7</mn><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>+</mo> <mn>0</mn></mrow></math>
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x Superscript
    6"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>2</mn> <msup><mi>x</mi> <mn>6</mn></msup></mrow></math>
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x Superscript
    6"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>2</mn> <msup><mi>x</mi> <mn>6</mn></msup></mrow></math>
- en: 'Let’s take another example. Consider the following integration problem:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子。考虑以下积分问题：
- en: <math alttext="integral 2 d x"><mrow><mo>∫</mo> <mn>2</mn> <mi>d</mi> <mi>x</mi></mrow></math>
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral 2 d x"><mrow><mo>∫</mo> <mn>2</mn> <mi>d</mi> <mi>x</mi></mrow></math>
- en: 'Naturally, using the rule, you should find the following result:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 根据规则，您应该找到以下结果：
- en: <math alttext="integral 2 d x equals 2 x plus upper C"><mrow><mo>∫</mo> <mn>2</mn>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mi>C</mi></mrow></math>
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral 2 d x equals 2 x plus upper C"><mrow><mo>∫</mo> <mn>2</mn>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mi>C</mi></mrow></math>
- en: 'Let’s move on to *definite integrals,* which are integrals with numbers on
    the top and bottom that represent intervals below a curve of a function. Hence,
    *indefinite* integrals find the area under the curve everywhere, and definite
    integrals are bounded within an interval given by point *a* and point *b*. The
    general definition of indefinite integrals is as follows:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论*定积分*，这些是在函数曲线下方用指定的上下限表示的积分。因此，*不定*积分在曲线下方找到的区域的任何地方，而定积分则在由点*a*和点*b*给定的区间内被限制。 不定积分的一般定义如下：
- en: <math alttext="integral Subscript a Superscript b Baseline f left-parenthesis
    x right-parenthesis d x equals upper F left-parenthesis upper B right-parenthesis
    minus upper F left-parenthesis upper A right-parenthesis"><mrow><msubsup><mo>∫</mo>
    <mi>a</mi> <mi>b</mi></msubsup> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo> <mi>B</mi> <mo>)</mo></mrow>
    <mo>-</mo> <mi>F</mi> <mrow><mo>(</mo> <mi>A</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral Subscript a Superscript b Baseline f left-parenthesis
    x right-parenthesis d x equals upper F left-parenthesis upper B right-parenthesis
    minus upper F left-parenthesis upper A right-parenthesis"><mrow><msubsup><mo>∫</mo>
    <mi>a</mi> <mi>b</mi></msubsup> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo> <mi>B</mi> <mo>)</mo></mrow>
    <mo>-</mo> <mi>F</mi> <mrow><mo>(</mo> <mi>A</mi> <mo>)</mo></mrow></mrow></math>
- en: 'This is as simple as it gets. You will solve the integral, then plug in the
    two numbers and subtract the two functions from each other. Consider the following
    evaluation of an integral (integral solving is commonly referred to as *evaluating*
    the integral):'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的方法。您将解决积分，然后插入两个数字并从彼此减去两个函数。考虑以下积分评估（积分求解通常称为*评估*积分）：
- en: <math alttext="integral Subscript 0 Superscript 6 Baseline 3 x squared minus
    10 x plus 4 d x"><mrow><msubsup><mo>∫</mo> <mn>0</mn> <mn>6</mn></msubsup> <mn>3</mn>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo> <mn>10</mn> <mi>x</mi> <mo>+</mo>
    <mn>4</mn> <mi>d</mi> <mi>x</mi></mrow></math>
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="integral Subscript 0 Superscript 6 Baseline 3 x squared minus
    10 x plus 4 d x"><mrow><msubsup><mo>∫</mo> <mn>0</mn> <mn>6</mn></msubsup> <mn>3</mn>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo> <mn>10</mn> <mi>x</mi> <mo>+</mo>
    <mn>4</mn> <mi>d</mi> <mi>x</mi></mrow></math>
- en: 'The first step is to understand what is being asked. From the definition of
    integrals, it seems that the area between [0, 2] on the *x*-axis is to be calculated
    using the given function:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是理解所询问的内容。从积分的定义来看，在*x*轴上[0, 2]之间的区域似乎是使用给定函数计算的：
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    left-bracket x cubed minus 5 x squared plus 4 x plus upper C right-bracket right-parenthesis
    vertical-bar Subscript 0 Baseline Superscript 6 Baseline"><mrow><mi>F</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <mrow><mo>[</mo> <msup><mi>x</mi>
    <mn>3</mn></msup> <mo>-</mo> <mn>5</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo>
    <mn>4</mn> <mi>x</mi> <mo>+</mo> <mi>C</mi> <mo>]</mo></mrow> <mo>)</mo></mrow>
    <msubsup><mrow><mo>|</mo></mrow> <mn>0</mn> <mn>6</mn></msubsup></mrow></math>
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    left-bracket x cubed minus 5 x squared plus 4 x plus upper C right-bracket right-parenthesis
    vertical-bar Subscript 0 Baseline Superscript 6 Baseline"><mrow><mi>F</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <mrow><mo>[</mo> <msup><mi>x</mi>
    <mn>3</mn></msup> <mo>-</mo> <mn>5</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo>
    <mn>4</mn> <mi>x</mi> <mo>+</mo> <mi>C</mi> <mo>]</mo></mrow> <mo>)</mo></mrow>
    <msubsup><mrow><mo>|</mo></mrow> <mn>0</mn> <mn>6</mn></msubsup></mrow></math>
- en: 'To evaluate the integral at the given points, simply plug in the values as
    follows:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 要在给定点评估积分，只需按以下方式插入值：
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    left-bracket 6 cubed minus 5 left-parenthesis 6 right-parenthesis squared plus
    4 left-parenthesis 6 right-parenthesis plus upper C right-bracket right-parenthesis
    minus left-parenthesis left-bracket 0 cubed minus 5 left-parenthesis 0 right-parenthesis
    squared plus 4 left-parenthesis 0 right-parenthesis plus upper C right-bracket
    right-parenthesis"><mrow><mi>F</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mrow><mo>(</mo> <mrow><mo>[</mo> <msup><mn>6</mn> <mn>3</mn></msup>
    <mo>-</mo> <mn>5</mn> <msup><mrow><mo>(</mo><mn>6</mn><mo>)</mo></mrow> <mn>2</mn></msup>
    <mo>+</mo> <mn>4</mn> <mrow><mo>(</mo> <mn>6</mn> <mo>)</mo></mrow> <mo>+</mo>
    <mi>C</mi> <mo>]</mo></mrow> <mo>)</mo></mrow> <mo>-</mo> <mrow><mo>(</mo> <mrow><mo>[</mo>
    <msup><mn>0</mn> <mn>3</mn></msup> <mo>-</mo> <mn>5</mn> <msup><mrow><mo>(</mo><mn>0</mn><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>+</mo> <mn>4</mn> <mrow><mo>(</mo> <mn>0</mn> <mo>)</mo></mrow>
    <mo>+</mo> <mi>C</mi> <mo>]</mo></mrow> <mo>)</mo></mrow></mrow></math>
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    left-bracket 6 cubed minus 5 left-parenthesis 6 right-parenthesis squared plus
    4 left-parenthesis 6 right-parenthesis plus upper C right-bracket right-parenthesis
    minus left-parenthesis left-bracket 0 cubed minus 5 left-parenthesis 0 right-parenthesis
    squared plus 4 left-parenthesis 0 right-parenthesis plus upper C right-bracket
    right-parenthesis"><mrow><mi>F</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mrow><mo>(</mo> <mrow><mo>[</mo> <msup><mn>6</mn> <mn>3</mn></msup>
    <mo>-</mo> <mn>5</mn> <msup><mrow><mo>(</mo><mn>6</mn><mo>)</mo></mrow> <mn>2</mn></msup>
    <mo>+</mo> <mn>4</mn> <mrow><mo>(</mo> <mn>6</mn> <mo>)</mo></mrow> <mo>+</mo>
    <mi>C</mi> <mo>]</mo></mrow> <mo>)</mo></mrow> <mo>-</mo> <mrow><mo>(</mo> <mrow><mo>[</mo>
    <msup><mn>0</mn> <mn>3</mn></msup> <mo>-</mo> <mn>5</mn> <msup><mrow><mo>(</mo><mn>0</mn><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>+</mo> <mn>4</mn> <mrow><mo>(</mo> <mn>0</mn> <mo>)</mo></mrow>
    <mo>+</mo> <mi>C</mi> <mo>]</mo></mrow> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    left-bracket 216 minus 180 plus 24 plus upper C right-bracket right-parenthesis
    minus left-parenthesis left-bracket 0 minus 0 plus 0 plus upper C right-bracket
    right-parenthesis"><mrow><mi>F</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo>
    <mo>(</mo> <mo>[</mo> <mn>216</mn> <mo>-</mo> <mn>180</mn> <mo>+</mo> <mn>24</mn>
    <mo>+</mo> <mi>C</mi> <mo>]</mo> <mo>)</mo> <mo>-</mo> <mo>(</mo> <mo>[</mo> <mn>0</mn>
    <mo>-</mo> <mn>0</mn> <mo>+</mo> <mn>0</mn> <mo>+</mo> <mi>C</mi> <mo>]</mo> <mo>)</mo></mrow></math>
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    left-bracket 216 minus 180 plus 24 plus upper C right-bracket right-parenthesis
    minus left-parenthesis left-bracket 0 minus 0 plus 0 plus upper C right-bracket
    right-parenthesis"><mrow><mi>F</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo>
    <mo>(</mo> <mo>[</mo> <mn>216</mn> <mo>-</mo> <mn>180</mn> <mo>+</mo> <mn>24</mn>
    <mo>+</mo> <mi>C</mi> <mo>]</mo> <mo>)</mo> <mo>-</mo> <mo>(</mo> <mo>[</mo> <mn>0</mn>
    <mo>-</mo> <mn>0</mn> <mo>+</mo> <mn>0</mn> <mo>+</mo> <mi>C</mi> <mo>]</mo> <mo>)</mo></mrow></math>
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    left-bracket 60 plus upper C right-bracket right-parenthesis minus left-parenthesis
    left-bracket 0 plus upper C right-bracket right-parenthesis"><mrow><mi>F</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mo>(</mo> <mo>[</mo> <mn>60</mn>
    <mo>+</mo> <mi>C</mi> <mo>]</mo> <mo>)</mo> <mo>-</mo> <mo>(</mo> <mo>[</mo> <mn>0</mn>
    <mo>+</mo> <mi>C</mi> <mo>]</mo> <mo>)</mo></mrow></math>
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    left-bracket 60 plus upper C right-bracket right-parenthesis minus left-parenthesis
    left-bracket 0 plus upper C right-bracket right-parenthesis"><mrow><mi>F</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mo>(</mo> <mo>[</mo> <mn>60</mn>
    <mo>+</mo> <mi>C</mi> <mo>]</mo> <mo>)</mo> <mo>-</mo> <mo>(</mo> <mo>[</mo> <mn>0</mn>
    <mo>+</mo> <mi>C</mi> <mo>]</mo> <mo>)</mo></mrow></math>
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    60 minus 0 right-parenthesis"><mrow><mi>F</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo>
    <mo>=</mo> <mo>(</mo> <mn>60</mn> <mo>-</mo> <mn>0</mn> <mo>)</mo></mrow></math>
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    60 minus 0 right-parenthesis"><mrow><mi>F</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo>
    <mo>=</mo> <mo>(</mo> <mn>60</mn> <mo>-</mo> <mn>0</mn> <mo>)</mo></mrow></math>
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals 60"><mrow><mi>F</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mn>60</mn></mrow></math>
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper F left-parenthesis x right-parenthesis equals 60"><mrow><mi>F</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mn>60</mn></mrow></math>
- en: Note
  id: totrans-556
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The constant *C* will always cancel out indefinite integrals, so you can leave
    it out in this kind of problem.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 常数*C*将始终取消掉不定积分，因此在这种问题中可以忽略它。
- en: 'Therefore, the area below the graph of *f(x)* and above the *x*-axis, as well
    as between [0, 6] on the *x*-axis, is equal to 60 square units. The following
    shows a few rules of thumb on integrals (after all, this chapter is supposed to
    refresh your knowledge or give you a basic understanding of a few key mathematical
    concepts):'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，图形*f(x)*下方和*x*轴上方的区域，以及在*x*轴上[0, 6]之间的区域，都等于60平方单位。以下显示了积分的一些经验法则（毕竟，本章旨在更新您的知识或使您对一些关键数学概念有基本理解）：
- en: 'To find the integral of a constant:'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要找到常数的积分：
- en: <math alttext="integral a d x equals a x plus upper C"><mrow><mo>∫</mo> <mi>a</mi>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mi>a</mi> <mi>x</mi> <mo>+</mo> <mi>C</mi></mrow></math>
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="integral a d x equals a x plus upper C"><mrow><mo>∫</mo> <mi>a</mi>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mi>a</mi> <mi>x</mi> <mo>+</mo> <mi>C</mi></mrow></math>
- en: 'To find the integral of a variable:'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要找到变量的积分：
- en: <math alttext="integral x d x equals one-half x squared plus upper C"><mrow><mo>∫</mo>
    <mi>x</mi> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mi>C</mi></mrow></math>
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="integral x d x equals one-half x squared plus upper C"><mrow><mo>∫</mo>
    <mi>x</mi> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mi>C</mi></mrow></math>
- en: 'To find the integral of a reciprocal:'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要找到倒数的积分：
- en: <math alttext="integral StartFraction 1 Over x EndFraction d x equals ln StartAbsoluteValue
    x EndAbsoluteValue plus upper C"><mrow><mo>∫</mo> <mfrac><mn>1</mn> <mi>x</mi></mfrac>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mo form="prefix">ln</mo> <mrow><mo>|</mo> <mi>x</mi>
    <mo>|</mo></mrow> <mo>+</mo> <mi>C</mi></mrow></math>
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="integral StartFraction 1 Over x EndFraction d x equals ln StartAbsoluteValue
    x EndAbsoluteValue plus upper C"><mrow><mo>∫</mo> <mfrac><mn>1</mn> <mi>x</mi></mfrac>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mo form="prefix">ln</mo> <mrow><mo>|</mo> <mi>x</mi>
    <mo>|</mo></mrow> <mo>+</mo> <mi>C</mi></mrow></math>
- en: 'To find the integral of an exponential:'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要找到指数的积分：
- en: <math alttext="integral a Superscript x Baseline d x equals StartFraction a
    Superscript x Baseline Over ln left-parenthesis a right-parenthesis EndFraction
    plus upper C"><mrow><mo>∫</mo> <msup><mi>a</mi> <mi>x</mi></msup> <mi>d</mi> <mi>x</mi>
    <mo>=</mo> <mfrac><msup><mi>a</mi> <mi>x</mi></msup> <mrow><mo form="prefix">ln</mo><mo>(</mo><mi>a</mi><mo>)</mo></mrow></mfrac>
    <mo>+</mo> <mi>C</mi></mrow></math>
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="integral a Superscript x Baseline d x equals StartFraction a
    Superscript x Baseline Over ln left-parenthesis a right-parenthesis EndFraction
    plus upper C"><mrow><mo>∫</mo> <msup><mi>a</mi> <mi>x</mi></msup> <mi>d</mi> <mi>x</mi>
    <mo>=</mo> <mfrac><msup><mi>a</mi> <mi>x</mi></msup> <mrow><mo form="prefix">ln</mo><mo>(</mo><mi>a</mi><mo>)</mo></mrow></mfrac>
    <mo>+</mo> <mi>C</mi></mrow></math>
- en: <math alttext="integral e Superscript x Baseline d x equals e Superscript x
    Baseline plus upper C"><mrow><mo>∫</mo> <msup><mi>e</mi> <mi>x</mi></msup> <mi>d</mi>
    <mi>x</mi> <mo>=</mo> <msup><mi>e</mi> <mi>x</mi></msup> <mo>+</mo> <mi>C</mi></mrow></math>
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="integral e Superscript x Baseline d x equals e Superscript x
    Baseline plus upper C"><mrow><mo>∫</mo> <msup><mi>e</mi> <mi>x</mi></msup> <mi>d</mi>
    <mi>x</mi> <mo>=</mo> <msup><mi>e</mi> <mi>x</mi></msup> <mo>+</mo> <mi>C</mi></mrow></math>
- en: 'The *fundamental theorem of calculus* links derivatives with integrals. This
    means that it defines derivatives in terms of integrals and vice versa. The fundamental
    theorem of calculus is actually made up of two parts:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '*微积分基本定理*将导数与积分联系起来。这意味着它用积分来定义导数，反之亦然。 微积分的基本定理实际上由两部分组成：'
- en: Part I
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分
- en: The first part of the fundamental theorem of calculus states that if you have
    a continuous function *f(x)*, then the original function *F(x)* defined as the
    antiderivative of *f(x)* from a fixed starting point *a* up to *x* is a function
    that is differentiable everywhere from *a* to *x*, and its derivative is simply
    *f(x)* evaluated at *x*.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分基本定理的第一部分指出，如果您有一个连续的函数*f(x)*，那么原始函数*F(x)*，定义为*f(x)*的反导数，从固定的起点*a*到*x*是一个在*a*到*x*处处可微的函数，并且其导数简单地是在*x*处评估的*f(x)*。
- en: Part II
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分
- en: The second part of the fundamental theorem of calculus states that if you have
    a function *f(x)* that is continuous over a certain interval [*a, b*], and you
    define a new function *F(x)* as the integral of *f(x)* from *a* to *x*, then the
    definite integral of *f(x)* over that same interval [*a, b*] can be calculated
    as *F(b) – F(a)*.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分基本定理的第二部分指出，如果您有一个在某个区间[*a, b*]上连续的函数*f(x)*，并定义一个新函数*F(x)*为*f(x)*从*a*到*x*的积分，则该函数*f(x)*在相同区间[*a,
    b*]上的定积分可以计算为*F(b) – F(a)*。
- en: 'The theorem is useful in many fields, including physics and engineering, but
    optimization and other mathematical models also benefit from it. Some examples
    of using integrals in the different learning algorithms can be summed up as follows:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 定理在许多领域都很有用，包括物理学和工程学，但优化和其他数学模型也受益于它。在不同学习算法中使用积分的一些例子可以总结如下：
- en: Density estimation
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 密度估计
- en: Integrals are used in density estimation, a part of many machine learning algorithms,
    to calculate the probability density function.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 积分在密度估计中使用，这是许多机器学习算法的一部分，用于计算概率密度函数。
- en: Reinforcement learning
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 强化学习
- en: Integrals are used in reinforcement learning to calculate expected values of
    reward functions. Reinforcement learning is covered in [Chapter 10](ch10.html#ch10).
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 积分在强化学习中用于计算奖励函数的期望值。强化学习在[第10章](ch10.html#ch10)中有详细介绍。
- en: Note
  id: totrans-578
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The key takeaways from this section are as follows:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的要点如下：
- en: Integrals are also known as antiderivatives and they are the opposite of derivatives.
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 积分也称为反导数，是导数的反向操作。
- en: Indefinite integrals find the area under the curve everywhere, while definite
    integrals are bounded within an interval given by point *a* and point *b*.
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不定积分在曲线下的整体面积，而定积分在由点*a*和点*b*界定的区间内。
- en: The fundamental theorem of calculus is the bridge between derivatives and integrals.
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微积分基本定理是导数和积分之间的桥梁。
- en: In machine learning integrals are used for modeling uncertainty, making predictions,
    and estimating expected values.
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在机器学习中，积分用于建模不确定性、进行预测和估计期望值。
- en: Optimization
  id: totrans-584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化
- en: Several machine and deep learning algorithms depend on optimization techniques
    to decrease error functions.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 几种机器学习和深度学习算法依赖于优化技术来减少误差函数。
- en: '*Optimization* is the process of finding the best solution among all possible
    solutions. Optimization is all about finding the highest and lowest points of
    a function. [Figure 4-17](#figure-4-17) shows the graph for the following formula:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '*优化*是在所有可能的解决方案中找到最佳解决方案的过程。优化就是找到函数的最高点和最低点。[图 4-17](#figure-4-17)展示了以下公式的图形：'
- en: <math alttext="f left-parenthesis x right-parenthesis equals x Superscript 4
    Baseline minus 2 x squared plus x"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>4</mn></msup> <mo>-</mo> <mn>2</mn>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mi>x</mi></mrow></math>
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals x Superscript 4
    Baseline minus 2 x squared plus x"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>4</mn></msup> <mo>-</mo> <mn>2</mn>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mi>x</mi></mrow></math>
- en: '![](assets/dlff_0417.png)'
  id: totrans-588
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dlff_0417.png)'
- en: Figure 4-17\. A graph of the function <math alttext="f left-parenthesis x right-parenthesis
    equals x Superscript 4 Baseline minus 2 x squared plus x"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>4</mn></msup> <mo>-</mo>
    <mn>2</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mi>x</mi></mrow></math>
  id: totrans-589
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-17\. 函数图：<math alttext="f left-parenthesis x right-parenthesis equals x
    Superscript 4 Baseline minus 2 x squared plus x"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>4</mn></msup> <mo>-</mo>
    <mn>2</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mi>x</mi></mrow></math>
- en: A *local minimum* exists when values on the right of the *x*-axis are decreasing
    until reaching a point where they start increasing. The point does not have to
    necessarily be the lowest point in the function, hence the name *local*. In [Figure 4-17](#figure-4-17),
    the function has a local minimum at point A.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '*局部最小值*是指在*x*轴右侧的数值递减，直到达到一个开始递增的点。该点不一定是函数中的最低点，因此称为*局部*。在[图 4-17](#figure-4-17)中，函数在点A处有局部最小值。'
- en: A *local maximum* exists when values on the right of the *x*-axis are increasing
    until reaching a point where they start decreasing. The point does not have to
    necessarily be the highest point in the function. In [Figure 4-17](#figure-4-17),
    the function has a local maximum at point B.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '*局部最大值*是指在*x*轴右侧的数值递增，直到达到一个开始递减的点。该点不一定是函数中的最高点。在[图 4-17](#figure-4-17)中，函数在点B处有局部最大值。'
- en: A *global minimum* exists when values on the right of the *x*-axis are decreasing
    until reaching a point where they start increasing. The point must be the lowest
    point in the function, hence the name global. In [Figure 4-17](#figure-4-17),
    the function has a global minimum at point C.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '*全局最小值*是指在*x*轴右侧的数值递减，直到达到一个开始递增的点。该点必须是函数中的最低点，因此称为*全局*。在[图 4-17](#figure-4-17)中，函数在点C处有全局最小值。'
- en: A *global maximum* exists when values on the right of the *x*-axis are increasing
    until reaching a point where they start decreasing. The point must be the highest
    point in the function. In [Figure 4-17](#figure-4-17), there is no global maximum,
    as the function will continue infinitely without creating a top. You can clearly
    see how the function accelerates upward.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '*全局最大值*是指在*x*轴右侧的数值递增，直到达到一个开始递减的点。该点必须是函数中的最高点。在[图 4-17](#figure-4-17)中，没有全局最大值，因为函数将无限地继续而没有顶点。您可以清楚地看到函数如何向上加速。'
- en: When dealing with machine and deep learning models, the aim is to find model
    parameters (or inputs) that minimize what is known as a *loss function* (a function
    that gives the error of forecasts). If the loss function is convex, optimization
    techniques should find the parameters that tend toward the global minimum where
    the loss function is minimized.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理机器和深度学习模型时，目标是找到能使所谓的*损失函数*（给出预测误差的函数）最小化的模型参数（或输入）。如果损失函数是凸的，优化技术应当找到能使损失函数最小化的参数，趋向于全局最小值。
- en: If the loss function is nonconvex, the convergence is not guaranteed, and the
    optimization may only lead toward approaching a local minimum, which is a part
    of the aim, but this leaves the global minimum, which is the final aim.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 如果损失函数是非凸的，则不能保证收敛，优化可能只会导致接近局部最小值，这是目标的一部分，但这会忽略全局最小值，这才是最终的目标。
- en: 'But how are these minima and maxima found? Let’s look at it step by step:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这些最小值和最大值是如何找到的呢？让我们一步一步来看：
- en: The first step is to perform the first derivative test (which is calculating
    the derivative of the function). Then, setting the function equal to zero and
    solving for *x* will give what are known as critical points. *Critical points*
    are the points where the function changes direction (the values stop going in
    one direction and start going in another direction). Therefore, these points are
    maxima and minima.
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是进行第一阶导数测试（即计算函数的导数）。然后，将函数设为零并解出*x*将给出所谓的临界点。*临界点*是函数变换方向的点（数值停止向一个方向移动并开始向另一个方向移动）。因此，这些点是极大值和极小值。
- en: The second step is to perform the second derivative test (which is simply calculating
    the derivative of the derivative). Then, setting the function equal to zero and
    solving for *x* will give what are known as inflection points. *Inflection points*
    show where the function is concave up and where it is concave down.
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步是进行二阶导数测试（即计算导数的导数）。然后，将函数设为零并解出*x*将给出所谓的拐点。*拐点*显示了函数凹向上和凹向下的地方。
- en: In other words, critical points are where the function changes direction, and
    inflection points are where the function changes concavity. [Figure 4-18](#figure-4-18)
    shows the difference between a concave up function and a concave down function.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，临界点是函数变换方向的地方，拐点是函数改变凹凸性的地方。[图 4-18](#figure-4-18) 显示了凹函数和凸函数之间的区别。
- en: <math alttext="Concave up function equals x squared"><mrow><mtext>Concave</mtext>
    <mtext>up</mtext> <mtext>function</mtext> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Concave up function equals x squared"><mrow><mtext>Concave</mtext>
    <mtext>up</mtext> <mtext>function</mtext> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
- en: <math alttext="Concave down function equals minus x squared"><mrow><mtext>Concave</mtext>
    <mtext>down</mtext> <mtext>function</mtext> <mo>=</mo> <mo>-</mo> <msup><mi>x</mi>
    <mn>2</mn></msup></mrow></math>
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Concave down function equals minus x squared"><mrow><mtext>Concave</mtext>
    <mtext>down</mtext> <mtext>function</mtext> <mo>=</mo> <mo>-</mo> <msup><mi>x</mi>
    <mn>2</mn></msup></mrow></math>
- en: '![](assets/dlff_0418.png)'
  id: totrans-602
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dlff_0418.png)'
- en: Figure 4-18\. A concave up function and a concave down function
  id: totrans-603
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-18\. 一个凹向上的函数和一个凹向下的函数
- en: 'The steps to find the extrema are as follows:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 找到极值的步骤如下：
- en: Find the first derivative and set it to zero.
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到第一阶导数并将其设为零。
- en: Solve the first derivative to find *x*. The values are called critical points,
    and they represent the points where the function changes direction.
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解第一阶导数以找到*x*。这些值称为临界点，它们代表函数变换方向的点。
- en: Plug values into the formula that are either below or above the critical points.
    If the result of the first derivative is positive, it means that it’s increasing
    around that point, and if it’s negative, it means that it’s decreasing around
    that point.
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值插入公式中，这些值要么在临界点下要么在临界点上。如果第一阶导数的结果为正，则意味着在该点周围增长，如果为负，则意味着在该点周围减少。
- en: Find the second derivative and set it to zero.
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到第二阶导数并将其设为零。
- en: Solve the second derivative to find *x*. The values, called inflection points,
    represent the points where concavity changes from up to down and vice versa.
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解第二阶导数以找到*x*。这些值称为拐点，代表了凹凸性从向上变为向下或反之的点。
- en: Plug values into the formula that are either below or above the inflection points.
    If the result of the second derivative is positive, it means there is a minimum
    at that point, and if it’s negative, it means there is a maximum at that point.
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值插入公式中，这些值要么在拐点下要么在拐点上。如果第二阶导数的结果为正，则意味着该点有一个最小值，如果为负，则意味着该点有一个最大值。
- en: 'It is important to understand that the first derivative test relates to critical
    points and the second derivative test relates to inflection points. The following
    example finds the extrema of the function:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，第一阶导数测试与临界点相关，而第二阶导数测试与拐点相关。以下示例找到函数的极值：
- en: <math alttext="f left-parenthesis x right-parenthesis equals x squared plus
    x plus 4"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mi>x</mi> <mo>+</mo> <mn>4</mn></mrow></math>
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals x squared plus
    x plus 4"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mi>x</mi> <mo>+</mo> <mn>4</mn></mrow></math>
- en: 'The first step is to take the first derivative, set it to zero, and solve for
    *x*:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是取第一阶导数，将其设为零并解出*x*：
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x plus
    1"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>1</mn></mrow></math>
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x plus
    1"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>1</mn></mrow></math>
- en: <math alttext="2 x plus 1 equals 0"><mrow><mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>1</mn>
    <mo>=</mo> <mn>0</mn></mrow></math>
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="2 x plus 1 equals 0"><mrow><mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>1</mn>
    <mo>=</mo> <mn>0</mn></mrow></math>
- en: <math alttext="x equals negative one-half"><mrow><mi>x</mi> <mo>=</mo> <mo>-</mo>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac></mrow></math>
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x equals negative one-half"><mrow><mi>x</mi> <mo>=</mo> <mo>-</mo>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac></mrow></math>
- en: 'The result shows there is a critical point at that value. Now find the second
    derivative:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明在该数值处存在临界点。现在找出二阶导数：
- en: <math alttext="f double-prime left-parenthesis x right-parenthesis equals 2"><mrow><msup><mi>f</mi>
    <mrow><mo>'</mo><mo>'</mo></mrow></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>2</mn></mrow></math>
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f double-prime left-parenthesis x right-parenthesis equals 2"><mrow><msup><mi>f</mi>
    <mrow><mo>'</mo><mo>'</mo></mrow></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>2</mn></mrow></math>
- en: 'Next, the critical point must be plugged into the second derivative formula:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，必须将临界点代入二阶导数公式中：
- en: <math alttext="f double-prime left-parenthesis negative one-half right-parenthesis
    equals 2"><mrow><msup><mi>f</mi> <mrow><mo>'</mo><mo>'</mo></mrow></msup> <mrow><mo>(</mo>
    <mo>-</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn></mrow></math>
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f double-prime left-parenthesis negative one-half right-parenthesis
    equals 2"><mrow><msup><mi>f</mi> <mrow><mo>'</mo><mo>'</mo></mrow></msup> <mrow><mo>(</mo>
    <mo>-</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn></mrow></math>
- en: The second derivative is positive at the critical point. This means that there
    is a local minimum at that point.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 在临界点，二阶导数为正。这意味着在该点有一个局部最小值。
- en: In the coming chapters, you will see more complex optimization techniques such
    as the gradient descent and the stochastic gradient descent, which are fairly
    common in machine learning algorithms. Note that you do not have to fully understand
    the details of optimization and solving for the unknown variables as the algorithms
    will do that on their own.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，您将看到更复杂的优化技术，如梯度下降和随机梯度下降，这些在机器学习算法中非常常见。请注意，您不必完全理解优化和解决未知变量的细节，因为算法将自行处理。
- en: Note
  id: totrans-623
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The key takeaways from this section are as follows:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的关键要点如下：
- en: Optimization is the process of finding the function’s extrema.
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化是找到函数的极值点的过程。
- en: Critical points are the points where the function changes direction.
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临界点是函数改变方向的点。
- en: Inflection points give where the function is concave up and where it is concave
    down.
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拐点表明函数凹向上和凹向下的位置。
- en: A loss function is a function that measures the error of forecasts in predictive
    machine learning.
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 损失函数是衡量预测机器学习中预测误差的函数。
- en: Summary
  id: totrans-629
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Chapters [2](ch02.html#ch02), [3](ch03.html#ch03), and [4](#ch04) presented
    the main numerical concepts to help you start understanding basic machine and
    deep learning models. I made all reasonable efforts to simplify the technical
    details as much as possible. However, I encourage you to read these three chapters
    at least twice so that everything you have learned becomes second nature. I also
    encourage you to research these concepts in more depth in other material.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章、第3章和第4章介绍了主要的数值概念，帮助您开始理解基本的机器学习和深度学习模型。我已尽最大努力尝试尽可能简化技术细节。然而，我建议您至少阅读这三章两次，这样您学到的所有东西就会变得非常熟悉。我还鼓励您在其他材料中深入研究这些概念。
- en: Naturally, deep learning requires more in-depth knowledge in mathematics, but
    I believe that with the concepts in this chapter, you may start dipping your toes
    into creating algorithms. After all, they come prebuilt from packages and libraries,
    and the aim of this chapter was to help you understand what you are working with.
    It is unlikely that you will build the models from scratch using archaic tools.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，深度学习需要更深入的数学知识，但我相信通过本章的概念，您可以开始涉足算法的创建。毕竟，它们是从包和库中预构建的，本章的目的是帮助您了解您正在使用的内容。使用过时的工具从头构建模型的可能性不大。
- en: 'By now, you should have gained a certain understanding of data science and
    the mathematical requirements that will get you started comfortably. We have two
    more topics to cover before you can start building your first machine learning
    model: technical analysis and Python for data science.'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，您应该已经对数据科学和数学要求有了一定的理解，可以舒适地开始。在您能够开始构建第一个机器学习模型之前，我们还有两个主题需要涵盖：技术分析和Python数据科学。
- en: ^([1](ch04.html#id453-marker)) Matrices can also contain symbols and expressions,
    but for the sake of simplicity, let’s stick to numbers.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch04.html#id453-marker)) 矩阵也可以包含符号和表达式，但出于简化的目的，让我们坚持使用数字。
