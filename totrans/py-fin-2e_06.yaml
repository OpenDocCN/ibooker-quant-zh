- en: Chapter 6\. Object Orientated Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of software engineering is to control complexity, not to create
    it.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Pamela Zave
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object oriented programming (OOP) is one of the most popular programming paradigms
    today. Used in the right way, it provides a number of advantages compared to,
    for example, procedural programming. In many cases, OOP seems to be particularly
    suited for financial modeling and implementing financial algorithms. However,
    there are also many critics of OOP, voicing their skepticism targeted towards
    single aspects of OOP or even the paradigm as a whole. This chapter takes a neutral
    stance in that OOP is considered an important tool that might not be the best
    one for every single problem, but one that should be at the disposal of programmers
    and quants working in finance.
  prefs: []
  type: TYPE_NORMAL
- en: 'With OOP, some new language comes along. The most important terms for the purposes
    of this book and chapter are (more follow below):'
  prefs: []
  type: TYPE_NORMAL
- en: Class
  prefs: []
  type: TYPE_NORMAL
- en: An abstract definition of a class of objects. For example, a human being.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute
  prefs: []
  type: TYPE_NORMAL
- en: A feature of the class (*class attribute*) or of an instance of the class (*instance
    attribute*). For example, being a mammal or color of the eyes.
  prefs: []
  type: TYPE_NORMAL
- en: Method
  prefs: []
  type: TYPE_NORMAL
- en: An operation that can be implemented on the class. For example, walking.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: Input parameters taken by a method to influence its behavior. For example, three
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: Object
  prefs: []
  type: TYPE_NORMAL
- en: An instance of a class. For example, Sandra with blue eyes.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiation
  prefs: []
  type: TYPE_NORMAL
- en: The process of creating a specific object based on an abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: Translated into Python code, a simple class implementing the example of a human
    being might look as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_object_orientated_programming_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Class definition statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_object_orientated_programming_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Special method called during instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](images/3.png)](#co_object_orientated_programming_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: First name attribute initialized with parameter value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](images/4.png)](#co_object_orientated_programming_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Eye color attribute initialized with parameter value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](images/5.png)](#co_object_orientated_programming_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Position attribute initialized with 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](images/6.png)](#co_object_orientated_programming_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Method definition for walking with `steps` as parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](images/7.png)](#co_object_orientated_programming_CO1-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Code that changes the position given the `steps` value.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the class definition, a new Python object can be instantiated and used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_object_orientated_programming_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_object_orientated_programming_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing attribute values.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](images/3.png)](#co_object_orientated_programming_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Calling the method.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](images/4.png)](#co_object_orientated_programming_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the updated `position` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several *human aspects* that might speak for the use of OOP:'
  prefs: []
  type: TYPE_NORMAL
- en: Natural way of thinking
  prefs: []
  type: TYPE_NORMAL
- en: Human thinking typically evolves around real-world or abstract objects, like,
    for example, a car or a financial instrument. OOP is suited to model such objects
    with their characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing complexity
  prefs: []
  type: TYPE_NORMAL
- en: Via different approaches, OOP helps reducing the complexity of a problem or
    algorithm and to model it feature-by-feature.
  prefs: []
  type: TYPE_NORMAL
- en: Nicer user interfaces
  prefs: []
  type: TYPE_NORMAL
- en: OOP allows in many cases for nicer user interfaces and more compact code. This
    becomes evident, for example, when looking at `NumPy`’s `ndarray` class or `pandas`’s
    `DataFrame` class.
  prefs: []
  type: TYPE_NORMAL
- en: Pythonic way of modeling
  prefs: []
  type: TYPE_NORMAL
- en: Independent of the pros and cons of OOP, it is simply the dominating paradigm
    in Python. This is where the saying “Everything is an object in Python.” comes
    from. OOP also allows the programmer o build custom classes whose instances behave
    like every other instance of a standard Python class.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also several *technical aspects* that might speak for OOP:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction
  prefs: []
  type: TYPE_NORMAL
- en: The use of attributes and methods allows building abstract, flexible models
    of objects — with a focus on what is relevant and neglecting what is not needed.
    In finance, this might mean to have a general class that models a financial instrument
    in abstract fashion. Instances of such a class would then be concrete financial
    products, engineered and offered by an investment bank, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Modularity
  prefs: []
  type: TYPE_NORMAL
- en: OOP simplifies to break code down into multiple modules which are then linked
    to form the complete code basis. For example, modeling a European option on a
    stock could be achieved by a single class or by two classes, one for the underlying
    stock and one for the option itself.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance refers to the concept that one class can *inherit* attributes and
    methods from another class. In finance, starting with a general financial instrument,
    the next level could be a general derivative instrument, then a European option,
    then a European call option. Every class might inherit attributes and methods
    from classes on a higher level.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation refers to the case in which an object is at least partly made up
    of multiple other objects that might exist independently. A class modeling a European
    call option might have as attributes other objects for both the underlying stock
    and the relevant short rate for discounting. The objects representing the stock
    and the short rate can be used independently by other objects as well.
  prefs: []
  type: TYPE_NORMAL
- en: Composition
  prefs: []
  type: TYPE_NORMAL
- en: Composition is similar to aggregation, but here the single objects cannot exist
    independently of each other. Consider a custom-tailored interest rate swap with
    a fixed leg and a floating leg. The two legs do not exist independently of the
    swap itself.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism can take on multiple forms. Of particular importance in a Python
    context is what is called *duck typing*. This refers to the fact that standard
    operations can be implemented on many different classes and their instances without
    knowing exactly what particular object one is dealing with. For a class of financial
    instruments this might mean that one can call a method `get_current_price()` independent
    of the specific type of the object (stock, option, swap).
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs: []
  type: TYPE_NORMAL
- en: This concept refers to the approach of making data within a class only accessible
    via public methods. A class modeling a stock might have an attribute `current_stock_price`.
    Encapsulation would then give access to the attribute value via a method `get_current_stock_price()`
    and would hide the data from the user (make it private). This approach might avoid
    unintended effects by simply working with and possibly changing attribute values.
    However, there are limits as to how data can be made private in a Python class.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a somewhat higher level, many of these aspects can be summarized by *two
    generals goals* in software engineering:'
  prefs: []
  type: TYPE_NORMAL
- en: Re-usability
  prefs: []
  type: TYPE_NORMAL
- en: Concepts like inheritance and polymorphism improve code re-usability and increase
    efficiency and productivity of the programmer. They also simplify code maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Non-redundancy
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, these approaches allow to build a almost non-redundant code,
    avoiding double implementation effort, reducing debugging and testing effort as
    well as maintenance effort. It might also lead to a smaller overall code basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter is organized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[“A Look at Python Objects”](#py_objects)'
  prefs: []
  type: TYPE_NORMAL
- en: The subsequent section takes a look at some Python objects through the lens
    of OOP.
  prefs: []
  type: TYPE_NORMAL
- en: '[“Basics of Python Classes”](#oop_basics)'
  prefs: []
  type: TYPE_NORMAL
- en: This section introduces central elements of OOP in Python and uses financial
    instruments and portfolio positions as major examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[“Python Data Model”](#data_model)'
  prefs: []
  type: TYPE_NORMAL
- en: This section discusses important elements of the Python data model and roles
    that certain special methods play.
  prefs: []
  type: TYPE_NORMAL
- en: A Look at Python Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section takes a brief look at some standard object, already encountered
    in previous section through the eyes of an OOP programmer.
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start simple, consider an integer object. Even for such a simple Python object,
    the major OOP features are present.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_object_orientated_programming_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: New instance `n`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_object_orientated_programming_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Type of the object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](images/3.png)](#co_object_orientated_programming_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: An attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](images/4.png)](#co_object_orientated_programming_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: A method.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](images/5.png)](#co_object_orientated_programming_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the + operator (addition).
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](images/6.png)](#co_object_orientated_programming_CO3-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the * operator (multiplication).
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](images/7.png)](#co_object_orientated_programming_CO3-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Calling the special method `__sizeof__()` to get the memory usage in bytes.^([1](ch06.html#idm140277674288640))
  prefs: []
  type: TYPE_NORMAL
- en: list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`list` objects have, for example, some more methods but basically behave the
    same way.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_object_orientated_programming_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: New instance `l`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_object_orientated_programming_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Type of the object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](images/3.png)](#co_object_orientated_programming_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting an element via indexing.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](images/4.png)](#co_object_orientated_programming_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: A method.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](images/5.png)](#co_object_orientated_programming_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the + operator (concatenation).
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](images/6.png)](#co_object_orientated_programming_CO4-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the * operator (concatenation).
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](images/7.png)](#co_object_orientated_programming_CO4-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the standard Python function `sum()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](images/8.png)](#co_object_orientated_programming_CO4-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Calling the special method `__sizeof__()` to get the memory usage in bytes.
  prefs: []
  type: TYPE_NORMAL
- en: ndarray
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`int` and `list` objects are standard Python objects. The `NumPy` `ndarray`
    object is a “custom-made” object from an open source package.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_object_orientated_programming_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Importing `numpy`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_object_orientated_programming_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A new instance `a`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](images/3.png)](#co_object_orientated_programming_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Type of the object.
  prefs: []
  type: TYPE_NORMAL
- en: Although the `ndarray` object is not a standard object, it behaves in many cases
    as if it would be one — thanks to the Python data model as explained further below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_object_orientated_programming_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: An attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_object_orientated_programming_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A method (aggregation).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](images/3.png)](#co_object_orientated_programming_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: A method (no aggregation).
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](images/4.png)](#co_object_orientated_programming_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the + operator (addition).
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](images/5.png)](#co_object_orientated_programming_CO6-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the * operator (multiplication).
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](images/6.png)](#co_object_orientated_programming_CO6-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the standard Python function `sum()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](images/7.png)](#co_object_orientated_programming_CO6-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the `NumPy` universal function `np.sum()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](images/8.png)](#co_object_orientated_programming_CO6-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Calling the special method `__sizeof__()` to get the memory usage in bytes.
  prefs: []
  type: TYPE_NORMAL
- en: DataFrame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, a quick look at the `pandas` `DataFrame` object for the behavior is
    mostly the same as for the `ndarray` object. First, the instantiation of the `DataFrame`
    object based on the `ndarray` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_object_orientated_programming_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Importing `pandas`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_object_orientated_programming_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A new instance `df`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](images/3.png)](#co_object_orientated_programming_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Type of the object.
  prefs: []
  type: TYPE_NORMAL
- en: Second, a look at attributes, methods and operations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_object_orientated_programming_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: An attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_object_orientated_programming_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A method (aggregation).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](images/3.png)](#co_object_orientated_programming_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: A method (no aggregation).
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](images/4.png)](#co_object_orientated_programming_CO8-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the + operator (addition).
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](images/5.png)](#co_object_orientated_programming_CO8-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the * operator (multiplication).
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](images/6.png)](#co_object_orientated_programming_CO8-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the `NumPy` universal function `np.sum()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](images/7.png)](#co_object_orientated_programming_CO8-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Calling the special method `__sizeof__()` to get the memory usage in bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Basics of Python Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is about major concepts and the concrete syntax to make use of
    OOP in Python. The context now is about building custom made classes to model
    types of objects that cannot easily, efficiently or properly modeled by existing
    Python object types. Throughout the example of a *financial instrument* is used.
    Two lines of code suffice to create a new Python class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_object_orientated_programming_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Class definition statement.^([2](ch06.html#idm140277672765360))
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_object_orientated_programming_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Some code; here simply the `pass` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](images/3.png)](#co_object_orientated_programming_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: A new instance of the class named `fi`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](images/4.png)](#co_object_orientated_programming_CO9-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Every Python object comes with certain, so-called special attributes and methods
    (from `object`); here the special method to retrieve the string representation
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](images/5.png)](#co_object_orientated_programming_CO9-6)'
  prefs: []
  type: TYPE_NORMAL
- en: So-called data attributes — in contrast to regular attributes — can be defined
    on the fly for every object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](images/6.png)](#co_object_orientated_programming_CO9-7)'
  prefs: []
  type: TYPE_NORMAL
- en: An important special method is `__init__` which gets called during every instantiation
    of an object. It takes as parameters the object itself (`self` by convention)
    and potentially multiple others. In addition to instance attributes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_object_orientated_programming_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Definition of a class attribute (= inherited by every instance).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_object_orientated_programming_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The special method `__init__` called during initialization.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](images/3.png)](#co_object_orientated_programming_CO10-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Definition of the instance attributes (= individual to every instance).
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](images/4.png)](#co_object_orientated_programming_CO10-6)'
  prefs: []
  type: TYPE_NORMAL
- en: A new instance of the class named `fi`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](images/5.png)](#co_object_orientated_programming_CO10-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing an instance attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](images/6.png)](#co_object_orientated_programming_CO10-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a class attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](images/7.png)](#co_object_orientated_programming_CO10-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Changing the value of an instance attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Prices of financial instruments change regularly, the symbol of a financial
    instrument probably does not change. To introduce encapsulation to the class definition,
    two methods `get_price()` and `set_price()` might be defined. The code that follows
    additionally inherits from the previous class definition (and not from `object`
    anymore).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_object_orientated_programming_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Class definition via inheritance from previous version.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_object_orientated_programming_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines the `get_price` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](images/3.png)](#co_object_orientated_programming_CO11-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines the `set_price` method …
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](images/4.png)](#co_object_orientated_programming_CO11-5)'
  prefs: []
  type: TYPE_NORMAL
- en: … and updates the instance attribute value given the parameter value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](images/5.png)](#co_object_orientated_programming_CO11-6)'
  prefs: []
  type: TYPE_NORMAL
- en: A new instance based on the new class definition named `fi`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](images/6.png)](#co_object_orientated_programming_CO11-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Calls the `get_price()` method to read the instance attribute value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](images/7.png)](#co_object_orientated_programming_CO11-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Updates the instance attribute value via `set_price()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](images/8.png)](#co_object_orientated_programming_CO11-10)'
  prefs: []
  type: TYPE_NORMAL
- en: Direct access to the instance attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation generally has the goal of hiding data from the user working with
    a class. Adding respective methods, sometimes called *getter* and *setter* methods,
    is one part of achieving this goal. This does not prevent, however, that the user
    my still directly access and manipulate instance attributes. This is where *private*
    instance attributes come into play. They are defined by two leading underscores.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_object_orientated_programming_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Price is defined as a private instance attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_object_orientated_programming_CO12-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The method `get_price()` returns its value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](images/3.png)](#co_object_orientated_programming_CO12-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Trying to access the attribute directly raises an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](images/4.png)](#co_object_orientated_programming_CO12-5)'
  prefs: []
  type: TYPE_NORMAL
- en: By prepending the class name with a single leading underscore, direct access
    and manipulation are still possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](images/5.png)](#co_object_orientated_programming_CO12-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the price back to its original value.
  prefs: []
  type: TYPE_NORMAL
- en: Caution
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Although encapsulation can basically be implemented for Python classes via private
    instance attributes and respective methods dealing with them, the hiding of data
    from the user cannot be fully enforced. In that sense, it is rather an engineering
    principle in Python than a technical feature of Python classes.
  prefs: []
  type: TYPE_NORMAL
- en: Consider another class that models a portfolio position of a financial instrument.
    With the two classes *aggregation* as a concept is easily illustrated. An instance
    of the `PortfolioPosition` class takes an instance of the `FinancialInstrument`
    class as attribute value. Adding an instance attribute, such as `position_size`,
    one can then calculate, for instance, the position value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_object_orientated_programming_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: An instance attribute based on an instance of the `FinancialInstrument` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_object_orientated_programming_CO13-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A private instance attribute of the `PortfolioPosition` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](images/3.png)](#co_object_orientated_programming_CO13-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Calculates the position value based on the attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](images/4.png)](#co_object_orientated_programming_CO13-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Methods attached to the instance attribute object can be accessed directly (could
    be hidden as well).
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](images/5.png)](#co_object_orientated_programming_CO13-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Updates the price of the financial instrument.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](images/6.png)](#co_object_orientated_programming_CO13-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Calculates the new position value based on the updated price.
  prefs: []
  type: TYPE_NORMAL
- en: Python Data Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The examples of the previous section already highlight some aspects of the
    so-called Python data or object model (cf. [*https://docs.python.org/3/reference/datamodel.html*](https://docs.python.org/3/reference/datamodel.html)).
    The Python data model allows to design classes that consistently interact with
    basic language constructs of Python. Among others, it supports (see Ramalho (2015),
    p. 4) the following tasks and constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: iteration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: collection handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: attribute access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: operator overloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: function and method invocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: object creation and destruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: string representation (e.g. for printing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: managed contexts (i.e. `with` blocks)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since the Python data model is so important, this section is dedicated to an
    example that explores several aspects of it. The example is found in the book
    Ramalho (2015) and is slightly adjusted. It implements a class for one-dimensional,
    three element vector (think of vectors in Euclidean space). First, the special
    method `__init__`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_object_orientated_programming_CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Three pre-initialized instance attributes (think three-dimensional space).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_object_orientated_programming_CO14-5)'
  prefs: []
  type: TYPE_NORMAL
- en: A new instance of the class named `v`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](images/3.png)](#co_object_orientated_programming_CO14-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The default string representation.
  prefs: []
  type: TYPE_NORMAL
- en: The special method `__str__` allows the definition of custom string representations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_object_orientated_programming_CO15-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The new string representation.
  prefs: []
  type: TYPE_NORMAL
- en: '`abs()` and `bool()` are two standard Python functions whose behavior on the
    `Vector` class can be defined via the special methods `__abs__` and `__bool__`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_object_orientated_programming_CO16-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the Euclidean norm given the three attribute values.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_object_orientated_programming_CO16-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A new `Vector` object with non-zero attribute values.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](images/3.png)](#co_object_orientated_programming_CO16-3)'
  prefs: []
  type: TYPE_NORMAL
- en: A new `Vector` object with zero attribute values only.
  prefs: []
  type: TYPE_NORMAL
- en: As shown multiple times, the `+` and `*` operators can be applied to almost
    any Python object. The behavior is defined through the special methods methods
    `__add__` and `__mul__`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_object_orientated_programming_CO17-1)'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, both special methods return an object of its own kind.
  prefs: []
  type: TYPE_NORMAL
- en: Another standard Python functions is `len()` which gives the length of an object
    in number of elements. This function accesses the special method `__len__` when
    called on a object. On the other hand, the special method `__getitem__` makes
    indexing via the square bracket notation possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_object_orientated_programming_CO18-1)'
  prefs: []
  type: TYPE_NORMAL
- en: All instances of the `Vector` class have a length of three.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the special method `__iter__` defines the behavior during iterations
    over elements of an object. An object, for which this operation is defined is
    called *iterable*. For instance, all collections and containers are iterable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_object_orientated_programming_CO19-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Indirect iteration using index values (via `__getitem__`).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_object_orientated_programming_CO19-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Direct iteration over the class instance (using `__iter__`).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Python data model allows the definition of Python classes that interact
    with standard Python operators, functions, etc. seamlessly. This makes Python
    a rather flexible programming language that can easily be enhanced by new classes
    and types of objects.
  prefs: []
  type: TYPE_NORMAL
- en: As a summary, sub-section [“Vector Class”](#vector_class) provides the `Vector`
    class definition in a single code block.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces notions and approaches from *object oriented programming
    (OOP)* both theoretically as well as on the basis of Python examples. OOP is one
    of the main programming paradigms used in Python. It does not only allow for the
    modeling and implementation of rather complex applications. It also allows to
    create custom objects that behave like standard Python objects due to the flexible
    *Python data model*. Although there are many critics arguing against OOP, it is
    safe to say that it provides the Python programmer and quant with powerful means
    and tools that are helpful when a certain degree of complexity is reached. The
    derivatives pricing package discussed and presented in [Link to Come] presents
    such a case where OOP seems the only sensible programming paradigm to deal with
    the inherent complexities and requirements for abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Further Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are valuable online resources about OOP in general and Python programming
    and Python OOP in particular:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Lecture Notes on Object-Oriented Programming](https://atomicobject.com/resources/oo-programming/introduction-motivation-for-oo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Object-Oriented Programming in Python](http://python-textbok.readthedocs.io/en/1.0/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An excellent resource in book form about Python OOP and the Python data model
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ramalho, Luciano (2016): *Fluent Python*. O’Reilly, Beijing et al.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python Codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vector Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: ^([1](ch06.html#idm140277674288640-marker)) Special attributes and methods in
    Python are characterized by double leading and trailing underscores, such as in
    `__XYZ__`.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch06.html#idm140277672765360-marker)) Camel case naming for classes is
    the recommended way. However, if there is no ambiguity, lower case naming can
    also be applied such as in `financial_instrument`.
  prefs: []
  type: TYPE_NORMAL
