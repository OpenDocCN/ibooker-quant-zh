["```py\nIn [1]: import math\n        import time\n        import numpy as np\n        import pandas as pd\n        import datetime as dt\n        from pylab import plt, mpl\n\nIn [2]: np.random.seed(1000)\n        plt.style.use('seaborn')\n        mpl.rcParams['savefig.dpi'] = 300\n        mpl.rcParams['font.family'] = 'serif'\n```", "```py\nIn [3]: p = 0.55  ![1](assets/1.png)\n\nIn [4]: f = p - (1 - p)  ![2](assets/2.png)\n\nIn [5]: f  ![2](assets/2.png)\nOut[5]: 0.10000000000000009\n\nIn [6]: I = 50  ![3](assets/3.png)\n\nIn [7]: n = 100  ![4](assets/4.png)\n```", "```py\nIn [8]: def run_simulation(f):\n            c = np.zeros((n, I))  ![1](assets/1.png)\n            c[0] = 100  ![2](assets/2.png)\n            for i in range(I):  ![3](assets/3.png)\n                for t in range(1, n):  ![4](assets/4.png)\n                    o = np.random.binomial(1, p)  ![5](assets/5.png)\n                    if o > 0:  ![6](assets/6.png)\n                        c[t, i] = (1 + f) * c[t - 1, i]  ![7](assets/7.png)\n                    else:  ![8](assets/8.png)\n                        c[t, i] = (1 - f) * c[t - 1, i]  ![9](assets/9.png)\n            return c\n\nIn [9]: c_1 = run_simulation(f)  ![10](assets/10.png)\n\nIn [10]: c_1.round(2)\nOut[10]: array([[100.  , 100.  , 100.  , ..., 100.  , 100.  , 100.  ],\n                [ 90.  , 110.  ,  90.  , ..., 110.  ,  90.  , 110.  ],\n                [ 99.  , 121.  ,  99.  , ..., 121.  ,  81.  , 121.  ],\n                ...,\n                [226.35, 338.13, 413.27, ..., 123.97, 123.97, 123.97],\n                [248.99, 371.94, 454.6 , ..., 136.37, 136.37, 136.37],\n                [273.89, 409.14, 409.14, ..., 122.73, 150.01, 122.73]])\n\nIn [11]: plt.figure(figsize=(10, 6))\n         plt.plot(c_1, 'b', lw=0.5)  ![11](assets/11.png)\n         plt.plot(c_1.mean(axis=1), 'r', lw=2.5);  ![12](assets/12.png)\n```", "```py\nIn [12]: c_2 = run_simulation(0.05)  ![1](assets/1.png)\n\nIn [13]: c_3 = run_simulation(0.25)  ![2](assets/2.png)\n\nIn [14]: c_4 = run_simulation(0.5)  ![3](assets/3.png)\n\nIn [15]: plt.figure(figsize=(10, 6))\n         plt.plot(c_1.mean(axis=1), 'r', label='$f^*=0.1$')\n         plt.plot(c_2.mean(axis=1), 'b', label='$f=0.05$')\n         plt.plot(c_3.mean(axis=1), 'y', label='$f=0.25$')\n         plt.plot(c_4.mean(axis=1), 'm', label='$f=0.5$')\n         plt.legend(loc=0);\n```", "```py\nIn [16]: raw = pd.read_csv('http://hilpisch.com/pyalgo_eikon_eod_data.csv',\n                           index_col=0, parse_dates=True)\n\nIn [17]: symbol = '.SPX'\n\nIn [18]: data = pd.DataFrame(raw[symbol])\n\nIn [19]: data['return'] = np.log(data / data.shift(1))\n\nIn [20]: data.dropna(inplace=True)\n\nIn [21]: data.tail()\nOut[21]:                .SPX    return\n         Date\n         2019-12-23  3224.01  0.000866\n         2019-12-24  3223.38 -0.000195\n         2019-12-27  3240.02  0.000034\n         2019-12-30  3221.29 -0.005798\n         2019-12-31  3230.78  0.002942\n```", "```py\nIn [22]: mu = data['return'].mean() * 252  ![1](assets/1.png)\n\nIn [23]: mu  ![1](assets/1.png)\nOut[23]: 0.09992181916534204\n\nIn [24]: sigma = data['return'].std() * 252 ** 0.5  ![2](assets/2.png)\n\nIn [25]: sigma  ![2](assets/2.png)\nOut[25]: 0.14761569775486563\n\nIn [26]: r = 0.0  ![3](assets/3.png)\n\nIn [27]: f = (mu - r) / sigma ** 2 ![4](assets/4.png)\n\nIn [28]: f  ![4](assets/4.png)\nOut[28]: 4.585590244019818\n```", "```py\nIn [29]: equs = []\n\nIn [30]: def kelly_strategy(f):\n             global equs\n             equ = 'equity_{:.2f}'.format(f)\n             equs.append(equ)\n             cap = 'capital_{:.2f}'.format(f)\n             data[equ] = 1  ![1](assets/1.png)\n             data[cap] = data[equ] * f  ![2](assets/2.png)\n             for i, t in enumerate(data.index[1:]):\n                 t_1 = data.index[i]  ![3](assets/3.png)\n                 data.loc[t, cap] = data[cap].loc[t_1] * \\\n                                     math.exp(data['return'].loc[t])  ![4](assets/4.png)\n                 data.loc[t, equ] = data[cap].loc[t] - \\\n                                     data[cap].loc[t_1] + \\\n                                     data[equ].loc[t_1]  ![5](assets/5.png)\n                 data.loc[t, cap] = data[equ].loc[t] * f  ![6](assets/6.png)\n\nIn [31]: kelly_strategy(f * 0.5)  ![7](assets/7.png)\n\nIn [32]: kelly_strategy(f * 0.66)  ![8](assets/8.png)\n\nIn [33]: kelly_strategy(f)  ![9](assets/9.png)\n\nIn [34]: print(data[equs].tail())\n                     equity_2.29  equity_3.03  equity_4.59\n         Date\n         2019-12-23     6.628865     9.585294    14.205748\n         2019-12-24     6.625895     9.579626    14.193019\n         2019-12-27     6.626410     9.580610    14.195229\n         2019-12-30     6.538582     9.412991    13.818934\n         2019-12-31     6.582748     9.496919    14.005618\n\nIn [35]: ax = data['return'].cumsum().apply(np.exp).plot(figsize=(10, 6))\n         data[equs].plot(ax=ax, legend=True);\n```", "```py\nIn [36]: import tpqoa\n\nIn [37]: %time api = tpqoa.tpqoa('../pyalgo.cfg')  ![1](assets/1.png)\n         CPU times: user 893 µs, sys: 198 µs, total: 1.09 ms\n         Wall time: 1.04 ms\n\nIn [38]: instrument = 'EUR_USD'  ![1](assets/1.png)\n\nIn [39]: raw = api.get_history(instrument,\n                                start='2020-06-08',\n                                end='2020-06-13',\n                                granularity='M10',\n                                price='M')  ![1](assets/1.png)\n\nIn [40]: raw.tail()\nOut[40]:                            o        h        l        c  volume  complete\n         time\n         2020-06-12 20:10:00  1.12572  1.12593  1.12532  1.12568     221      True\n         2020-06-12 20:20:00  1.12569  1.12578  1.12532  1.12558     163      True\n         2020-06-12 20:30:00  1.12560  1.12573  1.12534  1.12543     192      True\n         2020-06-12 20:40:00  1.12544  1.12594  1.12528  1.12542     219      True\n         2020-06-12 20:50:00  1.12544  1.12624  1.12541  1.12554     296      True\n\nIn [41]: raw.info()\n         <class 'pandas.core.frame.DataFrame'>\n         DatetimeIndex: 701 entries, 2020-06-08 00:00:00 to 2020-06-12 20:50:00\n         Data columns (total 6 columns):\n          #   Column    Non-Null Count  Dtype\n         ---  ------    --------------  -----\n          0   o         701 non-null    float64\n          1   h         701 non-null    float64\n          2   l         701 non-null    float64\n          3   c         701 non-null    float64\n          4   volume    701 non-null    int64\n          5   complete  701 non-null    bool\n         dtypes: bool(1), float64(4), int64(1)\n         memory usage: 33.5 KB\n\nIn [42]: spread = 0.00012  ![2](assets/2.png)\n\nIn [43]: mean = raw['c'].mean()  ![3](assets/3.png)\n\nIn [44]: ptc = spread / mean  ![4](assets/4.png)\n         ptc  ![4](assets/4.png)\nOut[44]: 0.00010599557439495706\n\nIn [45]: raw['c'].plot(figsize=(10, 6), legend=True);\n```", "```py\nIn [46]: data = pd.DataFrame(raw['c'])\n\nIn [47]: data.columns = [instrument,]\n\nIn [48]: window = 20  ![1](assets/1.png)\n         data['return'] = np.log(data / data.shift(1))  ![2](assets/2.png)\n         data['vol'] = data['return'].rolling(window).std()  ![3](assets/3.png)\n         data['mom'] = np.sign(data['return'].rolling(window).mean())  ![4](assets/4.png)\n         data['sma'] = data[instrument].rolling(window).mean()  ![5](assets/5.png)\n         data['min'] = data[instrument].rolling(window).min()  ![6](assets/6.png)\n         data['max'] = data[instrument].rolling(window).max()  ![7](assets/7.png)\n\nIn [49]: data.dropna(inplace=True)\n\nIn [50]: lags = 6  ![8](assets/8.png)\n\nIn [51]: features = ['return', 'vol', 'mom', 'sma', 'min', 'max']  ![8](assets/8.png)\n\nIn [52]: cols = []\n         for f in features:\n             for lag in range(1, lags + 1):\n                 col = f'{f}_lag_{lag}'\n                 data[col] = data[f].shift(lag)  ![8](assets/8.png)\n                 cols.append(col)\n\nIn [53]: data.dropna(inplace=True)\n\nIn [54]: data['direction'] = np.where(data['return'] > 0, 1, -1)  ![9](assets/9.png)\n\nIn [55]: data[cols].iloc[:lags, :lags]  ![10](assets/10.png)\nOut[55]:\n                          return_lag_1  return_lag_2  return_lag_3  return_lag_4 \\\n     time\n     2020-06-08 04:20:00      0.000097      0.000018     -0.000452      0.000035\n     2020-06-08 04:30:00     -0.000115      0.000097      0.000018     -0.000452\n     2020-06-08 04:40:00      0.000027     -0.000115      0.000097      0.000018\n     2020-06-08 04:50:00     -0.000142      0.000027     -0.000115      0.000097\n     2020-06-08 05:00:00      0.000035     -0.000142      0.000027     -0.000115\n     2020-06-08 05:10:00     -0.000159      0.000035     -0.000142      0.000027\n\n                          return_lag_5  return_lag_6\n     time\n     2020-06-08 04:20:00      0.000000      0.000009\n     2020-06-08 04:30:00      0.000035      0.000000\n     2020-06-08 04:40:00     -0.000452      0.000035\n     2020-06-08 04:50:00      0.000018     -0.000452\n     2020-06-08 05:00:00      0.000097      0.000018\n     2020-06-08 05:10:00     -0.000115      0.000097\n```", "```py\nIn [56]: from sklearn.metrics import accuracy_score\n         from sklearn.tree import DecisionTreeClassifier\n         from sklearn.ensemble import AdaBoostClassifier\n\nIn [57]: n_estimators=15  ![1](assets/1.png)\n         random_state=100  ![1](assets/1.png)\n         max_depth=2  ![1](assets/1.png)\n         min_samples_leaf=15  ![1](assets/1.png)\n         subsample=0.33  ![1](assets/1.png)\n\nIn [58]: dtc = DecisionTreeClassifier(random_state=random_state,\n                                      max_depth=max_depth,\n                                      min_samples_leaf=min_samples_leaf)  ![2](assets/2.png)\n\nIn [59]: model = AdaBoostClassifier(base_estimator=dtc,\n                                   n_estimators=n_estimators,\n                                   random_state=random_state)  ![3](assets/3.png)\n\nIn [60]: split = int(len(data) * 0.7)\n\nIn [61]: train = data.iloc[:split].copy()\n\nIn [62]: mu, std = train.mean(), train.std()  ![4](assets/4.png)\n\nIn [63]: train_ = (train - mu) / std  ![4](assets/4.png)\n\nIn [64]: model.fit(train_[cols], train['direction'])  ![5](assets/5.png)\nOut[64]: AdaBoostClassifier(algorithm='SAMME.R',\n         base_estimator=DecisionTreeClassifier(ccp_alpha=0.0,\n         class_weight=None,\n         criterion='gini',\n         max_depth=2,\n         max_features=None,\n         max_leaf_nodes=None,\n         min_impurity_decrease=0.0,\n         min_impurity_split=None,\n         min_samples_leaf=15,\n         min_samples_split=2,\n         min_weight_fraction_leaf=0.0,\n         presort='deprecated',\n         random_state=100,\n         splitter='best'),\n         learning_rate=1.0, n_estimators=15, random_state=100)\n\nIn [65]: accuracy_score(train['direction'], model.predict(train_[cols]))  ![6](assets/6.png)\nOut[65]: 0.8050847457627118\n\nIn [66]: test = data.iloc[split:].copy()  ![7](assets/7.png)\n\nIn [67]: test_ = (test - mu) / std  ![7](assets/7.png)\n\nIn [68]: test['position'] = model.predict(test_[cols])  ![8](assets/8.png)\n\nIn [69]: accuracy_score(test['direction'], test['position'])  ![9](assets/9.png)\nOut[69]: 0.5665024630541872\n```", "```py\nIn [70]: test['strategy'] = test['position'] * test['return']  ![1](assets/1.png)\n\nIn [71]: sum(test['position'].diff() != 0)  ![2](assets/2.png)\nOut[71]: 77\n\nIn [72]: test['strategy_tc'] = np.where(test['position'].diff() != 0,\n                                        test['strategy'] - ptc,  ![3](assets/3.png)\n                                        test['strategy'])\n\nIn [73]: test[['return', 'strategy', 'strategy_tc']].sum(\n                 ).apply(np.exp)\nOut[73]: return         0.990182\n         strategy       1.015827\n         strategy_tc    1.007570\n         dtype: float64\n\nIn [74]: test[['return', 'strategy', 'strategy_tc']].cumsum(\n                 ).apply(np.exp).plot(figsize=(10, 6));\n```", "```py\nIn [75]: mean = test[['return', 'strategy_tc']].mean() * len(data) * 52  ![1](assets/1.png)\n         mean\nOut[75]: return        -1.705965\n         strategy_tc    1.304023\n         dtype: float64\n\nIn [76]: var = test[['return', 'strategy_tc']].var() * len(data) * 52  ![2](assets/2.png)\n         var\nOut[76]: return         0.011306\n         strategy_tc    0.011370\n         dtype: float64\n\nIn [77]: vol = var ** 0.5  ![3](assets/3.png)\n         vol\nOut[77]: return         0.106332\n         strategy_tc    0.106631\n         dtype: float64\n\nIn [78]: mean / var  ![4](assets/4.png)\nOut[78]: return        -150.884961\n         strategy_tc    114.687875\n         dtype: float64\n\nIn [79]: mean / var * 0.5  ![5](assets/5.png)\nOut[79]: return        -75.442481\n         strategy_tc    57.343938\n         dtype: float64\n```", "```py\nIn [80]: to_plot = ['return', 'strategy_tc']\n\nIn [81]: for lev in [10, 20, 30, 40, 50]:\n             label = 'lstrategy_tc_%d' % lev\n             test[label] = test['strategy_tc'] * lev  ![1](assets/1.png)\n             to_plot.append(label)\n\nIn [82]: test[to_plot].cumsum().apply(np.exp).plot(figsize=(10, 6));\n```", "```py\nIn [83]: equity = 3333  ![1](assets/1.png)\n\nIn [84]: risk = pd.DataFrame(test['lstrategy_tc_30'])  ![2](assets/2.png)\n\nIn [85]: risk['equity'] = risk['lstrategy_tc_30'].cumsum(\n                                   ).apply(np.exp) * equity  ![3](assets/3.png)\n\nIn [86]: risk['cummax'] = risk['equity'].cummax()  ![4](assets/4.png)\n\nIn [87]: risk['drawdown'] = risk['cummax'] - risk['equity']  ![5](assets/5.png)\n\nIn [88]: risk['drawdown'].max()  ![6](assets/6.png)\nOut[88]: 511.38321383258017\n\nIn [89]: t_max = risk['drawdown'].idxmax()  ![7](assets/7.png)\n         t_max  ![7](assets/7.png)\nOut[89]: Timestamp('2020-06-12 10:30:00')\n```", "```py\nIn [90]: temp = risk['drawdown'][risk['drawdown'] == 0]  ![1](assets/1.png)\n\nIn [91]: periods = (temp.index[1:].to_pydatetime() -\n                    temp.index[:-1].to_pydatetime())  ![2](assets/2.png)\n\nIn [92]: periods[20:30]  ![2](assets/2.png)\nOut[92]: array([datetime.timedelta(seconds=600),\n          datetime.timedelta(seconds=1200),\n         datetime.timedelta(seconds=1200), datetime.timedelta(seconds=1200)],\n               dtype=object)\n\nIn [93]: t_per = periods.max()  ![3](assets/3.png)\n\nIn [94]: t_per  ![3](assets/3.png)\nOut[94]: datetime.timedelta(seconds=26400)\n\nIn [95]: t_per.seconds / 60 / 60  ![4](assets/4.png)\nOut[95]: 7.333333333333333\n\nIn [96]: risk[['equity', 'cummax']].plot(figsize=(10, 6))\n         plt.axvline(t_max, c='r', alpha=0.5);\n```", "```py\nIn [97]: import scipy.stats as scs\n\nIn [98]: percs = [0.01, 0.1, 1., 2.5, 5.0, 10.0]  ![1](assets/1.png)\n\nIn [99]: risk['return'] = np.log(risk['equity'] /\n                                  risk['equity'].shift(1))\n\nIn [100]: VaR = scs.scoreatpercentile(equity * risk['return'], percs)  ![2](assets/2.png)\n\nIn [101]: def print_var():\n              print('{}    {}'.format('Confidence Level', 'Value-at-Risk'))\n              print(33 * '-')\n              for pair in zip(percs, VaR):\n                  print('{:16.2f} {:16.3f}'.format(100 - pair[0], -pair[1]))  ![3](assets/3.png)\n\nIn [102]: print_var()  ![3](assets/3.png)\n          Confidence Level    Value-at-Risk\n          ---------------------------------\n                     99.99          162.570\n                     99.90          161.348\n                     99.00          132.382\n                     97.50          122.913\n                     95.00          100.950\n                     90.00           62.622\n```", "```py\nIn [103]: hourly = risk.resample('1H', label='right').last()  ![1](assets/1.png)\n\nIn [104]: hourly['return'] = np.log(hourly['equity'] /\n                                   hourly['equity'].shift(1))\n\nIn [105]: VaR = scs.scoreatpercentile(equity * hourly['return'], percs)  ![2](assets/2.png)\n\nIn [106]: print_var()\n          Confidence Level    Value-at-Risk\n          ---------------------------------\n                     99.99          252.460\n                     99.90          251.744\n                     99.00          244.593\n                     97.50          232.674\n                     95.00          125.498\n                     90.00           61.701\n```", "```py\nIn [107]: import pickle\n\nIn [108]: algorithm = {'model': model, 'mu': mu, 'std': std}\n\nIn [109]: pickle.dump(algorithm, open('algorithm.pkl', 'wb'))\n```", "```py\nIn [110]: algorithm = pickle.load(open('algorithm.pkl', 'rb'))\n\nIn [111]: algorithm['model']\nOut[111]: AdaBoostClassifier(algorithm='SAMME.R',\n          base_estimator=DecisionTreeClassifier(ccp_alpha=0.0,\n          class_weight=None,\n          criterion='gini',\n          max_depth=2,\n          max_features=None,\n          max_leaf_nodes=None,\n          min_impurity_decrease=0.0,\n          min_impurity_split=None,\n          min_samples_leaf=15,\n          min_samples_split=2,\n          min_weight_fraction_leaf=0.0,\n          presort='deprecated',\n          random_state=100,\n          splitter='best'),\n          learning_rate=1.0, n_estimators=15, random_state=100)\n```", "```py\nIn [112]: class MLTrader(tpqoa.tpqoa):\n              def __init__(self, config_file, algorithm):\n                  super(MLTrader, self).__init__(config_file)\n                  self.model = algorithm['model']  ![1](assets/1.png)\n                  self.mu = algorithm['mu']  ![1](assets/1.png)\n                  self.std = algorithm['std']  ![1](assets/1.png)\n                  self.units = 100000  ![2](assets/2.png)\n                  self.position = 0  ![3](assets/3.png)\n                  self.bar = '5s'  ![4](assets/4.png)\n                  self.window = 2  ![5](assets/5.png)\n                  self.lags = 6  ![6](assets/6.png)\n                  self.min_length = self.lags + self.window + 1\n                  self.features = ['return', 'sma', 'min', 'max', 'vol', 'mom']\n                  self.raw_data = pd.DataFrame()\n              def prepare_features(self):  ![7](assets/7.png)\n                  self.data['return'] = np.log(self.data['mid'] /\n                                               self.data['mid'].shift(1))\n                  self.data['sma'] = self.data['mid'].rolling(self.window).mean()\n                  self.data['min'] = self.data['mid'].rolling(self.window).min()\n                  self.data['mom'] = np.sign(\n                      self.data['return'].rolling(self.window).mean())\n                  self.data['max'] = self.data['mid'].rolling(self.window).max()\n                  self.data['vol'] = self.data['return'].rolling(\n                      self.window).std()\n                  self.data.dropna(inplace=True)\n                  self.data[self.features] -= self.mu\n                  self.data[self.features] /= self.std\n                  self.cols = []\n                  for f in self.features:\n                      for lag in range(1, self.lags + 1):\n                          col = f'{f}_lag_{lag}'\n                          self.data[col] = self.data[f].shift(lag)\n                          self.cols.append(col)\n              def on_success(self, time, bid, ask):  ![8](assets/8.png)\n                  df = pd.DataFrame({'bid': float(bid), 'ask': float(ask)},\n                                   index=[pd.Timestamp(time).tz_localize(None)])\n                  self.raw_data = self.raw_data.append(df)\n                  self.data = self.raw_data.resample(self.bar,\n                                          label='right').last().ffill()\n                  self.data = self.data.iloc[:-1]\n                  if len(self.data) > self.min_length:\n                      self.min_length +=1\n                      self.data['mid'] = (self.data['bid'] +\n                                          self.data['ask']) / 2\n                      self.prepare_features()\n                      features = self.data[\n                          self.cols].iloc[-1].values.reshape(1, -1)\n                      signal = self.model.predict(features)[0]\n                      print(f'NEW SIGNAL: {signal}', end='\\r')\n                      if self.position in [0, -1] and signal == 1:  ![9](assets/9.png)\n                          print('*** GOING LONG ***')\n                          self.create_order(self.stream_instrument,\n                                      units=(1 - self.position) * self.units)\n                          self.position = 1\n                      elif self.position in [0, 1] and signal == -1:  ![10](assets/10.png)\n                          print('*** GOING SHORT ***')\n                          self.create_order(self.stream_instrument,\n                                      units=-(1 + self.position) * self.units)\n                          self.position = -1\n```", "```py\nIn [113]: mlt = MLTrader('../pyalgo.cfg', algorithm)  ![1](assets/1.png)\n\nIn [114]: mlt.stream_data(instrument, stop=500)  ![2](assets/2.png)\n          print('*** CLOSING OUT ***')\n          mlt.create_order(mlt.stream_instrument,\n                            units=-mlt.position * mlt.units)  ![3](assets/3.png)\n```", "```py\n          *** GOING LONG ***\n\n          {'id': '1735', 'time': '2020-08-19T14:46:15.552233563Z', 'userID':\n           13834683, 'accountID': '101-004-13834683-001', 'batchID': '1734',\n           'requestID': '42730658849646182', 'type': 'ORDER_FILL', 'orderID':\n           '1734', 'instrument': 'EUR_USD', 'units': '100000.0',\n           'gainQuoteHomeConversionFactor': '0.835983419025',\n           'lossQuoteHomeConversionFactor': '0.844385262432', 'price': 1.1903,\n           'fullVWAP': 1.1903, 'fullPrice': {'type': 'PRICE', 'bids': [{'price':\n           1.19013, 'liquidity': '10000000'}], 'asks': [{'price': 1.1903,\n           'liquidity': '10000000'}], 'closeoutBid': 1.19013, 'closeoutAsk':\n           1.1903}, 'reason': 'MARKET_ORDER', 'pl': '0.0', 'financing': '0.0',\n           'commission': '0.0', 'guaranteedExecutionFee': '0.0',\n           'accountBalance': '98507.7425', 'tradeOpened': {'tradeID': '1735',\n           'units': '100000.0', 'price': 1.1903, 'guaranteedExecutionFee': '0.0',\n           'halfSpreadCost': '7.1416', 'initialMarginRequired': '3330.0'},\n           'halfSpreadCost': '7.1416'}\n\n          *** GOING SHORT ***\n\n          {'id': '1737', 'time': '2020-08-19T14:48:10.510726213Z', 'userID':\n           13834683, 'accountID': '101-004-13834683-001', 'batchID': '1736',\n           'requestID': '42730659332312267', 'type': 'ORDER_FILL', 'orderID':\n           '1736', 'instrument': 'EUR_USD', 'units': '-200000.0',\n           'gainQuoteHomeConversionFactor': '0.835885095595',\n           'lossQuoteHomeConversionFactor': '0.844285950827', 'price': 1.19029,\n           'fullVWAP': 1.19029, 'fullPrice': {'type': 'PRICE', 'bids': [{'price':\n           1.19029, 'liquidity': '10000000'}], 'asks': [{'price': 1.19042,\n           'liquidity': '10000000'}], 'closeoutBid': 1.19029, 'closeoutAsk':\n           1.19042}, 'reason': 'MARKET_ORDER', 'pl': '-0.8443', 'financing':\n           '0.0', 'commission': '0.0', 'guaranteedExecutionFee': '0.0',\n           'accountBalance': '98506.8982', 'tradeOpened': {'tradeID': '1737',\n           'units': '-100000.0', 'price': 1.19029, 'guaranteedExecutionFee':\n           '0.0', 'halfSpreadCost': '5.4606', 'initialMarginRequired': '3330.0'},\n           'tradesClosed': [{'tradeID': '1735', 'units': '-100000.0', 'price':\n           1.19029, 'realizedPL': '-0.8443', 'financing': '0.0',\n           'guaranteedExecutionFee': '0.0', 'halfSpreadCost': '5.4606'}],\n           'halfSpreadCost': '10.9212'}\n\n          *** GOING LONG ***\n\n          {'id': '1739', 'time': '2020-08-19T14:48:15.529680632Z', 'userID':\n           13834683, 'accountID': '101-004-13834683-001', 'batchID': '1738',\n           'requestID': '42730659353297789', 'type': 'ORDER_FILL', 'orderID':\n           '1738', 'instrument': 'EUR_USD', 'units': '200000.0',\n           'gainQuoteHomeConversionFactor': '0.835835944263',\n           'lossQuoteHomeConversionFactor': '0.844236305512', 'price': 1.1905,\n           'fullVWAP': 1.1905, 'fullPrice': {'type': 'PRICE', 'bids': [{'price':\n           1.19035, 'liquidity': '10000000'}], 'asks': [{'price': 1.1905,\n           'liquidity': '10000000'}], 'closeoutBid': 1.19035, 'closeoutAsk':\n           1.1905}, 'reason': 'MARKET_ORDER', 'pl': '-17.729', 'financing':\n           '0.0', 'commission': '0.0', 'guaranteedExecutionFee': '0.0',\n           'accountBalance': '98489.1692', 'tradeOpened': {'tradeID': '1739',\n           'units': '100000.0', 'price': 1.1905, 'guaranteedExecutionFee': '0.0',\n           'halfSpreadCost': '6.3003', 'initialMarginRequired': '3330.0'},\n           'tradesClosed': [{'tradeID': '1737', 'units': '100000.0', 'price':\n           1.1905, 'realizedPL': '-17.729', 'financing': '0.0',\n           'guaranteedExecutionFee': '0.0', 'halfSpreadCost': '6.3003'}],\n           'halfSpreadCost': '12.6006'}\n\n          *** CLOSING OUT ***\n\n          {'id': '1741', 'time': '2020-08-19T14:49:11.976885485Z', 'userID':\n           13834683, 'accountID': '101-004-13834683-001', 'batchID': '1740',\n           'requestID': '42730659588338204', 'type': 'ORDER_FILL', 'orderID':\n           '1740', 'instrument': 'EUR_USD', 'units': '-100000.0',\n           'gainQuoteHomeConversionFactor': '0.835730636848',\n           'lossQuoteHomeConversionFactor': '0.844129939731', 'price': 1.19051,\n           'fullVWAP': 1.19051, 'fullPrice': {'type': 'PRICE', 'bids': [{'price':\n           1.19051, 'liquidity': '10000000'}], 'asks': [{'price': 1.19064,\n           'liquidity': '10000000'}], 'closeoutBid': 1.19051, 'closeoutAsk':\n           1.19064}, 'reason': 'MARKET_ORDER', 'pl': '0.8357', 'financing':\n           '0.0', 'commission': '0.0', 'guaranteedExecutionFee': '0.0',\n           'accountBalance': '98490.0049', 'tradesClosed': [{'tradeID': '1739',\n           'units': '-100000.0', 'price': 1.19051, 'realizedPL': '0.8357',\n           'financing': '0.0', 'guaranteedExecutionFee': '0.0', 'halfSpreadCost':\n           '5.4595'}], 'halfSpreadCost': '5.4595'}\n```", "```py\n2020-06-15 17:04:14.298653\n================================================================================\nNUMBER OF TICKS: 147 | NUMBER OF BARS: 49\n\n================================================================================\nMOST RECENT DATA\n                     return_lag_1  return_lag_2  ...  max_lag_5  max_lag_6\n2020-06-15 15:04:06      0.026508     -0.125253  ...  -1.703276  -1.700746\n2020-06-15 15:04:08     -0.049373      0.026508  ...  -1.694419  -1.703276\n2020-06-15 15:04:10     -0.077828     -0.049373  ...  -1.694419  -1.694419\n2020-06-15 15:04:12      0.064448     -0.077828  ...  -1.705807  -1.694419\n2020-06-15 15:04:14     -0.020918      0.064448  ...  -1.710869  -1.705807\n\n[5 rows x 36 columns]\n\n================================================================================\nfeatures:\n[[-0.02091774  0.06444794 -0.07782834 -0.04937258  0.02650799 -0.12525265\n  -2.06428556 -1.96568848 -2.16288147 -2.08071843 -1.94925692 -2.19574189\n   0.92939697  0.92939697 -1.07368691  0.92939697 -1.07368691 -1.07368691\n  -1.41861822 -1.42605902 -1.4294412  -1.42470615 -1.4274119  -1.42470615\n  -1.05508516 -1.06879043 -1.06879043 -1.0619378  -1.06741991 -1.06741991\n  -1.70580717 -1.70707253 -1.71339931 -1.7108686  -1.7108686  -1.70580717]]\nposition: 1\nsignal:   1\n\n2020-06-15 17:04:14.402154\n================================================================================\n*** NO TRADE PLACED ***\n\n*** END OF CYCLE ***\n\n2020-06-15 17:04:16.199950\n================================================================================\n\n================================================================================\n*** GOING NEUTRAL ***\n\n{'id': '979', 'time': '2020-06-15T15:04:16.138027118Z', 'userID': 13834683,\n'accountID': '101-004-13834683-001', 'batchID': '978',\n'requestID': '60721506683906591', 'type': 'ORDER_FILL', 'orderID': '978',\n'instrument': 'EUR_USD', 'units': '-100000.0',\n'gainQuoteHomeConversionFactor': '0.882420762903',\n'lossQuoteHomeConversionFactor': '0.891289313284',\n'price': 1.12751, 'fullVWAP': 1.12751, 'fullPrice': {'type': 'PRICE',\n'bids': [{'price': 1.12751, 'liquidity': '10000000'}],\n'asks': [{'price': 1.12765, 'liquidity': '10000000'}],\n'closeoutBid': 1.12751, 'closeoutAsk': 1.12765}, 'reason': 'MARKET_ORDER',\n'pl': '-3.5652', 'financing': '0.0', 'commission': '0.0',\n'guaranteedExecutionFee': '0.0', 'accountBalance': '99259.7485',\n'tradesClosed': [{'tradeID': '975', 'units': '-100000.0',\n'price': 1.12751, 'realizedPL': '-3.5652', 'financing': '0.0',\n'guaranteedExecutionFee': '0.0', 'halfSpreadCost': '6.208'}],\n'halfSpreadCost': '6.208'}\n================================================================================\n```", "```py\n#\n# Automated ML-Based Trading Strategy for Oanda\n# Online Algorithm, Logging, Monitoring\n#\n# Python for Algorithmic Trading\n# (c) Dr. Yves J. Hilpisch\n#\nimport zmq\nimport tpqoa\nimport pickle\nimport numpy as np\nimport pandas as pd\nimport datetime as dt\n\nlog_file = 'automated_strategy.log'\n\n# loads the persisted algorithm object\nalgorithm = pickle.load(open('algorithm.pkl', 'rb'))\n\n# sets up the socket communication via ZeroMQ (here: \"publisher\")\ncontext = zmq.Context()\nsocket = context.socket(zmq.PUB)\n\n# this binds the socket communication to all IP addresses of the machine\nsocket.bind('tcp://0.0.0.0:5555')\n\n# recreating the log file\nwith open(log_file, 'w') as f:\n    f.write('*** NEW LOG FILE ***\\n')\n    f.write(str(dt.datetime.now()) + '\\n\\n\\n')\n\ndef logger_monitor(message, time=True, sep=True):\n    ''' Custom logger and monitor function.\n '''\n    with open(log_file, 'a') as f:\n        t = str(dt.datetime.now())\n        msg = ''\n        if time:\n            msg += '\\n' + t + '\\n'\n        if sep:\n            msg += 80 * '=' + '\\n'\n        msg += message + '\\n\\n'\n        # sends the message via the socket\n        socket.send_string(msg)\n        # writes the message to the log file\n        f.write(msg)\n\nclass MLTrader(tpqoa.tpqoa):\n    def __init__(self, config_file, algorithm):\n        super(MLTrader, self).__init__(config_file)\n        self.model = algorithm['model']\n        self.mu = algorithm['mu']\n        self.std = algorithm['std']\n        self.units = 100000\n        self.position = 0\n        self.bar = '2s'\n        self.window = 2\n        self.lags = 6\n        self.min_length = self.lags + self.window + 1\n        self.features = ['return', 'vol', 'mom', 'sma', 'min', 'max']\n        self.raw_data = pd.DataFrame()\n\n    def prepare_features(self):\n        self.data['return'] = np.log(\n            self.data['mid'] / self.data['mid'].shift(1))\n        self.data['vol'] = self.data['return'].rolling(self.window).std()\n        self.data['mom'] = np.sign(\n            self.data['return'].rolling(self.window).mean())\n        self.data['sma'] = self.data['mid'].rolling(self.window).mean()\n        self.data['min'] = self.data['mid'].rolling(self.window).min()\n        self.data['max'] = self.data['mid'].rolling(self.window).max()\n        self.data.dropna(inplace=True)\n        self.data[self.features] -= self.mu\n        self.data[self.features] /= self.std\n        self.cols = []\n        for f in self.features:\n            for lag in range(1, self.lags + 1):\n                col = f'{f}_lag_{lag}'\n                self.data[col] = self.data[f].shift(lag)\n                self.cols.append(col)\n\n    def report_trade(self, pos, order):\n        ''' Prints, logs, and sends trade data.\n '''\n        out = '\\n\\n' + 80 * '=' + '\\n'\n        out += '*** GOING {} *** \\n'.format(pos) + '\\n'\n        out += str(order) + '\\n'\n        out += 80 * '=' + '\\n'\n        logger_monitor(out)\n        print(out)\n\n    def on_success(self, time, bid, ask):\n        print(self.ticks, 20 * ' ', end='\\r')\n        df = pd.DataFrame({'bid': float(bid), 'ask': float(ask)},\n                          index=[pd.Timestamp(time).tz_localize(None)])\n        self.raw_data = self.raw_data.append(df)\n        self.data = self.raw_data.resample(\n            self.bar, label='right').last().ffill()\n        self.data = self.data.iloc[:-1]\n        if len(self.data) > self.min_length:\n            logger_monitor('NUMBER OF TICKS: {} | '.format(self.ticks) +\n                           'NUMBER OF BARS: {}'.format(self.min_length))\n            self.min_length += 1\n            self.data['mid'] = (self.data['bid'] + self.data['ask']) / 2\n            self.prepare_features()\n            features = self.data[self.cols].iloc[-1].values.reshape(1, -1)\n            signal = self.model.predict(features)[0]\n            # logs and sends major financial information\n            logger_monitor('MOST RECENT DATA\\n' +\n                           str(self.data[self.cols].tail()),\n                           False)\n            logger_monitor('features:\\n' + str(features) + '\\n' +\n                           'position: ' + str(self.position) + '\\n' +\n                           'signal:   ' + str(signal), False)\n            if self.position in [0, -1] and signal == 1:  # going long?\n                order = self.create_order(self.stream_instrument,\n                                          units=(1 - self.position) *\n                                          self.units,\n                                          suppress=True, ret=True)\n                self.report_trade('LONG', order)\n                self.position = 1\n            elif self.position in [0, 1] and signal == -1:  # going short?\n                order = self.create_order(self.stream_instrument,\n                                          units=-(1 + self.position) *\n                                          self.units,\n                                          suppress=True, ret=True)\n                self.report_trade('SHORT', order)\n                self.position = -1\n            else:  # no trade\n                logger_monitor('*** NO TRADE PLACED ***')\n\n            logger_monitor('*** END OF CYCLE ***\\n\\n', False, False)\n\nif __name__ == '__main__':\n    mlt = MLTrader('../pyalgo.cfg', algorithm)\n    mlt.stream_data('EUR_USD', stop=150)\n    order = mlt.create_order(mlt.stream_instrument,\n                             units=-mlt.position * mlt.units,\n                             suppress=True, ret=True)\n    mlt.position = 0\n    mlt.report_trade('NEUTRAL', order)\n```", "```py\n#\n# Automated ML-Based Trading Strategy for Oanda\n# Strategy Monitoring via Socket Communication\n#\n# Python for Algorithmic Trading\n# (c) Dr. Yves J. Hilpisch\n#\nimport zmq\n\n# sets up the socket communication via ZeroMQ (here: \"subscriber\")\ncontext = zmq.Context()\nsocket = context.socket(zmq.SUB)\n\n# adjust the IP address to reflect the remote location\nsocket.connect('tcp://134.122.70.51:5555')\n\n# local IP address used for testing\n# socket.connect('tcp://0.0.0.0:5555')\n\n# configures the socket to retrieve every message\nsocket.setsockopt_string(zmq.SUBSCRIBE, '')\n\nwhile True:\n    msg = socket.recv_string()\n    print(msg)\n```"]