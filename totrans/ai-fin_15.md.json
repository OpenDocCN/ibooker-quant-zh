["```py\nIn [1]: import os\n        import numpy as np\n        import pandas as pd\n        from pylab import plt, mpl\n        plt.style.use('seaborn')\n        mpl.rcParams['savefig.dpi'] = 300\n        mpl.rcParams['font.family'] = 'serif'\n        pd.set_option('mode.chained_assignment', None)\n        pd.set_option('display.float_format', '{:.4f}'.format)\n        np.set_printoptions(suppress=True, precision=4)\n        os.environ['PYTHONHASHSEED'] = '0'\n```", "```py\nIn [2]: import finance\n        import tradingbot\n        Using TensorFlow backend.\n\nIn [3]: symbol = 'EUR='\n        features = [symbol, 'r', 's', 'm', 'v']\n\nIn [4]: a = 0\n        b = 1750\n        c = 250\n\nIn [5]: learn_env = finance.Finance(symbol, features, window=20, lags=3,\n                         leverage=1, min_performance=0.9, min_accuracy=0.475,\n                         start=a, end=a + b, mu=None, std=None)\n\nIn [6]: learn_env.data.info()\n        <class 'pandas.core.frame.DataFrame'>\n        DatetimeIndex: 1750 entries, 2010-02-02 to 2017-01-12\n        Data columns (total 6 columns):\n         #   Column  Non-Null Count  Dtype\n        ---  ------  --------------  -----\n         0   EUR=    1750 non-null   float64\n         1   r       1750 non-null   float64\n         2   s       1750 non-null   float64\n         3   m       1750 non-null   float64\n         4   v       1750 non-null   float64\n         5   d       1750 non-null   int64\n        dtypes: float64(5), int64(1)\n        memory usage: 95.7 KB\n\nIn [7]: valid_env = finance.Finance(symbol, features=learn_env.features,\n                                    window=learn_env.window,\n                                    lags=learn_env.lags,\n                                    leverage=learn_env.leverage,\n                                    min_performance=0.0, min_accuracy=0.0,\n                                    start=a + b, end=a + b + c,\n                                    mu=learn_env.mu, std=learn_env.std)\n\nIn [8]: valid_env.data.info()\n        <class 'pandas.core.frame.DataFrame'>\n        DatetimeIndex: 250 entries, 2017-01-13 to 2018-01-10\n        Data columns (total 6 columns):\n         #   Column  Non-Null Count  Dtype\n        ---  ------  --------------  -----\n         0   EUR=    250 non-null    float64\n         1   r       250 non-null    float64\n         2   s       250 non-null    float64\n         3   m       250 non-null    float64\n         4   v       250 non-null    float64\n         5   d       250 non-null    int64\n        dtypes: float64(5), int64(1)\n        memory usage: 13.7 KB\n\nIn [9]: tradingbot.set_seeds(100)\n        agent = tradingbot.TradingBot(24, 0.001, learn_env, valid_env)\n\nIn [10]: episodes = 61\n\nIn [11]: %time agent.learn(episodes)\n         =======================================================================\n         episode: 10/61 | VALIDATION | treward:  247 | perf: 0.936 | eps: 0.95\n         =======================================================================\n         =======================================================================\n         episode: 20/61 | VALIDATION | treward:  247 | perf: 0.897 | eps: 0.86\n         =======================================================================\n         =======================================================================\n         episode: 30/61 | VALIDATION | treward:  247 | perf: 1.035 | eps: 0.78\n         =======================================================================\n         =======================================================================\n         episode: 40/61 | VALIDATION | treward:  247 | perf: 0.935 | eps: 0.70\n         =======================================================================\n         =======================================================================\n         episode: 50/61 | VALIDATION | treward:  247 | perf: 0.890 | eps: 0.64\n         =======================================================================\n         =======================================================================\n         episode: 60/61 | VALIDATION | treward:  247 | perf: 0.998 | eps: 0.58\n         =======================================================================\n         episode: 61/61 | treward:   17 | perf: 0.979 | av: 475.1 | max: 1747\n         CPU times: user 51.4 s, sys: 2.53 s, total: 53.9 s\n         Wall time: 47 s\n\nIn [12]: tradingbot.plot_treward(agent)\n```", "```py\nIn [13]: tradingbot.plot_performance(agent)\n```", "```py\nIn [14]: def reshape(s):\n             return np.reshape(s, [1, learn_env.lags,\n                                   learn_env.n_features])  ![1](Images/1.png)\n\nIn [15]: def backtest(agent, env):\n             env.min_accuracy = 0.0\n             env.min_performance = 0.0\n             done = False\n             env.data['p'] = 0  ![2](Images/2.png)\n             state = env.reset()\n             while not done:\n                 action = np.argmax(\n                     agent.model.predict(reshape(state))[0, 0])  ![3](Images/3.png)\n                 position = 1 if action == 1 else -1  ![4](Images/4.png)\n                 env.data.loc[:, 'p'].iloc[env.bar] = position  ![5](Images/5.png)\n                 state, reward, done, info = env.step(action)\n             env.data['s'] = env.data['p'] * env.data['r'] * learn_env.leverage  ![6](Images/6.png)\n```", "```py\nIn [16]: env = agent.learn_env  ![1](Images/1.png)\n\nIn [17]: backtest(agent, env)  ![2](Images/2.png)\n\nIn [18]: env.data['p'].iloc[env.lags:].value_counts()  ![3](Images/3.png)\nOut[18]:  1    961\n         -1    786\n         Name: p, dtype: int64\n\nIn [19]: env.data[['r', 's']].iloc[env.lags:].sum().apply(np.exp)  ![4](Images/4.png)\nOut[19]: r   0.7725\n         s   1.5155\n         dtype: float64\n\nIn [20]: env.data[['r', 's']].iloc[env.lags:].sum().apply(np.exp) - 1  ![5](Images/5.png)\nOut[20]: r   -0.2275\n         s    0.5155\n         dtype: float64\n\nIn [21]: env.data[['r', 's']].iloc[env.lags:].cumsum(\n                 ).apply(np.exp).plot(figsize=(10, 6));\n```", "```py\nIn [22]: test_env = finance.Finance(symbol, features=learn_env.features,\n                                    window=learn_env.window,\n                                    lags=learn_env.lags,\n                                    leverage=learn_env.leverage,\n                                    min_performance=0.0, min_accuracy=0.0,\n                                    start=a + b + c, end=None,\n                                    mu=learn_env.mu, std=learn_env.std)\n\nIn [23]: env = test_env\n\nIn [24]: backtest(agent, env)\n\nIn [25]: env.data['p'].iloc[env.lags:].value_counts()\nOut[25]: -1    437\n          1     56\n         Name: p, dtype: int64\n\nIn [26]: env.data[['r', 's']].iloc[env.lags:].sum().apply(np.exp)\nOut[26]: r   0.9144\n         s   1.0992\n         dtype: float64\n\nIn [27]: env.data[['r', 's']].iloc[env.lags:].sum().apply(np.exp) - 1\nOut[27]: r   -0.0856\n         s    0.0992\n         dtype: float64\n\nIn [28]: env.data[['r', 's']].iloc[env.lags:].cumsum(\n                     ).apply(np.exp).plot(figsize=(10, 6));\n```", "```py\nIn [29]: import backtesting as bt\n\nIn [30]: bb = bt.BacktestingBase(env=agent.learn_env, model=agent.model,\n                                 amount=10000, ptc=0.0001, ftc=1.0,\n                                 verbose=True)  ![1](Images/1.png)\n\nIn [31]: bb.initial_amount  ![2](Images/2.png)\nOut[31]: 10000\n\nIn [32]: bar = 100  ![3](Images/3.png)\n\nIn [33]: bb.get_date_price(bar)  ![4](Images/4.png)\nOut[33]: ('2010-06-25', 1.2374)\n\nIn [34]: bb.env.get_state(bar)  ![5](Images/5.png)\nOut[34]:               EUR=       r       s       m      v\n         Date\n         2010-06-22 -0.0242 -0.5622 -0.0916 -0.2022 1.5316\n         2010-06-23  0.0176  0.6940 -0.0939 -0.0915 1.5563\n         2010-06-24  0.0354  0.3034 -0.0865  0.6391 1.0890\n\nIn [35]: bb.place_buy_order(bar, amount=5000)  ![6](Images/6.png)\n         2010-06-25 | buy 4040 units for 1.2374\n         2010-06-25 | current balance = 4999.40\n\nIn [36]: bb.print_net_wealth(2 * bar)  ![7](Images/7.png)\n         2010-11-16 | net wealth = 10450.17\n\nIn [37]: bb.place_sell_order(2 * bar, units=1000)  ![8](Images/8.png)\n         2010-11-16 | sell 1000 units for 1.3492\n         2010-11-16 | current balance = 6347.47\n\nIn [38]: bb.close_out(3 * bar)  ![9](Images/9.png)\n         ==================================================\n         2011-04-11 | *** CLOSING OUT ***\n         2011-04-11 | sell 3040 units for 1.4434\n         2011-04-11 | current balance = 10733.97\n         2011-04-11 | net performance [%] = 7.3397\n         2011-04-11 | number of trades [#] = 3\n         ==================================================\n```", "```py\nIn [39]: class TBBacktester(bt.BacktestingBase):\n             def _reshape(self, state):\n                 ''' Helper method to reshape state objects.\n                 '''\n                 return np.reshape(state, [1, self.env.lags, self.env.n_features])\n             def backtest_strategy(self):\n                 ''' Event-based backtesting of the trading bot's performance.\n                 '''\n                 self.units = 0\n                 self.position = 0\n                 self.trades = 0\n                 self.current_balance = self.initial_amount\n                 self.net_wealths = list()\n                 for bar in range(self.env.lags, len(self.env.data)):\n                     date, price = self.get_date_price(bar)\n                     if self.trades == 0:\n                         print(50 * '=')\n                         print(f'{date} | *** START BACKTEST ***')\n                         self.print_balance(bar)\n                         print(50 * '=')\n                     state = self.env.get_state(bar)  ![1](Images/1.png)\n                     action = np.argmax(self.model.predict(\n                                 self._reshape(state.values))[0, 0])  ![2](Images/2.png)\n                     position = 1 if action == 1 else -1  ![3](Images/3.png)\n                     if self.position in [0, -1] and position == 1:  ![4](Images/4.png)\n                         if self.verbose:\n                             print(50 * '-')\n                             print(f'{date} | *** GOING LONG ***')\n                         if self.position == -1:\n                             self.place_buy_order(bar - 1, units=-self.units)\n                         self.place_buy_order(bar - 1,\n                                              amount=self.current_balance)\n                         if self.verbose:\n                             self.print_net_wealth(bar)\n                         self.position = 1\n                     elif self.position in [0, 1] and position == -1:  ![5](Images/5.png)\n                         if self.verbose:\n                             print(50 * '-')\n                             print(f'{date} | *** GOING SHORT ***')\n                         if self.position == 1:\n                             self.place_sell_order(bar - 1, units=self.units)\n                         self.place_sell_order(bar - 1,\n                                               amount=self.current_balance)\n                         if self.verbose:\n                             self.print_net_wealth(bar)\n                         self.position = -1\n                     self.net_wealths.append((date,\n                                              self.calculate_net_wealth(price)))  ![6](Images/6.png)\n                 self.net_wealths = pd.DataFrame(self.net_wealths,\n                                                 columns=['date', 'net_wealth'])  ![6](Images/6.png)\n                 self.net_wealths.set_index('date', inplace=True)  ![6](Images/6.png)\n                 self.net_wealths.index = pd.DatetimeIndex(\n                                                 self.net_wealths.index)  ![6](Images/6.png)\n                 self.close_out(bar)\n```", "```py\nIn [40]: env = learn_env\n\nIn [41]: tb = TBBacktester(env, agent.model, 10000,\n                           0.0, 0, verbose=False)  ![1](Images/1.png)\n\nIn [42]: tb.backtest_strategy()  ![1](Images/1.png)\n         ==================================================\n         2010-02-05 | *** START BACKTEST ***\n         2010-02-05 | current balance = 10000.00\n         ==================================================\n         ==================================================\n         2017-01-12 | *** CLOSING OUT ***\n         2017-01-12 | current balance = 14601.85\n         2017-01-12 | net performance [%] = 46.0185\n         2017-01-12 | number of trades [#] = 828\n         ==================================================\n\nIn [43]: tb_ = TBBacktester(env, agent.model, 10000,\n                            0.00012, 0.0, verbose=False)\n\nIn [44]: tb_.backtest_strategy()  ![2](Images/2.png)\n         ==================================================\n         2010-02-05 | *** START BACKTEST ***\n         2010-02-05 | current balance = 10000.00\n         ==================================================\n         ==================================================\n         2017-01-12 | *** CLOSING OUT ***\n         2017-01-12 | current balance = 13222.08\n         2017-01-12 | net performance [%] = 32.2208\n         2017-01-12 | number of trades [#] = 828\n         ==================================================\n\nIn [45]: ax = tb.net_wealths.plot(figsize=(10, 6))\n         tb_.net_wealths.columns = ['net_wealth (after tc)']\n         tb_.net_wealths.plot(ax=ax);\n```", "```py\nIn [46]: env = test_env\n\nIn [47]: tb = TBBacktester(env, agent.model, 10000,\n                           0.0, 0, verbose=False)  ![1](Images/1.png)\n\nIn [48]: tb.backtest_strategy()  ![1](Images/1.png)\n         ==================================================\n         2018-01-17 | *** START BACKTEST ***\n         2018-01-17 | current balance = 10000.00\n         ==================================================\n         ==================================================\n         2019-12-31 | *** CLOSING OUT ***\n         2019-12-31 | current balance = 10936.79\n         2019-12-31 | net performance [%] = 9.3679\n         2019-12-31 | number of trades [#] = 186\n         ==================================================\n\nIn [49]: tb_ = TBBacktester(env, agent.model, 10000,\n                            0.00012, 0.0, verbose=False)\n\nIn [50]: tb_.backtest_strategy()  ![2](Images/2.png)\n         ==================================================\n         2018-01-17 | *** START BACKTEST ***\n         2018-01-17 | current balance = 10000.00\n         ==================================================\n         ==================================================\n         2019-12-31 | *** CLOSING OUT ***\n         2019-12-31 | current balance = 10695.72\n         2019-12-31 | net performance [%] = 6.9572\n         2019-12-31 | number of trades [#] = 186\n         ==================================================\n\nIn [51]: ax = tb.net_wealths.plot(figsize=(10, 6))\n         tb_.net_wealths.columns = ['net_wealth (after tc)']\n         tb_.net_wealths.plot(ax=ax);\n```", "```py\nIn [52]: ax = (tb.net_wealths / tb.net_wealths.iloc[0]).plot(figsize=(10, 6))\n         tp = env.data[['r', 's']].iloc[env.lags:].cumsum().apply(np.exp)\n         (tp / tp.iloc[0]).plot(ax=ax);\n```", "```py\nIn [53]: data = pd.DataFrame(learn_env.data[symbol])  ![1](Images/1.png)\n\nIn [54]: data.head()  ![1](Images/1.png)\nOut[54]:              EUR=\n         Date\n         2010-02-02 1.3961\n         2010-02-03 1.3898\n         2010-02-04 1.3734\n         2010-02-05 1.3662\n         2010-02-08 1.3652\n\nIn [55]: window = 14  ![2](Images/2.png)\n\nIn [56]: data['min'] = data[symbol].rolling(window).min()  ![3](Images/3.png)\n\nIn [57]: data['max'] = data[symbol].rolling(window).max()  ![4](Images/4.png)\n\nIn [58]: data['mami'] = data['max'] - data['min']  ![5](Images/5.png)\n\nIn [59]: data['mac'] = abs(data['max'] - data[symbol].shift(1))  ![6](Images/6.png)\n\nIn [60]: data['mic'] = abs(data['min'] - data[symbol].shift(1))  ![7](Images/7.png)\n\nIn [61]: data['atr'] = np.maximum(data['mami'], data['mac'])  ![8](Images/8.png)\n\nIn [62]: data['atr'] = np.maximum(data['atr'], data['mic'])  ![9](Images/9.png)\n\nIn [63]: data['atr%'] = data['atr'] / data[symbol]  ![10](Images/10.png)\n\nIn [64]: data[['atr', 'atr%']].plot(subplots=True, figsize=(10, 6));\n```", "```py\nIn [65]: data[['atr', 'atr%']].tail()\nOut[65]:               atr   atr%\n         Date\n         2017-01-06 0.0218 0.0207\n         2017-01-09 0.0218 0.0206\n         2017-01-10 0.0218 0.0207\n         2017-01-11 0.0199 0.0188\n         2017-01-12 0.0206 0.0194\n```", "```py\nIn [66]: leverage = 10\n\nIn [67]: data[['atr', 'atr%']].tail() * leverage\nOut[67]:               atr   atr%\n         Date\n         2017-01-06 0.2180 0.2070\n         2017-01-09 0.2180 0.2062\n         2017-01-10 0.2180 0.2066\n         2017-01-11 0.1990 0.1881\n         2017-01-12 0.2060 0.1942\n\nIn [68]: data[['atr', 'atr%']].median() * leverage\nOut[68]: atr    0.3180\n         atr%   0.2481\n         dtype: float64\n```", "```py\n#\n# Event-Based Backtesting\n# --Base Class (2)\n#\n# (c) Dr. Yves J. Hilpisch\n#\nfrom backtesting import *\n\nclass BacktestingBaseRM(BacktestingBase):\n\n    def set_prices(self, price):\n        ''' Sets prices for tracking of performance.\n            To test for e.g. trailing stop loss hit.\n        '''\n        self.entry_price = price  ![1](Images/1.png)\n        self.min_price = price  ![2](Images/2.png)\n        self.max_price = price  ![3](Images/3.png)\n\n    def place_buy_order(self, bar, amount=None, units=None, gprice=None):\n        ''' Places a buy order for a given bar and for\n            a given amount or number of units.\n        '''\n        date, price = self.get_date_price(bar)\n        if gprice is not None:\n            price = gprice\n        if units is None:\n            units = int(amount / price)\n        self.current_balance -= (1 + self.ptc) * units * price + self.ftc\n        self.units += units\n        self.trades += 1\n        self.set_prices(price)  ![4](Images/4.png)\n        if self.verbose:\n            print(f'{date} | buy {units} units for {price:.4f}')\n            self.print_balance(bar)\n\n    def place_sell_order(self, bar, amount=None, units=None, gprice=None):\n        ''' Places a sell order for a given bar and for\n            a given amount or number of units.\n        '''\n        date, price = self.get_date_price(bar)\n        if gprice is not None:\n            price = gprice\n        if units is None:\n            units = int(amount / price)\n        self.current_balance += (1 - self.ptc) * units * price - self.ftc\n        self.units -= units\n        self.trades += 1\n        self.set_prices(price)  ![4](Images/4.png)\n        if self.verbose:\n            print(f'{date} | sell {units} units for {price:.4f}')\n            self.print_balance(bar)\n```", "```py\n# stop loss order\nif sl is not None and self.position != 0:  ![1](Images/1.png)\n    rc = (price - self.entry_price) / self.entry_price  ![2](Images/2.png)\n    if self.position == 1 and rc < -self.sl:  ![3](Images/3.png)\n        print(50 * '-')\n        if guarantee:\n            price = self.entry_price * (1 - self.sl)\n            print(f'*** STOP LOSS (LONG  | {-self.sl:.4f}) ***')\n        else:\n            print(f'*** STOP LOSS (LONG  | {rc:.4f}) ***')\n        self.place_sell_order(bar, units=self.units, gprice=price)  ![4](Images/4.png)\n        self.wait = wait  ![5](Images/5.png)\n        self.position = 0   ![6](Images/6.png)\n    elif self.position == -1 and rc > self.sl:  ![7](Images/7.png)\n        print(50 * '-')\n        if guarantee:\n            price = self.entry_price * (1 + self.sl)\n            print(f'*** STOP LOSS (SHORT | -{self.sl:.4f}) ***')\n        else:\n            print(f'*** STOP LOSS (SHORT | -{rc:.4f}) ***')\n        self.place_buy_order(bar, units=-self.units, gprice=price)  ![8](Images/8.png)\n        self.wait = wait  ![5](Images/5.png)\n        self.position = 0  ![6](Images/6.png)\n```", "```py\nIn [69]: import tbbacktesterrm as tbbrm\n\nIn [70]: env = test_env\n\nIn [71]: tb = tbbrm.TBBacktesterRM(env, agent.model, 10000,\n                                   0.0, 0, verbose=False)  ![1](Images/1.png)\n\nIn [72]: tb.backtest_strategy(sl=None, tsl=None, tp=None, wait=5)  ![2](Images/2.png)\n         ==================================================\n         2018-01-17 | *** START BACKTEST ***\n         2018-01-17 | current balance = 10000.00\n         ==================================================\n         ==================================================\n         2019-12-31 | *** CLOSING OUT ***\n         2019-12-31 | current balance = 10936.79\n         2019-12-31 | net performance [%] = 9.3679\n         2019-12-31 | number of trades [#] = 186\n         ==================================================\n\nIn [73]: tb.backtest_strategy(sl=0.0175, tsl=None, tp=None,\n                              wait=5, guarantee=False)  ![3](Images/3.png)\n         ==================================================\n         2018-01-17 | *** START BACKTEST ***\n         2018-01-17 | current balance = 10000.00\n         ==================================================\n         --------------------------------------------------\n         *** STOP LOSS (SHORT | -0.0203) ***\n         ==================================================\n         2019-12-31 | *** CLOSING OUT ***\n         2019-12-31 | current balance = 10717.32\n         2019-12-31 | net performance [%] = 7.1732\n         2019-12-31 | number of trades [#] = 188\n         ==================================================\n\nIn [74]: tb.backtest_strategy(sl=0.017, tsl=None, tp=None,\n                              wait=5, guarantee=True)  ![4](Images/4.png)\n         ==================================================\n         2018-01-17 | *** START BACKTEST ***\n         2018-01-17 | current balance = 10000.00\n         ==================================================\n         --------------------------------------------------\n         *** STOP LOSS (SHORT | -0.0170) ***\n         ==================================================\n         2019-12-31 | *** CLOSING OUT ***\n         2019-12-31 | current balance = 10753.52\n         2019-12-31 | net performance [%] = 7.5352\n         2019-12-31 | number of trades [#] = 188\n         ==================================================\n```", "```py\n# trailing stop loss order\nif tsl is not None and self.position != 0:\n    self.max_price = max(self.max_price, price)  ![1](Images/1.png)\n    self.min_price = min(self.min_price, price)  ![2](Images/2.png)\n    rc_1 = (price - self.max_price) / self.entry_price  ![3](Images/3.png)\n    rc_2 = (self.min_price - price) / self.entry_price  ![4](Images/4.png)\n    if self.position == 1 and rc_1 < -self.tsl:  ![5](Images/5.png)\n        print(50 * '-')\n        print(f'*** TRAILING SL (LONG  | {rc_1:.4f}) ***')\n        self.place_sell_order(bar, units=self.units)\n        self.wait = wait\n        self.position = 0\n    elif self.position == -1 and rc_2 < -self.tsl:  ![6](Images/6.png)\n        print(50 * '-')\n        print(f'*** TRAILING SL (SHORT | {rc_2:.4f}) ***')\n        self.place_buy_order(bar, units=-self.units)\n        self.wait = wait\n        self.position = 0\n```", "```py\nIn [75]: tb.backtest_strategy(sl=None, tsl=0.015,\n                              tp=None, wait=5)  ![1](Images/1.png)\n         ==================================================\n         2018-01-17 | *** START BACKTEST ***\n         2018-01-17 | current balance = 10000.00\n         ==================================================\n         --------------------------------------------------\n         *** TRAILING SL (SHORT | -0.0152) ***\n         --------------------------------------------------\n         *** TRAILING SL (SHORT | -0.0169) ***\n         --------------------------------------------------\n         *** TRAILING SL (SHORT | -0.0164) ***\n         --------------------------------------------------\n         *** TRAILING SL (SHORT | -0.0191) ***\n         --------------------------------------------------\n         *** TRAILING SL (SHORT | -0.0166) ***\n         --------------------------------------------------\n         *** TRAILING SL (SHORT | -0.0194) ***\n         --------------------------------------------------\n         *** TRAILING SL (SHORT | -0.0172) ***\n         --------------------------------------------------\n         *** TRAILING SL (SHORT | -0.0181) ***\n         --------------------------------------------------\n         *** TRAILING SL (SHORT | -0.0153) ***\n         --------------------------------------------------\n         *** TRAILING SL (SHORT | -0.0160) ***\n         ==================================================\n         2019-12-31 | *** CLOSING OUT ***\n         2019-12-31 | current balance = 10577.93\n         2019-12-31 | net performance [%] = 5.7793\n         2019-12-31 | number of trades [#] = 201\n         ==================================================\n```", "```py\n# take profit order\nif tp is not None and self.position != 0:\n    rc = (price - self.entry_price) / self.entry_price\n    if self.position == 1 and rc > self.tp:\n        print(50 * '-')\n        if guarantee:\n            price = self.entry_price * (1 + self.tp)\n            print(f'*** TAKE PROFIT (LONG  | {self.tp:.4f}) ***')\n        else:\n            print(f'*** TAKE PROFIT (LONG  | {rc:.4f}) ***')\n        self.place_sell_order(bar, units=self.units, gprice=price)\n        self.wait = wait\n        self.position = 0\n    elif self.position == -1 and rc < -self.tp:\n        print(50 * '-')\n        if guarantee:\n            price = self.entry_price * (1 - self.tp)\n            print(f'*** TAKE PROFIT (SHORT | {self.tp:.4f}) ***')\n        else:\n            print(f'*** TAKE PROFIT (SHORT | {-rc:.4f}) ***')\n        self.place_buy_order(bar, units=-self.units, gprice=price)\n        self.wait = wait\n        self.position = 0\n```", "```py\nIn [76]: tb.backtest_strategy(sl=None, tsl=None, tp=0.015,\n                              wait=5, guarantee=False)  ![1](Images/1.png)\n         ==================================================\n         2018-01-17 | *** START BACKTEST ***\n         2018-01-17 | current balance = 10000.00\n         ==================================================\n         --------------------------------------------------\n         *** TAKE PROFIT (SHORT | 0.0155) ***\n         --------------------------------------------------\n         *** TAKE PROFIT (SHORT | 0.0155) ***\n         --------------------------------------------------\n         *** TAKE PROFIT (SHORT | 0.0204) ***\n         --------------------------------------------------\n         *** TAKE PROFIT (SHORT | 0.0240) ***\n         --------------------------------------------------\n         *** TAKE PROFIT (SHORT | 0.0168) ***\n         --------------------------------------------------\n         *** TAKE PROFIT (SHORT | 0.0156) ***\n         --------------------------------------------------\n         *** TAKE PROFIT (SHORT | 0.0183) ***\n         ==================================================\n         2019-12-31 | *** CLOSING OUT ***\n         2019-12-31 | current balance = 11210.33\n         2019-12-31 | net performance [%] = 12.1033\n         2019-12-31 | number of trades [#] = 198\n         ==================================================\n\nIn [77]: tb.backtest_strategy(sl=None, tsl=None, tp=0.015,\n                              wait=5, guarantee=True)  ![2](Images/2.png)\n         ==================================================\n         2018-01-17 | *** START BACKTEST ***\n         2018-01-17 | current balance = 10000.00\n         ==================================================\n         --------------------------------------------------\n         *** TAKE PROFIT (SHORT | 0.0150) ***\n         --------------------------------------------------\n         *** TAKE PROFIT (SHORT | 0.0150) ***\n         --------------------------------------------------\n         *** TAKE PROFIT (SHORT | 0.0150) ***\n         --------------------------------------------------\n         *** TAKE PROFIT (SHORT | 0.0150) ***\n         --------------------------------------------------\n         *** TAKE PROFIT (SHORT | 0.0150) ***\n         --------------------------------------------------\n         *** TAKE PROFIT (SHORT | 0.0150) ***\n         --------------------------------------------------\n         *** TAKE PROFIT (SHORT | 0.0150) ***\n         ==================================================\n         2019-12-31 | *** CLOSING OUT ***\n         2019-12-31 | current balance = 10980.86\n         2019-12-31 | net performance [%] = 9.8086\n         2019-12-31 | number of trades [#] = 198\n         ==================================================\n```", "```py\nIn [78]: tb.backtest_strategy(sl=0.015, tsl=None,\n                              tp=0.0185, wait=5)  ![1](Images/1.png)\n         ==================================================\n         2018-01-17 | *** START BACKTEST ***\n         2018-01-17 | current balance = 10000.00\n         ==================================================\n         --------------------------------------------------\n         *** STOP LOSS (SHORT | -0.0203) ***\n         --------------------------------------------------\n         *** TAKE PROFIT (SHORT | 0.0202) ***\n         --------------------------------------------------\n         *** TAKE PROFIT (SHORT | 0.0213) ***\n         --------------------------------------------------\n         *** TAKE PROFIT (SHORT | 0.0240) ***\n         --------------------------------------------------\n         *** STOP LOSS (SHORT | -0.0171) ***\n         --------------------------------------------------\n         *** TAKE PROFIT (SHORT | 0.0188) ***\n         --------------------------------------------------\n         *** STOP LOSS (SHORT | -0.0153) ***\n         --------------------------------------------------\n         *** STOP LOSS (SHORT | -0.0154) ***\n         ==================================================\n         2019-12-31 | *** CLOSING OUT ***\n         2019-12-31 | current balance = 10552.00\n         2019-12-31 | net performance [%] = 5.5200\n         2019-12-31 | number of trades [#] = 201\n         ==================================================\n\nIn [79]: tb.backtest_strategy(sl=None, tsl=0.02,\n                              tp=0.02, wait=5)  ![2](Images/2.png)\n         ==================================================\n         2018-01-17 | *** START BACKTEST ***\n         2018-01-17 | current balance = 10000.00\n         ==================================================\n         --------------------------------------------------\n         *** TRAILING SL (SHORT | -0.0235) ***\n         --------------------------------------------------\n         *** TRAILING SL (SHORT | -0.0202) ***\n         --------------------------------------------------\n         *** TAKE PROFIT (SHORT | 0.0250) ***\n         --------------------------------------------------\n         *** TAKE PROFIT (SHORT | 0.0227) ***\n         --------------------------------------------------\n         *** TAKE PROFIT (SHORT | 0.0240) ***\n         --------------------------------------------------\n         *** TRAILING SL (SHORT | -0.0216) ***\n         --------------------------------------------------\n         *** TAKE PROFIT (SHORT | 0.0241) ***\n         --------------------------------------------------\n         *** TRAILING SL (SHORT | -0.0206) ***\n         ==================================================\n         2019-12-31 | *** CLOSING OUT ***\n         2019-12-31 | current balance = 10346.38\n         2019-12-31 | net performance [%] = 3.4638\n         2019-12-31 | number of trades [#] = 198\n         ==================================================\n```", "```py\n#\n# Finance Environment\n#\n# (c) Dr. Yves J. Hilpisch\n# Artificial Intelligence in Finance\n#\nimport math\nimport random\nimport numpy as np\nimport pandas as pd\n\nclass observation_space:\n    def __init__(self, n):\n        self.shape = (n,)\n\nclass action_space:\n    def __init__(self, n):\n        self.n = n\n\n    def sample(self):\n        return random.randint(0, self.n - 1)\n\nclass Finance:\n    intraday = False\n    if intraday:\n        url = 'http://hilpisch.com/aiif_eikon_id_eur_usd.csv'\n    else:\n        url = 'http://hilpisch.com/aiif_eikon_eod_data.csv'\n\n    def __init__(self, symbol, features, window, lags,\n                 leverage=1, min_performance=0.85, min_accuracy=0.5,\n                 start=0, end=None, mu=None, std=None):\n        self.symbol = symbol\n        self.features = features\n        self.n_features = len(features)\n        self.window = window\n        self.lags = lags\n        self.leverage = leverage\n        self.min_performance = min_performance\n        self.min_accuracy = min_accuracy\n        self.start = start\n        self.end = end\n        self.mu = mu\n        self.std = std\n        self.observation_space = observation_space(self.lags)\n        self.action_space = action_space(2)\n        self._get_data()\n        self._prepare_data()\n\n    def _get_data(self):\n        self.raw = pd.read_csv(self.url, index_col=0,\n                               parse_dates=True).dropna()\n        if self.intraday:\n            self.raw = self.raw.resample('30min', label='right').last()\n            self.raw = pd.DataFrame(self.raw['CLOSE'])\n            self.raw.columns = [self.symbol]\n\n    def _prepare_data(self):\n        self.data = pd.DataFrame(self.raw[self.symbol])\n        self.data = self.data.iloc[self.start:]\n        self.data['r'] = np.log(self.data / self.data.shift(1))\n        self.data.dropna(inplace=True)\n        self.data['s'] = self.data[self.symbol].rolling(self.window).mean()\n        self.data['m'] = self.data['r'].rolling(self.window).mean()\n        self.data['v'] = self.data['r'].rolling(self.window).std()\n        self.data.dropna(inplace=True)\n        if self.mu is None:\n            self.mu = self.data.mean()\n            self.std = self.data.std()\n        self.data_ = (self.data - self.mu) / self.std\n        self.data['d'] = np.where(self.data['r'] > 0, 1, 0)\n        self.data['d'] = self.data['d'].astype(int)\n        if self.end is not None:\n            self.data = self.data.iloc[:self.end - self.start]\n            self.data_ = self.data_.iloc[:self.end - self.start]\n\n    def _get_state(self):\n        return self.data_[self.features].iloc[self.bar -\n                                              self.lags:self.bar]\n\n    def get_state(self, bar):\n        return self.data_[self.features].iloc[bar - self.lags:bar]\n\n    def seed(self, seed):\n        random.seed(seed)\n        np.random.seed(seed)\n\n    def reset(self):\n        self.treward = 0\n        self.accuracy = 0\n        self.performance = 1\n        self.bar = self.lags\n        state = self.data_[self.features].iloc[self.bar -\n                                               self.lags:self.bar]\n        return state.values\n\n    def step(self, action):\n        correct = action == self.data['d'].iloc[self.bar]\n        ret = self.data['r'].iloc[self.bar] * self.leverage\n        reward_1 = 1 if correct else 0\n        reward_2 = abs(ret) if correct else -abs(ret)\n        self.treward += reward_1\n        self.bar += 1\n        self.accuracy = self.treward / (self.bar - self.lags)\n        self.performance *= math.exp(reward_2)\n        if self.bar >= len(self.data):\n            done = True\n        elif reward_1 == 1:\n            done = False\n        elif (self.performance < self.min_performance and\n              self.bar > self.lags + 15):\n            done = True\n        elif (self.accuracy < self.min_accuracy and\n              self.bar > self.lags + 15):\n            done = True\n        else:\n            done = False\n        state = self._get_state()\n        info = {}\n        return state.values, reward_1 + reward_2 * 5, done, info\n```", "```py\n#\n# Financial Q-Learning Agent\n#\n# (c) Dr. Yves J. Hilpisch\n# Artificial Intelligence in Finance\n#\nimport os\nimport random\nimport numpy as np\nfrom pylab import plt, mpl\nfrom collections import deque\nimport tensorflow as tf\nfrom keras.layers import Dense, Dropout\nfrom keras.models import Sequential\nfrom keras.optimizers import Adam, RMSprop\n\nos.environ['PYTHONHASHSEED'] = '0'\nplt.style.use('seaborn')\nmpl.rcParams['savefig.dpi'] = 300\nmpl.rcParams['font.family'] = 'serif'\n\ndef set_seeds(seed=100):\n    ''' Function to set seeds for all\n random number generators.\n '''\n    random.seed(seed)\n    np.random.seed(seed)\n    tf.random.set_seed(seed)\n\nclass TradingBot:\n    def __init__(self, hidden_units, learning_rate, learn_env,\n                 valid_env=None, val=True, dropout=False):\n        self.learn_env = learn_env\n        self.valid_env = valid_env\n        self.val = val\n        self.epsilon = 1.0\n        self.epsilon_min = 0.1\n        self.epsilon_decay = 0.99\n        self.learning_rate = learning_rate\n        self.gamma = 0.5\n        self.batch_size = 128\n        self.max_treward = 0\n        self.averages = list()\n        self.trewards = []\n        self.performances = list()\n        self.aperformances = list()\n        self.vperformances = list()\n        self.memory = deque(maxlen=2000)\n        self.model = self._build_model(hidden_units,\n                             learning_rate, dropout)\n\n    def _build_model(self, hu, lr, dropout):\n        ''' Method to create the DNN model.\n '''\n        model = Sequential()\n        model.add(Dense(hu, input_shape=(\n            self.learn_env.lags, self.learn_env.n_features),\n            activation='relu'))\n        if dropout:\n            model.add(Dropout(0.3, seed=100))\n        model.add(Dense(hu, activation='relu'))\n        if dropout:\n            model.add(Dropout(0.3, seed=100))\n        model.add(Dense(2, activation='linear'))\n        model.compile(\n            loss='mse',\n            optimizer=RMSprop(lr=lr)\n        )\n        return model\n\n    def act(self, state):\n        ''' Method for taking action based on\n a) exploration\n b) exploitation\n '''\n        if random.random() <= self.epsilon:\n            return self.learn_env.action_space.sample()\n        action = self.model.predict(state)[0, 0]\n        return np.argmax(action)\n\n    def replay(self):\n        ''' Method to retrain the DNN model based on\n batches of memorized experiences.\n '''\n        batch = random.sample(self.memory, self.batch_size)\n        for state, action, reward, next_state, done in batch:\n            if not done:\n                reward += self.gamma * np.amax(\n                    self.model.predict(next_state)[0, 0])\n            target = self.model.predict(state)\n            target[0, 0, action] = reward\n            self.model.fit(state, target, epochs=1,\n                           verbose=False)\n        if self.epsilon > self.epsilon_min:\n            self.epsilon *= self.epsilon_decay\n\n    def learn(self, episodes):\n        ''' Method to train the DQL agent.\n '''\n        for e in range(1, episodes + 1):\n            state = self.learn_env.reset()\n            state = np.reshape(state, [1, self.learn_env.lags,\n                                       self.learn_env.n_features])\n            for _ in range(10000):\n                action = self.act(state)\n                next_state, reward, done, info = self.learn_env.step(action)\n                next_state = np.reshape(next_state,\n                                        [1, self.learn_env.lags,\n                                         self.learn_env.n_features])\n                self.memory.append([state, action, reward,\n                                    next_state, done])\n                state = next_state\n                if done:\n                    treward = _ + 1\n                    self.trewards.append(treward)\n                    av = sum(self.trewards[-25:]) / 25\n                    perf = self.learn_env.performance\n                    self.averages.append(av)\n                    self.performances.append(perf)\n                    self.aperformances.append(\n                        sum(self.performances[-25:]) / 25)\n                    self.max_treward = max(self.max_treward, treward)\n                    templ = 'episode: {:2d}/{} | treward: {:4d} | '\n                    templ += 'perf: {:5.3f} | av: {:5.1f} | max: {:4d}'\n                    print(templ.format(e, episodes, treward, perf,\n                                       av, self.max_treward), end='\\r')\n                    break\n            if self.val:\n                self.validate(e, episodes)\n            if len(self.memory) > self.batch_size:\n                self.replay()\n        print()\n\n    def validate(self, e, episodes):\n        ''' Method to validate the performance of the\n DQL agent.\n '''\n        state = self.valid_env.reset()\n        state = np.reshape(state, [1, self.valid_env.lags,\n                                   self.valid_env.n_features])\n        for _ in range(10000):\n            action = np.argmax(self.model.predict(state)[0, 0])\n            next_state, reward, done, info = self.valid_env.step(action)\n            state = np.reshape(next_state, [1, self.valid_env.lags,\n                                            self.valid_env.n_features])\n            if done:\n                treward = _ + 1\n                perf = self.valid_env.performance\n                self.vperformances.append(perf)\n                if e % int(episodes / 6) == 0:\n                    templ = 71 * '='\n                    templ += '\\nepisode: {:2d}/{} | VALIDATION | '\n                    templ += 'treward: {:4d} | perf: {:5.3f} | eps: {:.2f}\\n'\n                    templ += 71 * '='\n                    print(templ.format(e, episodes, treward,\n                                       perf, self.epsilon))\n                break\n\ndef plot_treward(agent):\n    ''' Function to plot the total reward\n per training episode.\n '''\n    plt.figure(figsize=(10, 6))\n    x = range(1, len(agent.averages) + 1)\n    y = np.polyval(np.polyfit(x, agent.averages, deg=3), x)\n    plt.plot(x, agent.averages, label='moving average')\n    plt.plot(x, y, 'r--', label='regression')\n    plt.xlabel('episodes')\n    plt.ylabel('total reward')\n    plt.legend()\n\ndef plot_performance(agent):\n    ''' Function to plot the financial gross\n performance per training episode.\n '''\n    plt.figure(figsize=(10, 6))\n    x = range(1, len(agent.performances) + 1)\n    y = np.polyval(np.polyfit(x, agent.performances, deg=3), x)\n    plt.plot(x, agent.performances[:], label='training')\n    plt.plot(x, y, 'r--', label='regression (train)')\n    if agent.val:\n        y_ = np.polyval(np.polyfit(x, agent.vperformances, deg=3), x)\n        plt.plot(x, agent.vperformances[:], label='validation')\n        plt.plot(x, y_, 'r-.', label='regression (valid)')\n    plt.xlabel('episodes')\n    plt.ylabel('gross performance')\n    plt.legend()\n```", "```py\n#\n# Event-Based Backtesting\n# --Base Class (1)\n#\n# (c) Dr. Yves J. Hilpisch\n# Artificial Intelligence in Finance\n#\n\nclass BacktestingBase:\n    def __init__(self, env, model, amount, ptc, ftc, verbose=False):\n        self.env = env  ![1](Images/1.png)\n        self.model = model  ![2](Images/2.png)\n        self.initial_amount = amount  ![3](Images/3.png)\n        self.current_balance = amount  ![3](Images/3.png)\n        self.ptc = ptc   ![4](Images/4.png)\n        self.ftc = ftc   ![5](Images/5.png)\n        self.verbose = verbose  ![6](Images/6.png)\n        self.units = 0  ![7](Images/7.png)\n        self.trades = 0  ![8](Images/8.png)\n\n    def get_date_price(self, bar):\n        ''' Returns date and price for a given bar.\n        '''\n        date = str(self.env.data.index[bar])[:10]  ![9](Images/9.png)\n        price = self.env.data[self.env.symbol].iloc[bar]  ![10](Images/10.png)\n        return date, price\n\n    def print_balance(self, bar):\n        ''' Prints the current cash balance for a given bar.\n        '''\n        date, price = self.get_date_price(bar)\n        print(f'{date} | current balance = {self.current_balance:.2f}')  ![11](Images/11.png)\n\n    def calculate_net_wealth(self, price):\n        return self.current_balance + self.units * price  ![12](Images/12.png)\n\n    def print_net_wealth(self, bar):\n        ''' Prints the net wealth for a given bar\n            (cash + position).\n        '''\n        date, price = self.get_date_price(bar)\n        net_wealth = self.calculate_net_wealth(price)\n        print(f'{date} | net wealth = {net_wealth:.2f}')  ![13](Images/13.png)\n\n    def place_buy_order(self, bar, amount=None, units=None):\n        ''' Places a buy order for a given bar and for\n            a given amount or number of units.\n        '''\n        date, price = self.get_date_price(bar)\n        if units is None:\n            units = int(amount / price)  ![14](Images/14.png)\n            # units = amount / price ![14](Images/14.png)\n        self.current_balance -= (1 + self.ptc) * \\\n            units * price + self.ftc  ![15](Images/15.png)\n        self.units += units  ![16](Images/16.png)\n        self.trades += 1  ![17](Images/17.png)\n        if self.verbose:\n            print(f'{date} | buy {units} units for {price:.4f}')\n            self.print_balance(bar)\n\n    def place_sell_order(self, bar, amount=None, units=None):\n        ''' Places a sell order for a given bar and for\n            a given amount or number of units.\n        '''\n        date, price = self.get_date_price(bar)\n        if units is None:\n            units = int(amount / price)  ![14](Images/14.png)\n            # units = amount / price ![14](Images/14.png)\n        self.current_balance += (1 - self.ptc) * \\\n            units * price - self.ftc  ![15](Images/15.png)\n        self.units -= units  ![16](Images/16.png)\n        self.trades += 1  ![17](Images/17.png)\n        if self.verbose:\n            print(f'{date} | sell {units} units for {price:.4f}')\n            self.print_balance(bar)\n\n    def close_out(self, bar):\n        ''' Closes out any open position at a given bar.\n        '''\n        date, price = self.get_date_price(bar)\n        print(50 * '=')\n        print(f'{date} | *** CLOSING OUT ***')\n        if self.units < 0:\n            self.place_buy_order(bar, units=-self.units)  ![18](Images/18.png)\n        else:\n            self.place_sell_order(bar, units=self.units)  ![19](Images/19.png)\n        if not self.verbose:\n            print(f'{date} | current balance = {self.current_balance:.2f}')\n        perf = (self.current_balance / self.initial_amount - 1) * 100  ![20](Images/20.png)\n        print(f'{date} | net performance [%] = {perf:.4f}')\n        print(f'{date} | number of trades [#] = {self.trades}')\n        print(50 * '=')\n```", "```py\n#\n# Event-Based Backtesting\n# --Trading Bot Backtester\n# (incl. Risk Management)\n#\n# (c) Dr. Yves J. Hilpisch\n#\nimport numpy as np\nimport pandas as pd\nimport backtestingrm as btr\n\nclass TBBacktesterRM(btr.BacktestingBaseRM):\n    def _reshape(self, state):\n        ''' Helper method to reshape state objects.\n '''\n        return np.reshape(state, [1, self.env.lags, self.env.n_features])\n\n    def backtest_strategy(self, sl=None, tsl=None, tp=None,\n                          wait=5, guarantee=False):\n        ''' Event-based backtesting of the trading bot's performance.\n Incl. stop loss, trailing stop loss and take profit.\n '''\n        self.units = 0\n        self.position = 0\n        self.trades = 0\n        self.sl = sl\n        self.tsl = tsl\n        self.tp = tp\n        self.wait = 0\n        self.current_balance = self.initial_amount\n        self.net_wealths = list()\n        for bar in range(self.env.lags, len(self.env.data)):\n            self.wait = max(0, self.wait - 1)\n            date, price = self.get_date_price(bar)\n            if self.trades == 0:\n                print(50 * '=')\n                print(f'{date} | *** START BACKTEST ***')\n                self.print_balance(bar)\n                print(50 * '=')\n\n            # stop loss order\n            if sl is not None and self.position != 0:\n                rc = (price - self.entry_price) / self.entry_price\n                if self.position == 1 and rc < -self.sl:\n                    print(50 * '-')\n                    if guarantee:\n                        price = self.entry_price * (1 - self.sl)\n                        print(f'*** STOP LOSS (LONG  | {-self.sl:.4f}) ***')\n                    else:\n                        print(f'*** STOP LOSS (LONG  | {rc:.4f}) ***')\n                    self.place_sell_order(bar, units=self.units, gprice=price)\n                    self.wait = wait\n                    self.position = 0\n                elif self.position == -1 and rc > self.sl:\n                    print(50 * '-')\n                    if guarantee:\n                        price = self.entry_price * (1 + self.sl)\n                        print(f'*** STOP LOSS (SHORT | -{self.sl:.4f}) ***')\n                    else:\n                        print(f'*** STOP LOSS (SHORT | -{rc:.4f}) ***')\n                    self.place_buy_order(bar, units=-self.units, gprice=price)\n                    self.wait = wait\n                    self.position = 0\n\n            # trailing stop loss order\n            if tsl is not None and self.position != 0:\n                self.max_price = max(self.max_price, price)\n                self.min_price = min(self.min_price, price)\n                rc_1 = (price - self.max_price) / self.entry_price\n                rc_2 = (self.min_price - price) / self.entry_price\n                if self.position == 1 and rc_1 < -self.tsl:\n                    print(50 * '-')\n                    print(f'*** TRAILING SL (LONG  | {rc_1:.4f}) ***')\n                    self.place_sell_order(bar, units=self.units)\n                    self.wait = wait\n                    self.position = 0\n                elif self.position == -1 and rc_2 < -self.tsl:\n                    print(50 * '-')\n                    print(f'*** TRAILING SL (SHORT | {rc_2:.4f}) ***')\n                    self.place_buy_order(bar, units=-self.units)\n                    self.wait = wait\n                    self.position = 0\n\n            # take profit order\n            if tp is not None and self.position != 0:\n                rc = (price - self.entry_price) / self.entry_price\n                if self.position == 1 and rc > self.tp:\n                    print(50 * '-')\n                    if guarantee:\n                        price = self.entry_price * (1 + self.tp)\n                        print(f'*** TAKE PROFIT (LONG  | {self.tp:.4f}) ***')\n                    else:\n                        print(f'*** TAKE PROFIT (LONG  | {rc:.4f}) ***')\n                    self.place_sell_order(bar, units=self.units, gprice=price)\n                    self.wait = wait\n                    self.position = 0\n                elif self.position == -1 and rc < -self.tp:\n                    print(50 * '-')\n                    if guarantee:\n                        price = self.entry_price * (1 - self.tp)\n                        print(f'*** TAKE PROFIT (SHORT | {self.tp:.4f}) ***')\n                    else:\n                        print(f'*** TAKE PROFIT (SHORT | {-rc:.4f}) ***')\n                    self.place_buy_order(bar, units=-self.units, gprice=price)\n                    self.wait = wait\n                    self.position = 0\n\n            state = self.env.get_state(bar)\n            action = np.argmax(self.model.predict(\n                self._reshape(state.values))[0, 0])\n            position = 1 if action == 1 else -1\n            if self.position in [0, -1] and position == 1 and self.wait == 0:\n                if self.verbose:\n                    print(50 * '-')\n                    print(f'{date} | *** GOING LONG ***')\n                if self.position == -1:\n                    self.place_buy_order(bar - 1, units=-self.units)\n                self.place_buy_order(bar - 1, amount=self.current_balance)\n                if self.verbose:\n                    self.print_net_wealth(bar)\n                self.position = 1\n            elif self.position in [0, 1] and position == -1 and self.wait == 0:\n                if self.verbose:\n                    print(50 * '-')\n                    print(f'{date} | *** GOING SHORT ***')\n                if self.position == 1:\n                    self.place_sell_order(bar - 1, units=self.units)\n                self.place_sell_order(bar - 1, amount=self.current_balance)\n                if self.verbose:\n                    self.print_net_wealth(bar)\n                self.position = -1\n            self.net_wealths.append((date, self.calculate_net_wealth(price)))\n        self.net_wealths = pd.DataFrame(self.net_wealths,\n                                        columns=['date', 'net_wealth'])\n        self.net_wealths.set_index('date', inplace=True)\n        self.net_wealths.index = pd.DatetimeIndex(self.net_wealths.index)\n        self.close_out(bar)\n```"]