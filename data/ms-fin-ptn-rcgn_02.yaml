- en: Chapter 2\. Algorithmic Mindset and Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 算法思维与函数
- en: An *algorithm* is a set of rules that a computer applies given the realization
    of certain conditions. You generally use an algorithm to solve a specific problem
    or to simply follow a repetitive sequence of tasks. You can also use algorithms
    to find patterns by scanning for the conditions that you set.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*算法*是计算机根据特定条件的实现应用的一组规则。通常使用算法来解决特定问题或简单地遵循重复任务的序列。您还可以使用算法通过扫描设置的条件来查找模式。'
- en: 'The main purpose of this book is to show you how to scan, find, and evaluate
    candlestick patterns and strategies. The main benefits of using an algorithm as
    opposed to manually performing the tasks are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的主要目的是向您展示如何扫描、发现和评估蜡烛图形和策略。使用算法而不是手动执行任务的主要好处如下：
- en: Speed
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 速度
- en: Algorithms can run at extreme speed compared to humans. While a simple algorithm
    can scan hundreds of thousands of data pieces in a few seconds, a human may spend
    weeks and months doing the same task.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 算法与人类相比能够以极快的速度运行。一个简单的算法可以在几秒钟内扫描数十万条数据，而人类可能需要数周甚至数月来完成同样的任务。
- en: Discipline
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 纪律
- en: Algorithms follow a distinct set of rules and do not have feelings or emotions
    that make them ignore the rules occasionally. In addition, algorithms do not fall
    into the trap of subjective interpretation. This is important for the evaluation
    process as you need objective and clear measures to judge your trading system.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 算法遵循一组明确的规则，并且不具备使它们偶尔忽略规则的情感或情绪。此外，算法不会陷入主观解释的陷阱。这对评估过程至关重要，因为您需要客观和清晰的衡量标准来评判您的交易系统。
- en: Percentage of error
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 错误百分比
- en: Algorithms are generally error-free when there are no bugs in the code. Humans
    can make a lot of mistakes due to inattention and fatigue.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码中没有错误时，算法通常是无误差的。人类由于不注意和疲劳可能会犯很多错误。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A *trading system* is composed of multiple algorithms such as trading and risk
    management algorithms. A robust trading system relies on clear and stable rules-based
    algorithms to give reliable measures.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*交易系统*由多个算法组成，如交易和风险管理算法。强大的交易系统依赖于明确和稳定的基于规则的算法来提供可靠的衡量标准。'
- en: This chapter is divided into four sections. First it covers [primal functions](#primal-functions),
    which deal with the basic data manipulation that I use throughout the book. Then
    it shows how to [code the signals](#coding-signals) of the patterns and strategies.
    It then moves on to [visualizing the signals](#signal-charts) on the price charts
    so that you have an aesthetic and interpretable representation. Finally, you’ll
    learn the [key performance evaluation metrics](#performance-evaluation) and how
    to code them. Make sure you master the concepts of this chapter as they are crucial
    for the rest of the book; they are helpful not only in detecting the patterns
    but also in creating strategies.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为四节。首先涵盖了[原始函数](#primal-functions)，这些函数处理了本书中始终使用的基本数据操作。然后展示了如何对模式和策略的信号进行[编码](#coding-signals)。接着介绍了如何在价格图表上[可视化信号](#signal-charts)，以便您得到美观且易于解释的表现。最后，您将学习[关键绩效评估指标](#performance-evaluation)及其编码方式。确保掌握本章的概念，因为它们对本书的其余部分至关重要；它们不仅有助于检测模式，还有助于创建策略。
- en: Coding the Primal Functions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码原始函数
- en: The *primal functions* are of a small collection of custom functions that help
    you better manipulate data arrays. The idea of primal functions began as an exercise
    for me to practice coding in my early years, but over time, they became regular
    code snippets that I use all the time in my research.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*原始函数*是一小组自定义函数，帮助您更好地操作数据数组。原始函数的概念始于我早年练习编码的一项练习，但随着时间的推移，它们成为我在研究中经常使用的常规代码片段。'
- en: Analyzing and back-testing are repetitive tasks that require some functions
    to work everywhere. Let’s start with the most basic primal functions (remember,
    you will be using `numpy` throughout the book).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 分析和回测是重复性任务，需要一些函数在任何地方起作用。让我们从最基本的原始函数开始（记住，您将在整本书中使用`numpy`）。
- en: The Function to Add Columns to an Array
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向数组添加列的函数
- en: 'Occasionally, you need to add columns to populate them with either indicators
    or signals. For example, assume that you have an OHLC array composed of four columns.
    You can use a function to add an extra column that you may use to harbor the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您需要添加列以填充它们，其中可以是指标或信号。例如，假设您有一个由四列组成的OHLC数组。您可以使用函数添加额外的列，您可以使用这些列来容纳以下内容：
- en: An indicator calculated from the close price, such as a simple moving average^([1](ch02.xhtml#idm46762874354240))
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于收盘价计算的指标，例如简单移动平均^([1](ch02.xhtml#idm46762874354240))
- en: A proxy for buy and sell signals using predetermined binary values (such as
    1 for buy signals and −1 for sell signals)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预定的二进制值（例如买入信号为1，卖出信号为−1）作为买卖信号的代理
- en: Note
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The rows in the arrays represent time steps. I use the hourly time frame in
    the book, which means that every row contains the hourly OHLC values and any indicator
    value or a buy and sell proxy.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的行表示时间步骤。在本书中我使用小时时间框架，这意味着每行包含每小时的开盘、最高、最低、收盘价以及任何指标值或买卖代理。
- en: 'The first primal function is therefore `add_column()`, as shown in the following
    code snippet:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一个原始函数是`add_column()`，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The function loops a predetermined number of times chosen by the variable `times`,
    and for every loop, a new array is created containing zero values and having the
    same length as the original data, as shown by `len(data)`. This new array is born
    out of the `np.zeros()` prebuilt `numpy` function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 函数循环由变量`times`选择的预定次数，并且每次循环都会创建一个新的数组，其中包含与原始数据相同长度的零值，如`len(data)`所示。这个新数组由`np.zeros()`预建的`numpy`函数创建。
- en: The final step is to take this freshly created array and paste it right next
    to the original four columns using `np.append()`, thus giving an array with five
    columns.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是使用`np.append()`将这个新创建的数组直接粘贴到原始四列旁边，从而得到一个有五列的数组。
- en: As the loop continues, the number of columns increases. The argument `axis`
    specifies a binary choice between rows and columns. When it is equal to 0, it
    refers to rows, and when it is equal to 1, it refers to columns. Remember that
    the variable `times` is the number of columns that you want to add, and this is
    specified when calling the function. Let’s look at an example to make things clearer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 随着循环的进行，列数逐渐增加。参数`axis`指定了行和列之间的二元选择。当它等于0时，它指的是行，当它等于1时，它指的是列。记住，变量`times`是您希望添加的列数，这在调用函数时指定。让我们看一个示例以使事情更清楚。
- en: 'You have an array called `my_data` consisting of four columns, and you want
    to add five new columns to update your original array so that it has nine columns.
    What would you write to accomplish this assuming you have already defined the
    `add_column()` function? The answer is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一个名为`my_data`的数组，由四列组成，您希望添加五列新列以更新原始数组，使其具有九列。假设您已经定义了`add_column()`函数，您会写什么来完成这个任务？答案如下：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Function to Delete Columns from an Array
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从数组中删除列的函数
- en: Extra columns may occur when trying to calculate complex indicators because
    you may have to populate them by intermediary calculations that are not needed
    after the indicator is ready. An example of this would to be to use a column to
    calculate weights and to use the next column to calculate a weight-based indicator.
    You would retain the indicator column but not the weight column.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试计算复杂的指标时，可能会出现额外的列，因为您可能需要通过中间计算来填充它们，这些计算在指标准备好之后是不需要的。例如，使用一列来计算权重，然后使用下一列来计算基于权重的指标。您会保留指标列，但不保留权重列。
- en: At the end, you want to retain the final result of the indicator and remove
    the previous columns so that you have a clean array composed of OHLC data with
    the indicator’s readings in the next column.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您希望保留指标的最终结果，并删除先前的列，这样您就可以得到一个由OHLC数据组成的干净数组，其中下一列是指标的读数。
- en: 'A quick and easy way to do this is the `delete_column()` function. The following
    code snippet shows how to define it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 快速简便的方法是使用`delete_column()`函数。下面的代码片段显示了如何定义它：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that to use a function, you must define it first. This means that after
    writing the syntax of the function, you must execute it so that Python stores
    it in its memory.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在使用函数之前，必须先定义它。这意味着在编写函数的语法后，必须执行它，以便Python将其存储在内存中。
- en: The function loops around the specified range, which is the number of columns
    you want to delete as of a selected index. For example, the function deletes the
    three columns as of column number 4, which is included.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 函数循环遍历指定范围，即您要从选定索引开始删除的列数。例如，函数删除从第4列开始的三列，包括第4列。
- en: 'The function states that the newly transformed array has a column deleted using
    the built-in `numpy` function `np.delete()` starting from the variable `index`.
    Finally, the variable `times` is the number of columns to delete, and this is
    specified when calling the function. Here are two examples to make things clearer:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 函数说明，新转换的数组使用内置的`numpy`函数`np.delete()`从变量`index`开始删除列。最后，变量`times`是要删除的列数，在调用函数时指定。以下是两个示例，以便更清晰地理解：
- en: 'You have an array consisting of 10 columns, and you want to erase 4 of them
    starting from the column indexed at 4. Here is how to do so:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一个包含10列的数组，并且想要从索引为4的列开始删除4列。下面是如何实现的：
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that a column indexed at 4 is not the fourth column but the fifth.
    This is because Python starts indexing at zero.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，索引为4的列不是第四列，而是第五列。这是因为Python从零开始索引。
- en: 'You have an array consisting of eight columns, and you want to erase two of
    them starting from the column indexed at 1\. Here is how to do so:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一个包含八列的数组，并且想要从索引为1的列开始删除两列。下面是如何实现的：
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You would use `delete_column()` mostly with technical indicators as opposed
    to patterns, as the latter are direct rules instead of sequential complex calculations
    like some indicators.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你主要会在技术指标中使用`delete_column()`，而不是模式，因为后者是直接的规则，而不是像一些指标那样的顺序复杂计算。
- en: The Function to Add Rows to an Array
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向数组添加行的函数
- en: 'Sometimes you want to add rows to the end of an array due to lag or the addition
    of manual values from the coder. You can add empty rows to the end of an array
    using the following function:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你想在数组末尾添加行，由于滞后或手动添加编码值。你可以使用以下函数向数组末尾添加空行：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The function loops around the data, and in each loop it finds the shape of the
    array using the `np.shape()` built-in function, which gives out the number or
    rows and columns in a matrix. Since you are interested only in the number of columns,
    you would add `[1]` to tell the algorithm that you want only the second value,
    which is the number of columns. Having stored the number in the variable `columns`,
    the algorithm proceeds to the next line and creates a whole new array made up
    of zeros with only one row and a column number equal to the variable `columns`.
    Finally, the algorithm appends this freshly created array with one row to the
    end of the original array, thus giving out a new row with the same size as the
    other rows.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数循环遍历数据，并在每次循环中使用内置函数`np.shape()`找到数组的形状，该函数输出矩阵的行数和列数。由于你只关心列数，你会添加`[1]`来告诉算法你只想要第二个值，也就是列数。将列数存储在变量`columns`中后，算法继续执行下一行，并创建一个全由零组成的新数组，该数组只有一行，列数等于变量`columns`。最后，算法将这个新创建的带有一行的数组附加到原始数组的末尾，从而输出一个与其他行大小相同的新行。
- en: The Function to Remove Rows from an Array
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从数组中删除行的函数
- en: 'When calculating indicators, some calculations may require a minimum number
    of data in the past; otherwise, you would see invalid values, which appear as
    NaN^([2](ch02.xhtml#idm46762878053424)) in Python. The following function deletes
    rows from the start:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算指标时，一些计算可能需要过去最少数量的数据；否则，你会看到无效值，在Python中表现为NaN^([2](ch02.xhtml#idm46762878053424))。以下函数从开头删除行：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This simple function states that the data actually starts from the `number`
    index and continues to the end of the data. Basically, it ignores a select number
    of rows from the beginning.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的函数说明，实际数据从`number`索引开始，一直到数据的末尾。基本上，它忽略了从开头选择的若干行。
- en: The Function to Round Numbers
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 舍入数字的函数
- en: Why discuss such a simple concept here that does not seem to be important enough
    to be a function on its own? The answer is that there are certain patterns that
    are extremely rare unless you round the numbers of the OHLC data.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在这里讨论一个看起来不足以成为独立函数的简单概念？答案是除非你将OHLC数据的数字四舍五入，否则某些模式非常罕见。
- en: Let’s look at an example of the currency pair EURUSD. In recent years, for accuracy
    reasons, retail market dealers started quoting most currency pairs in five decimals
    instead of four. While traders were used to the concept of a *pip*, which is the
    fourth decimal (i.e., the 4 in 1.0964), they now have a *pipette, *which is the
    fifth decimal (the 5 in 1.09645).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以欧元美元货币对为例。近年来，出于精确性原因，零售市场经销商开始对大多数货币对进行五位小数报价，而不是四位。尽管交易员习惯于*点*的概念，即第四位小数（即1.0964中的4），但现在他们有一个*点分*，即第五位小数（即1.09645中的5）。
- en: The change can be confusing for market participants who have been used to the
    conventional four-decimals system, but it is necessary and favors a tighter spread
    quoted by dealers. The *spread* is the difference between the ask (buy) and bid
    (sell) prices. It is the compensation of the market dealer for the risk taken.
    It is considered a transaction cost to the trader because it entails buying slightly
    more expensive and selling slightly cheaper.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变化可能会让习惯于传统四位小数系统的市场参与者感到困惑，但这是必要的，并且有利于交易商报出更紧密的价差。*价差*是买入（询价）和卖出（出价）价格之间的差异。这是市场交易商承担风险的补偿。对交易者来说，它被视为交易成本，因为购买时稍微更贵，而出售时稍微更便宜。
- en: Let’s take this opportunity to discuss how currency pairs work and then build
    up to the need to round the numbers eventually.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用这个机会讨论一下货币对的工作原理，然后逐步详细解释为什么最终需要对数字进行四舍五入。
- en: A currency pair is made up of two currencies; the one on the left is the base
    currency, and the one on its right is the price currency. When you see the pair
    EURUSD quoting at 1.0500, it means that to buy 1 EUR, you need to spend 1.0500
    USD.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 货币对由两种货币组成；左边的是基础货币，右边的是价格货币。当你看到EURUSD交易报价为1.0500时，意味着购买1欧元需要花费1.0500美元。
- en: Now, let’s assume that you bought 10,000 EUR for 10,500 USD and several weeks
    later find that EURUSD is quoting at 1.0750\. What does this mean exactly? It
    means that the value of EUR has gone up relative to the value of USD because now
    you need 10,750 USD to buy 10,000 EUR; therefore, theoretically, you have made
    250 USD (which you can also refer to as 250 pips gain, as the value per 1 EUR
    has gone up by 0.0250). This is realized only if you exchange your EUR back to
    USD, which gives you back 10,750 USD instead of 10,500 USD. With the development
    of markets and the introduction of the five-decimals system, you may now see EURUSD
    with five numbers after the decimals (e.g., EURUSD at 1.07516).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你用10500美元购买了10000欧元，几周后发现EURUSD的报价为1.0750。这到底意味着什么？这意味着相对于美元，欧元的价值上升了，因为现在你需要10750美元来购买10000欧元；因此，从理论上讲，你赚了250美元（你也可以称之为250点的收益，因为每1欧元的价值提高了0.0250）。只有当你将你的欧元兑换成美元时才会实现这一点，这将使你获得10750美元，而不是10500美元。随着市场的发展和五位小数系统的引入，你现在可能会看到EURUSD的小数点后有五个数字（例如，EURUSD为1.07516）。
- en: 'There are certain candlestick patterns that require a close price similar to
    the open price. This is why I include rounding in some of the patterns presented
    in subsequent chapters. The optimal rounding number for currency pairs must be
    four decimals—no more, no less. The following code block shows the rounding function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 存在某些蜡烛图模式，需要接近开盘价的收盘价。这就是为什么我在后续章节中的某些模式中包含四舍五入的原因。货币对的最佳四舍五入数必须是四位小数——不多不少。以下代码块显示了四舍五入函数：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The function uses a built-in function called `round()` to simplify the process.
    Make sure to understand the necessity of rounding the OHLC data when searching
    for specific patterns as you will need it in subsequent chapters.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 函数使用内置函数`round()`来简化过程。确保理解在搜索特定模式时需要对OHLC数据进行四舍五入的必要性，因为在后续章节中你会用到它。
- en: 'Before moving on, let’s briefly practice the new functions you have learned
    in this section. Suppose you have an OHLC array and you want to:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们简要练习一下你在本节学到的新函数。假设你有一个OHLC数组，你想要：
- en: 'Add two columns to the array:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数组中添加两列：
- en: '[PRE8]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Delete three columns starting from the second column:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从第二列开始删除三列：
- en: '[PRE9]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add 11 rows to the end of the array:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数组末尾添加11行：
- en: '[PRE10]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Delete the first four rows in the array:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除数组中的前四行：
- en: '[PRE11]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Round all the values in the array to four decimals:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数组中所有的值四舍五入到四位小数：
- en: '[PRE12]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that the variable `data` is generally used in the functions and refers
    to any data you want to refer to, whereas the variable `my_data`is my default
    name of all the OHLC arrays I import.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，变量`data`通常用于函数中，并引用你想引用的任何数据，而变量`my_data`是我导入的所有OHLC数组的默认名称。
- en: Coding Signals
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码信号
- en: This marks the beginning of the signal algorithm. Remember, the aim of this
    section is to see how to create a set of conditions in order to find valid signals.
    Up to this point, you have imported an OHLC array of an asset or a currency pair.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着信号算法的开始。记住，本节的目的是看如何创建一组条件以寻找有效信号。到目前为止，你已经导入了一个资产或货币对的OHLC数组。
- en: 'As I have not yet started the discussion of any candlestick patterns, I will
    create a hypothetical pattern and then code its conditions and create the signal
    algorithm. Let’s call this hypothetical configuration the Alpha pattern:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我还没有讨论任何蜡烛图案的情况下，我会创建一个假设的模式，然后编写其条件并创建信号算法。我们称这个假设的配置为Alpha模式：
- en: A long (buy) signal is generated on the next open whenever the current low is
    lower than the low price 5 periods ago and the low price 13 periods ago but higher
    than the low price 21 periods ago. Simultaneously, the close price of the current
    bar must be higher than the close price 3 periods ago.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个开盘时会产生一个长期（买入）信号，只要当前的最低价低于5个周期前和13个周期前的最低价，但高于21个周期前的最低价。同时，当前条的收盘价必须高于3个周期前的收盘价。
- en: A short (sell) signal is generated on the next open whenever the current high
    price is higher than the high price 5 periods ago and the high price 13 periods
    ago but lower than the high price 21 periods ago. Simultaneously, the close price
    of the current bar must be lower than the close price 3 periods ago.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前的高价高于5个周期前和13个周期前的高价，但低于21个周期前的高价时，下一个开盘会产生一个短期（卖出）信号。同时，当前条的收盘价必须低于3个周期前的收盘价。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A *short sell* position is a complex action where you profit from a price decrease.
    In layperson’s terms, you borrow an asset from a third party and then sell it
    to a buyer. Finally, you buy it back and return it to the original owner. If the
    price has decreased, you would pocket the difference; otherwise, you would buy
    it back at a higher price than when you sold it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*空头卖出*位置是一种复杂的行为，您从第三方借入资产然后卖给买方以获利。最后，您将其买回并归还给原始所有者。如果价格下跌，您将会赚取差价；否则，您将以比您卖出时更高的价格买回它。'
- en: The previous bullet points give everything you need to generate buy and sell
    signals, and hence, you can start coding the `signal()` function.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的要点提供了生成买入和卖出信号所需的一切，因此，您可以开始编写`signal()`函数。
- en: Think of the `signal()` function as the one that scans each row and leaves a
    trace if all the conditions you set are made. These traces are buy and sell proxy
    orders.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将`signal()`函数视为扫描每一行并在满足您设置的所有条件时留下痕迹的函数。这些痕迹是买入和卖出代理订单的代理。
- en: The first thing you need to tell the algorithm is to have a sufficient number
    of columns that you want to populate with buy and sell orders. As previously seen,
    you can do this with `add_column()`. The next step is to tell the algorithm to
    loop around the totality of data, and this is done using the `for` statement,
    which performs a finite loop between a predefined range, which in your case is
    the length of the OHLC data array.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要告诉算法的第一件事是拥有足够数量的列，您希望用买入和卖出订单填充。如前所述，您可以使用`add_column()`来完成这个操作。接下来的步骤是告诉算法在整个数据范围内进行循环，这可以通过`for`语句完成，它在预定义的范围内执行有限循环，而在您的情况下，是OHLC数据数组的长度。
- en: As you are initiating the position on the next open price after validating the
    pattern at the close price, you can use the `try()` and `except()` functions,
    which simply bypass errors caused by having a signal at the last data of the array
    that gives a trigger on the next nonexistent row. To illustrate this error, imagine
    having 500 rows and getting a buy signal on the 500th row. Since you are buying
    on the next open, the signal would appear on the next row, which does not exist.
    This would cause an index error.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在验证模式时，可以在接下来的开盘价格上启动仓位，您可以使用`try()`和`except()`函数，它们仅仅是绕过由于在数组的最后一行出现信号并在下一个不存在的行上触发错误导致的错误。为了说明这个错误，想象有500行并在第500行得到一个买入信号。由于您在下一个开盘时购买，信号将出现在下一个不存在的行上。这将导致索引错误。
- en: By now, you are ready to code the Alpha pattern’s conditions. I generally code
    the bullish conditions first. Therefore, after telling the algorithm to add two
    columns and to loop across the data while ignoring the `IndexError()` issue, I
    will simply add the conditions using the `if` statement.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经准备好编写Alpha模式的条件了。通常我先编写看涨条件。因此，在告诉算法添加两列并在忽略`IndexError()`问题的同时循环数据时，我会简单地使用`if`语句添加条件。
- en: 'The conditions are intuitive: all you need to know is that the variable `i` refers
    to the current row index in the ongoing loop and therefore `i-5` refers to the
    variable five rows (time steps) before the current one. The `i` variable is used
    with the `for` loop so that the conditions can be applied to every row.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这些条件很直观：你只需知道变量`i`是当前循环中的行索引，因此`i-5`是当前行之前五行（时间步长）的变量。`i`变量与`for`循环一起使用，以便条件可以应用于每一行。
- en: 'However, sometimes you may need to calculate indicators or volatility measures
    after the OHLC data, which pushes the buy and sell columns to the next indices.
    This is covered in [“Indicator Analysis”](ch03.xhtml#ch3_indicator-analysis).
    The following code snippet defines the function of the Alpha pattern:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时候你可能需要在OHLC数据之后计算指标或波动率度量，这将推动买入和卖出列到下一个索引。这在[“指标分析”](ch03.xhtml#ch3_indicator-analysis)中有所涵盖。以下代码片段定义了Alpha模式的函数：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The statement `data[i, 4] == 0` is the condition that to have a buy signal,
    you must not have had a buy signal in the previous row.^([3](ch02.xhtml#idm46762875822448))
    This is to avoid successive signals in case the pattern is repetitive in nature.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 语句`data[i, 4] == 0`是要有买入信号，必须在上一行没有买入信号的条件。^([3](ch02.xhtml#idm46762875822448))
    这是为了避免在模式具有重复性质时出现连续信号。
- en: The proxy for a long signal is the number 1 inputted in the column indexed at
    4 (therefore, the fifth column). The reason I write `data[i + 1, 4] = 1` after
    validating the pattern is to force the algorithm to buy on the next open after
    finishing with the current close price. In parallel, the proxy for a short signal
    is the number −1 in the column indexed at 5 (therefore, the sixth column).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 长信号的代理是在索引为4的列中输入数字1（因此是第五列）。我在验证模式后写`data[i + 1, 4] = 1`的原因是为了强制算法在完成当前收盘价后，在下一个开盘价上进行买入。相反，短信号的代理是在索引为5的列中输入数字-1（因此是第六列）。
- en: And voilà, you have coded the necessary conditions to create signals based on
    the open of the row. How would you code the following conditions?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就编写了根据行开盘创建信号所需的条件。你如何编写以下条件呢？
- en: A long signal is generated on the next open price whenever the current close
    price is higher than the close price two periods ago.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前收盘价高于两个周期前的收盘价时，下一个开盘价上生成一个长信号。
- en: A short signal is generated on the next open price whenever the current close
    price is lower than the close price two periods ago.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当当前收盘价低于两个周期前的收盘价时，下一个开盘价上生成一个短信号。
- en: 'The answer is in the following code snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在以下代码片段中：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There you have it! The way you code signals is by using functions and then calling
    them. Calling a function is synonymous to applying it and seeing it realized.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！你编写信号的方式是使用函数，然后调用它们。调用函数等同于应用它并看到它实现。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'To call a signal function, use the following syntax:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用信号函数，请使用以下语法：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `return` statement obliges you to redefine your array to be what you want
    it to be (as defined by the signal function). This obligation comes from the fact
    that you are adding columns and, therefore, you must re-create the array.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`语句强制你重新定义数组，使其成为你想要的（由信号函数定义）。这一义务来自于你正在添加列，因此你必须重新创建数组。'
- en: 'Now, let’s proceed to the third algorithm: visual representation of the signals.
    It may seem that this is an optional step, and it is, but it is helpful to look
    at a sample of the signals so that you get an idea of what to expect. You must
    also visually check the signals of the patterns to make sure the algorithm is
    detecting the right configurations.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行第三个算法：信号的可视化表示。看起来这是一个可选步骤，而且确实是，但是查看信号样本对你了解可以期待什么是有帮助的。你还必须视觉检查模式的信号，以确保算法正在检测到正确的配置。
- en: Creating the Signal Charts
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建信号图表
- en: 'When you create and apply long and short signals, you have the core of your
    strategy ready, so you need to evaluate it in two different ways:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建和应用长信号和短信号时，你的策略核心准备就绪，因此你需要以两种不同的方式进行评估：
- en: Subjectively
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 主观地
- en: Visually inspect multiple signal charts to detect anomalies that can give hints
    to coding bugs (e.g., a wrong pattern detected by the algorithm). This can also
    help you understand better the frequency and the succession of signals. This is
    what you will see in this section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 目视检查多个信号图表，以检测可能提供算法错误提示的异常情况（例如，算法检测到的错误模式）。这也可以帮助你更好地理解信号的频率和连续性。这就是你将在本节中看到的内容。
- en: Objectively
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 客观地
- en: Objective evaluation is the more important method. It is about calculating performance
    metrics such as the hit ratio. You will see and code all the metrics needed in
    the next section as I discuss them in depth.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 目标评估是更重要的方法。这涉及计算诸如命中率之类的性能指标。随着我在下一节中深入讨论这些指标，您将看到并编写所需的所有指标。
- en: The simple diagram in [Figure 2-1](#figure2-1) can help you understand where
    you stand at this point. Visualization is the third algorithm within the framework
    after importing the historical data and coding the signals.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-1](#figure2-1)中的简单图表可以帮助您了解当前所处位置。在导入历史数据和编写信号之后，可视化是框架中的第三个算法。'
- en: '![](assets/mfpr_0201.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/mfpr_0201.png)'
- en: Figure 2-1\. Algorithmic diagram
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-1\. 算法图
- en: '[Chapter 1](ch01.xhtml#chapter1) covered how to import historical OHLC data
    from the MetaTrader 5 platform, and you have also seen how to load your own data
    in case it is not included on the MetaTrader 5 platform. This chapter has already
    discussed how to code and apply the signals generated from a set of conditions
    called the Alpha pattern. Let’s continue with that same example.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[第一章](ch01.xhtml#chapter1)介绍了如何从 MetaTrader 5 平台导入历史 OHLC 数据，您还看到了如何在 MetaTrader
    5 平台上没有包含数据的情况下加载您自己的数据。本章已经讨论了如何编写并应用从一组称为 Alpha 模式的条件生成的信号。让我们继续使用相同的例子。'
- en: 'Here is a refresher of the trading conditions leading to a valid Alpha pattern:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是导致有效 Alpha 模式的交易条件的提醒：
- en: A long signal is generated on the next open whenever the current low is lower
    than the low price 5 periods ago and the low price 13 periods ago but higher than
    the low price 21 periods ago. Simultaneously, the close price of the current bar
    must be higher than the close price 3 periods ago.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前低点低于 5 个周期前和 13 个周期前的低点但高于 21 个周期前的低点时，下一个开盘产生长期信号。同时，当前柱的收盘价必须高于 3 个周期前的收盘价。
- en: A short signal is generated on the next open whenever the current high price
    is higher than the high price 5 periods ago and the high price 13 periods ago
    but lower than the high price 21 periods ago. Simultaneously, the close price
    of the current bar must be lower than the close price 3 periods ago.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前高价高于 5 个周期前和 13 个周期前的高价但低于 21 个周期前的高价时，下一个开盘产生短期信号。同时，当前柱的收盘价必须低于 3 个周期前的收盘价。
- en: The next step is to visualize these signals using simple bar charts. I then
    apply upward-pointing arrows where long signals are generated and downward-pointing
    arrows where short signals are generated. Later in the book, I create these signal
    charts using candlesticks, but since I have not introduced those yet, I will use
    *simple bar charts*, which are black vertical lines joining the highs and the
    lows of every bar. [Figure 2-2](#figure2-2) shows a simple bar.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用简单的柱状图可视化这些信号。然后我在产生长期信号的地方应用朝上箭头，并在产生短期信号的地方应用朝下箭头。在本书后面，我将使用蜡烛图创建这些信号图，但由于我尚未介绍它们，我将使用*简单柱状图*，这是连接每个柱的高点和低点的黑色垂直线。[图2-2](#figure2-2)展示了一个简单的柱状图。
- en: '![](assets/mfpr_0202.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/mfpr_0202.png)'
- en: Figure 2-2\. A simple high to low bar
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-2\. 一个简单的高低杆
- en: As a reminder, I have not yet discussed technical analysis, so don’t worry if
    you feel overwhelmed with information, as everything should be clearer by the
    [next chapter](ch03.xhtml#chapter3).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，我还没有讨论技术分析，所以如果您感到信息过载，请不要担心，因为在[下一章](ch03.xhtml#chapter3)中一切都应该更清楚。
- en: Take a look at [Figure 2-3](#figure2-3). It is an example of a simple bar chart
    where a vertical line has been drawn between the high and the low of every hour.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 看一看[图2-3](#figure2-3)。这是一个简单的柱状图示例，其中在每个小时的高点和低点之间绘制了垂直线。
- en: Let’s apply the signals from the Alpha pattern on the bars so that you know
    the positioning of your trades relative to the price action. This allows you to
    see what has happened to the price every time you have gotten an Alpha signal.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 Alpha 模式的信号应用于这些柱上，以便您了解交易相对于价格走势的位置。这使您可以看到每次获得 Alpha 信号时价格发生了什么变化。
- en: '![](assets/mfpr_0203.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/mfpr_0203.png)'
- en: Figure 2-3\. Simple bar chart on USDCHF
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-3\. USDCHF 上的简单柱状图
- en: 'Use the following function, which I call `signal_chart()`. Before I define
    the signal chart, here is how to create the simple bar chart by using the `ohlc_plot_bars()` function,
    defined as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下面的函数，我称之为`signal_chart()`。在我定义信号图表之前，这是如何使用以下函数定义的`ohlc_plot_bars()`创建简单的柱状图的：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The function allows you to plot the simple bar chart. It first starts by defining
    the *lookback period*, which is the number of recent observations to include in
    the visualization. The variable for the lookback period is `window`; thus, a window
    of 500 shows you the last 500 observations. It later loops around the observations
    that are within the variable `window` and plots vertical lines using `plt.vlines()`,
    as shown in the previous code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数允许你绘制简单的条形图。它首先通过定义*回顾期*（即最近观察到的数量）来开始，用于可视化的观察数量。回顾期的变量是`window`，因此，一个窗口大小为500将显示最近的500个观察结果。然后，它通过循环遍历在`window`变量内的观察结果，并使用`plt.vlines()`绘制垂直线，正如前面的代码所示。
- en: 'To chart the last 500 bars, use the following syntax:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制最近的500个条形图，请使用以下语法：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let’s add the signals represented by arrows to the simple bar chart. Take
    a look at the following code block that defines the `signal_chart()` function
    and notice how it uses the previous function I showed:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将由箭头表示的信号添加到简单的条形图中。看一下以下定义`signal_chart()`函数的代码块，并注意它如何使用我之前展示的函数：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The variable `position` should be set to zero because the signals refer to
    open prices, which makes the arrows well placed. The function is therefore called
    like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`position`应设置为零，因为信号是指开盘价，这样箭头位置就合适了。因此，函数被这样调用：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you apply this function on the OHLC array where you have already applied
    the signals from the Alpha pattern, you would get the signal chart in [Figure 2-4](#figure2-4).
    Note that upward-pointing arrows represent exactly where long signals have been
    generated, whereas downward-pointing arrows represent where short signals have
    been generated. [Figure 2-4](#figure2-4) shows a signal chart on the hourly USDCHF
    values.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此函数应用于OHLC数组，其中已经应用了来自Alpha模式的信号，你将得到图 [2-4](#figure2-4)中的信号图表。请注意，向上箭头表示长信号的确切生成位置，而向下箭头表示短信号的生成位置。图 [2-4](#figure2-4)显示了USDCHF小时值上的信号图表。
- en: '![](assets/mfpr_0204.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/mfpr_0204.png)'
- en: Figure 2-4\. Signal chart on USDCHF
  id: totrans-135
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-4\. USDCHF上的信号图表
- en: Let’s recap what you have done so far. You started by defining and coding the
    signals so that you have your proxies for buy and sell orders. Then you coded
    a chart function that shows these signals superimposed on the price chart, which
    gives an idea of where you bought and sold in the past.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下你迄今为止做过的事情。你首先定义和编码了信号，以便有你的买入和卖出订单的代理。然后，你编写了一个图表函数，显示这些信号叠加在价格图表上，这给出了你在过去买入和卖出的位置的概念。
- en: Note that even though the simple bar chart shows only the highs and lows, the
    signals are put where the open price is, as it takes into account the totality
    of the OHLC data.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使简单的条形图只显示高点和低点，信号是放在开盘价处的，因为它考虑了OHLC数据的总体情况。
- en: 'The following code shows the chronological order of doing this process on the
    hourly values of USDCHF, as shown in the previous chart:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码显示了在USDCHF小时值上按时间顺序执行此过程的过程，如前面的图表所示：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[Figure 2-5](#figure2-5) shows the same process applied on the hourly values
    of EURUSD. Note that the pattern is hypothetical and has no scientific backing.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-5](#figure2-5)展示了应用在EURUSD小时值上的相同过程。请注意，该模式是假设的，没有科学依据。'
- en: '![](assets/mfpr_0205.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/mfpr_0205.png)'
- en: Figure 2-5\. Signal chart on the EURUSD
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-5\. EURUSD上的信号图表
- en: Coding Performance Evaluation Functions
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写绩效评估函数
- en: Visualizing signals is only a first step. You need objective data that tells
    you whether you have a winning or losing trading system.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化信号只是第一步。你需要客观数据来告诉你是否有一个赢利或亏损的交易系统。
- en: For this, you need *performance evaluation*, which is simply the calculation
    of different metrics and ratios that give you hints about past performance. Your
    job afterward is to interpret these metrics and try to tweak the use of the pattern
    to improve the metrics.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，你需要*绩效评估*，这只是计算不同指标和比率的过程，这些指标和比率可以给你关于过去绩效的线索。之后，你的工作是解释这些指标，并尝试调整模式的使用以改善这些指标。
- en: Remember, a trading strategy can easily be a few conditions that lead to a pattern;
    therefore, even though this book discusses the details of candlestick patterns,
    I will briefly review trading strategies. Chapters [10](ch10.xhtml#chapter10)
    and [11](ch11.xhtml#chapter11) discuss a few strategies that naturally involve
    candlestick patterns.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，一个交易策略很容易是导致模式的几个条件；因此，即使本书讨论蜡烛图案的细节，我也将简要回顾交易策略。第[10](ch10.xhtml#chapter10)章和第[11](ch11.xhtml#chapter11)章讨论了几个自然涉及蜡烛图案的策略。
- en: Note
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Performance evaluation also involves the expectation that past performance indicates
    future performance. This kind of persistence is unlikely, but back-testing and
    evaluating past performance is the best you can do to validate and take your strategy
    live.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 绩效评估还涉及到过去绩效预示未来绩效的期望。这种持续性可能性不大，但回测和评估过去绩效是验证和实施你的策略的最佳方法。
- en: The Hit Ratio
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命中率
- en: We humans like to be right more often than we are wrong. Typically, we are proud
    of our achievements and ashamed of our failures, which is why we are comforted
    when we find out that most of our decisions led to the expected and desired results.
    Being right most of the time provides an ego boost that everyone welcomes. After
    all, who doesn’t want to be seen as successful?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们人类更喜欢正确而不是错误。通常情况下，我们为自己的成就感到自豪，为失败感到羞愧，这就是为什么当我们发现大多数决策导致预期和期望结果时，我们会感到安慰。大多数时候正确提供了一种每个人都欢迎的自我提升感。毕竟，谁不想被视为成功呢？
- en: 'The *hit ratio* in trading jargon is the number of past profitable trades divided
    by the total number of realized past trades. This means that the hit ratio measures
    the percentage of when you were right about the future direction. A 70% hit ratio
    means that, on average, you tend to make money on 70 trades out of every 100,
    which is not bad, but you must absolutely be careful because this is a double-edged
    sword, and you will see why later. Now, let’s take a look at the mathematical
    representation of the hit ratio:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在交易行话中，*命中率* 是过去盈利交易数量除以总已实现过去交易数量。这意味着命中率衡量了你在预测未来方向时正确的百分比。70%的命中率意味着平均而言，你在每100次交易中有70次盈利，这并不差，但你必须绝对小心，因为这是一把双刃剑，稍后你会明白为什么。现在，让我们看一下命中率的数学表示：
- en: <math alttext="Hit ratio equals StartFraction Number of profitable trades Over
    Number of total trades EndFraction"><mrow><mtext>Hit</mtext> <mtext>ratio</mtext>
    <mo>=</mo> <mfrac><mrow><mtext>Number</mtext><mtext>of</mtext><mtext>profitable</mtext><mtext>trades</mtext></mrow>
    <mrow><mtext>Number</mtext><mtext>of</mtext><mtext>total</mtext><mtext>trades</mtext></mrow></mfrac></mrow></math>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Hit ratio equals StartFraction Number of profitable trades Over
    Number of total trades EndFraction"><mrow><mtext>Hit</mtext> <mtext>ratio</mtext>
    <mo>=</mo> <mfrac><mrow><mtext>Number</mtext><mtext>of</mtext><mtext>profitable</mtext><mtext>trades</mtext></mrow>
    <mrow><mtext>Number</mtext><mtext>of</mtext><mtext>total</mtext><mtext>trades</mtext></mrow></mfrac></mrow></math>
- en: Evidently, the number of total trades includes both the number of profitable
    and losing trades. The hit ratio is one of the most observed and analyzed performance
    metrics due to its psychological effect on the receiver. Make sure you calculate
    the ratio on the total number of realized trades excluding the pending trades.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，总交易次数包括盈利交易和亏损交易的数量。命中率是接收者心理影响最观察和分析的绩效指标之一。确保你计算的比率是在已实现交易总数上，不包括未决交易。
- en: The Rate of Return
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收益率
- en: 'When you invest $100 and one year later it becomes $105, what can you say about
    your rate of return? Instead of stating that you have gained $5, you can present
    your profit as a return over the initial investment calculated this way:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当你投资100美元，一年后它变成105美元，你可以如何描述你的收益率呢？不要仅仅说你赚了5美元，而是可以将你的利润表述为相对于初始投资的回报，计算方法如下：
- en: <math alttext="Rate of return equals left-parenthesis StartFraction New balance
    Over Initial balance EndFraction right-parenthesis minus 1"><mrow><mtext>Rate</mtext>
    <mtext>of</mtext> <mtext>return</mtext> <mo>=</mo> <mo>(</mo> <mfrac><mrow><mtext>New</mtext><mtext>balance</mtext></mrow>
    <mrow><mtext>Initial</mtext><mtext>balance</mtext></mrow></mfrac> <mo>)</mo> <mo>-</mo>
    <mn>1</mn></mrow></math>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Rate of return equals left-parenthesis StartFraction New balance
    Over Initial balance EndFraction right-parenthesis minus 1"><mrow><mtext>Rate</mtext>
    <mtext>of</mtext> <mtext>return</mtext> <mo>=</mo> <mo>(</mo> <mfrac><mrow><mtext>New</mtext><mtext>balance</mtext></mrow>
    <mrow><mtext>Initial</mtext><mtext>balance</mtext></mrow></mfrac> <mo>)</mo> <mo>-</mo>
    <mn>1</mn></mrow></math>
- en: 'This means that your rate of return is 5%. Expressing profitability in percentage
    terms gives better information regarding the magnitude of the gains and losses
    on the portfolio. Take, for example, these two hypotheticals:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你的收益率为5%。用百分比来表达盈利能更好地反映投资组合的盈亏幅度。例如，看看以下两个假设情况：
- en: Portfolio A made $125,000.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A组投资组合赚取了$125,000。
- en: Portfolio B returned 10%.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B组投资组合回报率为10%。
- en: Portfolio A does seem more impressive, but what if I told you that both portfolios
    had a starting (initial) balance of $2,000,000? This sure makes portfolio A the
    underperformer, as it made only 6.25%, whereas portfolio B made 10% ($200,000).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: A组投资组合似乎更令人印象深刻，但如果我告诉你两个投资组合的初始余额都是$2,000,000呢？这确实使得A组的表现不佳，因为它只赚了6.25%，而B组则赚了10%（$200,000）。
- en: 'You can also calculate several types of returns, namely, the *gross* rate of
    return and the *net* rate of return. Surely what should interest you is the latter
    as it is net of fees. Let’s see the difference between the two in the following
    example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以计算几种类型的回报率，即*毛*回报率和*净*回报率。当然，你最应该关注的是后者，因为它扣除了费用。让我们看看以下例子中两者的区别：
- en: Initial balance on 01/01/2021 = $1,000,000
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2021年01月01日的初始余额为$1,000,000
- en: Final gross balance on 12/31/2021 = $1,175,000
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2021年12月31日的最终总余额为$1,175,000。
- en: Total unpaid commissions and fees incurred during 2021 = $35,000
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2021年期间未支付的佣金和费用总计为$35,000。
- en: Unpaid research provider fees during 2021 = $10,000
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2021年未支付的研究提供商费用为$10,000。
- en: 'In this example, the gross rate of return is the one that does not consider
    the fees paid to the broker and other third-party vendors:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，毛收益率是不考虑支付给经纪人和其他第三方供应商的费用的收益率：
- en: <math alttext="Gross rate of return left-parenthesis StartFraction 1 comma 175
    comma 000 Over 1 comma 000 comma 000 EndFraction right-parenthesis minus 1 equals
    17.5 percent-sign"><mrow><mtext>Gross</mtext> <mtext>rate</mtext> <mtext>of</mtext>
    <mtext>return</mtext> <mo>=</mo> <mo>(</mo> <mfrac><mrow><mn>1</mn><mo lspace="0%"
    rspace="0%">,</mo><mn>175</mn><mo lspace="0%" rspace="0%">,</mo><mn>000</mn></mrow>
    <mrow><mn>1</mn><mo lspace="0%" rspace="0%">,</mo><mn>000</mn><mo lspace="0%"
    rspace="0%">,</mo><mn>000</mn></mrow></mfrac> <mo>)</mo> <mo>-</mo> <mn>1</mn>
    <mo>=</mo> <mn>17</mn> <mo lspace="0%" rspace="0%">.</mo> <mn>5</mn> <mo lspace="0%"
    rspace="0%">%</mo></mrow></math>
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Gross rate of return left-parenthesis StartFraction 1 comma 175
    comma 000 Over 1 comma 000 comma 000 EndFraction right-parenthesis minus 1 equals
    17.5 percent-sign"><mrow><mtext>Gross</mtext> <mtext>rate</mtext> <mtext>of</mtext>
    <mtext>return</mtext> <mo>=</mo> <mo>(</mo> <mfrac><mrow><mn>1</mn><mo lspace="0%"
    rspace="0%">,</mo><mn>175</mn><mo lspace="0%" rspace="0%">,</mo><mn>000</mn></mrow>
    <mrow><mn>1</mn><mo lspace="0%" rspace="0%">,</mo><mn>000</mn><mo lspace="0%"
    rspace="0%">,</mo><mn>000</mn></mrow></mfrac> <mo>)</mo> <mo>-</mo> <mn>1</mn>
    <mo>=</mo> <mn>17</mn> <mo lspace="0%" rspace="0%">.</mo> <mn>5</mn> <mo lspace="0%"
    rspace="0%">%</mo></mrow></math>
- en: 'The net return is closer to what you actually gain and is found through this
    calculation:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 净回报率更接近你实际获得的收益，通过以下计算得出：
- en: <math alttext="Net rate of return left-parenthesis StartFraction 1 comma 175
    comma 000 minus 35 comma 000 minus 10 comma 000 Over 1 comma 000 comma 000 EndFraction
    right-parenthesis minus 1 equals 13 percent-sign"><mrow><mtext>Net</mtext> <mtext>rate</mtext>
    <mtext>of</mtext> <mtext>return</mtext> <mo>=</mo> <mo>(</mo> <mfrac><mrow><mn>1</mn><mo
    lspace="0%" rspace="0%">,</mo><mn>175</mn><mo lspace="0%" rspace="0%">,</mo><mn>000</mn><mo>-</mo><mn>35</mn><mo
    lspace="0%" rspace="0%">,</mo><mn>000</mn><mo>-</mo><mn>10</mn><mo lspace="0%"
    rspace="0%">,</mo><mn>000</mn></mrow> <mrow><mn>1</mn><mo lspace="0%" rspace="0%">,</mo><mn>000</mn><mo
    lspace="0%" rspace="0%">,</mo><mn>000</mn></mrow></mfrac> <mo>)</mo> <mo>-</mo>
    <mn>1</mn> <mo>=</mo> <mn>13</mn> <mo lspace="0%" rspace="0%">%</mo></mrow></math>
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Net rate of return left-parenthesis StartFraction 1 comma 175
    comma 000 minus 35 comma 000 minus 10 comma 000 Over 1 comma 000 comma 000 EndFraction
    right-parenthesis minus 1 equals 13 percent-sign"><mrow><mtext>Net</mtext> <mtext>rate</mtext>
    <mtext>of</mtext> <mtext>return</mtext> <mo>=</mo> <mo>(</mo> <mfrac><mrow><mn>1</mn><mo
    lspace="0%" rspace="0%">,</mo><mn>175</mn><mo lspace="0%" rspace="0%">,</mo><mn>000</mn><mo>-</mo><mn>35</mn><mo
    lspace="0%" rspace="0%">,</mo><mn>000</mn><mo>-</mo><mn>10</mn><mo lspace="0%"
    rspace="0%">,</mo><mn>000</mn></mrow> <mrow><mn>1</mn><mo lspace="0%" rspace="0%">,</mo><mn>000</mn><mo
    lspace="0%" rspace="0%">,</mo><mn>000</mn></mrow></mfrac> <mo>)</mo> <mo>-</mo>
    <mn>1</mn> <mo>=</mo> <mn>13</mn> <mo lspace="0%" rspace="0%">%</mo></mrow></math>
- en: Warning
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The portfolio is still profitable but has taken a hit after subtracting the
    costs. Some portfolios switch from winners to losers after removing the costs,
    which is why it is important to choose a broker with an acceptable fee structure
    so that it does not eat away your profits over time. Even small differences in
    commissions can have a huge impact on active traders.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 投资组合仍然盈利，但在扣除成本后受到了打击。有些投资组合在扣除成本后从赢家变成了输家，这就是选择一个有合理费率结构的经纪商的重要性，以免长期侵蚀你的利润。即使是佣金的小差异也会对积极交易者产生巨大影响。
- en: The Profit Factor
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 盈利因子
- en: 'The *profit factor* is a quick measure to see how much you are winning for
    every 1 currency unit of loss. It is calculated as the ratio between gross overall
    profit and gross overall loss, meaning that you divide the sum of the profits
    from all profitable trades by the sum of the losses from all losing trades. Mathematically,
    it is expressed as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*盈利因子*是一个快速衡量指标，用来看你每损失1个货币单位时赢得多少。它的计算方法是总毛利润与总毛亏损之间的比率，也就是将所有盈利交易的盈利总和除以所有亏损交易的亏损总和。在数学上，它表示如下：'
- en: <math alttext="Profit factor equals StartFraction Gross total profit Over StartAbsoluteValue
    Gross total loss EndAbsoluteValue EndFraction"><mrow><mtext>Profit</mtext> <mtext>factor</mtext>
    <mo>=</mo> <mfrac><mrow><mtext>Gross</mtext><mtext>total</mtext><mtext>profit</mtext></mrow>
    <mrow><mo>|</mo><mtext>Gross</mtext><mtext>total</mtext><mtext>loss</mtext><mo>|</mo></mrow></mfrac></mrow></math>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Profit factor equals StartFraction Gross total profit Over StartAbsoluteValue
    Gross total loss EndAbsoluteValue EndFraction"><mrow><mtext>Profit</mtext> <mtext>factor</mtext>
    <mo>=</mo> <mfrac><mrow><mtext>Gross</mtext><mtext>total</mtext><mtext>profit</mtext></mrow>
    <mrow><mo>|</mo><mtext>Gross</mtext><mtext>total</mtext><mtext>loss</mtext><mo>|</mo></mrow></mfrac></mrow></math>
- en: It is important to divide by the absolute value of the gross total loss. Let’s
    consider an example of a portfolio that had $127,398 profits in 2020 and $88,318
    losses. What would be the profit ratio in this case?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 将其除以总毛亏损的绝对值非常重要。让我们以2020年赚取了$127,398和亏损了$88,318的投资组合为例。在这种情况下，盈利比率将是多少？
- en: The answer is 1.44, which is interpreted as gaining on average $1.44 for every
    $1.00 lost. Whenever the profitability is positive, the profit factor is bigger
    than 1, and whenever the profitability is negative, the profit factor is less
    than 1\. Some traders like to optimize their strategies by tweaking them until
    they find the highest profit factor.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是1.44，这被解释为平均每损失$1.00赢得$1.44。每当盈利性为正时，盈利因子大于1，每当盈利性为负时，盈利因子小于1。一些交易者喜欢通过调整策略来优化它们，直到找到最高的盈利因子。
- en: The Risk-Reward Ratio
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 风险-收益比
- en: A good trading system is measured by the amount of reward acquired per amount
    of risk taken to achieve the reward. When you risk $1.00 to gain $1.00, the risk-reward
    ratio is equal to 1.00, and you have 50% chance of either winning or losing the
    same amount, unless you have a statistical edge that over time makes you win more
    often than you lose.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的交易系统是通过获得奖励来衡量每承担一定风险量。当你冒着$1.00的风险赢得$1.00时，风险-收益比等于1.00，你有50%的机会赢得或输掉相同的金额，除非你有一个随时间推移使你比输赢更多的统计优势。
- en: This statistical edge is the notion of the hit ratio. When you enter a trade
    and set your *target* (the level at which you close out profitably) and your *stop*
    (the level at which you close out at a loss to avoid a worse outcome), you can
    actually calculate your theoretical (expected) risk-reward ratio.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个统计优势是命中率的概念。当你进入一笔交易并设置*目标*（盈利平仓的水平）和*止损*（为避免更糟结果而进行的亏损平仓水平）时，你实际上可以计算出你的理论（预期）风险-收益比。
- en: 'Here is a simple example based on buying the cryptocurrency Cardano (ADA) relative
    to the USDT (a proxy for the USD):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，基于购买加密货币Cardano（ADA）相对于USDT（代表USD）：
- en: Buy ADAUSDT at $1.00.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以$1.00购买ADAUSDT。
- en: Set stop at $0.95.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置止损价为$0.95。
- en: Set target at $1.10.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置目标为$1.10。
- en: What is the risk-reward ratio of this trade, and how can you interpret it? Simply
    put, you are risking $0.05 to gain $0.10, which means your reward is double the
    risk; hence, the risk-reward ratio is 2.00.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这笔交易的风险-收益比是多少，你如何解释它？简单来说，你冒着$0.05的风险来赚取$0.10，这意味着你的奖励是风险的两倍；因此，风险-收益比为2.00。
- en: <math alttext="Risk reward ratio equals StartFraction StartAbsoluteValue Entry
    price minus Target price EndAbsoluteValue Over StartAbsoluteValue Entry price
    minus Stop price EndAbsoluteValue EndFraction"><mrow><mtext>Risk</mtext> <mtext>reward</mtext>
    <mtext>ratio</mtext> <mo>=</mo> <mfrac><mrow><mo>|</mo><mtext>Entry</mtext><mtext>price</mtext><mo>-</mo><mtext>Target</mtext><mtext>price</mtext><mo>|</mo></mrow>
    <mrow><mo>|</mo><mtext>Entry</mtext><mtext>price</mtext><mo>-</mo><mtext>Stop</mtext><mtext>price</mtext><mo>|</mo></mrow></mfrac></mrow></math>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Risk reward ratio equals StartFraction StartAbsoluteValue Entry
    price minus Target price EndAbsoluteValue Over StartAbsoluteValue Entry price
    minus Stop price EndAbsoluteValue EndFraction"><mrow><mtext>Risk</mtext> <mtext>reward</mtext>
    <mtext>ratio</mtext> <mo>=</mo> <mfrac><mrow><mo>|</mo><mtext>Entry</mtext><mtext>price</mtext><mo>-</mo><mtext>Target</mtext><mtext>price</mtext><mo>|</mo></mrow>
    <mrow><mo>|</mo><mtext>Entry</mtext><mtext>price</mtext><mo>-</mo><mtext>Stop</mtext><mtext>price</mtext><mo>|</mo></mrow></mfrac></mrow></math>
- en: The preceding formula shows how to calculate the theoretical or expected risk-reward
    ratio, which is set before the trade.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 上述公式显示了如何计算理论或预期风险-收益比，这是在交易之前设定的。
- en: Tip
  id: totrans-187
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: A rule of thumb is to generally try to target strategies that offer a risk-reward
    ratio close to 2.00, as this gives you enough margin of predictability error to
    stay in the green. Assuming same quantity trading, with a 2.00 risk-reward ratio,
    you only need a hit ratio of 33.33% to break even.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经验法则是通常尝试选择提供接近2.00的风险-收益比的策略，因为这为你提供了足够的可预测误差余地以保持盈利。假设交易数量相同，具有2.00风险-收益比，你只需33.33%的命中率即可打平。
- en: 'The break-even hit ratio is the minimum hit ratio needed to achieve zero profit
    and loss, excluding costs and fees. As it is just an indicative measure, the break-even
    hit ratio is rarely presented in performance reports. However, you can easily
    calculate it through the risk-reward ratio like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 保本命中率是达到零利润和损失所需的最低命中率，不包括成本和费用。由于它仅仅是一个指示性的测量，保本命中率在绩效报告中很少呈现。然而，你可以通过风险-收益比轻松计算它，如下所示：
- en: <math><mrow><mtext>Break-even hit ratio</mtext> <mo>=</mo> <mfrac><mn>1</mn>
    <mrow><mn>1</mn><mo>+</mo><mtext>Risk reward ratio</mtext></mrow></mfrac></mrow></math>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <math><mrow><mtext>保本命中率</mtext> <mo>=</mo> <mfrac><mn>1</mn> <mrow><mn>1</mn><mo>+</mo><mtext>风险收益比</mtext></mrow></mfrac></mrow></math>
- en: 'That gives you a negative relationship between the hit ratio and the risk-reward
    ratio, as the less you risk and increase your reward, the less you are likely
    to actually hit the reward (target) because you are closer to the risk (stop).
    Consider the following example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致命中率与风险-收益比之间存在负相关关系，因为你的风险越小、收益越大，实际上命中收益（目标）的可能性就越小，因为你距离风险（止损）更近。考虑以下例子：
- en: Hit ratio since 01-01-2021 = 43.67%
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自2021年1月1日以来的命中率 = 43.67%
- en: Realized risk-reward ratio since 01-01-2021 = 2.11
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自2021年1月1日以来实现的风险-收益比 = 2.11
- en: 'What would be the break-even hit ratio in this case? By using the formula,
    you can find the following result:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，保本命中率会是多少？通过使用公式，你可以找到以下结果：
- en: <math><mrow><mtext>Break-even hit ratio</mtext> <mo>=</mo> <mfrac><mn>1</mn>
    <mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo lspace="0%" rspace="0%">.</mo><mn>11</mn></mrow></mfrac>
    <mo>=</mo> <mn>32</mn> <mo lspace="0%" rspace="0%">.</mo> <mn>15</mn> <mo lspace="0%"
    rspace="0%">%</mo></mrow></math>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <math><mrow><mtext>保本命中率</mtext> <mo>=</mo> <mfrac><mn>1</mn> <mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo
    lspace="0%" rspace="0%">.</mo><mn>11</mn></mrow></mfrac> <mo>=</mo> <mn>32</mn>
    <mo lspace="0%" rspace="0%">.</mo> <mn>15</mn> <mo lspace="0%" rspace="0%">%</mo></mrow></math>
- en: This means that you have a winning strategy because you have on average 43–44
    profitable trades per 100 trades. Furthermore, for each of these trades, you win
    on average 2.11 times the amount you lose, and this is what makes the difference.
    Proper risk management is what makes profitable trading systems. A first look
    on the hit ratio leaves the eye unimpressed, but by glancing at the risk-reward,
    a whole new picture emerges.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你拥有一个获胜的策略，因为你平均每100笔交易中有43-44笔盈利交易。此外，对于这些交易中的每一笔，你的平均盈利是你亏损的2.11倍，这就是区别所在。良好的风险管理是使交易系统盈利的关键。仅凭命中率的初步观察，会让人感觉不起眼，但通过看风险-收益比，会呈现出全新的画面。
- en: 'In reality, some trades can be closed before getting stopped out or before
    seeing their targets, and this is due to various reasons, like getting another
    signal in the same direction. Therefore, you have two different risk-reward ratios:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有些交易可以在止损或目标价位之前关闭，这是由于各种原因，例如在同一方向上再次得到信号。因此，你有两个不同的风险-收益比：
- en: The theoretical risk-reward ratio
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上的风险-收益比
- en: This is generally set before the trade and is a forecast.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是在交易之前设置的，是一个预测。
- en: The realized risk-reward ratio
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的风险-收益比
- en: This is the average profit per trade divided by the average loss per trade,
    which gives an idea of how close you are to your theoretical risk-reward ratio.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是每笔交易的平均利润除以每笔交易的平均亏损，这给出了你与理论风险-收益比有多接近的一个想法。
- en: 'Let’s take a look at another example to interpret the two ratios:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子来解释这两个比率：
- en: Theoretical risk-reward ratio set on 01-01-2021 = 2.00
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在2021年1月1日设定的理论风险-收益比 = 2.00
- en: Average gain per trade during 2021 = $241,597
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2021年平均每笔交易的盈利 = $241,597
- en: Average loss per trade during 2021 = $127,222
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2021年平均每笔交易的亏损 = $127,222
- en: The realized risk-reward ratio is therefore 1.90, which is slightly less than
    the theoretical one. This is acceptable as sometimes you exit some trades before
    reaching the stop or target level. The ratios presented in the back-tests in this
    book are the realized ones.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，实现的风险-收益比为1.90，略低于理论值。这是可以接受的，因为有时你在达到止损或目标水平之前会退出一些交易。本书中回测中呈现的比率是实现的比率。
- en: The Number of Trades
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交易次数
- en: The frequency of trades is important for performance evaluation. A rule of thumb
    to keep in mind is to have at least 30 trades in order to meet the minimum threshold
    for reliability. Of course, over the years, the frequency of trades must be much
    higher. Some patterns are so rare that they are unlikely to give many signals,
    thus preventing you from properly judging them.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 交易频率对于性能评估至关重要。需要记住的一个经验法则是至少要有30笔交易，以达到可靠性的最低阈值。当然，多年来，交易频率必须要高得多。有些模式非常罕见，不太可能提供多少信号，从而阻止你对其进行正确的评估。
- en: 'Unfortunately, some patterns can be quite rare, but, in any case, the book
    is not about blemishing and glorifying them, as some are actually very bad and
    nonpredictive yet are used by many retail traders to analyze the market. This
    brings us to the second utility of the book: demystification. It is time to see
    how to code these metrics in Python.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，有些模式可能非常罕见，但无论如何，这本书并不是关于美化和夸大它们的，因为其中一些实际上非常糟糕且不具预测性，但仍被许多零售交易者用来分析市场。这将我们带到书的第二个实用性：揭秘。现在是时候看看如何在Python中编写这些指标了。
- en: Creating a Performance Evaluation Function
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个性能评估函数。
- en: You have finally ended the theoretical part of the discussion of performance
    metrics. Even though in reality there are more metrics that dig into the details
    of performance, you do not need to calculate them all to get a quick idea of what
    works and what does not.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你终于结束了关于性能指标的理论部分讨论。即使在现实中有更多深入细节的性能指标，你也不需要计算它们所有来快速了解什么有效什么无效。
- en: 'For example, the rate of return is not very useful in the back-tests later
    in the book because it is a function of position size and transaction costs, so
    it does not deal with predictability directly. This is why I use only the other
    four metrics:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，回报率在后面的回测中并不是很有用，因为它是仓位大小和交易成本的函数，所以它并不直接处理可预测性。这就是为什么我只使用其他四个指标：
- en: The hit ratio gives you a preliminary idea of the predictability of the pattern
    or the strategy.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命中率给你一个关于模式或策略可预测性的初步概念。
- en: The profit factor allows you to see whether the generated profits are greater
    than the generated losses regardless of position sizing.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利润因子让你看到生成的利润是否大于生成的损失，而不论仓位大小。
- en: The realized risk-reward ratio shows you how much you are being rewarded compared
    to the risk you are taking.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现的风险回报比告诉你，相比于承担的风险，你能得到多少回报。
- en: The frequency of signals reveals whether the results are meaningful or not and
    whether you expect frequent signals or uncommon ones.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号的频率显示结果是否有意义，以及你是否期望频繁信号或罕见信号。
- en: 'The performance metrics are bundled into a Python function that I call `performance()`,
    shown in the following code block. I will explain after the code how it works
    and what it outputs:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 性能指标被捆绑到一个我称为`performance()`的Python函数中，如下面的代码块所示。我将在代码之后解释它是如何工作的及其输出：
- en: '[PRE21]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The function is not as complex as it seems. For instance, it takes seven variables
    that refer to the array and its column indices. The variable `data` represents
    the OHLC array that contains the historical data and the signals generated by
    the pattern. Remember, the signals are in the form of 1s in case of a long trigger
    and in the form of −1s in case of a short trigger. The variable `open_price` is
    simply the first column of the array, which represents the open price for each
    time step. In your case, it would be each hour as you are using the hourly time
    frame.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 函数并不像看起来那么复杂。例如，它接受七个变量，这些变量指的是数组及其列索引。变量`data`表示包含历史数据和模式生成信号的OHLC数组。记住，信号以1的形式表示长触发，以−1的形式表示短触发。变量`open_price`只是数组的第一列，表示每个时间步的开盘价格。在你的情况下，因为你使用的是每小时的时间框架。
- en: Do not forget that the first column of an array is indexed at zero in Python,
    so the variable `open_price` always has a value of 0\. The following two variables
    represent the positions where the buy and sell signals are stored, respectively.
    With simple patterns, it is generally 4 and 5, while with more complex patterns,
    it can be more. The `long_result_col` and the `short_result_col` variables are
    the indices of the results found from the `buy_column` and `sell_column`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，在Python中，数组的第一列索引为零，因此变量`open_price`始终具有值0。接下来的两个变量分别表示买入和卖出信号的位置。对于简单的模式，通常是4和5，而对于更复杂的模式，则可能更多。`long_result_col`和`short_result_col`变量是从`buy_column`和`sell_column`中找到的结果的索引。
- en: 'This means that whenever you exit a long position, the result of that position
    is stored in the column described by the variable `long_result_col`. Finally,
    `total_result_col` is always the next column to come after `short_result_col`
    as it is the sum of the two result columns. The `total_result_col` column is created
    to facilitate the calculation of the performance metrics. Now, to call the function,
    use the following syntax:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每当你退出一个多头头寸时，该头寸的结果就会存储在由变量`long_result_col`描述的列中。最后，`total_result_col`总是紧随`short_result_col`之后的下一列，因为它是两个结果列的总和。`total_result_col`列被创建以便于计算绩效指标。现在，要调用函数，请使用以下语法：
- en: '[PRE22]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The statement calls the performance function on an array called `my_data`, which
    you have seen how to import, then it replaces the variables with the necessary
    values. If you are unsure of how to find the variables, carefully reread the previous
    paragraph.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句调用了一个名为`my_data`的数组上的性能函数，你已经学会如何导入它，然后用必要的值替换变量。如果你不确定如何找到这些变量，请仔细重新阅读前面的段落。
- en: 'A Hypothetical Example: Appraising Performance'
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个假设的例子：评估绩效
- en: 'Before I close this chapter, let’s take a look at a full example and interpret
    its results. After all, back-testing is about understanding what the strategy
    or pattern has given so that you improve it. The following details are for a portfolio
    that uses a single strategy between 2017 and 2021:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在我结束本章之前，让我们看一个完整的例子并解释其结果。毕竟，回测是关于理解策略或模式提供了什么，以便改进它。以下是一个在2017年到2021年之间使用单一策略的投资组合的详细信息：
- en: Total number of trades = 2,348
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总交易数 = 2,348
- en: Profitable trades = 1,236
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 盈利交易 = 1,236
- en: Losing trades = 1,112
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亏损交易 = 1,112
- en: Theoretical risk-reward ratio = 2.00
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理论风险-收益比 = 2.00
- en: Total net gain from trades = $457,995
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易总净收益 = $457,995
- en: Total net loss from trades = $321,589
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易总净损失 = $321,589
- en: Average gain per trade = $370.54
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每笔交易的平均盈利 = $370.54
- en: Average loss per trade = $289.19
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每笔交易的平均损失 = $289.19
- en: What is the hit ratio of the period between 2017 and 2021?
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2017年到2021年期间的命中率是多少？
- en: The hit ratio is simply the number of profitable trades divided by the total
    number of realized trades. In this example, it is 52.64%.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 命中率简单地指的是盈利交易数与实现交易总数的比率。在这个例子中，它是52.64%。
- en: What is the net profit factor between 2017 and 2021? How would you interpret
    it?
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2017年到2021年之间的净利润因子是多少？你会如何解释它？
- en: The profit factor is the total profits divided by the total losses. In this
    example, it is 1.42, which is well above 1.00\. The portfolio is generating $1.42
    for every $1.00 it loses.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 利润因子是总利润除以总损失。在这个例子中，它是1.42，远高于1.00。该投资组合每损失1.00美元就能赚取1.42美元。
- en: What is the realized risk-reward ratio between 2017 and 2021? And how does it
    compare to the theoretical risk-reward ratio?
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2017年到2021年之间的实现的风险-收益比是多少？与理论风险-收益比相比如何？
- en: The realized risk-reward ratio is the ratio of the average gain per trade to
    the average loss per trade. In this example, it is 1.28\. It is well below the
    theoretical risk-reward ratio, which stands at 2.00, and therefore the portfolio
    is experiencing suboptimal risk management, probably due to early closing of positions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的风险-收益比是每笔交易的平均收益与平均损失的比率。在这个例子中，它是1.28。远低于理论风险-收益比2.00，因此投资组合正在经历次优的风险管理，可能是由于过早关闭头寸。
- en: How should we interpret the frequency of signals?
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们应如何解释信号的频率？
- en: With 2,348 trades over the course of five years, the portfolio has a relatively
    high trading activity, about 469 trades per year. Transaction costs are a cause
    of concern with such a high number of trades. Statistically, the performance metrics
    should properly describe the portfolio’s situation since there are many signals.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在五年中进行了2,348笔交易，这个投资组合的交易活动相对较高，约每年469笔交易。对于如此多的交易量来说，交易成本是一个令人担忧的问题。从统计上讲，性能指标应适当描述投资组合的情况，因为有很多信号。
- en: Is this a well-managed portfolio?
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这是一个管理良好的投资组合吗？
- en: Even though profitability as shown by the profit factor is high, the manager
    should consider improving the realized risk-reward ratio while maintaining a hit
    ratio above 50%. This can be done through tweaks, optimizations, and even reviewing
    the entry/exit techniques. The manager should also investigate filtering the trades
    in order to decrease brokerage fees. However, the portfolio is in the green and
    seems to have a predictive strategy.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通过利润因子显示的盈利能力很高，管理者应考虑在保持命中率超过50%的情况下改进实现的风险-回报比。这可以通过调整、优化甚至审查进出场技术来实现。管理者还应该研究对交易进行过滤，以减少经纪费用。然而，投资组合处于盈利状态，并且似乎有一种预测策略。
- en: You have now finished building the core of the algorithms that you will use
    to analyze and back-test the candlestick patterns. Before presenting those patterns,
    you have one more stop to make, which is to understand technical analysis, the
    field of research where candlestick pattern recognition lies.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经完成了构建算法核心的工作，这些算法将用于分析和回测蜡烛图形态。在展示这些图形态之前，你还有一个必须理解的技术分析，这是蜡烛图形态识别所属的研究领域。
- en: ^([1](ch02.xhtml#idm46762874354240-marker)) A *moving average* is a mean calculated
    on a rolling window. It is typically used to understand the trend of the market.
    Moving averages are discussed in greater depth in [Chapter 3](ch03.xhtml#chapter3).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.xhtml#idm46762874354240-marker)) *移动平均线* 是在滚动窗口上计算的均值。通常用于理解市场的趋势。移动平均线在第
    [Chapter 3](ch03.xhtml#chapter3) 中有更深入的讨论。
- en: ^([2](ch02.xhtml#idm46762878053424-marker)) An abbreviation for Not a Number.
    The cell that has NaN is considered invalid and will yield only other NaNs if
    used in calculations.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.xhtml#idm46762878053424-marker)) NaN 的缩写。如果单元格有 NaN，则被视为无效，如果用于计算，将只产生其他
    NaN。
- en: ^([3](ch02.xhtml#idm46762875822448-marker)) Since I use an hourly time frame
    throughout the book, the previous row refers to the previous hourly candlestick.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.xhtml#idm46762875822448-marker)) 由于本书始终使用小时时间框架，上一行指的是前一个小时蜡烛图。
