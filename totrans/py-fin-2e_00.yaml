- en: Chapter 1\. Why Python for Finance?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Banks are essentially technology firms.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Hugo Banziger
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What Is Python?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python is a high-level, multipurpose programming language that is used in a
    wide range of domains and technical fields. On the Python website you find the
    following executive summary (see [*https://www.python.org/doc/essays/blurb*](https://www.python.org/doc/essays/blurb)):'
  prefs: []
  type: TYPE_NORMAL
- en: Python is an interpreted, object-oriented, high-level programming language with
    dynamic semantics. Its high-level built in data structures, combined with dynamic
    typing and dynamic binding, make it very attractive for Rapid Application Development,
    as well as for use as a scripting or glue language to connect existing components
    together. Python’s simple, easy to learn syntax emphasizes readability and therefore
    reduces the cost of program maintenance. Python supports modules and packages,
    which encourages program modularity and code reuse. The Python interpreter and
    the extensive standard library are available in source or binary form without
    charge for all major platforms, and can be freely distributed.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This pretty well describes *why* Python has evolved into one of the major programming
    languages as of today. Nowadays, Python is used by the beginner programmer as
    well as by the highly skilled expert developer, at schools, in universities, at
    web companies, in large corporations and financial institutions, as well as in
    any scientific field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among others, Python is characterized by the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Open source
  prefs: []
  type: TYPE_NORMAL
- en: Python and the majority of supporting libraries and tools available are open
    source and generally come with quite flexible and open licenses.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreted
  prefs: []
  type: TYPE_NORMAL
- en: The reference `CPython` implementation is an interpreter of the language that
    translates Python code at runtime to executable byte code.
  prefs: []
  type: TYPE_NORMAL
- en: Multiparadigm
  prefs: []
  type: TYPE_NORMAL
- en: Python supports different programming and implementation paradigms, such as
    object orientation and imperative, functional, or procedural programming.
  prefs: []
  type: TYPE_NORMAL
- en: Multipurpose
  prefs: []
  type: TYPE_NORMAL
- en: Python can be used for rapid, interactive code development as well as for building
    large applications; it can be used for low-level systems operations as well as
    for high-level analytics tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform
  prefs: []
  type: TYPE_NORMAL
- en: Python is available for the most important operating systems, such as Windows,
    Linux, and Mac OS; it is used to build desktop as well as web applications; it
    can be used on the largest clusters and most powerful servers as well as on such
    small devices as the Raspberry Pi (see [*http://www.raspberrypi.org*](http://www.raspberrypi.org)).
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically typed
  prefs: []
  type: TYPE_NORMAL
- en: Types in Python are in general inferred during runtime and not statically declared
    as in most compiled languages.
  prefs: []
  type: TYPE_NORMAL
- en: Indentation aware
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to the majority of other programming languages, Python uses indentation
    for marking code blocks instead of parentheses, brackets, or semicolons.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collecting
  prefs: []
  type: TYPE_NORMAL
- en: Python has automated garbage collection, avoiding the need for the programmer
    to manage memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to Python syntax and what Python is all about, Python Enhancement
    Proposal 20—i.e., the so-called “Zen of Python”—provides the major guidelines.
    It can be accessed from every interactive shell with the command `import this`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Brief History of Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although Python might still have the appeal of something *new* to some people,
    it has been around for quite a long time. In fact, development efforts began in
    the 1980s by Guido van Rossum from the Netherlands. He is still active in Python
    development and has been awarded the title of *Benevolent Dictator for Life* by
    the Python community (see [*http://en.wikipedia.org/wiki/History_of_Python*](http://en.wikipedia.org/wiki/History_of_Python)).
    The following can be considered milestones in the development of Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python 0.9.0** released in 1991 (first release)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python 1.0** released in 1994'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python 2.0** released in 2000'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python 2.6** released in 2008'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python 3.0** released in 2008'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python 3.1** released in 2009'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python 2.7** released in 2010'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python 3.2** released in 2011'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python 3.3** released in 2012'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python 3.4** released in 2014'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python 3.5** released in 2015'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python 3.6** released in 2016'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is remarkable, and sometimes confusing to Python newcomers, that there are
    two major versions available, still being developed and, more importantly, in
    parallel use since 2008\. As of this writing, this will probably keep on for a
    little while since a mass of code available and in production is still Python
    2.6/2.7\. While the first edition of this book was based on Python 2.7, this second
    edition uses Python 3.6 throughout.
  prefs: []
  type: TYPE_NORMAL
- en: The Python Ecosystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A major feature of Python as an ecosystem, compared to just being a programming
    language, is the availability of a large number of packages and tools. These packages
    and tools generally have to be *imported* when needed (e.g., a plotting library)
    or have to be started as a separate system process (e.g., a Python development
    environment). Importing means making a package available to the current namespace
    and the current Python interpreter process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python itself already comes with a large set of packages and modules that enhance
    the basic interpreter in different directions. One speaks of the *Python Standard
    Library* (see [*https://docs.python.org/3/library/index.html*](https://docs.python.org/3/library/index.html)).
    For example, basic mathematical calculations can be done without any importing,
    while more specialized mathematical functions need to be imported through the
    `math` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: While `math` is a standard Python library available with any installation, there
    are many more libraries that can be installed optionally and that can be used
    in the very same fashion as the standard libraries. Such libraries are available
    from different (web) sources. However, it is generally advisable to use a Python
    package manager that makes sure that all libraries are consistent with each other
    (see [Chapter 2](ch02.html#infrastructure) for more on this topic).
  prefs: []
  type: TYPE_NORMAL
- en: The code examples presented so far all use `IPython` (see [*http://www.ipython.org*](http://www.ipython.org)),
    which is one of the most popular interactive development environments (IDE) for
    Python. Although it started out as an enhanced shell only, it today has many features
    typically found in IDEs (e.g., support for profiling and debugging). Those features
    missing are typically provided by advanced text/code editors, like Sublime Text
    (see [*http://www.sublimetext.com*](http://www.sublimetext.com)). Therefore, it
    is not unusual to combine `IPython` with one’s text/code editor of choice to form
    the basic tool set for a Python development process.
  prefs: []
  type: TYPE_NORMAL
- en: '``IPython`` enhances the standard interactive shell in many ways. For example,
    it provides improved command-line history functions and allows for easy object
    inspection. For instance, the help text (`docstring`) for a function is printed
    by just adding a `?` behind or before the function name (adding `??` will provide
    even more information).'
  prefs: []
  type: TYPE_NORMAL
- en: '`IPython` originally came in two popular versions: a *shell* version and a
    *browser-based version* (the `Notebook`). The `Notebook` variant has proven to
    be that useful and popular that it has become an independent, language-agnostic
    project and tool, called `Jupyter` now (see [*http://jupyter.org*](http://jupyter.org)).'
  prefs: []
  type: TYPE_NORMAL
- en: Python User Spectrum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python does not only appeal to professional software developers; it is also
    of use for the casual developer as well as for domain experts and scientific developers.
  prefs: []
  type: TYPE_NORMAL
- en: '*Professional software developers* find all that they need to efficiently build
    large applications. Almost all programming paradigms are supported; there are
    powerful development tools available; and any task can, in principle, be addressed
    with Python. These types of users typically build their own frameworks and classes,
    also work on the fundamental Python and scientific stack, and strive to make the
    most of the ecosystem.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Scientific developers* or *domain experts* are generally heavy users of certain
    libraries and frameworks, have built their own applications that they enhance
    and optimize over time, and tailor the ecosystem to their specific needs. These
    groups of users also generally engage in longer interactive sessions, rapidly
    prototyping new code as well as exploring and visualizing their research and/or
    domain data sets.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Casual programmers* like to use Python generally for specific problems they
    know that Python has its strengths in. For example, visiting the gallery page
    of `matplotlib`, copying a certain piece of visualization code provided there,
    and adjusting the code to their specific needs might be a beneficial use case
    for members of this group.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also another important group of Python users: *beginner programmers*,
    i.e., those that are just starting to program. Nowadays, Python has become a very
    popular language at universities, colleges, and even schools to introduce students
    to programming.^([1](ch01.html#idm140277704171024)) A major reason for this is
    that its basic syntax is easy to learn and easy to understand, even for the nondeveloper.
    In addition, it is helpful that Python supports almost all programming styles.^([2](ch01.html#idm140277704168880))'
  prefs: []
  type: TYPE_NORMAL
- en: The Scientific Stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a certain set of libraries that is collectively labeled the *scientific
    stack*. This stack comprises, among others, the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`NumPy`](http://www.numpy.org)'
  prefs: []
  type: TYPE_NORMAL
- en: '`NumPy` provides a multidimensional array object to store homogeneous or heterogeneous
    data; it also provides optimized functions/methods to operate on this array object.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`SciPy`](http://www.scipy.org)'
  prefs: []
  type: TYPE_NORMAL
- en: '`SciPy` is a collection of sub-packages and functions implementing important
    standard functionality often needed in science or finance; for example, one finds
    functions for cubic splines interpolation as well as for numerical integration.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`matplotlib`](http://www.matplotlib.org)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the most popular plotting and visualization library for Python, providing
    both 2D and 3D visualization capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '[`PyTables`](http://www.pytables.org)'
  prefs: []
  type: TYPE_NORMAL
- en: '`PyTables` is a popular wrapper for the `HDF5` data storage library (see [*http://www.hdfgroup.org/HDF5/*](http://www.hdfgroup.org/HDF5/));
    it is a library to implement optimized, disk-based I/O operations based on a hierarchical
    database/file format.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`pandas`](http://pandas.pydata.org)'
  prefs: []
  type: TYPE_NORMAL
- en: '`pandas` builds on `NumPy` and provides richer classes for the management and
    analysis of time series and tabular data; it is tightly integrated with `matplotlib`
    for plotting and `PyTables` for data storage and retrieval.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Scikit-Learn`](http://scikit-learn.org)'
  prefs: []
  type: TYPE_NORMAL
- en: '`Scikit-Learn` is a popular machine learning (ML) package that provides a unified
    API for many different ML algorithms, for instance, for estimation, classification
    or clustering.'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the specific domain or problem, this stack is enlarged by additional
    libraries, which more often than not have in common that they build on top of
    one or more of these fundamental libraries. However, the *least common denominator*
    or *basic building block* in general is the `NumPy` `ndarray` class (see [Chapter 4](ch04.html#numpy)),
    or nowadays the `pandas` `DataFrame` class (see [Chapter 5](ch05.html#pandas)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking Python as a programming language alone, there are a number of other
    languages available that can probably keep up with its syntax and elegance. For
    example, `Ruby` is quite a popular language often compared to Python. On the language’s
    web site [*http://www.ruby-lang.org*](http://www.ruby-lang.org) you find the following
    description:'
  prefs: []
  type: TYPE_NORMAL
- en: A dynamic, open source programming language with a focus on simplicity and productivity.
    It has an elegant syntax that is natural to read and easy to write.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The majority of people using Python would probably also agree with the exact
    same statement being made about Python itself. However, what distinguishes Python
    for many users from equally appealing languages like `Ruby` is the availability
    of the scientific stack. This makes Python not only a good and elegant language
    to use, but also one that is capable of replacing domain-specific languages and
    tool sets like Matlab or R. It provides by default also anything that you would
    expect, say, as a seasoned web developer or systems administrator. In addition,
    Python is also good at interfacing with domain specific languages, such as R,
    so that the decision usually is not about *either Python or something else* — it
    is rather about which language should be the major one.
  prefs: []
  type: TYPE_NORMAL
- en: Technology in Finance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have some rough ideas of what Python is all about, it makes sense
    to step back a bit and to briefly contemplate the role of technology in finance.
    This will put us in a position to better judge the role Python already plays and,
    even more importantly, will probably play in the financial industry of the future.
  prefs: []
  type: TYPE_NORMAL
- en: In a sense, technology per se is *nothing special* to financial institutions
    (as compared, for instance, to industrial companies) or to the finance function
    (as compared to other corporate functions, like logistics). However, in recent
    years, spurred by innovation and also regulation, banks and other financial institutions
    like hedge funds have evolved more and more into technology companies instead
    of being *just* financial intermediaries. Technology has become a major asset
    for almost any financial institution around the globe, having the potential to
    lead to competitive advantages as well as disadvantages. Some background information
    can shed light on the reasons for this development.
  prefs: []
  type: TYPE_NORMAL
- en: Technology Spending
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Banks and financial institutions together form the industry that spends the
    most on technology on an annual basis. The following statement therefore shows
    not only that technology is important for the financial industry, but that the
    financial industry is also really important to the technology sector ([http://www.idc.com](https://www.idc.com/getdoc.jsp?containerId=prUS41216616)):'
  prefs: []
  type: TYPE_NORMAL
- en: …, financial services IT spending will reach almost $480 billion worldwide in
    2016 with a five-year compound annual growth rate (CAGR) of 4.2%.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: IDC
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In particular, banks and other financial institutions are engaging in a race
    to move their business and operating models on a digital basis ([http://www.statista.com](https://www.statista.com/statistics/379517/forecast-of-bank-spending-on-new-tech-by-region/)):'
  prefs: []
  type: TYPE_NORMAL
- en: Bank spending on new technologies was predicted to amount to 19.9 billion U.S.
    dollars in 2017 in North America.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The banks develop current systems and work on new technological solutions in
    order to increase their competitiveness on the global market and to attract clients
    interested in new online and mobile technologies. It is a big opportunity for
    global Fintech companies which provide new ideas and software solutions for the
    banking industry.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Statista
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Large, multinational banks today generally employ thousands of developers that
    maintain existing systems and build new ones. Large investment banks with heavy
    technological requirements show technology budgets often of several billion USD
    per year.
  prefs: []
  type: TYPE_NORMAL
- en: Technology as Enabler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The technological development has also contributed to innovations and efficiency
    improvements in the financial sector:'
  prefs: []
  type: TYPE_NORMAL
- en: The financial services industry has seen drastic technology-led changes over
    the past few years. Many executives look to their IT departments to improve efficiency
    and facilitate game-changing innovation — while somehow also lowering costs and
    continuing to support legacy systems. Meanwhile, FinTech start-ups are encroaching
    upon established markets, leading with customer-friendly solutions developed from
    the ground up and unencumbered by legacy systems.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PwC 19th Annual Global CEO Survey 2016
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As a side effect of the increasing efficiency, competitive advantages must often
    be looked for in ever more complex products or transactions. This in turn inherently
    increases risks and makes risk management as well as oversight and regulation
    more and more difficult. The financial crisis of 2007 and 2008 tells the story
    of potential dangers resulting from such developments. In a similar vein, “algorithms
    and computers gone wild” also represent a potential risk to the financial markets;
    this materialized dramatically in the so-called *flash crash* of May 2010, where
    automated selling led to large intraday drops in certain stocks and stock indices
    (see [*http://en.wikipedia.org/wiki/2010_Flash_Crash*](http://en.wikipedia.org/wiki/2010_Flash_Crash)).
  prefs: []
  type: TYPE_NORMAL
- en: Technology and Talent as Barriers to Entry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On the one hand, technology advances reduce cost over time, *ceteris paribus*.
    On the other hand, financial institutions continue to invest heavily in technology
    to both gain market share and defend their current positions. To be active in
    certain areas in finance today often brings with it the need for large-scale investments
    in both technology and skilled staff. As an example, consider the derivatives
    analytics space:'
  prefs: []
  type: TYPE_NORMAL
- en: Aggregated over the total software lifecycle, firms adopting in-house strategies
    for OTC [derivatives] pricing will require investments between $25 million and
    $36 million alone to build, maintain, and enhance a complete derivatives library.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Ding 2010
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Not only is it costly and time-consuming to build a full-fledged derivatives
    analytics library, but you also need to have *enough experts* to do so. And these
    experts have to have the right tools and technologies available to accomplish
    their tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quote about the early days of Long-Term Capital Management (LTCM),
    formerly one of the most respected quantitative hedge funds—which, however, went
    bust in the late 1990s—further supports this insight about technology and talent:'
  prefs: []
  type: TYPE_NORMAL
- en: Meriwether spent $20 million on a state-of-the-art computer system and hired
    a crack team of financial engineers to run the show at LTCM, which set up shop
    in Greenwich, Connecticut. It was risk management on an industrial level.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Patterson 2010
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The same computing power that Meriwether had to buy for millions of dollars
    is today probably available for thousands. On the other hand, trading, pricing,
    and risk management have become so complex for larger financial institutions that
    today they need to deploy IT infrastructures with tens of thousands of computing
    cores.
  prefs: []
  type: TYPE_NORMAL
- en: Ever-Increasing Speeds, Frequencies, Data Volumes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is one dimension of the finance industry that has been influenced most
    by technological advances: the *speed* and *frequency* with which financial transactions
    are decided and executed. The recent book by Lewis (2014) describes so-called
    *flash trading*—i.e., trading at the highest speeds possible—in vivid detail.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the one hand, increasing data availability on ever-smaller scales makes
    it necessary to react in real time. On the other hand, the increasing speed and
    frequency of trading let the data volumes further increase. This leads to processes
    that reinforce each other and push the average time scale for financial transactions
    systematically down:'
  prefs: []
  type: TYPE_NORMAL
- en: Renaissance’s Medallion fund gained an astonishing 80 percent in 2008, capitalizing
    on the market’s extreme volatility with its lightning-fast computers. Jim Simons
    was the hedge fund world’s top earner for the year, pocketing a cool $2.5 billion.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Patterson 2010
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Thirty years’ worth of daily stock price data for a single stock represents
    roughly 7,500 quotes. This kind of data is what most of today’s finance theory
    is based on. For example, theories like the modern portfolio theory (MPT), the
    capital asset pricing model (CAPM), and value-at-risk (VaR) all have their foundations
    in daily stock price data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In comparison, on a typical trading day the stock price of Apple Inc. (AAPL)
    is quoted around 15,000 times—two times as many quotes as seen for end-of-day
    quoting over a time span of 30 years. This brings with it a number of challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: Data processing
  prefs: []
  type: TYPE_NORMAL
- en: It does not suffice to consider and process end-of-day quotes for stocks or
    other financial instruments; “too much” happens during the day for some instruments
    during 24 hours for 7 days a week.
  prefs: []
  type: TYPE_NORMAL
- en: Analytics speed
  prefs: []
  type: TYPE_NORMAL
- en: Decisions often have to be made in milliseconds or even faster, making it necessary
    to build the respective analytics capabilities and to analyze large amounts of
    data in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Theoretical foundations
  prefs: []
  type: TYPE_NORMAL
- en: Although traditional finance theories and concepts are far from being perfect,
    they have been well tested (and sometimes well rejected) over time; for the millisecond
    scales important as of today, consistent concepts and theories that have proven
    to be somewhat robust over time are still missing.
  prefs: []
  type: TYPE_NORMAL
- en: All these challenges can in principle only be addressed by modern technology.
    Something that might also be a little bit surprising is that the lack of consistent
    theories often is addressed by technological approaches, in that high-speed algorithms
    exploit market microstructure elements (e.g., order flow, bid-ask spreads) rather
    than relying on some kind of financial reasoning.
  prefs: []
  type: TYPE_NORMAL
- en: The Rise of Real-Time Analytics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is one discipline that has seen a strong increase in importance in the
    finance industry: *financial and data analytics*. This phenomenon has a close
    relationship to the insight that speeds, frequencies, and data volumes increase
    at a rapid pace in the industry. In fact, real-time analytics can be considered
    the industry’s answer to this trend.'
  prefs: []
  type: TYPE_NORMAL
- en: Roughly speaking, “financial and data analytics” refers to the discipline of
    applying software and technology in combination with (possibly advanced) algorithms
    and methods to gather, process, and analyze data in order to gain insights, to
    make decisions, or to fulfill regulatory requirements, for instance. Examples
    might include the estimation of sales impacts induced by a change in the pricing
    structure for a financial product in the retail branch of a bank. Another example
    might be the large-scale overnight calculation of credit value adjustments (CVA)
    for complex portfolios of derivatives trades of an investment bank.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two major challenges that financial institutions face in this context:'
  prefs: []
  type: TYPE_NORMAL
- en: Big data
  prefs: []
  type: TYPE_NORMAL
- en: Banks and other financial institutions had to deal with massive amounts of data
    even before the term “big data” was coined; however, the amount of data that has
    to be processed during single analytics tasks has increased tremendously over
    time, demanding both increased computing power and ever-larger memory and storage
    capacities.
  prefs: []
  type: TYPE_NORMAL
- en: Real-time economy
  prefs: []
  type: TYPE_NORMAL
- en: In the past, decision makers could rely on structured, regular planning, decision,
    and (risk) management processes, whereas they today face the need to take care
    of these functions in real time; several tasks that have been taken care of in
    the past via overnight batch runs in the back office have now been moved to the
    front office and are executed in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Again, one can observe an interplay between advances in technology and financial/business
    practice. On the one hand, there is the need to constantly improve analytics approaches
    in terms of speed and capability by applying modern technologies. On the other
    hand, advances on the technology side allow new analytics approaches that were
    considered impossible (or infeasible due to budget constraints) a couple of years
    or even months ago.
  prefs: []
  type: TYPE_NORMAL
- en: One major trend in the analytics space has been the utilization of parallel
    architectures on the CPU (central processing unit) side and massively parallel
    architectures on the GPGPU (general-purpose graphical processing units) side.
    Current GPGPUs often have more than 1,000 computing cores, making necessary a
    sometimes radical rethinking of what parallelism might mean to different algorithms.
    What is still an obstacle in this regard is that users generally have to learn
    new paradigms and techniques to harness the power of such hardware.^([3](ch01.html#idm140277704069440))
  prefs: []
  type: TYPE_NORMAL
- en: Python for Finance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous section describes some selected aspects characterizing the role
    of technology in finance:'
  prefs: []
  type: TYPE_NORMAL
- en: Costs for technology in the finance industry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technology as an enabler for new business and innovation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technology and talent as barriers to entry in the finance industry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing speeds, frequencies, and data volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rise of real-time analytics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we want to analyze how Python can help in addressing several
    of the challenges implied by these aspects. But first, on a more fundamental level,
    let us examine Python for finance from a language and syntax standpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Finance and Python Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most people who make their first steps with Python in a finance context may
    attack an algorithmic problem. This is similar to a scientist who, for example,
    wants to solve a differential equation, wants to evaluate an integral, or simply
    wants to visualize some data. In general, at this stage, there is only little
    thought spent on topics like a formal development process, testing, documentation,
    or deployment. However, this especially seems to be the stage when people fall
    in love with Python. A major reason for this might be that the Python syntax is
    generally quite close to the mathematical syntax used to describe scientific problems
    or financial algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: We can illustrate this phenomenon by a simple financial algorithm, namely the
    valuation of a European call option by Monte Carlo simulation. We will consider
    a Black-Scholes-Merton (BSM) setup (see also [Link to Come]) in which the option’s
    underlying risk factor follows a geometric Brownian motion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have the following numerical *parameter values* for the valuation:'
  prefs: []
  type: TYPE_NORMAL
- en: Initial stock index level <math alttext="upper S 0 equals 100"><mrow><msub><mi>S</mi>
    <mn>0</mn></msub> <mo>=</mo> <mn>100</mn></mrow></math>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strike price of the European call option <math alttext="upper K equals 105"><mrow><mi>K</mi>
    <mo>=</mo> <mn>105</mn></mrow></math>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time-to-maturity <math alttext="upper T equals 1"><mrow><mi>T</mi> <mo>=</mo>
    <mn>1</mn></mrow></math> year
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constant, riskless short rate <math alttext="r equals 0.05"><mrow><mi>r</mi>
    <mo>=</mo> <mn>0</mn> <mo>.</mo> <mn>05</mn></mrow></math>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constant volatility <math><mrow><mi>σ</mi> <mo>=</mo> <mn>0</mn> <mo>.</mo>
    <mn>2</mn></mrow></math>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the BSM model, the index level at maturity is a random variable, given by
    [Equation 1-1](#bsm_rv) with *z* being a standard normally distributed random
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Equation 1-1\. Black-Scholes-Merton (1973) index level at maturity
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: <math display="block" alttext="upper S Subscript upper T Baseline equals upper
    S 0 exp left-parenthesis left-parenthesis r minus one-half sigma squared right-parenthesis
    upper T plus sigma StartRoot upper T EndRoot z right-parenthesis"><mrow><msub><mi>S</mi>
    <mi>T</mi></msub> <mo>=</mo> <msub><mi>S</mi> <mn>0</mn></msub> <mo form="prefix">exp</mo>
    <mfenced separators="" open="(" close=")"><mfenced separators="" open="(" close=")"><mi>r</mi>
    <mo>-</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <msup><mi>σ</mi> <mn>2</mn></msup></mfenced>
    <mi>T</mi> <mo>+</mo> <mi>σ</mi> <msqrt><mi>T</mi></msqrt> <mi>z</mi></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an *algorithmic description* of the Monte Carlo valuation
    procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: Draw <math><mi>I</mi></math> (pseudo)random numbers <math alttext="z left-parenthesis
    i right-parenthesis comma i i n left-brace 1 comma 2 comma period period period
    comma upper I right-brace"><mrow><mi>z</mi> <mo>(</mo> <mi>i</mi> <mo>)</mo> <mo>,</mo>
    <mi>i</mi> <mi>i</mi> <mi>n</mi> <mo>{</mo> <mn>1</mn> <mo>,</mo> <mn>2</mn> <mo>,</mo>
    <mo>.</mo> <mo>.</mo> <mo>.</mo> <mo>,</mo> <mi>I</mi> <mo>}</mo></mrow></math>
    , from the standard normal distribution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate all resulting index levels at maturity <math alttext="upper S Subscript
    upper T Baseline left-parenthesis i right-parenthesis"><mrow><msub><mi>S</mi>
    <mi>T</mi></msub> <mrow><mo>(</mo> <mi>i</mi> <mo>)</mo></mrow></mrow></math>
    for given <math alttext="z left-parenthesis i right-parenthesis"><mrow><mi>z</mi>
    <mo>(</mo> <mi>i</mi> <mo>)</mo></mrow></math> and [Equation 1-1](#bsm_rv).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate all inner values of the option at maturity as <math alttext="h Subscript
    upper T Baseline left-parenthesis i right-parenthesis equals max left-parenthesis
    upper S Subscript upper T Baseline left-parenthesis i right-parenthesis minus
    upper K comma 0 right-parenthesis"><mrow><msub><mi>h</mi> <mi>T</mi></msub> <mrow><mo>(</mo>
    <mi>i</mi> <mo>)</mo></mrow> <mo>=</mo> <mo movablelimits="true" form="prefix">max</mo>
    <mrow><mo>(</mo> <msub><mi>S</mi> <mi>T</mi></msub> <mrow><mo>(</mo> <mi>i</mi>
    <mo>)</mo></mrow> <mo>-</mo> <mi>K</mi> <mo>,</mo> <mn>0</mn> <mo>)</mo></mrow></mrow></math>
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Estimate the option present value via the Monte Carlo estimator given in [Equation
    1-2](#bsm_mcs_est).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Equation 1-2\. Monte Carlo estimator for European option
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: <math display="block"><mrow><msub><mi>C</mi> <mn>0</mn></msub> <mo>≈</mo> <msup><mi>e</mi>
    <mrow><mo>-</mo><mi>r</mi><mi>T</mi></mrow></msup> <mfrac><mn>1</mn> <mi>I</mi></mfrac>
    <munder><mo>∑</mo> <mi>I</mi></munder> <msub><mi>h</mi> <mi>T</mi></msub> <mrow><mo>(</mo>
    <mi>i</mi> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: We are now going to translate this problem and algorithm into Python code. The
    reader might follow the single steps by using, for example, `IPython`—this is,
    however, not really necessary at this stage.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_python_and_finance_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The model parameter values are defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_python_and_finance_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: '`NumPy` is used here as the main package.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](images/3.png)](#co_python_and_finance_CO1-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The seed value for the randon number generator is fixed.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](images/4.png)](#co_python_and_finance_CO1-8)'
  prefs: []
  type: TYPE_NORMAL
- en: This draws standard normally distributed random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](images/5.png)](#co_python_and_finance_CO1-9)'
  prefs: []
  type: TYPE_NORMAL
- en: This simulates the end-of-period values.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](images/6.png)](#co_python_and_finance_CO1-10)'
  prefs: []
  type: TYPE_NORMAL
- en: The option payoffs at maturity are calculated.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](images/7.png)](#co_python_and_finance_CO1-11)'
  prefs: []
  type: TYPE_NORMAL
- en: The Monte Carlo estimator is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](images/8.png)](#co_python_and_finance_CO1-12)'
  prefs: []
  type: TYPE_NORMAL
- en: This prints the resulting value estimate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three aspects are worth highlighting:'
  prefs: []
  type: TYPE_NORMAL
- en: Syntax
  prefs: []
  type: TYPE_NORMAL
- en: The Python syntax is indeed quite close to the mathematical syntax, e.g., when
    it comes to the parameter value assignments.
  prefs: []
  type: TYPE_NORMAL
- en: Translation
  prefs: []
  type: TYPE_NORMAL
- en: Every mathematical and/or algorithmic statement can generally be translated
    into a *single* line of Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Vectorization
  prefs: []
  type: TYPE_NORMAL
- en: One of the strengths of `NumPy` is the compact, vectorized syntax, e.g., allowing
    for 100,000 calculations within a single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: This code can be used in an interactive environment like `IPython`. However,
    code that is meant to be reused regularly typically gets organized in so-called
    *modules* (or *scripts*), which are single Python (technicakky “text”) files with
    the suffix `.py`. Such a module could in this case look like [Example 1-1](#bsm_mcs_euro)
    and could be saved as a file named `bsm_mcs_euro.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-1\. Monte Carlo valuation of European call option
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The rather simple algorithmic example in this subsection illustrates that Python,
    with its very syntax, is well suited to complement the classic duo of scientific
    languages, English and Mathematics. It seems that adding `Python` to the set of
    scientific languages makes it more well rounded. We have
  prefs: []
  type: TYPE_NORMAL
- en: '**English** for *writing, talking* about scientific and financial problems,
    etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mathematics** for *concisely and exactly describing and modeling* abstract
    aspects, algorithms, complex quantities, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python** for *technically modeling and implementing* abstract aspects, algorithms,
    complex quantities, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mathematics and Python Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is hardly any programming language that comes as close to mathematical
    syntax as Python. Numerical algorithms are therefore simple to translate from
    the mathematical representation into the `Pythonic` implementation. This makes
    prototyping, development, and code maintenance in such areas quite efficient with
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: In some areas, it is common practice to use *pseudocode* and therewith to introduce
    a fourth language family member. The role of pseudocode is to represent, for example,
    financial algorithms in a more technical fashion that is both still close to the
    mathematical representation and already quite close to the technical implementation.
    In addition to the algorithm itself, pseudocode takes into account how computers
    work in principle.
  prefs: []
  type: TYPE_NORMAL
- en: This practice generally has its cause in the fact that with most programming
    languages the technical implementation is quite “far away” from its formal, mathematical
    representation. The majority of programming languages make it necessary to include
    so many elements that are only technically required that it is hard to see the
    equivalence between the mathematics and the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nowadays, Python is often used in a *pseudocode way* since its syntax is almost
    analogous to the mathematics and since the technical “overhead” is kept to a minimum.
    This is accomplished by a number of high-level concepts embodied in the language
    that not only have their advantages but also come in general with risks and/or
    other costs. However, it is safe to say that with Python you can, whenever the
    need arises, follow the same strict implementation and coding practices that other
    languages might require from the outset. In that sense, Python can provide the
    best of both worlds: *high-level abstraction* and *rigorous implementation*.'
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency and Productivity Through Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At a high level, benefits from using Python can be measured in three dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency
  prefs: []
  type: TYPE_NORMAL
- en: How can Python help in getting results faster, in saving costs, and in saving
    time?
  prefs: []
  type: TYPE_NORMAL
- en: Productivity
  prefs: []
  type: TYPE_NORMAL
- en: How can Python help in getting more done with the same resources (people, assets,
    etc.)?
  prefs: []
  type: TYPE_NORMAL
- en: Quality
  prefs: []
  type: TYPE_NORMAL
- en: What does Python allow us to do that we could not do with alternative technologies?
  prefs: []
  type: TYPE_NORMAL
- en: A discussion of these aspects can by nature not be exhaustive. However, it can
    highlight some arguments as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Shorter time-to-results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A field where the efficiency of Python becomes quite obvious is interactive
    data analytics. This is a field that benefits strongly from such powerful tools
    as `IPython` and libraries like `pandas`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a finance student, writing her master’s thesis and interested in S&P
    500 index values. She wants to analyze historical index levels for, say, a few
    years to see how the volatility of the index has fluctuated over time. She wants
    to find evidence that volatility, in contrast to some typical model assumptions,
    fluctuates over time and is far from being constant. The results should also be
    visualized. She mainly has to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve index level data from the Web.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate the annualized rolling standard deviation of the log returns (volatility).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plot the index level data and the results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These tasks are complex enough that not too long ago one would have considered
    them to be something for professional financial analysts. Today, even the finance
    student can easily cope with such problems. Let us see how exactly this works—without
    worrying about syntax details at this stage (everything is explained in detail
    in subsequent chapters).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_python_and_finance_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This imports `NumPy` and `pandas`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_python_and_finance_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`read_csv` allows the retrievel of remotely stored data sets.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](images/3.png)](#co_python_and_finance_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: A sub-set of the data is picked.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](images/4.png)](#co_python_and_finance_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: This shows some meta-information about the data set.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](images/5.png)](#co_python_and_finance_CO2-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The log returns are calculated in vectorized fashion (“no looping”).
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](images/6.png)](#co_python_and_finance_CO2-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The rolling, annzalized volatility is derived.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](images/7.png)](#co_python_and_finance_CO2-8)'
  prefs: []
  type: TYPE_NORMAL
- en: This line finally plots the two time series.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-1](#spx_vola) shows the graphical result of this brief interactive
    session. It can be considered almost amazing that a few lines of code suffice
    to implement three rather complex tasks typically encountered in financial analytics:
    data gathering, complex and repeated mathematical calculations, and visualization
    of results. This example illustrates that `pandas` makes working with whole time
    series almost as simple as doing mathematical operations on floating-point numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: '![spx volatility](images/spx_volatility.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-1\. S&P 500 closing values and annualized volatility
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Translated to a professional finance context, the example implies that financial
    analysts can—when applying the right Python tools and libraries, providing high-level
    abstraction—focus on their very domain and not on the technical intrinsicalities.
    Analysts can react faster, providing valuable insights almost in real time and
    making sure they are one step ahead of the competition. This example of *increased
    efficiency* can easily translate into measurable bottom-line effects.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring high performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In general, it is accepted that Python has a rather concise syntax and that
    it is relatively efficient to code with. However, due to the very nature of Python
    being an interpreted language, the *prejudice* persists that Python generally
    is too slow for compute-intensive tasks in finance. Indeed, depending on the specific
    implementation approach, Python can be really slow. But it *does not have to be
    slow*—it can be highly performing in almost any application area. In principle,
    one can distinguish at least three different strategies for better performance:'
  prefs: []
  type: TYPE_NORMAL
- en: Paradigm
  prefs: []
  type: TYPE_NORMAL
- en: In general, many different ways can lead to the same result in Python, but with
    rather different performance characteristics; “simply” choosing the right way
    (e.g., a specific library) can improve results significantly.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, there are several performance libraries available that provide compiled
    versions of important functions or that compile Python code statically or dynamically
    (at runtime or call time) to machine code, which can be orders of magnitude faster;
    popular ones are `Cython` and `Numba`.
  prefs: []
  type: TYPE_NORMAL
- en: Parallelization
  prefs: []
  type: TYPE_NORMAL
- en: Many computational tasks, in particular in finance, can strongly benefit from
    parallel execution; this is nothing special to Python but something that can easily
    be accomplished with it.
  prefs: []
  type: TYPE_NORMAL
- en: Performance Computing with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python per se is not a high-performance computing technology. However, Python
    has developed into an ideal platform to access current performance technologies.
    In that sense, Python has become something like a *glue language for performance
    computing*.
  prefs: []
  type: TYPE_NORMAL
- en: Later chapters illustrate all three techniques in detail. For the moment, we
    want to stick to a simple, but still realistic, example that touches upon all
    three techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quite common task in financial analytics is to evaluate complex mathematical
    expressions on large arrays of numbers. To this end, Python itself provides everything
    needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The Python interpreter needs 1.5 seconds in this case to evaluate the function
    `f` 2,500,000 times.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same task can be implemented using `NumPy`, which provides optimized (i.e.,
    *pre-compiled*), functions to handle such array-based operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Using `NumPy` considerably reduces the execution time to 90 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is even a library specifically dedicated to this kind of task.
    It is called `numexpr`, for “numerical expressions.” It *compiles* the expression
    to improve upon the performance of `NumPy`’s general functionality by, for example,
    avoiding in-memory copies of arrays along the way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this more specialized approach further reduces execution time to 80 milliseconds.
    However, `numexpr` also has built-in capabilities to parallelize the execution
    of the respective operation. This allows us to use multiple threads of a CPU:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This brings execution time further down to some 25 milliseconds in this case,
    with four threads utilized. Overall, this is a performance improvement of more
    than 50 times. Note, in particular, that this kind of improvement is possible
    without altering the basic problem/algorithm and without knowing anything about
    compiling or parallelization issues. The capabilities are accessible from a high
    level even by nonexperts. However, one has to be aware, of course, of which capabilities
    and options exist.
  prefs: []
  type: TYPE_NORMAL
- en: The example shows that Python provides a number of options to make more out
    of existing resources—i.e., to *increase productivity*. With the sequential approach,
    about 31 mn evaluations per second are accomplished, while the parallel approach
    allows for more than 100 mn evaluations per second—in this case simply by telling
    Python to use all available CPU threads instead of just one.
  prefs: []
  type: TYPE_NORMAL
- en: From Prototyping to Production
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Efficiency in interactive analytics and performance when it comes to execution
    speed are certainly two benefits of Python to consider. Yet another major benefit
    of using Python for finance might at first sight seem a bit subtler; at second
    sight it might present itself as an important strategic factor. It is the possibility
    to use Python end to end, from *prototyping to production*.
  prefs: []
  type: TYPE_NORMAL
- en: Today’s practice in financial institutions around the globe, when it comes to
    financial development processes, is often characterized by a separated, two-step
    process. On the one hand, there are the *quantitative analysts* (“quants”) responsible
    for model development and technical prototyping. They like to use tools and environments
    like `Matlab` and `R` that allow for rapid, interactive application development.
    At this stage of the development efforts, issues like performance, stability,
    exception management, separation of data access, and analytics, among others,
    are not that important. One is mainly looking for a proof of concept and/or a
    prototype that exhibits the main desired features of an algorithm or a whole application.
  prefs: []
  type: TYPE_NORMAL
- en: Once the prototype is finished, IT departments with their *developers* take
    over and are responsible for translating the existing *prototype code* into reliable,
    maintainable, and performant *production code*. Typically, at this stage there
    is a paradigm shift in that languages like `C`++ or `Java` are now used to fulfill
    the requirements for production. Also, a formal development process with professional
    tools, version control, etc. is applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'This two-step approach has a number of generally unintended consequences:'
  prefs: []
  type: TYPE_NORMAL
- en: Inefficiencies
  prefs: []
  type: TYPE_NORMAL
- en: Prototype code is not reusable; algorithms have to be implemented twice; redundant
    efforts take time and resources.
  prefs: []
  type: TYPE_NORMAL
- en: Diverse skill sets
  prefs: []
  type: TYPE_NORMAL
- en: Different departments show different skill sets and use different languages
    to implement “the same things.”
  prefs: []
  type: TYPE_NORMAL
- en: Legacy code
  prefs: []
  type: TYPE_NORMAL
- en: Code is available and has to be maintained in different languages, often using
    different styles of implementation (e.g., from an architectural point of view).
  prefs: []
  type: TYPE_NORMAL
- en: Using Python, on the other hand, enables a *streamlined* end-to-end process
    from the first interactive prototyping steps to highly reliable and efficiently
    maintainable production code. The communication between different departments
    becomes easier. The training of the workforce is also more streamlined in that
    there is only one major language covering all areas of financial application building.
    It also avoids the inherent inefficiencies and redundancies when using different
    technologies in different steps of the development process. All in all, Python
    can provide a *consistent technological framework* for almost all tasks in financial
    application development and algorithm implementation.
  prefs: []
  type: TYPE_NORMAL
- en: AI-First Finance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data Availability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Machine & Deep Learning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Traditional vs. AI-First Finance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conclusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python as a language—but much more so as an ecosystem—is an ideal technological
    framework for the financial industry. It is characterized by a number of benefits,
    like an elegant syntax, efficient development approaches, and usability for prototyping
    *and* production, among others. With its huge amount of available libraries and
    tools, Python seems to have answers to most questions raised by recent developments
    in the financial industry in terms of analytics, data volumes and frequency, compliance,
    and regulation, as well as technology itself. It has the potential to provide
    a *single, powerful, consistent framework* with which to streamline end-to-end
    development and production efforts even across larger financial institutions.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following book, by the same author, covers many aspects only touched upon
    briefly in this chapter in considerable detail (e.g. derivatives analytics):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hilpisch, Yves (2015): *Derivatives Analytics with Python*. Wiley Finance,
    Chichester, England. [*http://derivatives-analytics-with-python.com*](http://derivatives-analytics-with-python.com).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The quotes in this chapter are taken from the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Crosman, Penny (2013): “Top 8 Ways Banks Will Spend Their 2014 IT Budgets.”
    *Bank Technology News*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Deutsche Börse Group (2008): “The Global Derivatives Market—An Introduction.”
    White paper.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ding, Cubillas (2010): “Optimizing the OTC Pricing and Valuation Infrastructure.”
    *Celent study*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lewis, Michael (2014): *Flash Boys*. W. W. Norton & Company, New York.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Patterson, Scott (2010): *The Quants.* Crown Business, New York.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch01.html#idm140277704171024-marker)) Python, for example, is a major
    language used in the Master of Financial Engineering program at Baruch College
    of the City University of New York (see [*http://mfe.baruch.cuny.edu*](http://mfe.baruch.cuny.edu)).
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch01.html#idm140277704168880-marker)) See [*http://wiki.python.org/moin/BeginnersGuide*](http://wiki.python.org/moin/BeginnersGuide),
    where you will find links to many valuable resources for both developers and nondevelopers
    getting started with Python.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch01.html#idm140277704069440-marker)) [Link to Come] provides an example
    for the benefits of using modern GPGPUs in the context of the generation of random
    numbers.
  prefs: []
  type: TYPE_NORMAL
