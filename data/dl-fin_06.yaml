- en: Chapter 6\. Introductory Python for Data Science
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 为数据科学介绍Python
- en: This is the final chapter before we dive into the realm of machine and deep
    learning. This chapter is optional for experienced Python developers but is important
    for anyone without a solid programming background. Understanding the intuition
    behind the algorithms is a great advantage, but that knowledge will not get you
    far if you fail to properly implement the algorithms. After all, these algorithms
    need to be coded to work and do not function manually, so you need to understand
    the basic syntax and how to manipulate and transform data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们深入进入机器学习和深度学习领域之前的最后一章。对于有经验的Python开发人员来说，本章是可选的，但对于没有扎实编程背景的人来说却很重要。了解算法背后的直觉是一个很大的优势，但如果你不能正确实现这些算法，你的知识将无法发挥作用。毕竟，这些算法需要编写代码才能工作，而不能手动操作，因此你需要理解基本的语法以及如何操作和转换数据。
- en: As the book is not meant to be an A–Z guide to programming in Python, this chapter
    only focuses on some of the essentials and a few additional techniques that should
    help you smoothly navigate the subsequent chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书不旨在成为Python编程的A-Z指南，本章仅侧重于一些基础知识和一些额外的技术，这些将有助于你顺利地浏览后续章节。
- en: Downloading Python
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载Python
- en: '*Code* is defined as a set of instructions designed to be executed by a computer.
    Generally, specific syntax is required so that the computer applies the set of
    instructions without errors. There are many coding languages, and they are divided
    into two broad categories:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码*被定义为一组指令，旨在由计算机执行。通常需要特定的语法，以便计算机无误地应用一组指令。有许多编程语言，它们分为两大类：'
- en: Low-level coding languages
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 低级编程语言
- en: These are machine languages usually used to write operating systems and firmware.
    They are very difficult to read. These languages have a sizable level of control
    over hardware. Assembly language is an example of a low-level language.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是通常用于编写操作系统和固件的机器语言。它们非常难以阅读。这些语言对硬件有相当高的控制级别。汇编语言是低级语言的一个例子。
- en: High-level coding languages
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 高级编程语言
- en: These are user-friendly languages (with a high level of abstraction). They are
    generally used to code programs and software. Examples of high-level languages
    include Python and Julia.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是用户友好的高级语言（抽象级别高）。它们通常用于编写程序和软件。高级语言的例子包括Python和Julia。
- en: The coding language used in this book is Python, a popular and versatile language
    with many advantages and wide adoption in the research and professional trading
    communities. As you have probably gathered from the chapter’s title, you will
    get an introduction to Python and to the tools you need to start building your
    own scripts. But before that, you need to download Python.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中使用的编程语言是Python，这是一种流行且多才多艺的语言，在研究和专业交易社区中广泛采用。正如你从本章标题中可能已经了解到的那样，你将会对Python以及开始构建自己脚本所需的工具有所了解。但在此之前，你需要下载Python。
- en: A *Python interpreter* is software used to write and execute code written using
    Python syntax. I use Spyder. Some people may be more familiar with other interpreters
    such as Jupyter and PyCharm, but the process is the same. You can download Spyder
    from the [official website](https://oreil.ly/Vlh4c) or, even better, download
    it as part of a bigger package called [Anaconda](https://oreil.ly/nI8Ed), which
    facilitates installation and offers more tools. Note that Spyder is open source
    and free to use.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python解释器*是用于编写和执行使用Python语法编写的代码的软件。我使用Spyder。有些人可能更熟悉其他解释器，如Jupyter和PyCharm，但处理过程是一样的。你可以从[官方网站](https://oreil.ly/Vlh4c)下载Spyder，或者更好地作为一个更大的包Anaconda的一部分下载它，Anaconda便于安装并提供更多工具。请注意，Spyder是开源且免费使用的。'
- en: '[Figure 6-1](#figure-6-1) shows Python’s console, where the output of the code
    appears.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-1](#figure-6-1)显示了Python控制台，代码输出显示在其中。'
- en: '![](assets/dlff_0601.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dlff_0601.png)'
- en: Figure 6-1\. Spyder’s console
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-1 Spyder的控制台
- en: Python files have the extension *.py*, and they allow you to save the code and
    refer to it at a later stage. You can also open multiple files of code and navigate
    between them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Python文件的扩展名为*.py*，它们允许你保存代码并在以后引用它们。你还可以打开多个代码文件并在它们之间导航。
- en: 'The outline of this chapter is as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大纲如下：
- en: Understand the language of Python and how to write error-free code
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Python语言以及如何编写无错误的代码
- en: Understand how to use control flow and its importance with time series analysis
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用控制流以及在时间序列分析中的重要性
- en: Understand libraries and functions and their role in facilitating coding
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解库和函数及其在简化编码中的作用
- en: Understand different types of errors and how to handle them
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解不同类型的错误及其处理方法
- en: Understand how to use data manipulation libraries such as *numpy* and *pandas*
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何使用数据操作库如*numpy*和*pandas*
- en: Finally, see how to import historical financial time series data into Python
    so that it gets analyzed with the proper tools (those we already discussed as
    well as those we will discuss in coming chapters)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，了解如何将历史财务时间序列数据导入Python，以便使用适当的工具进行分析（这些工具我们已经讨论过，也将在接下来的章节中讨论）。
- en: Basic Operations and Syntax
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本操作和语法
- en: '*Syntax* is the set of rules that define the structure of statements needed
    to write code that functions. When you are communicating with a computer, you
    have to make sure it understands you, so having a solid understanding of syntax
    is important.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*语法*是定义编写可运行代码所需语句结构的一组规则。当您与计算机进行通信时，必须确保它能理解您，因此对语法有扎实的理解非常重要。'
- en: '*Comments* are nonexecutable code used to explain the executable code that
    follows. Comments are used so that other programmers understand the code. Comments
    in Python are preceded by a hash sign (**#**):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*注释*是非可执行代码，用于解释随后的可执行代码。注释用于让其他程序员理解代码。在Python中，注释前面带有井号（**#**）：'
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure you understand that comments are nonexecutable. This means that when
    you run (execute) the code, they will be ignored by the interpreter and will not
    return an error.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保理解注释是非可执行的。这意味着当您运行（执行）代码时，解释器会忽略它们，不会返回错误。
- en: 'Sometimes you need to write documentation for your code, which may require
    multiple lines of code (even paragraphs, in some instances). Writing the hash
    sign at every line can be tedious and cluttersome. This is why there is a way
    to write long comments. To do this, write your comment between three single quotation
    marks as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您需要为您的代码编写文档，这可能需要多行代码（在某些情况下甚至是段落）。在每一行写上井号可能会很乏味且凌乱。这就是为什么有一种方法可以编写长注释。为此，您可以使用三个单引号将您的注释写在其中，如下所示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is worth noting that triple quotes are called *docstrings* and are not really
    comments (according to the official Python documentation).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，三重引号称为*文档字符串*，实际上并不是注释（根据官方Python文档）。
- en: 'Let’s discuss variables and constants. A *constant* is a fixed value that does
    not change, whereas a *variable* takes on different values given an event. A constant
    can be the number 6, while a variable can be the letter *x*, which takes on any
    number given a set of conditions or a state. A variable is defined using the `=`
    operator:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论变量和常量。*常量*是一个不变的值，而*变量*在给定事件时可以取不同的值。常量可以是数字6，而变量可以是字母*x*，在一定条件或状态下可以取任何数字。变量使用`=`运算符进行定义：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Running (executing) the previous code will store the variable `x` with its
    respective value in the variable explorer. Simultaneously, the output of the code
    will be `6`. Variables are case sensitive. Therefore:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 运行（执行）前面的代码将会在变量资源管理器中存储变量`x`及其相应值。同时，代码的输出将是`6`。变量是区分大小写的。因此：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A variable declaration cannot start with a number, but a number can be included
    in the middle or the end of a variable declaration:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 变量声明不能以数字开头，但数字可以包含在变量声明的中间或末尾：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Variables can also contain underscores but nothing else:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 变量还可以包含下划线，但不能包含其他字符：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It is highly recommended that variables have short and straightforward names.
    For example, consider creating a variable that holds the lookback period of a
    certain moving average (a technical indicator introduced in [Chapter 5](ch05.html#ch05)):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议变量使用简短而直接的名称。例如，考虑创建一个变量来保存某个移动平均线的回溯期（这是在[第5章](ch05.html#ch05)中介绍的技术指标）：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are several different data types with different characteristics:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的数据类型，具有不同的特性：
- en: '*Numerical data types*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*数值数据类型*'
- en: This is the simplest data type, formed exclusively from numbers. Numerical data
    types are divided into integers, float numbers, and complex numbers. *Integers*
    are simple whole numbers (positive or negative), such as 6 and –19\. *Float numbers*
    are more precise than integers as they incorporate the values after the comma,
    for example, 2.7 and –8.09\. *Complex numbers* include imaginary numbers.^([1](ch06.html#id561))
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的数据类型，仅由数字组成。数值数据类型分为整数、浮点数和复数。*整数*是简单的整数（正数或负数），如6和-19。*浮点数*比整数更精确，因为它们包含逗号后的值，例如2.7和-8.09。*复数*包括虚数。^([1](ch06.html#id561))
- en: '*Strings*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串*'
- en: As you saw previously with comments and docstrings, it is possible to write
    text next to the code without it interfering with the execution process. *Strings*
    are text structures that represent sequences of characters. Strings can be inputs
    and arguments of functions and not necessarily just comments.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前通过注释和文档字符串看到的那样，可以在代码旁边写入文本而不影响执行过程。*字符串*是表示字符序列的文本结构。字符串可以是函数的输入和参数，而不仅仅是注释。
- en: '*Booleans*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值*'
- en: A Boolean is a binary (true or false) data type used to evaluate the truth value
    of the given expression or condition. For example, you can use Booleans to evaluate
    whether the market price is above or below the 100-period moving average.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值是用于评估给定表达式或条件的真值的二进制（真或假）数据类型。例如，可以使用布尔值来评估市场价格是否高于或低于100期移动平均线。
- en: '*Data collection*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据集合*'
- en: These are sequences that contain multiple datasets, each having a different
    and unique usage. An *array* is a sequence of elements of the same type (mostly
    numerical). Arrays will be used frequently in this book (with a Python library
    called *numpy* that is discussed in this chapter). A *dataframe* is a two-dimensional
    table of structured data that is also frequently used in this book (with a Python
    library called *pandas* also discussed in this chapter). A *set* is a sequence
    of unordered elements. A *list* is an ordered collection of elements that can
    be of different data types. A *tuple* is an ordered, immutable collection of elements
    that may be of different data types. It is used for storing a fixed sequence of
    values. A *dictionary* represents a collection of key-value pairs grouped together.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是包含多个数据集的序列，每个数据集具有不同且独特的用途。*数组*是相同类型元素的序列（主要是数值）。在本书中经常会使用数组（使用一个名为*numpy*的Python库，在本章中进行讨论）。*数据框*是二维结构化数据表，也经常在本书中使用（使用一个名为*pandas*的Python库，在本章中也进行讨论）。*集合*是无序元素的序列。*列表*是有序元素的集合，可以是不同的数据类型。*元组*是有序的不可变元素集合，可以是不同的数据类型。用于存储固定值序列。*字典*表示键-值对的集合。
- en: 'The following code snippet shows a few examples of the numerical data type:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了数值数据类型的几个示例：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output should be as follows (note that the two created variables will appear
    in the variable explorer):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示（请注意，创建的两个变量将出现在变量资源管理器中）：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Strings are simply text. The most commonly used example to explain a string
    is the phrase “Hello World”:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串只是文本。用来解释字符串的最常用示例是短语“Hello World”：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output should be as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Strings can also be used as arguments in functions, as you will see later in
    this chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串也可以作为函数的参数，后面你会在本章看到。
- en: 'Booleans are either true or false values. The following code snippet shows
    an example of using them:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值是真或假值。下面的代码片段展示了它们的使用示例：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the previous code is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s discuss how operators work. You already saw an example of an operator:
    the assignment operator `=` used to define variables. *Operators* perform special
    mathematical and other tasks between variables, constants, and even data structures.
    There are different types of operators. Let’s start with *arithmetic operators*,
    as shown in the following snippet:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论操作符的工作原理。你已经看到了一个操作符的示例：赋值操作符`=`用于定义变量。*操作符*在变量、常量甚至数据结构之间执行特殊的数学和其他任务。有不同类型的操作符。让我们从*算术运算符*开始，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The next type of operator is the *comparison operators*. These are used to
    compare different elements. They are mostly used in control flow events, as explained
    in the next section of this chapter. The following snippet shows a few comparison
    operators:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个类型的运算符是*比较运算符*。这些用于比较不同的元素。它们在控制流事件中经常使用，如本章的下一节所述。以下代码片段显示了一些比较运算符：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Logical operators* combine two or more conditions that are later evaluated.
    There are three logical operators: `and`, `or`, and `not`. The following code
    block shows an example of logical operators:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*逻辑运算符*结合两个或多个条件进行后续评估。有三个逻辑运算符：`and`、`or`和`not`。以下代码块展示了逻辑运算符的一个例子：'
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Data collection structures (arrays and dataframes) are discussed in a later
    section, as they require an in-depth presentation due to their complexity and
    unique tools. Let’s end this section with code that combines what has been discussed
    so far:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 数据收集结构（数组和数据帧）将在后续章节中讨论，因为它们由于复杂性和独特工具的原因需要深入介绍。让我们以结合到目前为止所讨论内容的代码结束这一部分：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Control Flow
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流
- en: Conditional statements form the first part of what is known as *control flow*
    (the second part is *loops*, discussed shortly). *Conditional statements* are
    the ancestors of today’s artificial intelligence as they only execute code if
    certain conditions are met.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句构成了所谓*控制流*的第一部分（第二部分是稍后讨论的*循环*）。*条件语句*作为今天人工智能的祖先，只有在满足特定条件时才执行代码。
- en: 'Conditional statements are managed using `if`, `elif`, and `else`. Take the
    following code snippet as an example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`if`、`elif`和`else`来管理条件语句。以下代码片段是一个例子：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Therefore, conditional statements start with `if`. Then, for every new unique
    and specific condition, `elif` is used (which is a fusion of *else if*), until
    it makes sense to use the rest of the probability universe as a condition on its
    own, which is used by the `else` statement. Note that the `else` statement does
    not need a condition, as it exists to cover the rest of the uncovered universe.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，条件语句以`if`开始。然后，针对每个新的唯一和特定条件，使用`elif`（它是*else if*的融合），直到使用其余的概率宇宙作为独立的条件是有意义的，这是由`else`语句使用的。请注意，`else`语句不需要条件，因为它存在的目的是覆盖未覆盖的其余部分。
- en: '*Loops* are used to execute blocks of code repeatedly until a predefined condition
    is met. Loops are heavily used with time series to calculate indicators, verify
    states, and backtest trading strategies.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*循环*用于重复执行代码块，直到满足预定义条件。循环在时间序列中广泛用于计算指标、验证状态和回测交易策略。'
- en: 'Loops are managed using `for` (for iterating over a finite and defined sequence
    or a range of elements) and `while` (used to continue the iteration until a condition
    is met) statements. For example, the following code prints the values `{1, 2,
    3, 4}` using a loop:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`for`（用于迭代有限和定义的序列或一系列元素）和`while`（用于在满足条件之前继续迭代）语句管理循环。例如，以下代码使用循环打印值`{1,
    2, 3, 4}`：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `for` loop when translated is simply saying that for every element called
    `i` (or any other letter depending on the coder) in the range that starts at 1
    and ends at 5 (excluded), print the value of `i` at every loop (hence, in the
    first loop the value of `i` is equal to 1, and in the second loop it is equal
    to 2).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译后的`for`循环简单地表示，对于范围从1开始到5（不包括）的每个元素`i`（或任何其他字母，取决于编码器），在每次循环中打印`i`的值（因此，在第一次循环中，`i`的值为1，在第二次循环中，其值为2）。
- en: The `while` loop says that, starting from a value of `i = 1`, while looping,
    print its value and then add 1 to it before finishing the first loop. End the
    loop when `i` becomes greater than 4.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环表示从`i = 1`开始，循环时打印其值，然后在完成第一次循环前将其加1。当`i`变大于4时结束循环。'
- en: Note
  id: totrans-81
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Theoretically, a `while` loop is infinite until told otherwise.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，`while`循环是无限的，直到另有指示。
- en: 'It is worth noting that `i = i + 1` can also be expressed as `i += 1`. The
    goal of an algorithm is the ability to apply many operations recursively in an
    objective way, which makes loops extremely useful, especially when combined with
    conditional statements. Let’s look at an example of a financial time series:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`i = i + 1`也可以表达为`i += 1`。算法的目标是以客观的方式递归地应用许多操作，这使得循环结合条件语句尤其有用。让我们看一个金融时间序列的例子：
- en: Create a range of values to simulate hypothetical prices.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一系列数值以模拟假设价格。
- en: Loop through the range of the data while creating the condition that if the
    price rose since the preceding period, print 1\. Similarly, if the price fell
    since the preceding period, print –1\. Last, print 0 if the price didn’t change
    from the preceding period.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环数据范围内循环，创建条件：如果价格自上一时期以来上涨，则打印1。类似地，如果价格自上一时期以来下跌，则打印-1。最后，如果价格与上一时期相同，则打印0。
- en: 'This can be done with the following code block:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下代码块完成：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code defines a list of values (in this case, a time series called `time_series`),
    then loops around its length using the `len()` function to apply the conditions.
    Notice how at every loop, the current time step is referred to as `i`, thus making
    the previous time step `i – 1`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码定义了一个值列表（在本例中是一个称为`time_series`的时间序列），然后使用`len()`函数循环其长度以应用条件。请注意，在每个循环中，当前时间步被称为`i`，因此使得前一个时间步为`i
    – 1`。
- en: Libraries and Functions
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库和函数
- en: A *library* in Python is a group of prewritten code that offers functionality
    to facilitate the creation of applications. *Modules*, which are individual Python
    files with reusable code and data that can be imported and used in other Python
    code, are commonly found in libraries. A module is therefore a single Python file
    that contains functions and other types of code that may be used and imported
    by other Python programs. Large codebases are often easier to manage and maintain
    by using modules to divide similar code into different files.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，*库*是一组预写代码，提供功能以便于创建应用程序。*模块*是独立的Python文件，包含可重复使用的代码和数据，可以被导入和在其他Python代码中使用，这在库中很常见。因此，模块是一个包含函数和其他类型代码的单个Python文件，可以被其他Python程序使用和导入。通过使用模块将相似的代码分成不同的文件，通常可以更轻松和有效地管理和维护大型代码库。
- en: Coding is all about simplifying tasks and making them clearer. Functions are
    essential in this regard. A *function* is a block of reusable code that performs
    a specific task when called. It only needs to be defined once. When you have a
    recurring task such as calculating a moving average of a time series, you can
    use a function so that you do not have to write the moving-average code all over
    again every time you want to use it. Instead, you define the function with the
    original code and then call it whenever you need to calculate the moving average.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 编程就是简化任务并使其更清晰的过程。函数在这方面至关重要。*函数*是一段可重复使用的代码块，在调用时执行特定任务。它只需要定义一次。例如，当您有一个重复的任务，比如计算时间序列的移动平均值时，可以使用函数，这样您就不必每次想使用它时都重新编写移动平均代码。相反，您定义函数与原始代码，然后在需要计算移动平均时调用它。
- en: Multiple functions form a module, and multiple modules form a library. A library
    is generally theme oriented. For example, in this book the *sklearn* library will
    be used with machine learning models. Similarly, data manipulation and importing
    are done using *numpy* and *pandas*, two libraries discussed in a later section
    of this chapter. Plotting and charting are done using the *matplotlib* library.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 多个函数形成一个模块，多个模块形成一个库。一个库通常是主题导向的。例如，在本书中，*sklearn*库将与机器学习模型一起使用。类似地，数据处理和导入使用两个后面章节中讨论的库*numpy*和*pandas*。绘图和制图使用*matplotlib*库完成。
- en: 'Libraries must be imported to the Python interpreter before you can use them
    (this is the equivalent of acknowledging their existence). The syntax for doing
    this is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用之前必须将库导入Python解释器（这相当于承认它们的存在）。这样做的语法如下：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Sometimes you need to import just one function or module from a library. For
    this, you don’t need to import the entire library:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您只需要从库中导入一个函数或模块。为此，您不需要导入整个库：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding code says that *math* is a Python library that harbors many mathematical
    functions, namely the `sqrt` function, which is used to find the square root of
    a given number.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码说明了*math*是一个Python库，包含许多数学函数，特别是用于找出给定数字的平方根的`sqrt`函数。
- en: 'Let’s see how to define a function. A function is defined using `def` followed
    by the name of the function and any optional arguments. The following example
    creates a function that sums any two given variables:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何定义一个函数。使用`def`后跟函数名和任何可选参数来定义函数。以下示例创建了一个函数，用于对任意两个给定变量求和：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-100
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '*Calling* a function means executing what it’s supposed to do. In other words,
    calling a function is simply using it. The timeline of a function is getting defined
    and then getting called.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用*函数意味着执行其预期功能。换句话说，调用函数就是简单地使用它。函数的时间轴是定义和调用。'
- en: 'Let’s see how to import a function from a library and use its functions:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何从库中导入一个函数并使用其功能：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As a side note, the *factorial* operation is a mathematical operation that is
    used to calculate the product of all positive integers from 1 up to a certain
    number (which is the argument requested in `math.factorial()`).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，*阶乘*操作是一种数学操作，用于计算从1到某个数字（这是`math.factorial()`中请求的参数）的所有正整数的乘积。
- en: 'Libraries may not be as easy as one plus one. Sometimes external libraries
    require installation first before they can be imported to the Python interpreter.
    Installation can be done through the prompt using the following syntax:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 库可能不像1加1那么容易。有时，需要先安装外部库，然后才能将其导入Python解释器。安装可以通过命令提示符使用以下语法完成：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Recall [Chapter 3](ch03.html#ch03), where the maximal information coefficient
    (MIC) was discussed. To calculate the MIC, you can use the following code (after
    having defined the sine and cosine waves):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾[第三章](ch03.html#ch03)，讨论了最大信息系数（MIC）。要计算MIC，可以使用以下代码（在定义正弦和余弦波之后）。
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Importing the library directly will likely lead to an error as it has not been
    `pip` installed. Therefore, you must install the library first using the following
    syntax at the prompt (not in the Python interpreter):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 直接导入库可能会导致错误，因为它尚未通过`pip`安装。因此，您必须首先使用提示符安装库，语法如下（不在Python解释器中）：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You may need to update Microsoft Visual C++ (to version 14.0 or greater) to
    avoid any errors in trying to run the *minepy* library.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要更新Microsoft Visual C++（至少到版本14.0）以避免在尝试运行*minepy*库时出现任何错误。
- en: It is also important to read the documentation that comes with libraries in
    order to use them correctly. A library’s documentation will explain the aim of
    the functions as well as what types of arguments each function can accept (e.g.,
    strings or numerics).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要仔细阅读库随附的文档，以便正确使用它们。库的文档将解释函数的目的，以及每个函数可以接受的参数类型（例如，字符串或数字）。
- en: Let’s return now to the topic of functions. A function can have a `return` statement
    that allows the result to be stored in a variable so that it can be used in other
    parts of the code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到函数的主题。函数可以有一个`return`语句，允许将结果存储在变量中，以便在代码的其他部分中使用。
- en: 'Let’s take two simple examples and then discuss them step by step:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举两个简单的例子，然后逐步讨论它们：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The previous code defines the `sum_operation` function with two arguments,
    then stores the operation in a variable called `final_sum` before returning it
    so that it can be stored externally. Next, a new variable called `summed_value`
    is defined as the output of the function. Finally, another variable is created,
    `double_summed_value`, that is the result of `summed_value` multiplied by 2\.
    This is an example of how to use results from functions as variables in external
    operations. Now let’s consider an example of a nested function (while keeping
    in mind the previously defined `sum_operation` function):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码定义了一个名为`sum_operation`的函数，该函数接受两个参数，然后将操作存储在一个名为`final_sum`的变量中，然后将其返回，以便可以在外部存储它。接下来，定义了一个名为`summed_value`的新变量，它作为函数的输出。最后，创建了另一个变量`double_summed_value`，它是`summed_value`乘以2的结果。这是如何在外部操作中使用函数结果作为变量的示例。现在让我们考虑一个嵌套函数的例子（请记住之前定义的`sum_operation`函数）：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding code snippet defines a function called `square_summed_value`,
    which takes on two arguments. Furthermore, it uses a nested function, which in
    this case is `sum_operation`. The result of the nested function is once again
    stored in a variable called `final_sum`, which is used as an input in finding
    the `squared_sum` variable. The variable is found as `final_sum` to the power
    of two.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段定义了一个名为`square_summed_value`的函数，它接受两个参数。此外，它使用了一个嵌套函数，在本例中是`sum_operation`。嵌套函数的结果再次存储在一个名为`final_sum`的变量中，该变量作为在找到`squared_sum`变量时的输入。该变量以`final_sum`的平方的形式找到。
- en: 'Let’s end the section with common libraries in Python and machine learning
    (other than *numpy* and *pandas*):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们结束Python和机器学习中常见库的部分（除了*numpy*和*pandas*）：
- en: '*matplotlib*: For plotting and visualizing data'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*matplotlib*：用于绘制和可视化数据'
- en: '*sklearn*: For machine learning models'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*sklearn*：用于机器学习模型'
- en: '*scipy*: For scientific computing and optimization'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*scipy*：用于科学计算和优化'
- en: '*keras*: For neural networks'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*keras*：用于神经网络'
- en: '*math*: For using mathematical tools such as square roots'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*math*：用于使用数学工具，如平方根'
- en: '*random*: For generating random variables'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*random*：用于生成随机变量'
- en: '*requests*: For making HTTP requests used in web scraping'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*requests*：用于进行网页抓取的HTTP请求'
- en: Exception Handling and Errors
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理和错误
- en: 'Quite often, errors occur when the code is executed and the interpreter finds
    an obstacle that prevents it from continuing further. The most basic error is
    the `SyntaxError`, which occurs when there are misspelled words or missing elements
    that make the code unintelligible:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，当代码执行时出现错误，并且解释器遇到阻止其进一步执行的障碍时会发生错误。最基本的错误是`SyntaxError`，当单词拼写错误或缺少使代码无法理解的元素时会发生：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see from the previous code, there is a missing parenthesis at the
    end of the second code line, which is not understood by the interpreter. This
    type of error is likely to be your most common one. Another common error is the
    `NameError`, which occurs when failing to define a variable before executing a
    code that contains it. Consider the following example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码可以看出，第二行代码末尾缺少括号，解释器无法理解。这种类型的错误可能是您最常见的错误之一。另一个常见错误是`NameError`，当在执行包含它的代码之前未定义变量时会发生。考虑以下示例：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The previous code will give you a `NameError` because the interpreter does not
    know the value of `x` and `y` since they were not defined.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于解释器不知道`x`和`y`的值，因为它们没有定义，上述代码将给您一个`NameError`。
- en: 'The `ModuleNotFoundError` occurs when the interpreter cannot find the library
    or module you are trying to import. This generally occurs when the module or library
    is installed in a bad directory or when it is not properly installed. Common fixes
    for this issue include:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当解释器无法找到您尝试导入的库或模块时，将发生`ModuleNotFoundError`。这通常发生在库或模块安装在错误的目录或未正确安装时。解决此问题的常见方法包括：
- en: Verifying that the module’s name was written correctly
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证模块的名称是否正确写入
- en: Verifying that the module was correctly `pip` installed
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证模块是否正确`pip`安装
- en: Verifying that the module was installed in the correct location
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证模块是否安装在正确的位置
- en: 'Another type of common error is the `TypeError`, and it occurs when you apply
    a certain operation on an incompatible element, such as summing an integer with
    a string. The following operation raises a `TypeError`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见错误类型是`TypeError`，当您在不兼容的元素上应用某个操作时会发生，例如将整数与字符串相加。以下操作会引发`TypeError`：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In time series analysis, you will likely to encounter these four errors:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间序列分析中，您可能会遇到以下四种错误：
- en: '`IndexError`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`IndexError`'
- en: This is raised when referring to an index that is out of range regarding the
    current array or dataframe. Imagine having an array of 300 values (rows). If you
    want to loop through them and, at each loop, input the number 1 in the next cell
    (time step + 1), the interpreter will raise an `IndexError` because in the last
    loop there is no next cell.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当引用当前数组或数据框超出范围的索引时，将引发此错误。想象一下，有一个包含300个值（行）的数组。如果您想循环遍历它们，并在每个循环中在下一个单元格（时间步长+1）中输入数字1，那么解释器将引发`IndexError`，因为在最后一个循环中没有下一个单元格。
- en: '`ValueError`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValueError`'
- en: This is raised when you try to call a function with an invalid argument. An
    example of this would be trying to pass an integer element as a string when calling
    a function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试用无效参数调用函数时，将引发此错误。例如，试图在调用函数时将整数元素作为字符串传递。
- en: '`KeyError`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyError`'
- en: This occurs when trying to access an element in a dataframe that does not exist.
    For example, if you have three columns in the dataframe and you refer to one that
    does not exist (maybe due to a syntax issue), you are likely to run into a `KeyError`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试访问不存在的数据框中的元素时会发生这种情况。例如，如果数据框中有三列，并且您引用一个不存在的列（可能由于语法问题），那么您可能会遇到`KeyError`。
- en: '`ZeroDivisionError`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`ZeroDivisionError`'
- en: This error is intuitive and occurs when trying to divide a number by zero.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误很直观，在试图除以零时发生。
- en: There are other types of errors that you may encounter. It is important to understand
    what they refer to so that you are able to fix them and get the code running again.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会遇到其他类型的错误。重要的是要理解它们指的是什么，以便能够修复它们并使代码再次运行。
- en: '*Exceptions* are errors that may not be fatal to the code in the sense that
    they only show a warning but don’t necessarily terminate the code. Therefore,
    exceptions occur during code execution (as opposed to errors, which occur because
    the interpreter is unable to execute the code). To ignore certain exceptions (and
    errors), the `try`  and `except` keywords are used. This is useful when you are
    certain that handling the exception will not alter the output of the code.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*异常* 是可能不会致命到代码的错误，因为它们只是显示一个警告，但不一定终止代码。因此，异常发生在代码执行期间（与错误相反，错误是因为解释器无法执行代码而发生的）。要忽略某些异常（和错误），使用
    `try` 和 `except` 关键字。当你确信处理异常不会改变代码的输出时，这是很有用的。'
- en: 'Let’s take an example of creating a function that divides the first column
    of a time series by the next value of the second column. The first step is to
    define the time series as a dataframe or as an array (or any other data collection
    structure):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以创建一个将时间序列的第一列除以第二列的下一个值为例。第一步是将时间序列定义为数据框或数组（或任何其他数据收集结构）：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now let’s write the division function that will take any value in the first
    column and divide it by the next value in the second column:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写一个除法函数，它将获取第一列中的任何值，并将其除以第二列中的下一个值：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Running the two previous code blocks will give an `IndexError` because in the
    last loop, the function cannot find the next value of the second column since
    it does not exist:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前两个代码块将会产生一个 `IndexError`，因为在最后一个循环中，函数找不到第二列的下一个值，因为它不存在：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Fixing this through `try` and `except` will ignore the last calculation that
    is causing the problem and will return the expected results:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `try` 和 `except` 来修复这个问题将忽略导致问题的最后一次计算，并返回期望的结果：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output is as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Data Structures in numpy and pandas
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: numpy 和 pandas 中的数据结构
- en: 'You now understand what a library is and know that *numpy* and *pandas* are
    the go-to libraries to manipulate, handle, and import data in Python. This section
    discusses the differences between the two, along with key functions that are definitely
    a great addition to your data analysis toolbox. But first, let’s define these
    two libraries:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在了解了什么是库，并且知道 *numpy* 和 *pandas* 是在 Python 中操作、处理和导入数据的首选库。本节讨论了两者之间的区别，以及绝对是您数据分析工具箱中的重要功能。但首先，让我们定义这两个库：
- en: '*numpy*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*numpy*'
- en: Short for numerical Python, *numpy* is a Python library that allows working
    with multidimensional arrays and matrices. It provides a powerful  interface for
    performing various operations on arrays and matrices.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*numpy* 是 Numerical Python 的缩写，是一个允许使用多维数组和矩阵的 Python 库。它提供了一个强大的接口，用于对数组和矩阵执行各种操作。'
- en: '*pandas*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*pandas*'
- en: 'Short for panel data, *pandas* is a Python library that allows working with
    dataframes (a type of tabular data). It provides two main data structures: series
    and dataframes. A *series* is a one-dimensional array-like object that can hold
    any data type. A *dataframe* is a two-dimensional table-like structure that consists
    of rows and columns (similar to a spreadsheet).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*pandas* 是 Panel Data 的缩写，是一个允许使用数据框（一种类型的表格数据）的 Python 库。它提供了两种主要的数据结构：series
    和 dataframes。*series* 是一个类似数组的一维对象，可以保存任何数据类型。*dataframe* 是一个二维表格状结构，由行和列组成（类似于电子表格）。'
- en: Both libraries are very useful in analyzing time series data. Arrays hold only
    numerical type data and therefore do not really hold date type data. This may
    be one of the advantages of using *pandas* over *numpy*, but both have strengths
    and relative weaknesses. In the end, it is a matter of choice. This book will
    prioritize using *numpy* due to its simplicity and the fact that the machine learning
    models in the next chapter use the *sklearn* library, which is applied on arrays.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个库在分析时间序列数据方面非常有用。数组仅保存数值类型数据，因此实际上不保存日期类型数据。这可能是使用 *pandas* 而不是 *numpy* 的优点之一，但两者都有各自的优势和相对的弱点。最终，这是一个选择问题。本书将优先使用
    *numpy*，因为它简单，并且下一章中的机器学习模型使用 *sklearn* 库，该库应用于数组。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Switching between *numpy* and *pandas* requires converting the time series type.
    This is a relatively easy task, but it can sometimes cause the loss of certain
    types of data (e.g., date data).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *numpy* 和 *pandas* 之间切换需要转换时间序列类型。这是一个相对简单的任务，但有时可能会导致某些类型数据的丢失（例如，日期数据）。
- en: 'Let’s import both libraries before discussing some of their potential:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论它们的潜力之前，让我们导入这两个库：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following code creates two time series with two columns and three rows.
    The first time series is called `my_data_frame` and is created using the *pandas*
    library function `pd.DataFrame`. The second time series is called `my_array` and
    is created using the *numpy* library function `np.array`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了两个具有两列和三行的时间序列。第一个时间序列称为`my_data_frame`，使用*pandas*库函数`pd.DataFrame`创建。第二个时间序列称为`my_array`，使用*numpy*库函数`np.array`创建：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As shown in [Figure 6-2](#figure-6-2), dataframes have real indices and can
    have column names. Arrays can only hold one type of data.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如图[6-2](#figure-6-2)所示，数据框具有真实的索引，可以有列名。数组只能容纳一种数据类型。
- en: '![](assets/dlff_0602.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dlff_0602.png)'
- en: Figure 6-2\. A *pandas* dataframe (left) and a *numpy* array (right)
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-2。*pandas*数据框（左）和*numpy*数组（右）
- en: 'To switch between the two types of data, you will be using the same two functions
    used in the previous code block:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要在这两种类型的数据之间切换，您将使用前面代码块中使用的相同两个函数：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let’s now take a look at useful functions that will come in handy when dealing
    with models. Slicing and concatenation are among the processes you must master
    to smoothly navigate through data analysis. Consider the following arrays:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看在处理模型时会非常有用的一些函数。切片和连接是您必须掌握的过程之一，以便在数据分析中顺利导航。考虑以下数组：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Concatenation* is the act of fusing two datasets together either through rows
    (axis = 0) or through columns (axis = 1). Let’s do both of them:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*连接*是将两个数据集合并在一起的行为，可以通过行（axis = 0）或列（axis = 1）来进行。让我们都来做一下：'
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now let’s do the same thing for dataframes. Consider the following dataframes:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们对数据框做同样的事情。考虑以下数据框：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Concatenation is useful when you want to combine data into one structure. This
    is how it can be done with dataframes (notice that it’s simply a change of syntax
    and function source):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当您希望将数据合并为一个结构时，连接非常有用。这是如何在数据框中完成的（请注意，这只是语法和函数源的简单更改）：
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Remember that with time series, *rows* (horizontal cells) represent one time
    step (e.g., hourly) with all the data inside, while *columns* represent the different
    types of data (e.g., open price and close price of a financial instrument). Now
    let’s see slicing techniques for arrays:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，对于时间序列，*行*（水平单元格）代表一个时间步（例如，每小时），其中包含所有的数据，而*列*则代表不同类型的数据（例如，金融工具的开盘价和收盘价）。现在让我们看看数组的切片技术：
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-189
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to know that Python indexing starts at zero. This means that
    to refer to the first element in a data structure, you refer to its index as index
    = 0\. It is also worth noting that in ranges, the last element is excluded, which
    means that the first three elements in a data structure are referred to as `[0,
    3]`, which will give the elements indexed at 0, 1, and 2.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，Python的索引从零开始。这意味着要引用数据结构中的第一个元素，您需要将其索引为 index = 0。值得注意的是，在范围内，最后一个元素是被排除的，这意味着数据结构中的前三个元素被称为
    `[0, 3]`，这将给出索引为0、1和2的元素。
- en: 'Let’s see the same thing for dataframes so that this section becomes a sort
    of mini reference whenever you want to manipulate data structures:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看数据框的同样的事情，这样当您想要操作数据结构时，这节就会成为一种迷你参考：
- en: '[PRE45]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note
  id: totrans-193
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Try going back to the earlier chapters to execute the code given there. You
    should have a more solid understanding by now.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试回到前面的章节执行那里提供的代码。现在你应该有更加牢固的理解了。
- en: Importing Financial Time Series in Python
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中导入金融时间序列
- en: This section discusses a key aspect of deploying machine and deep learning algorithms.
    It deals with the historical OHLC data that is needed to run the models and evaluate
    their performance.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了部署机器和深度学习算法的关键方面。它涉及到运行模型和评估其性能所需的历史OHLC数据。
- en: 'The first step is to prepare the environment and everything else necessary
    for the success of the algorithms. For this, you need two programs:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是准备算法成功所需的环境和其他一切。为此，您需要两个程序：
- en: A Python interpreter that you use to write and execute code. You already completed
    this step.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您用来编写和执行代码的Python解释器。您已经完成了这一步骤。
- en: Charting and financial software that you use as a database. This part is covered
    in this section.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您用作数据库的制图和金融软件。本节涵盖了这部分内容。
- en: For charting benchmarks, I use MetaTrader 5, a program used by many traders
    around the globe. MetaTrader 5 works with Spyder, so you should start by downloading
    Spyder and familiarizing yourself with how it works.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 用于制定基准图表的是MetaTrader 5，这是全球许多交易员使用的程序。MetaTrader 5与Spyder一起工作，因此您应该先下载Spyder并熟悉其工作方式。
- en: From the [official website](https://oreil.ly/YlNWu), download and install MetaTrader
    5\. You need to create a demo account, which is simply a virtual account with
    imaginary money. The word *demo* does not refer to a limited duration of use but
    to the fact that it is not using real money.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [官方网站](https://oreil.ly/YlNWu) 下载并安装 MetaTrader 5\. 你需要创建一个演示账户，这只是一个带有虚拟货币的虚拟账户。单词 *demo* 并不是指使用的时间有限，而是指它不使用真实货币。
- en: To open an account, select File > Open an Account, choose MetaQuotes Software
    Corp, and then click Next. Then choose the first option to open a demo account;
    this will let you trade virtual money. Finally, enter some basic information such
    as your name, email, and account type. You will not receive a verification request
    or any type of confirmation as the demo should launch directly, allowing you to
    see the charts.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要开设账户，请选择 文件 > 开设账户，选择 MetaQuotes Software Corp，然后点击下一步。然后选择第一个选项开设演示账户；这将允许你交易虚拟货币。最后，输入一些基本信息，如你的姓名、电子邮件和账户类型。你将不会收到验证请求或任何类型的确认，因为演示应直接启动，让你查看图表。
- en: '[Figure 6-3](#figure-6-3) shows the platform’s interface. By default, MetaTrader
    5 does not show all the markets it covers, so you need to make them accessible
    for import and visualization if necessary. Click View, click Market Watch, and
    then right-click any of the symbols shown in the new tab and choose Show All.
    This way, you can see the extended list with more markets.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](#figure-6-3) 展示了平台的界面。默认情况下，MetaTrader 5 并不显示其覆盖的所有市场，因此，如果需要导入和可视化，你需要使其可访问。点击
    View，点击 Market Watch，然后右键点击任何新标签中显示的符号，并选择 Show All。这样，你可以看到更多市场的扩展列表。'
- en: 'Before you can start coding, you need to install the MetaTrader 5 Python integration
    library so that you can use it later in Spyder. This is easy and requires one
    step. Open the Anaconda prompt and type:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始编码之前，你需要安装 MetaTrader 5 Python 集成库，以便稍后在 Spyder 中使用它。这很简单，只需一步。打开 Anaconda
    提示符，输入：
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Installation is the bridge that allows you to use Python modules and functions
    designed for MetaTrader 5 in the interpreter.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 安装是让你在解释器中使用为 MetaTrader 5 设计的 Python 模块和函数的桥梁。
- en: '![](assets/dlff_0603.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dlff_0603.png)'
- en: Figure 6-3\. MetaTrader 5 interface
  id: totrans-208
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-3\. MetaTrader 5 界面
- en: 'The following code block uses the `import` built-in statement, which calls
    for internal (self-created) or external (created by third parties) libraries.
    You’ll recall that a library is a store of functions, and thus, you need to import
    the libraries that are pertinent to what you want to do. For demonstration purposes,
    import the following modules, packages, and libraries:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块使用了内置语句 `import`，该语句调用了内部（自创建）或外部（第三方创建）的库。你会记得库是函数的存储库，因此，你需要导入与你想要做的事情相关的库。为了演示目的，导入以下模块、包和库：
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The next step is to create the universe of the time frames that you will be
    able to import. Even though I will be showing you how to analyze and backtest
    hourly data, you can define a wider universe, as shown in the following code snippet:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建你可以导入的时间框架的宇宙。尽管我将向你展示如何分析和回测小时数据，你可以定义一个更广泛的宇宙，如下面的代码片段所示：
- en: '[PRE48]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note
  id: totrans-213
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The full code is found in this book’s [GitHub repository](https://oreil.ly/5YGHI)
    under the name *master_function.py.*
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码可在本书的 [GitHub 仓库](https://oreil.ly/5YGHI) 中找到，名称为 *master_function.py*。
- en: A *time frame* is the frequency with which you record the prices. With hourly
    data, you will record the last price printed every hour. This means that in a
    day, you can have up to 24 hourly prices. This allows you to see the intraday
    evolution of the price. The aim is to record the totality of the OHLC data within
    a specific period.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*时间框架* 是你记录价格频率的方式。使用小时数据时，你将每小时记录最后一个价格。这意味着在一天内，你可以有多达 24 个小时价格。这允许你查看价格的日内演变。目标是在特定期间内记录全部的
    OHLC 数据。'
- en: 'The following code defines the current time, which is used so that the algorithm
    has a reference point when importing the data. Basically, you are creating a variable
    that stores the current time and date:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码定义了当前时间，这样算法在导入数据时就有了一个参考点。基本上，你正在创建一个存储当前时间和日期的变量：
- en: '[PRE49]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let’s now proceed to defining the universe of the financial instruments you
    want to backtest. In this book, the backtests will be done exclusively on the
    foreign exchange (FX) market. So let’s create a variable that stores some key
    currency pairs:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们继续定义您想要进行回测的金融工具的全集。在本书中，回测将专注于外汇市场（FX）。因此，让我们创建一个变量来存储一些关键的货币对：
- en: '[PRE50]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now that you have your time and asset variables ready, all you need to do is
    create the structure of the importing algorithm. The `get_quotes()` function does
    this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已准备好时间和资产变量，只需创建导入算法的结构。函数`get_quotes()`完成此任务：
- en: '[PRE51]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Notice that in the `get_quotes()` function, you use the *pytz* and *pandas*
    libraries. The function starts by defining the Olson time zone,^([2](ch06.html#id594))
    which you can set yourself. Here is a brief, nonexhaustive list of what you can
    enter depending on your time zone:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`get_quotes()`函数中，您使用了*pytz*和*pandas*库。该函数首先定义了Olson时区，^([2](ch06.html#id594))您可以自行设置。以下是一个简要的、不详尽的时间区域列表，根据您的时区，您可以输入以下内容：
- en: '[PRE52]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next define two variables called `time_from` and `time_to`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来定义两个名为`time_from`和`time_to`的变量：
- en: The `time_from` variable contains the `datetime` referring to the beginning
    of the import date (e.g., 01-01-2020).
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量`time_from`包含指向导入日期开始的`datetime`（例如，2020年01月01日）。
- en: The `time_to` variable contains the `datetime` referring to the end of the import
    date, which uses the `now` variable to represent the current time and date.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量`time_to`包含指向导入日期结束的`datetime`，它使用变量`now`表示当前时间和日期。
- en: 'The next step is to create a variable that imports the financial data using
    the time periods you have specified. This is done through the `rates` variable
    using the `mt5.copy_rates_range()` function. Finally, using *pandas*, transform
    the data into a dataframe. The final function required for the importing process
    is the `mass_import()` function. It lets you choose the time frame using the variable
    and then uses the `get_quotes()` function to import the data and format it to
    an array. The following code snippet defines the `mass_import()` function:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个变量，使用您指定的时间段导入金融数据。通过`rates`变量使用`mt5.copy_rates_range()`函数完成。最后，使用*pandas*将数据转换为数据框。导入过程所需的最终函数是`mass_import()`函数。它允许您使用变量选择时间范围，然后使用`get_quotes()`函数导入和格式化数据到数组。以下代码片段定义了`mass_import()`函数：
- en: '[PRE53]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `mass_import()` function automatically converts the dataframe into an array,
    so you do not have to worry about conversion when using the automatic import.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`mass_import()`自动将数据框转换为数组，因此在使用自动导入时无需担心转换问题。
- en: Note
  id: totrans-230
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You may need to adjust the year argument higher to get the data in case you
    have an empty array. For instance, if you get an empty array using the `mass_import()` function,
    try putting a more recent year in the `get_quotes()` function (“2014” instead
    of “2013”).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`mass_import()`函数时出现空数组，可能需要将年份参数调整得更高，以获取数据。例如，如果在`mass_import()`函数中得到空数组，尝试在`get_quotes()`函数中使用更新一些的年份（“2014”而不是“2013”）。
- en: 'To import the historical hourly EURUSD data from the beginning of 2014 to date,
    you may type the following (assuming `get_quotes()`, `now`, the frames, and the
    libraries are already defined):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入从2014年初至今的历史小时级EURUSD数据，可以键入以下内容（假设已经定义了`get_quotes()`、`now`、数据框和相关库）：
- en: '[PRE54]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note
  id: totrans-234
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Notice how the `return` statement is used in the `mass_import` function to store
    the historical data in chosen variables.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`mass_import`函数中如何使用`return`语句将历史数据存储在选择的变量中。
- en: Even though there is a macOS version of MetaTrader 5, the Python library only
    works on Windows. It requires a Windows emulator on macOS. For macOS or Linux
    users, you may want to try the manual import method (or the alternative way proposed
    in [Chapter 7](ch07.html#ch07) that uses a library called *pandas-datareader*).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管MetaTrader 5有macOS版本，但Python库只在Windows上运行。在macOS或Linux上，您可能需要尝试手动导入方法（或者在[第7章](ch07.html#ch07)中提出的使用*pandas-datareader*库的替代方法）。
- en: Automatic import is a huge time-saver, but even Windows users may run into frustrating
    errors. Therefore, I will show you the manual import method, which you can use
    as a fix. On the [Github page](https://oreil.ly/5YGHI) for this book, you will
    find a folder called *Historical Data*. Inside the folder there is a selection
    of historical financial time series in Excel format that you can download.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 自动导入是一个巨大的时间节省器，但即使是Windows用户也可能遇到令人沮丧的错误。因此，我将向你展示手动导入的方法，这可以作为解决方法。在本书的[Github页面](https://oreil.ly/5YGHI)上，你会找到一个名为*Historical
    Data*的文件夹。文件夹内包含一系列以Excel格式存储的历史金融时间序列，可以下载。
- en: Manual import requires an Excel file with OHLC data that you have downloaded
    from a third party (such as the Excel files provided in this book’s GitHub repository).
    In this case, you can use the *pandas* library to import it and transform it into
    an array.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 手动导入需要一个包含从第三方下载的OHLC数据的Excel文件（例如本书GitHub存储库中提供的Excel文件）。在这种情况下，你可以使用*pandas*库来导入并将其转换为数组。
- en: Let’s take an example of *Daily_GBPUSD_Historical_Data.xlsx**.* Download the
    file from the repository (found in *Historical Data*) and store it on your desktop.
    The Spyder directory must be in the same place as the file. In layperson’s terms,
    this means Spyder must search your desktop for the Excel file. To choose the right
    directory, click the folder button next to the arrow. The Directory tab should
    look like [Figure 6-4](#figure-6-4).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以*Daily_GBPUSD_Historical_Data.xlsx**.*为例。从存储库（在*Historical Data*中找到）下载文件并存储在桌面上。Spyder目录必须与文件处于同一位置。通俗地讲，这意味着Spyder必须在你的桌面上搜索Excel文件。要选择正确的目录，点击箭头旁边的文件夹按钮。目录选项卡应该看起来像[图 6-4](#figure-6-4)。
- en: '![](assets/dlff_0604.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dlff_0604.png)'
- en: Figure 6-4\. The Directory tab after choosing the correct folder
  id: totrans-241
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-4\. 选择正确文件夹后的目录选项卡
- en: You should get a separate window where you can choose the desktop location and
    then validate the choice. Having done this, the tab should look like [Figure 6-5](#figure-6-5).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会得到一个单独的窗口，你可以在其中选择桌面位置，然后验证选择。完成这些步骤后，选项卡应该看起来像[图 6-5](#figure-6-5)。
- en: '![](assets/dlff_0605.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dlff_0605.png)'
- en: Figure 6-5\. The Directory tab after choosing the correct desktop location
  id: totrans-244
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-5\. 选择正确桌面位置后的目录选项卡
- en: 'You use the `read_excel()` function (built into *pandas* and accessible after
    importing it) to get the values inside the Excel file. Follow this syntax:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用内置于*pandas*中的`read_excel()`函数来获取Excel文件中的值。按照以下语法操作：
- en: '[PRE55]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You should have a dataframe called *Daily_GBPUSD_Historical_Data.xlsx* with
    five different columns representing open, high, low, and close prices. You generally
    have to enter the library’s name before using a function that belongs to it; this
    is why `read_excel()` is preceded by `pd`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该有一个名为*Daily_GBPUSD_Historical_Data.xlsx*的数据框，其中包含五列，分别代表开盘价、最高价、最低价和收盘价。通常在使用属于它的函数之前，你必须输入库的名称；这就是为什么`read_excel()`之前要加上`pd`的原因。
- en: Note
  id: totrans-248
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: I recommend using automatic import for Windows users and manual import for macOS
    users due to compatibility issues.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 由于兼容性问题，我建议Windows用户使用自动导入，而macOS用户使用手动导入。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: Python, a major star among coding languages, enjoys widespread adoption by the
    developer community. Mastering it is key to unlocking huge potential in the data
    science world.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Python，作为编程语言中的主要明星，得到了开发者社区的广泛采纳。掌握它对于开启数据科学领域的巨大潜力至关重要。
- en: The next chapter discusses machine learning and different prediction algorithms.
    The main aim is to be able to code the algorithms and run a backtest over financial
    data. You will see that once you start understanding the process, it becomes a
    matter of removing one algorithm and plugging another one in (in case they have
    the same assumptions). The warm-up chapters are over, and it’s time to start coding.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论机器学习和不同的预测算法。主要目标是能够编写这些算法并在金融数据上运行回测。你会发现，一旦开始理解这个过程，只需移除一个算法并插入另一个（如果它们具有相同的假设），就能轻松应对。热身章节结束了，现在是时候开始编程了。
- en: ^([1](ch06.html#id561-marker)) Imaginary numbers are a type of complex number
    that represents the square root of a negative number.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch06.html#id561-marker)) 虚数是一种表示负数平方根的复数类型。
- en: ^([2](ch06.html#id594-marker)) Named after its creator, Arthur David Olson,
    the Olson time zone addresses issues related to time zone data and daylight saving
    time rules. It has been an essential resource for developers and computer systems
    to accurately handle time-related functions and conversions.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch06.html#id594-marker)) 这个 Olson 时区命名自其创建者阿瑟·大卫·奥尔森，处理与时区数据和夏令时规则相关的问题。对于开发人员和计算机系统来说，它是处理时间相关功能和转换的重要资源。
