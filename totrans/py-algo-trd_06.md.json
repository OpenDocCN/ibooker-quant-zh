["```py\n    def __init__(self, symbol, start, end, amount,\n                 ftc=0.0, ptc=0.0, verbose=True):\n        self.symbol = symbol\n        self.start = start\n        self.end = end\n        self.initial_amount = amount  ![1](assets/1.png)\n        self.amount = amount  ![2](assets/2.png)\n        self.ftc = ftc  ![3](assets/3.png)\n        self.ptc = ptc  ![4](assets/4.png)\n        self.units = 0  ![5](assets/5.png)\n        self.position = 0  ![6](assets/6.png)\n        self.trades = 0  ![7](assets/7.png)\n        self.verbose = verbose  ![8](assets/8.png)\n        self.get_data()\n```", "```py\n    def get_data(self):\n        ''' Retrieves and prepares the data.\n '''\n        raw = pd.read_csv('http://hilpisch.com/pyalgo_eikon_eod_data.csv',\n                          index_col=0, parse_dates=True).dropna()\n        raw = pd.DataFrame(raw[self.symbol])\n        raw = raw.loc[self.start:self.end]\n        raw.rename(columns={self.symbol: 'price'}, inplace=True)\n        raw['return'] = np.log(raw / raw.shift(1))\n        self.data = raw.dropna()\n```", "```py\n    def plot_data(self, cols=None):\n        ''' Plots the closing prices for symbol.\n '''\n        if cols is None:\n            cols = ['price']\n        self.data['price'].plot(figsize=(10, 6), title=self.symbol)\n```", "```py\n    def get_date_price(self, bar):\n        ''' Return date and price for bar.\n '''\n        date = str(self.data.index[bar])[:10]\n        price = self.data.price.iloc[bar]\n        return date, price\n```", "```py\n    def print_balance(self, bar):\n        ''' Print out current cash balance info.\n '''\n        date, price = self.get_date_price(bar)\n        print(f'{date} | current balance {self.amount:.2f}')\n\n    def print_net_wealth(self, bar):\n        ''' Print out current cash balance info.\n '''\n        date, price = self.get_date_price(bar)\n        net_wealth = self.units * price + self.amount\n        print(f'{date} | current net wealth {net_wealth:.2f}')\n```", "```py\n    def place_buy_order(self, bar, units=None, amount=None):\n        ''' Place a buy order.\n        '''\n        date, price = self.get_date_price(bar)  ![1](assets/1.png)\n        if units is None:  ![2](assets/2.png)\n            units = int(amount / price)  ![3](assets/3.png)\n        self.amount -= (units * price) * (1 + self.ptc) + self.ftc  ![4](assets/4.png)\n        self.units += units  ![5](assets/5.png)\n        self.trades += 1  ![6](assets/6.png)\n        if self.verbose:  ![7](assets/7.png)\n            print(f'{date} | selling {units} units at {price:.2f}')  ![8](assets/8.png)\n            self.print_balance(bar)  ![9](assets/9.png)\n            self.print_net_wealth(bar)  ![10](assets/10.png)\n```", "```py\n    def place_sell_order(self, bar, units=None, amount=None):\n        ''' Place a sell order.\n        '''\n        date, price = self.get_date_price(bar)\n        if units is None:\n            units = int(amount / price)\n        self.amount += (units * price) * (1 - self.ptc) - self.ftc  ![1](assets/1.png)\n        self.units -= units  ![2](assets/2.png)\n        self.trades += 1\n        if self.verbose:\n            print(f'{date} | selling {units} units at {price:.2f}')\n            self.print_balance(bar)\n            self.print_net_wealth(bar)\n```", "```py\n    def close_out(self, bar):\n        ''' Closing out a long or short position.\n        '''\n        date, price = self.get_date_price(bar)\n        self.amount += self.units * price  ![1](assets/1.png)\n        self.units = 0\n        self.trades += 1\n        if self.verbose:\n            print(f'{date} | inventory {self.units} units at {price:.2f}')\n            print('=' * 55)\n        print('Final balance   [$] {:.2f}'.format(self.amount))  ![2](assets/2.png)\n        perf = ((self.amount - self.initial_amount) /\n                self.initial_amount * 100)\n        print('Net Performance [%] {:.2f}'.format(perf))  ![3](assets/3.png)\n        print('Trades Executed [#] {:.2f}'.format(self.trades))  ![3](assets/3.png)\n        print('=' * 55)\n```", "```py\nif __name__ == '__main__':\n    bb = BacktestBase('AAPL.O', '2010-1-1', '2019-12-31', 10000)\n    print(bb.data.info())\n    print(bb.data.tail())\n    bb.plot_data()\n```", "```py\nIn [1]: %run BacktestBase.py\n<class 'pandas.core.frame.DataFrame'>\nDatetimeIndex: 2515 entries, 2010-01-05 to 2019-12-31\nData columns (total 2 columns):\n #   Column  Non-Null Count  Dtype\n---  ------  --------------  -----\n 0   price   2515 non-null   float64\n 1   return  2515 non-null   float64\ndtypes: float64(2)\nmemory usage: 58.9 KB\nNone\n             price    return\nDate\n2019-12-24  284.27  0.000950\n2019-12-26  289.91  0.019646\n2019-12-27  289.80 -0.000380\n2019-12-30  291.52  0.005918\n2019-12-31  293.65  0.007280\n\nIn [2]:\n```", "```py\n    def run_mean_reversion_strategy(self, SMA, threshold):\n        ''' Backtesting a mean reversion-based strategy.\n\n        Parameters\n        ==========\n        SMA: int\n            simple moving average in days\n        threshold: float\n            absolute value for deviation-based signal relative to SMA\n        '''\n        msg = f'\\n\\nRunning mean reversion strategy | '\n        msg += f'SMA={SMA} & thr={threshold}'\n        msg += f'\\nfixed costs {self.ftc} | '\n        msg += f'proportional costs {self.ptc}'\n        print(msg)  ![1](assets/1.png)\n        print('=' * 55)\n        self.position = 0  ![2](assets/2.png)\n        self.trades = 0  ![2](assets/2.png)\n        self.amount = self.initial_amount  ![3](assets/3.png)\n\n        self.data['SMA'] = self.data['price'].rolling(SMA).mean()  ![4](assets/4.png)\n\n        for bar in range(SMA, len(self.data)):  ![5](assets/5.png)\n            if self.position == 0:  ![6](assets/6.png)\n                if (self.data['price'].iloc[bar] <\n                        self.data['SMA'].iloc[bar] - threshold):  ![7](assets/7.png)\n                    self.place_buy_order(bar, amount=self.amount)  ![8](assets/8.png)\n                    self.position = 1  ![9](assets/9.png)\n            elif self.position == 1:  ![10](assets/10.png)\n                if self.data['price'].iloc[bar] >= self.data['SMA'].iloc[bar]:  ![11](assets/11.png)\n                    self.place_sell_order(bar, units=self.units)  ![12](assets/12.png)\n                    self.position = 0  ![13](assets/13.png)\n        self.close_out(bar)  ![14](assets/14.png)\n```", "```py\nRunning SMA strategy | SMA1=42 & SMA2=252\nfixed costs 0.0 | proportional costs 0.0\n=======================================================\nFinal balance   [$] 56204.95\nNet Performance [%] 462.05\n=======================================================\n\nRunning momentum strategy | 60 days\nfixed costs 0.0 | proportional costs 0.0\n=======================================================\nFinal balance   [$] 136716.52\nNet Performance [%] 1267.17\n=======================================================\n\nRunning mean reversion strategy | SMA=50 & thr=5\nfixed costs 0.0 | proportional costs 0.0\n=======================================================\nFinal balance   [$] 53907.99\nNet Performance [%] 439.08\n=======================================================\n\nRunning SMA strategy | SMA1=42 & SMA2=252\nfixed costs 10.0 | proportional costs 0.01\n=======================================================\nFinal balance   [$] 51959.62\nNet Performance [%] 419.60\n=======================================================\n\nRunning momentum strategy | 60 days\nfixed costs 10.0 | proportional costs 0.01\n=======================================================\nFinal balance   [$] 38074.26\nNet Performance [%] 280.74\n=======================================================\n\nRunning mean reversion strategy | SMA=50 & thr=5\nfixed costs 10.0 | proportional costs 0.01\n=======================================================\nFinal balance   [$] 15375.48\nNet Performance [%] 53.75\n=======================================================\n```", "```py\n    def go_long(self, bar, units=None, amount=None):  ![1](assets/1.png)\n        if self.position == -1:  ![2](assets/2.png)\n            self.place_buy_order(bar, units=-self.units)  ![3](assets/3.png)\n        if units:  ![4](assets/4.png)\n            self.place_buy_order(bar, units=units)  ![5](assets/5.png)\n        elif amount:  ![6](assets/6.png)\n            if amount == 'all':  ![7](assets/7.png)\n                amount = self.amount  ![8](assets/8.png)\n            self.place_buy_order(bar, amount=amount)  ![9](assets/9.png)\n\n    def go_short(self, bar, units=None, amount=None):\n        if self.position == 1:\n            self.place_sell_order(bar, units=self.units)\n        if units:\n            self.place_sell_order(bar, units=units)\n        elif amount:\n            if amount == 'all':\n                amount = self.amount\n            self.place_sell_order(bar, amount=amount)\n```", "```py\n        for bar in range(SMA, len(self.data)):\n            if self.position == 0:  ![1](assets/1.png)\n                if (self.data['price'].iloc[bar] <\n                        self.data['SMA'].iloc[bar] - threshold):  ![2](assets/2.png)\n                    self.go_long(bar, amount=self.initial_amount)  ![3](assets/3.png)\n                    self.position = 1  ![4](assets/4.png)\n                elif (self.data['price'].iloc[bar] >\n                        self.data['SMA'].iloc[bar] + threshold):  ![5](assets/5.png)\n                    self.go_short(bar, amount=self.initial_amount)\n                    self.position = -1  ![6](assets/6.png)\n            elif self.position == 1:  ![7](assets/7.png)\n                if self.data['price'].iloc[bar] >= self.data['SMA'].iloc[bar]:  ![8](assets/8.png)\n                    self.place_sell_order(bar, units=self.units)  ![9](assets/9.png)\n                    self.position = 0  ![10](assets/10.png)\n            elif self.position == -1:  ![11](assets/11.png)\n                if self.data['price'].iloc[bar] <= self.data['SMA'].iloc[bar]:  ![12](assets/12.png)\n                    self.place_buy_order(bar, units=-self.units)  ![13](assets/13.png)\n                    self.position = 0  ![14](assets/14.png)\n        self.close_out(bar)\n```", "```py\nRunning SMA strategy | SMA1=42 & SMA2=252\nfixed costs 0.0 | proportional costs 0.0\n=======================================================\nFinal balance   [$] 45631.83\nNet Performance [%] 356.32\n=======================================================\n\nRunning momentum strategy | 60 days\nfixed costs 0.0 | proportional costs 0.0\n=======================================================\nFinal balance   [$] 105236.62\nNet Performance [%] 952.37\n=======================================================\n\nRunning mean reversion strategy | SMA=50 & thr=5\nfixed costs 0.0 | proportional costs 0.0\n=======================================================\nFinal balance   [$] 17279.15\nNet Performance [%] 72.79\n=======================================================\n\nRunning SMA strategy | SMA1=42 & SMA2=252\nfixed costs 10.0 | proportional costs 0.01\n=======================================================\nFinal balance   [$] 38369.65\nNet Performance [%] 283.70\n=======================================================\n\nRunning momentum strategy | 60 days\nfixed costs 10.0 | proportional costs 0.01\n=======================================================\nFinal balance   [$] 6883.45\nNet Performance [%] -31.17\n=======================================================\n\nRunning mean reversion strategy | SMA=50 & thr=5\nfixed costs 10.0 | proportional costs 0.01\n=======================================================\nFinal balance   [$] -5110.97\nNet Performance [%] -151.11\n=======================================================\n```", "```py\n#\n# Python Script with Base Class\n# for Event-Based Backtesting\n#\n# Python for Algorithmic Trading\n# (c) Dr. Yves J. Hilpisch\n# The Python Quants GmbH\n#\nimport numpy as np\nimport pandas as pd\nfrom pylab import mpl, plt\nplt.style.use('seaborn')\nmpl.rcParams['font.family'] = 'serif'\n\nclass BacktestBase(object):\n    ''' Base class for event-based backtesting of trading strategies.\n\n Attributes\n ==========\n symbol: str\n TR RIC (financial instrument) to be used\n start: str\n start date for data selection\n end: str\n end date for data selection\n amount: float\n amount to be invested either once or per trade\n ftc: float\n fixed transaction costs per trade (buy or sell)\n ptc: float\n proportional transaction costs per trade (buy or sell)\n\n Methods\n =======\n get_data:\n retrieves and prepares the base data set\n plot_data:\n plots the closing price for the symbol\n get_date_price:\n returns the date and price for the given bar\n print_balance:\n prints out the current (cash) balance\n print_net_wealth:\n prints out the current net wealth\n place_buy_order:\n places a buy order\n place_sell_order:\n places a sell order\n close_out:\n closes out a long or short position\n '''\n\n    def __init__(self, symbol, start, end, amount,\n                 ftc=0.0, ptc=0.0, verbose=True):\n        self.symbol = symbol\n        self.start = start\n        self.end = end\n        self.initial_amount = amount\n        self.amount = amount\n        self.ftc = ftc\n        self.ptc = ptc\n        self.units = 0\n        self.position = 0\n        self.trades = 0\n        self.verbose = verbose\n        self.get_data()\n\n    def get_data(self):\n        ''' Retrieves and prepares the data.\n '''\n        raw = pd.read_csv('http://hilpisch.com/pyalgo_eikon_eod_data.csv',\n                          index_col=0, parse_dates=True).dropna()\n        raw = pd.DataFrame(raw[self.symbol])\n        raw = raw.loc[self.start:self.end]\n        raw.rename(columns={self.symbol: 'price'}, inplace=True)\n        raw['return'] = np.log(raw / raw.shift(1))\n        self.data = raw.dropna()\n\n    def plot_data(self, cols=None):\n        ''' Plots the closing prices for symbol.\n '''\n        if cols is None:\n            cols = ['price']\n        self.data['price'].plot(figsize=(10, 6), title=self.symbol)\n\n    def get_date_price(self, bar):\n        ''' Return date and price for bar.\n '''\n        date = str(self.data.index[bar])[:10]\n        price = self.data.price.iloc[bar]\n        return date, price\n\n    def print_balance(self, bar):\n        ''' Print out current cash balance info.\n '''\n        date, price = self.get_date_price(bar)\n        print(f'{date} | current balance {self.amount:.2f}')\n\n    def print_net_wealth(self, bar):\n        ''' Print out current cash balance info.\n '''\n        date, price = self.get_date_price(bar)\n        net_wealth = self.units * price + self.amount\n        print(f'{date} | current net wealth {net_wealth:.2f}')\n\n    def place_buy_order(self, bar, units=None, amount=None):\n        ''' Place a buy order.\n '''\n        date, price = self.get_date_price(bar)\n        if units is None:\n            units = int(amount / price)\n        self.amount -= (units * price) * (1 + self.ptc) + self.ftc\n        self.units += units\n        self.trades += 1\n        if self.verbose:\n            print(f'{date} | selling {units} units at {price:.2f}')\n            self.print_balance(bar)\n            self.print_net_wealth(bar)\n\n    def place_sell_order(self, bar, units=None, amount=None):\n        ''' Place a sell order.\n '''\n        date, price = self.get_date_price(bar)\n        if units is None:\n            units = int(amount / price)\n        self.amount += (units * price) * (1 - self.ptc) - self.ftc\n        self.units -= units\n        self.trades += 1\n        if self.verbose:\n            print(f'{date} | selling {units} units at {price:.2f}')\n            self.print_balance(bar)\n            self.print_net_wealth(bar)\n\n    def close_out(self, bar):\n        ''' Closing out a long or short position.\n '''\n        date, price = self.get_date_price(bar)\n        self.amount += self.units * price\n        self.units = 0\n        self.trades += 1\n        if self.verbose:\n            print(f'{date} | inventory {self.units} units at {price:.2f}')\n            print('=' * 55)\n        print('Final balance   [$] {:.2f}'.format(self.amount))\n        perf = ((self.amount - self.initial_amount) /\n                self.initial_amount * 100)\n        print('Net Performance [%] {:.2f}'.format(perf))\n        print('Trades Executed [#] {:.2f}'.format(self.trades))\n        print('=' * 55)\n\nif __name__ == '__main__':\n    bb = BacktestBase('AAPL.O', '2010-1-1', '2019-12-31', 10000)\n    print(bb.data.info())\n    print(bb.data.tail())\n    bb.plot_data()\n```", "```py\n#\n# Python Script with Long Only Class\n# for Event-Based Backtesting\n#\n# Python for Algorithmic Trading\n# (c) Dr. Yves J. Hilpisch\n# The Python Quants GmbH\n#\nfrom BacktestBase import *\n\nclass BacktestLongOnly(BacktestBase):\n\n    def run_sma_strategy(self, SMA1, SMA2):\n        ''' Backtesting an SMA-based strategy.\n\n Parameters\n ==========\n SMA1, SMA2: int\n shorter and longer term simple moving average (in days)\n '''\n        msg = f'\\n\\nRunning SMA strategy | SMA1={SMA1} & SMA2={SMA2}'\n        msg += f'\\nfixed costs {self.ftc} | '\n        msg += f'proportional costs {self.ptc}'\n        print(msg)\n        print('=' * 55)\n        self.position = 0  # initial neutral position\n        self.trades = 0  # no trades yet\n        self.amount = self.initial_amount  # reset initial capital\n        self.data['SMA1'] = self.data['price'].rolling(SMA1).mean()\n        self.data['SMA2'] = self.data['price'].rolling(SMA2).mean()\n\n        for bar in range(SMA2, len(self.data)):\n            if self.position == 0:\n                if self.data['SMA1'].iloc[bar] > self.data['SMA2'].iloc[bar]:\n                    self.place_buy_order(bar, amount=self.amount)\n                    self.position = 1  # long position\n            elif self.position == 1:\n                if self.data['SMA1'].iloc[bar] < self.data['SMA2'].iloc[bar]:\n                    self.place_sell_order(bar, units=self.units)\n                    self.position = 0  # market neutral\n        self.close_out(bar)\n\n    def run_momentum_strategy(self, momentum):\n        ''' Backtesting a momentum-based strategy.\n\n Parameters\n ==========\n momentum: int\n number of days for mean return calculation\n '''\n        msg = f'\\n\\nRunning momentum strategy | {momentum} days'\n        msg += f'\\nfixed costs {self.ftc} | '\n        msg += f'proportional costs {self.ptc}'\n        print(msg)\n        print('=' * 55)\n        self.position = 0  # initial neutral position\n        self.trades = 0  # no trades yet\n        self.amount = self.initial_amount  # reset initial capital\n        self.data['momentum'] = self.data['return'].rolling(momentum).mean()\n        for bar in range(momentum, len(self.data)):\n            if self.position == 0:\n                if self.data['momentum'].iloc[bar] > 0:\n                    self.place_buy_order(bar, amount=self.amount)\n                    self.position = 1  # long position\n            elif self.position == 1:\n                if self.data['momentum'].iloc[bar] < 0:\n                    self.place_sell_order(bar, units=self.units)\n                    self.position = 0  # market neutral\n        self.close_out(bar)\n\n    def run_mean_reversion_strategy(self, SMA, threshold):\n        ''' Backtesting a mean reversion-based strategy.\n\n Parameters\n ==========\n SMA: int\n simple moving average in days\n threshold: float\n absolute value for deviation-based signal relative to SMA\n '''\n        msg = f'\\n\\nRunning mean reversion strategy | '\n        msg += f'SMA={SMA} & thr={threshold}'\n        msg += f'\\nfixed costs {self.ftc} | '\n        msg += f'proportional costs {self.ptc}'\n        print(msg)\n        print('=' * 55)\n        self.position = 0\n        self.trades = 0\n        self.amount = self.initial_amount\n\n        self.data['SMA'] = self.data['price'].rolling(SMA).mean()\n\n        for bar in range(SMA, len(self.data)):\n            if self.position == 0:\n                if (self.data['price'].iloc[bar] <\n                        self.data['SMA'].iloc[bar] - threshold):\n                    self.place_buy_order(bar, amount=self.amount)\n                    self.position = 1\n            elif self.position == 1:\n                if self.data['price'].iloc[bar] >= self.data['SMA'].iloc[bar]:\n                    self.place_sell_order(bar, units=self.units)\n                    self.position = 0\n        self.close_out(bar)\n\nif __name__ == '__main__':\n    def run_strategies():\n        lobt.run_sma_strategy(42, 252)\n        lobt.run_momentum_strategy(60)\n        lobt.run_mean_reversion_strategy(50, 5)\n    lobt = BacktestLongOnly('AAPL.O', '2010-1-1', '2019-12-31', 10000,\n                            verbose=False)\n    run_strategies()\n    # transaction costs: 10 USD fix, 1% variable\n    lobt = BacktestLongOnly('AAPL.O', '2010-1-1', '2019-12-31',\n                            10000, 10.0, 0.01, False)\n    run_strategies()\n```", "```py\n#\n# Python Script with Long-Short Class\n# for Event-Based Backtesting\n#\n# Python for Algorithmic Trading\n# (c) Dr. Yves J. Hilpisch\n# The Python Quants GmbH\n#\nfrom BacktestBase import *\n\nclass BacktestLongShort(BacktestBase):\n\n    def go_long(self, bar, units=None, amount=None):\n        if self.position == -1:\n            self.place_buy_order(bar, units=-self.units)\n        if units:\n            self.place_buy_order(bar, units=units)\n        elif amount:\n            if amount == 'all':\n                amount = self.amount\n            self.place_buy_order(bar, amount=amount)\n\n    def go_short(self, bar, units=None, amount=None):\n        if self.position == 1:\n            self.place_sell_order(bar, units=self.units)\n        if units:\n            self.place_sell_order(bar, units=units)\n        elif amount:\n            if amount == 'all':\n                amount = self.amount\n            self.place_sell_order(bar, amount=amount)\n\n    def run_sma_strategy(self, SMA1, SMA2):\n        msg = f'\\n\\nRunning SMA strategy | SMA1={SMA1} & SMA2={SMA2}'\n        msg += f'\\nfixed costs {self.ftc} | '\n        msg += f'proportional costs {self.ptc}'\n        print(msg)\n        print('=' * 55)\n        self.position = 0  # initial neutral position\n        self.trades = 0  # no trades yet\n        self.amount = self.initial_amount  # reset initial capital\n        self.data['SMA1'] = self.data['price'].rolling(SMA1).mean()\n        self.data['SMA2'] = self.data['price'].rolling(SMA2).mean()\n\n        for bar in range(SMA2, len(self.data)):\n            if self.position in [0, -1]:\n                if self.data['SMA1'].iloc[bar] > self.data['SMA2'].iloc[bar]:\n                    self.go_long(bar, amount='all')\n                    self.position = 1  # long position\n            if self.position in [0, 1]:\n                if self.data['SMA1'].iloc[bar] < self.data['SMA2'].iloc[bar]:\n                    self.go_short(bar, amount='all')\n                    self.position = -1  # short position\n        self.close_out(bar)\n\n    def run_momentum_strategy(self, momentum):\n        msg = f'\\n\\nRunning momentum strategy | {momentum} days'\n        msg += f'\\nfixed costs {self.ftc} | '\n        msg += f'proportional costs {self.ptc}'\n        print(msg)\n        print('=' * 55)\n        self.position = 0  # initial neutral position\n        self.trades = 0  # no trades yet\n        self.amount = self.initial_amount  # reset initial capital\n        self.data['momentum'] = self.data['return'].rolling(momentum).mean()\n        for bar in range(momentum, len(self.data)):\n            if self.position in [0, -1]:\n                if self.data['momentum'].iloc[bar] > 0:\n                    self.go_long(bar, amount='all')\n                    self.position = 1  # long position\n            if self.position in [0, 1]:\n                if self.data['momentum'].iloc[bar] <= 0:\n                    self.go_short(bar, amount='all')\n                    self.position = -1  # short position\n        self.close_out(bar)\n\n    def run_mean_reversion_strategy(self, SMA, threshold):\n        msg = f'\\n\\nRunning mean reversion strategy | '\n        msg += f'SMA={SMA} & thr={threshold}'\n        msg += f'\\nfixed costs {self.ftc} | '\n        msg += f'proportional costs {self.ptc}'\n        print(msg)\n        print('=' * 55)\n        self.position = 0  # initial neutral position\n        self.trades = 0  # no trades yet\n        self.amount = self.initial_amount  # reset initial capital\n\n        self.data['SMA'] = self.data['price'].rolling(SMA).mean()\n\n        for bar in range(SMA, len(self.data)):\n            if self.position == 0:\n                if (self.data['price'].iloc[bar] <\n                        self.data['SMA'].iloc[bar] - threshold):\n                    self.go_long(bar, amount=self.initial_amount)\n                    self.position = 1\n                elif (self.data['price'].iloc[bar] >\n                        self.data['SMA'].iloc[bar] + threshold):\n                    self.go_short(bar, amount=self.initial_amount)\n                    self.position = -1\n            elif self.position == 1:\n                if self.data['price'].iloc[bar] >= self.data['SMA'].iloc[bar]:\n                    self.place_sell_order(bar, units=self.units)\n                    self.position = 0\n            elif self.position == -1:\n                if self.data['price'].iloc[bar] <= self.data['SMA'].iloc[bar]:\n                    self.place_buy_order(bar, units=-self.units)\n                    self.position = 0\n        self.close_out(bar)\n\nif __name__ == '__main__':\n    def run_strategies():\n        lsbt.run_sma_strategy(42, 252)\n        lsbt.run_momentum_strategy(60)\n        lsbt.run_mean_reversion_strategy(50, 5)\n    lsbt = BacktestLongShort('EUR=', '2010-1-1', '2019-12-31', 10000,\n                             verbose=False)\n    run_strategies()\n    # transaction costs: 10 USD fix, 1% variable\n    lsbt = BacktestLongShort('AAPL.O', '2010-1-1', '2019-12-31',\n                             10000, 10.0, 0.01, False)\n    run_strategies()\n```"]