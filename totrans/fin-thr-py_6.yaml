- en: Chapter 6\. Dynamic Economy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multiperiod models of securities markets are much more realistic than single
    period models. In fact, they are extensively used for practical purposes in the
    financial industry.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Stanley Pliska (1997)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although markets are not complete at any one time, they are dynamically complete
    in the sense that any consumption process can be financed by trading the given
    set of financial securities, adjusting portfolios through time as uncertainty
    is resolved bit by bit.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Darrell Duffie (1986)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In reality, quantitative information‚Äîsuch as changes in stock prices or interest
    rates‚Äîis revealed gradually over time. While static model economies are an elegant
    way of introducing fundamental notions in finance, a realistic financial model
    requires a dynamic representation of the financial world.
  prefs: []
  type: TYPE_NORMAL
- en: 'The formalism needed to properly model dynamic economies is more involved and
    cannot be covered in full detail in this chapter. However, the chapter can present
    two of the most important dynamic model economies based on discrete time dynamics:
    the Cox-Ross-Rubinstein (1979) binomial option pricing model and the Black-Scholes-Merton
    (1973) option pricing model in a discrete Monte Carlo simulation version. In this
    context, *discrete time* means that the set of relevant dates is extended from
    just two to a larger, but still finite, number‚Äîsay, to five or 50.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The tools used in this chapter are more or less the same as before: linear
    algebra, probability theory, and also, like in the previous chapter, stochastic
    elements to implement Monte Carlo simulation. Duffie (1988) and Pliska (1997)
    are great resources for dynamic financial modeling in discrete time. Glasserman
    (2004) is a comprehensive reference book for Monte Carlo simulation methods in
    finance.'
  prefs: []
  type: TYPE_NORMAL
- en: Topics covered in this chapter are stochastic processes, option pricing in dynamically
    complete markets, binomial option pricing, Black-Scholes-Merton (1973) dynamic
    simulation, early exercise and American option pricing, as well as Least-Squares
    Monte Carlo (LSM) option pricing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table gives an overview of the topics in finance, mathematics,
    and Python found in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Finance | Mathematics | Python |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Uncertainty, tree-based | Stochastic process, binomial tree | `NumPy`, `ndarray`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Uncertainty, simulation-based | Stochastic process, Monte Carlo simulation
    | `NumPy`, `ndarray`, `rng.standard_normal` |'
  prefs: []
  type: TYPE_TB
- en: '| European option pricing | Inner values, backward induction, risk-neutral
    expectation | `NumPy`, `ndarray`, `np.maximum` |'
  prefs: []
  type: TYPE_TB
- en: '| American option pricing | Inner values, continuation values, OLS regression,
    backward induction, risk-neutral expectation | `NumPy`, `ndarray`, `np.polyval`,
    `np.polyfit`, `np.where` |'
  prefs: []
  type: TYPE_TB
- en: As in [Chapter¬†5](ch05_split_000.xhtml#static_economy), the major goal of this
    chapter is *generalization*. While [Chapter¬†5](ch05_split_000.xhtml#static_economy)
    generalizes the *state space*, this chapter sets out to generalize the *discrete
    set of relevant points in time* at which new information is revealed and economic
    action takes place. While some additional formalism is needed to do so, the chapter
    is, on the other hand, less formal since it focuses on two specific models only
    and does not try to provide a general framework for dynamic economies in discrete
    time. Such a general framework, including many examples implemented in Python,
    is found in Hilpisch (2015).
  prefs: []
  type: TYPE_NORMAL
- en: Binomial Option Pricing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The binomial option pricing model became popular immediately after publication
    in 1979‚Äîboth as a numerically efficient method to price European options and American
    options as well as a teaching tool. While the Black-Scholes-Merton (1973) model
    relies on continuous time finance and stochastic calculus, the binomial option
    pricing model is, in a sense, a discrete time version of the BSM model that can
    be fully understood with elementary mathematics only.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Cox-Ross-Rubinstein (1979) model, there are two traded financial assets:
    a risky one, called *stock*, and a risk-less one, called *bond*. The model economy
    is considered over a *finite set of dates* <math alttext="script upper T identical-to
    StartSet t 0 equals 0 comma t 1 comma t 2 comma period period period comma t Subscript
    upper M Baseline equals upper T EndSet"><mrow><mi>ùíØ</mi> <mo>‚â°</mo> <mo>{</mo>
    <msub><mi>t</mi> <mn>0</mn></msub> <mo>=</mo> <mn>0</mn> <mo>,</mo> <msub><mi>t</mi>
    <mn>1</mn></msub> <mo>,</mo> <msub><mi>t</mi> <mn>2</mn></msub> <mo>,</mo> <mo>.</mo>
    <mo>.</mo> <mo>.</mo> <mo>,</mo> <msub><mi>t</mi> <mi>M</mi></msub> <mo>=</mo>
    <mi>T</mi> <mo>}</mo></mrow></math> , with <math alttext="upper M plus 1 comma
    upper M greater-than 1"><mrow><mi>M</mi> <mo>+</mo> <mn>1</mn> <mo>,</mo> <mi>M</mi>
    <mo>></mo> <mn>1</mn></mrow></math> elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a stock price of <math alttext="upper S Subscript t Sub Subscript i"><msub><mi>S</mi>
    <msub><mi>t</mi> <mi>i</mi></msub></msub></math> , the stock price at the next
    date <math alttext="upper S Subscript t Sub Subscript i plus 1"><msub><mi>S</mi>
    <msub><mi>t</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></msub></math>
    can only take on two different values:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper S Subscript t Sub Subscript i plus 1 Baseline equals StartLayout
    Enlarged left-brace 1st Row  upper S Subscript t Sub Subscript i Baseline dot
    u 2nd Row  upper S Subscript t Sub Subscript i Baseline dot d EndLayout" display="block"><mrow><msub><mi>S</mi>
    <msub><mi>t</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></msub> <mo>=</mo>
    <mfenced separators="" open="{" close=""><mtable><mtr><mtd columnalign="left"><mrow><msub><mi>S</mi>
    <msub><mi>t</mi> <mi>i</mi></msub></msub> <mo>¬∑</mo> <mi>u</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><msub><mi>S</mi> <msub><mi>t</mi> <mi>i</mi></msub></msub>
    <mo>¬∑</mo> <mi>d</mi></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="u"><mi>u</mi></math> stands for an *upward movement* and <math
    alttext="d"><mi>d</mi></math> for a *downward movement*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify the handling of dates, assume an evenly spaced time grid with <math
    alttext="upper M"><mi>M</mi></math> time intervals of length <math alttext="normal
    upper Delta t equals StartFraction upper T Over upper M EndFraction"><mrow><mi>Œî</mi>
    <mi>t</mi> <mo>=</mo> <mfrac><mi>T</mi> <mi>M</mi></mfrac></mrow></math> each.
    The finite set of dates can then be written as <math alttext="script upper T identical-to
    StartSet t 0 equals 0 comma t 1 equals normal upper Delta t comma t 2 equals 2
    normal upper Delta t comma period period period comma upper T EndSet"><mrow><mi>ùíØ</mi>
    <mo>‚â°</mo> <mo>{</mo> <msub><mi>t</mi> <mn>0</mn></msub> <mo>=</mo> <mn>0</mn>
    <mo>,</mo> <msub><mi>t</mi> <mn>1</mn></msub> <mo>=</mo> <mi>Œî</mi> <mi>t</mi>
    <mo>,</mo> <msub><mi>t</mi> <mn>2</mn></msub> <mo>=</mo> <mn>2</mn> <mi>Œî</mi>
    <mi>t</mi> <mo>,</mo> <mo>.</mo> <mo>.</mo> <mo>.</mo> <mo>,</mo> <mi>T</mi> <mo>}</mo></mrow></math>
    . In addition, define:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout Enlarged left-brace 1st Row  u identical-to e Superscript
    sigma StartRoot normal upper Delta t EndRoot Baseline 2nd Row  d identical-to
    e Superscript minus sigma StartRoot normal upper Delta t EndRoot Baseline equals
    u Superscript negative 1 EndLayout" display="block"><mfenced separators="" open="{"
    close=""><mtable><mtr><mtd columnalign="left"><mrow><mi>u</mi> <mo>‚â°</mo> <msup><mi>e</mi>
    <mrow><mi>œÉ</mi><msqrt><mrow><mi>Œî</mi><mi>t</mi></mrow></msqrt></mrow></msup></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>d</mi> <mo>‚â°</mo> <msup><mi>e</mi> <mrow><mo>-</mo><mi>œÉ</mi><msqrt><mrow><mi>Œî</mi><mi>t</mi></mrow></msqrt></mrow></msup>
    <mo>=</mo> <msup><mi>u</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></mtd></mtr></mtable></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that one consequence of this definition is the property <math alttext="u
    dot d equals 1"><mrow><mi>u</mi> <mo>¬∑</mo> <mi>d</mi> <mo>=</mo> <mn>1</mn></mrow></math>
    , which will prove convenient in that it creates a so-called *recombining* binomial
    tree. <math><mrow><mi>œÉ</mi><mo>‚àà</mo><msub><mi>‚Ñù</mi> <mrow><mn>>0</mn></mrow></msub></mrow></math>
    represents the constant *volatility factor*.
  prefs: []
  type: TYPE_NORMAL
- en: Assume that the risk-less, constant short rate is given by <math><mrow><mi>r</mi><mo>‚àà</mo><msub><mi>‚Ñù</mi>
    <mrow><mn>‚â•0</mn></mrow></msub></mrow></math> . Given a bond price of <math alttext="upper
    B Subscript t Sub Subscript i"><msub><mi>B</mi> <msub><mi>t</mi> <mi>i</mi></msub></msub></math>
    , the price of the bond one period later is given by
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper B Subscript t Sub Subscript i plus 1 Baseline equals upper
    B Subscript t Sub Subscript i Baseline dot e Superscript r dot left-parenthesis
    t Super Subscript i plus 1 Superscript minus t Super Subscript i Superscript right-parenthesis"
    display="block"><mrow><msub><mi>B</mi> <msub><mi>t</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></msub>
    <mo>=</mo> <msub><mi>B</mi> <msub><mi>t</mi> <mi>i</mi></msub></msub> <mo>¬∑</mo>
    <msup><mi>e</mi> <mrow><mi>r</mi><mo>¬∑</mo><mo>(</mo><msub><mi>t</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>-</mo><msub><mi>t</mi> <mi>i</mi></msub> <mo>)</mo></mrow></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper B Subscript t plus normal upper Delta t Baseline equals
    upper B Subscript t Baseline dot e Superscript r dot normal upper Delta t" display="block"><mrow><msub><mi>B</mi>
    <mrow><mi>t</mi><mo>+</mo><mi>Œî</mi><mi>t</mi></mrow></msub> <mo>=</mo> <msub><mi>B</mi>
    <mi>t</mi></msub> <mo>¬∑</mo> <msup><mi>e</mi> <mrow><mi>r</mi><mo>¬∑</mo><mi>Œî</mi><mi>t</mi></mrow></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: for some <math alttext="t element-of script upper T minus upper T"><mrow><mi>t</mi>
    <mo>‚àà</mo> <mi>ùíØ</mi> <mo>‚àñ</mo> <mi>T</mi></mrow></math> .
  prefs: []
  type: TYPE_NORMAL
- en: 'A central numerical parameter value to be derived, based on the preceding assumptions,
    is the martingale probability for an upward movement at any given node. Given
    that there are only two branches for every node, the downward probability is then
    known as well. Denote the *martingale probability* for an upward movement by <math><mrow><mi>q</mi><mo>‚àà</mo><msub><mi>‚Ñù</mi>
    <mrow><mn>>0</mn></mrow></msub> <mo>,</mo><mn>0</mn><mo><</mo><mi>q</mi><mo><</mo><mn>1</mn></mrow></math>.
    One gets from the martingale property for the stock price:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row 1st Column upper S Subscript t 2nd Column
    equals 3rd Column e Superscript minus r normal upper Delta t Baseline bold upper
    E Superscript upper Q Baseline left-parenthesis upper S Subscript t plus normal
    upper Delta t Baseline right-parenthesis 2nd Row 1st Column Blank 2nd Column equals
    3rd Column e Superscript minus r normal upper Delta t Baseline left-parenthesis
    q upper S Subscript t Baseline u plus left-parenthesis 1 minus q right-parenthesis
    upper S Subscript t Baseline d right-parenthesis 3rd Row 1st Column 1 2nd Column
    equals 3rd Column e Superscript minus r normal upper Delta t Baseline left-parenthesis
    q u plus left-parenthesis 1 minus q right-parenthesis d right-parenthesis 4th
    Row 1st Column q 2nd Column equals 3rd Column StartFraction e Superscript r normal
    upper Delta t Baseline minus d Over u minus d EndFraction EndLayout" display="block"><mtable><mtr><mtd><msub><mi>S</mi>
    <mi>t</mi></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><mrow><msup><mi>e</mi> <mrow><mo>-</mo><mi>r</mi><mi>Œî</mi><mi>t</mi></mrow></msup>
    <msup><mi>ùêÑ</mi> <mi>Q</mi></msup> <mrow><mo>(</mo> <msub><mi>S</mi> <mrow><mi>t</mi><mo>+</mo><mi>Œî</mi><mi>t</mi></mrow></msub>
    <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd><mo>=</mo></mtd> <mtd><mrow><msup><mi>e</mi>
    <mrow><mo>-</mo><mi>r</mi><mi>Œî</mi><mi>t</mi></mrow></msup> <mfenced separators=""
    open="(" close=")"><mi>q</mi> <msub><mi>S</mi> <mi>t</mi></msub> <mi>u</mi> <mo>+</mo>
    <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <mi>q</mi> <mo>)</mo></mrow> <msub><mi>S</mi>
    <mi>t</mi></msub> <mi>d</mi></mfenced></mrow></mtd></mtr> <mtr><mtd><mrow><mo>‚áî</mo>
    <mn>1</mn></mrow></mtd> <mtd><mo>=</mo></mtd> <mtd><mrow><msup><mi>e</mi> <mrow><mo>-</mo><mi>r</mi><mi>Œî</mi><mi>t</mi></mrow></msup>
    <mfenced separators="" open="(" close=")"><mi>q</mi> <mi>u</mi> <mo>+</mo> <mo>(</mo>
    <mn>1</mn> <mo>-</mo> <mi>q</mi> <mo>)</mo> <mi>d</mi></mfenced></mrow></mtd></mtr>
    <mtr><mtd><mrow><mo>‚áî</mo> <mi>q</mi></mrow></mtd> <mtd><mo>=</mo></mtd> <mtd><mfrac><mrow><msup><mi>e</mi>
    <mrow><mi>r</mi><mi>Œî</mi><mi>t</mi></mrow></msup> <mo>-</mo><mi>d</mi></mrow>
    <mrow><mi>u</mi><mo>-</mo><mi>d</mi></mrow></mfrac></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: This shows that the martingale measure is fixed at every node and consequently
    for the whole tree.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of the binomial option pricing model are easily translated into Python
    code:^([1](ch06.xhtml#idm44853685071096))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_dynamic_economy_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The initial stock price value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_dynamic_economy_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The strike price for the option to be valued.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_dynamic_economy_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The constant risk-less short rate.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_dynamic_economy_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The time horizon and option maturity.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_dynamic_economy_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The constant volatility factor.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_dynamic_economy_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The number of time intervals.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](#co_dynamic_economy_CO1-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting length of each time interval.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](Images/8.png)](#co_dynamic_economy_CO1-8)'
  prefs: []
  type: TYPE_NORMAL
- en: The discount factor for the fixed time interval.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](Images/9.png)](#co_dynamic_economy_CO1-9)'
  prefs: []
  type: TYPE_NORMAL
- en: The upward and downward factors.
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](Images/10.png)](#co_dynamic_economy_CO1-11)'
  prefs: []
  type: TYPE_NORMAL
- en: The martingale probability for an upward movement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simulation of the stock price process and the valuation of options in this
    model are a bit more involved. The following presents two different implementations:
    one based on *Python loops*, which might be easier to understand at the beginning,
    and one based on *vectorized* `NumPy` *code*, which is more concise and efficient,
    but may be a bit harder to grasp at first.'
  prefs: []
  type: TYPE_NORMAL
- en: Simulation and Valuation Based on Python Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even though the implementation in this subsection uses Python loops, the basic
    data structure is a `NumPy` `ndarray` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_dynamic_economy_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Initializes the `ndarray` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_dynamic_economy_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the initial stock price value in the upper-lefthand corner.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_dynamic_economy_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets a counter `z` to 1.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_dynamic_economy_CO2-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterates from `1` to `m+1`, that is, over all time steps after 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_dynamic_economy_CO2-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterates over the relevant nodes for the given time step.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_dynamic_economy_CO2-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Calculates the up and down values and sets them in the `ndarray` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](#co_dynamic_economy_CO2-10)'
  prefs: []
  type: TYPE_NORMAL
- en: Increases the counter by 1 to include more relevant nodes in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](Images/8.png)](#co_dynamic_economy_CO2-11)'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting recombining binomial tree.
  prefs: []
  type: TYPE_NORMAL
- en: European option pricing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The valuation of a European option based on the available stock price process
    happens by calculating the inner values of the option at maturity and applying
    *backward induction*. This basically means starting at the end, moving backward
    step by step to the present, and at every node repeatedly applying the risk-neutral
    pricing paradigm as introduced in the simple static two-state economy of [Chapter¬†2](ch02_split_000.xhtml#two_state_economy).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Python code assumes a European put option payoff:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_dynamic_economy_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `ndarray` object for the inner values.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_dynamic_economy_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This calculates the inner values for the relevant nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_dynamic_economy_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This does the node-wise valuation by applying risk-neutral pricing.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_dynamic_economy_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting present value binomial tree.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_dynamic_economy_CO3-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The present value today of the European put option.
  prefs: []
  type: TYPE_NORMAL
- en: American option pricing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the major features of the binomial option pricing model is that American
    options are as easily valued as their European counterparts. An *American option*
    can be exercised at any time *on and before* the maturity date. The adjustment
    to be made to the backward valuation algorithm is simple: one just needs to check
    whether the inner value of the American option is at any given node higher than
    the continuation value, that is, the present value of not exercising the option.
    If that is the case, the option is exercised, and the value of the American option
    is set to the inner value. Formally, one gets'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper V Subscript t Baseline equals max left-bracket h Subscript
    t Baseline comma e Superscript minus r normal upper Delta t Baseline bold upper
    E Superscript upper Q Baseline left-parenthesis upper V Subscript t plus normal
    upper Delta t Baseline right-parenthesis right-bracket" display="block"><mrow><msub><mi>V</mi>
    <mi>t</mi></msub> <mo>=</mo> <mo movablelimits="true" form="prefix">max</mo> <mfenced
    separators="" open="[" close="]"><msub><mi>h</mi> <mi>t</mi></msub> <mo>,</mo>
    <msup><mi>e</mi> <mrow><mo>-</mo><mi>r</mi><mi>Œî</mi><mi>t</mi></mrow></msup>
    <msup><mi>ùêÑ</mi> <mi>Q</mi></msup> <mrow><mo>(</mo> <msub><mi>V</mi> <mrow><mi>t</mi><mo>+</mo><mi>Œî</mi><mi>t</mi></mrow></msub>
    <mo>)</mo></mrow></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: where <math alttext="h Subscript t"><msub><mi>h</mi> <mi>t</mi></msub></math>
    is the inner value at time <math alttext="t"><mi>t</mi></math> , and <math alttext="e
    Superscript minus r normal upper Delta t Baseline bold upper E Superscript upper
    Q Baseline left-parenthesis upper V Subscript t plus normal upper Delta t Baseline
    right-parenthesis"><mrow><msup><mi>e</mi> <mrow><mo>-</mo><mi>r</mi><mi>Œî</mi><mi>t</mi></mrow></msup>
    <msup><mi>ùêÑ</mi> <mi>Q</mi></msup> <mrow><mo>(</mo> <msub><mi>V</mi> <mrow><mi>t</mi><mo>+</mo><mi>Œî</mi><mi>t</mi></mrow></msub>
    <mo>)</mo></mrow></mrow></math> is the continuation value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, a single line of code needs to be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_dynamic_economy_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This line checks for the early exercise decision and puts the inner value as
    the American option value when it is higher than the continuation value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_dynamic_economy_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting binomial tree for the present values of the American put option.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_dynamic_economy_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The present value today of the American put option, which is considerably higher
    than without early exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Simulation and Valuation Based on Vectorized Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The algorithm implementation that follows makes systematic use of `NumPy` vectorization
    capabilities. The implementation is presented step by step, also with some illustrating
    lines of code not needed for the algorithm implementation itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_dynamic_economy_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Creates an `ndarray` object for the number of upward movements from `0` to `m`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_dynamic_economy_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the squares by a vectorized operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_dynamic_economy_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the powers of 2 by using the `u` object as a vector exponent.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_dynamic_economy_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Resizes the `u` object from one dimension to two dimensions. The number of upward
    movements is now stored in each row.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_dynamic_economy_CO5-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Transposes the `u` object to get a two-dimensional `ndarray` object `d` with
    the number of downward movements in each column.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_dynamic_economy_CO5-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Combines the `u` and `d` objects to arrive at the net number of upward and downward
    movements. For instance, `+2` means ‚Äútwo more upward movements than downward movements‚Äù
    or `-1` means ‚Äúone more downward movement than upward movements.‚Äù^([2](ch06.xhtml#idm44853683423000))
  prefs: []
  type: TYPE_NORMAL
- en: 'Equipped with a matrix containing the net number of movements in the binomial
    tree, simulation of the stock price process boils down to a single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_dynamic_economy_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The vectorized simulation of the stock price process (binomial tree).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_dynamic_economy_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Only the numbers on and above the diagonal are relevant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The valuation of both the European and American put options is also vectorized
    to some extent. A single loop over the time steps remains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_dynamic_economy_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The calculation of the inner value of the put option, fully vectorized this
    time.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_dynamic_economy_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: As before, only the numbers on and above the diagonal are relevant.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_dynamic_economy_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a copy of the `h` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_dynamic_economy_CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The partly vectorized valuation algorithm for the European put option.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_dynamic_economy_CO7-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The present value of the European put option.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_dynamic_economy_CO7-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The partly vectorized valuation algorithm for the American put option.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](#co_dynamic_economy_CO7-10)'
  prefs: []
  type: TYPE_NORMAL
- en: The present value of the American put option.
  prefs: []
  type: TYPE_NORMAL
- en: European and American Options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The beauty of the (recombining) binomial option pricing model of Cox, Ross,
    and Rubinstein (1979) not only lies in its simplicity but also in the fact that
    it can be used to value both European options and American options with high accuracy
    in an efficient manner. In the limit, making time steps infinitely small, the
    model converges to the Black-Scholes-Merton (1973) model, which is another advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Speed Comparison
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Vectorizing code not only makes Python code more concise, but it generally
    allows for significant speed improvements. The following code snippets implement
    the previous algorithms for a speed comparison based on a larger, more realistic
    number of time steps. First, the basic numerical parameters need to be adjusted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_dynamic_economy_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Increases the number of time intervals to a realistic level, yielding rather
    accurate numerical option values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `binomial_looping()` integrates all elements of the *loop-based
    implementation* of the simulation and valuation algorithm for the American put
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution takes less than 200 milliseconds on the author‚Äôs computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `binomial_vectorization()` integrates all elements of the *vectorized
    implementation* of the simulation and valuation algorithm for the American put
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This implementation is about 40 times faster than the loop-based one, which
    impressively illustrates the power of vectorized implementation approaches in
    terms of performance improvements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Infrastructure and Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All absolute times reported here are dependent both on the hardware and software
    configuration used. For instance, you can use `NumPy` in combination with the
    [Math Kernel Library (MKL) from Intel](https://oreil.ly/dWyk9). This combination
    can significantly speed up numerical operations on Intel processor-based systems.
    Relative times and speed-up factors should be roughly similar on different infrastructures.
  prefs: []
  type: TYPE_NORMAL
- en: Black-Scholes-Merton Option Pricing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A static simulation version of the Black-Scholes-Merton (1973) model for option
    pricing is discussed in [Chapter¬†5](ch05_split_000.xhtml#static_economy). This
    section introduces a *dynamic simulation version* for their seminal option pricing
    model. For additional background information on the model, refer to [Chapter¬†5](ch05_split_000.xhtml#static_economy).
  prefs: []
  type: TYPE_NORMAL
- en: The stochastic differential equation for the Black-Scholes-Merton (1973) economy
    is given by
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="d upper S Subscript t Baseline equals r upper S Subscript t Baseline
    d t plus sigma upper S Subscript t Baseline d upper Z Subscript t" display="block"><mrow><mi>d</mi>
    <msub><mi>S</mi> <mi>t</mi></msub> <mo>=</mo> <mi>r</mi> <msub><mi>S</mi> <mi>t</mi></msub>
    <mi>d</mi> <mi>t</mi> <mo>+</mo> <mi>œÉ</mi> <msub><mi>S</mi> <mi>t</mi></msub>
    <mi>d</mi> <msub><mi>Z</mi> <mi>t</mi></msub></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: where <math><mrow><msub><mi>S</mi> <mi>t</mi></msub> <mo>‚àà</mo><msub><mi>‚Ñù</mi>
    <mrow><mn>>0</mn></mrow></msub></mrow></math> is the stock price at time <math
    alttext="t"><mi>t</mi></math> , <math><mrow><mi>r</mi><mo>‚àà</mo><msub><mi>‚Ñù</mi>
    <mrow><mn>‚â•0</mn></mrow></msub></mrow></math> is the constant short rate, <math><mrow><mi>œÉ</mi><mo>‚àà</mo><msub><mi>‚Ñù</mi>
    <mrow><mn>>0</mn></mrow></msub></mrow></math> is the constant volatility factor,
    and <math alttext="upper Z Subscript t"><msub><mi>Z</mi> <mi>t</mi></msub></math>
    is an arithmetic Brownian motion (see Glasserman (2004, chapter 3) and Hilpisch
    (2018, chapter 12)).
  prefs: []
  type: TYPE_NORMAL
- en: Monte Carlo Simulation of Stock Price Paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assume a finite set of relevant points in time <math alttext="script upper T
    identical-to StartSet t 0 equals 0 comma t 1 comma t 2 comma period period period
    comma t Subscript upper M Baseline equals upper T EndSet"><mrow><mi>ùíØ</mi> <mo>‚â°</mo>
    <mo>{</mo> <msub><mi>t</mi> <mn>0</mn></msub> <mo>=</mo> <mn>0</mn> <mo>,</mo>
    <msub><mi>t</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>t</mi> <mn>2</mn></msub>
    <mo>,</mo> <mo>.</mo> <mo>.</mo> <mo>.</mo> <mo>,</mo> <msub><mi>t</mi> <mi>M</mi></msub>
    <mo>=</mo> <mi>T</mi> <mo>}</mo></mrow></math> , with <math alttext="upper M plus
    1 comma upper M greater-than 1"><mrow><mi>M</mi> <mo>+</mo> <mn>1</mn> <mo>,</mo>
    <mi>M</mi> <mo>></mo> <mn>1</mn></mrow></math> , and a fixed interval length of
    <math alttext="normal upper Delta t"><mrow><mi>Œî</mi> <mi>t</mi></mrow></math>
    . The stock price <math alttext="upper S Subscript t Baseline comma 0 less-than
    t less-than-or-equal-to upper T"><mrow><msub><mi>S</mi> <mi>t</mi></msub> <mo>,</mo>
    <mn>0</mn> <mo><</mo> <mi>t</mi> <mo>‚â§</mo> <mi>T</mi></mrow></math> , given the
    previous stock price <math alttext="upper S Subscript t minus normal upper Delta
    t"><msub><mi>S</mi> <mrow><mi>t</mi><mo>-</mo><mi>Œî</mi><mi>t</mi></mrow></msub></math>
    , can then be simulated according to the difference equation
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper S Subscript t Baseline equals upper S Subscript t minus
    normal upper Delta t Baseline dot exp left-parenthesis left-parenthesis r minus
    StartFraction sigma squared Over 2 EndFraction right-parenthesis normal upper
    Delta t plus sigma StartRoot normal upper Delta t EndRoot z right-parenthesis"
    display="block"><mrow><msub><mi>S</mi> <mi>t</mi></msub> <mo>=</mo> <msub><mi>S</mi>
    <mrow><mi>t</mi><mo>-</mo><mi>Œî</mi><mi>t</mi></mrow></msub> <mo>¬∑</mo> <mo form="prefix">exp</mo>
    <mfenced separators="" open="(" close=")"><mfenced separators="" open="(" close=")"><mi>r</mi>
    <mo>-</mo> <mfrac><msup><mi>œÉ</mi> <mn>2</mn></msup> <mn>2</mn></mfrac></mfenced>
    <mi>Œî</mi> <mi>t</mi> <mo>+</mo> <mi>œÉ</mi> <msqrt><mrow><mi>Œî</mi> <mi>t</mi></mrow></msqrt>
    <mi>z</mi></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: where <math alttext="z"><mi>z</mi></math> is a standard normally distributed
    random variable. This scheme is called *Euler discretization*. It is known to
    be accurate in that it ensures convergence of the discrete time process to the
    continuous time process for <math alttext="normal upper Delta t"><mrow><mi>Œî</mi>
    <mi>t</mi></mrow></math> converging to 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dynamic Monte Carlo simulation is‚Äîwith the background knowledge from the
    static simulation in [Chapter¬†5](ch05_split_000.xhtml#static_economy)‚Äîstraightforward
    to implement in Python. [Figure¬†6-1](#bsm_dyn_01) shows 10 simulated stock price
    paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_dynamic_economy_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The financial parameters are as before.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_dynamic_economy_CO9-6)'
  prefs: []
  type: TYPE_NORMAL
- en: These are the Monte Carlo simulation parameters (paths, time steps, length of
    time interval, discount factor for single time interval).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_dynamic_economy_CO9-12)'
  prefs: []
  type: TYPE_NORMAL
- en: A two-dimensional `ndarray` object with standard normally distributed random
    numbers of appropriate size is generated.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_dynamic_economy_CO9-14)'
  prefs: []
  type: TYPE_NORMAL
- en: Another two-dimensional `ndarray` object of the same shape is instantiated,
    and the initial values for the single stock price paths are set.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_dynamic_economy_CO9-17)'
  prefs: []
  type: TYPE_NORMAL
- en: The single stock price paths are simulated based on the initial stock prices,
    the random number matrix, and the difference equation for the geometric Brownian
    motion.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_dynamic_economy_CO9-19)'
  prefs: []
  type: TYPE_NORMAL
- en: Plots the first 10 simulated paths.
  prefs: []
  type: TYPE_NORMAL
- en: '![ftwp 0601](Images/ftwp_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. Simulated stock price paths for Black-Scholes-Merton (1973)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As in the static case, the end-of-period values of the stock price can be visualized
    in the form of a histogram (see [Figure¬†6-2](#bsm_dyn_02)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_dynamic_economy_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Mathematically expected value for <math alttext="upper S Subscript upper T"><msub><mi>S</mi>
    <mi>T</mi></msub></math> .
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_dynamic_economy_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The average over all simulated values `ST`.
  prefs: []
  type: TYPE_NORMAL
- en: '![ftwp 0602](Images/ftwp_0602.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2\. Frequency distribution of simulated end-of-period stock prices
    for Black-Scholes-Merton (1973)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Monte Carlo Valuation of the European Put Option
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Monte Carlo estimator for the price of the European put option is
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P 0 equals e Superscript minus r upper T Baseline StartFraction
    1 Over upper I EndFraction sigma-summation Underscript i equals 1 Overscript upper
    I Endscripts max left-parenthesis upper K minus upper S Subscript upper T Baseline
    left-parenthesis i right-parenthesis comma 0 right-parenthesis" display="block"><mrow><msub><mi>P</mi>
    <mn>0</mn></msub> <mo>=</mo> <msup><mi>e</mi> <mrow><mo>-</mo><mi>r</mi><mi>T</mi></mrow></msup>
    <mfrac><mn>1</mn> <mi>I</mi></mfrac> <munderover><mo>‚àë</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>I</mi></munderover> <mo movablelimits="true" form="prefix">max</mo> <mrow><mo>(</mo>
    <mi>K</mi> <mo>-</mo> <msub><mi>S</mi> <mi>T</mi></msub> <mrow><mo>(</mo> <mi>i</mi>
    <mo>)</mo></mrow> <mo>,</mo> <mn>0</mn> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'where <math alttext="upper I"><mi>I</mi></math> is the number of simulated
    price paths. Against this background, European put option pricing boils down to
    a few lines of Python code only given the simulated stock price paths. [Figure¬†6-3](#bsm_dyn_03)
    shows a histogram of the simulated inner values at maturity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_dynamic_economy_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Calculates the inner values in vectorized fashion.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_dynamic_economy_CO11-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Plots the frequency distribution of the inner values at maturity, illustrating
    the highly asymmetric payoff that is typical for an option.^([3](ch06.xhtml#idm44853679632632))
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_dynamic_economy_CO11-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Calculates the average over all inner values and discounts the average to the
    present.
  prefs: []
  type: TYPE_NORMAL
- en: '![ftwp 0603](Images/ftwp_0603.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-3\. Frequency distribution of simulated inner values at maturity for
    the European put option
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Monte Carlo Valuation of the American Put Option
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The valuation of American (put) options based on Monte Carlo simulation is a
    bit more involved. The most popular algorithm in this regard is the *Least-Squares
    Monte Carlo* (LSM) algorithm from Longstaff and Schwartz (2001) because it is
    relatively simple and efficient to apply from a numerical and computational perspective.
    The scope of this chapter does not allow us to go into details. However, it allows
    us to present a concise, highly vectorized Python implementation. For an in-depth
    treatment of the LSM algorithm applied to the Black-Scholes-Merton (1973) model
    economy, including Python code, refer to Hilpisch (2015, chapter 7).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Python code implements the LSM algorithm for American option
    valuation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_dynamic_economy_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Calculates the inner values over the complete stock price path `ndarray` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_dynamic_economy_CO12-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the initial simulated American option price values to the inner values
    at maturity.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_dynamic_economy_CO12-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm also works based on backward induction, starting at <math alttext="upper
    T minus normal upper Delta t"><mrow><mi>T</mi> <mo>-</mo> <mi>Œî</mi> <mi>t</mi></mrow></math>
    and stopping at <math alttext="normal upper Delta t"><mrow><mi>Œî</mi> <mi>t</mi></mrow></math>
    .
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_dynamic_economy_CO12-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the central step of the algorithm during which the continuation values
    are estimated (approximated) based on the OLS regression of the present simulated
    option values against the stock price levels.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_dynamic_economy_CO12-6)'
  prefs: []
  type: TYPE_NORMAL
- en: If the inner value is higher than the estimated (approximated) continuation
    value, exercise takes place and otherwise not.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_dynamic_economy_CO12-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The present value is calculated as the average over the American option price
    vector at <math alttext="t equals normal upper Delta t"><mrow><mi>t</mi> <mo>=</mo>
    <mi>Œî</mi> <mi>t</mi></mrow></math> as derived based on the LSM algorithm and
    discounted for the last remaining time interval to the present <math alttext="t
    equals 0"><mrow><mi>t</mi> <mo>=</mo> <mn>0</mn></mrow></math> .
  prefs: []
  type: TYPE_NORMAL
- en: Early Exercise and Monte Carlo Simulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The efficient, Monte Carlo simulation‚Äìbased valuation of options and derivatives
    with early exercise features had been a mainly unsolved problem until the end
    of the 1990s. At the beginning of the 2000s only, researchers were able to propose
    computationally efficient algorithms to deal with early exercise in a simulation
    context. As often in science and finance, once such an algorithm is known‚Äîsuch
    as the LSM algorithm‚Äîthe implementation and application almost seem quite natural.
    After all, only a few lines of Python code are needed to accurately value the
    American put option in this section based on simulation. Nevertheless, the LSM
    algorithm must be considered a major breakthrough that helped to kick off the
    computational period in finance (see [Chapter¬†1](ch01.xhtml#finance_python)).
  prefs: []
  type: TYPE_NORMAL
- en: Conclusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presents in a rather informal manner two popular, dynamically complete
    financial models. The first is the so-called *recombining binomial tree model*
    by Cox-Ross-Rubinstein (1979). The beauty of it lies in its simplicity and that
    it allows one to implement European and American option pricing in a numerically
    efficient way and based on high school mathematics only. It is also a good ‚Äúteaching
    and understanding‚Äù tool as compared to continuous time financial models that require
    advanced stochastic calculus.
  prefs: []
  type: TYPE_NORMAL
- en: The second model is a *dynamic Monte Carlo simulation version* of the Black-Scholes-Merton
    (1973) continuous time option pricing model. Using `NumPy` simulation techniques,
    dynamic Monte Carlo simulation can also be implemented in a numerically efficient
    manner. Even the computationally demanding Least-Squares Monte Carlo algorithm
    by Longstaff and Schwartz (2001), involving a time-consuming OLS regression step,
    is quite fast when implemented based on vectorization techniques.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, `NumPy`, with its powerful vectorization capabilities, has proven
    once again that it allows not only for concise algorithmic code but also for fast
    execution times‚Äîeven in the context of more realistic and complex dynamic model
    economies.
  prefs: []
  type: TYPE_NORMAL
- en: Further Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Papers cited in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Black, Fischer and Myron Scholes. 1973\. ‚ÄúThe Pricing of Options and Corporate
    Liabilities.‚Äù *Journal of Political Economy* 81 (3): 638‚Äì659.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cox, John, Stephen Ross and Mark Rubinstein. 1979\. ‚ÄúOption Pricing: A Simplified
    Approach.‚Äù *Journal of Financial Economics* 7 (3): 229‚Äì263.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Duffie, Darrell. 1986\. ‚ÄúStochastic Equilibria: Existence, Spanning Number,
    and the *No Expected Gains from Financial Trade* Hypothesis.‚Äù *Econometrica* 54
    (5): 1161‚Äì1183.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Longstaff, Francis and Eduardo Schwartz. 2001\. ‚ÄúValuing American Options by
    Simulation: A Simple Least Squares Approach.‚Äù *Review of Financial Studies* 14
    (1): 113‚Äì147.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Merton, Robert. 1973\. ‚ÄúTheory of Rational Option Pricing.‚Äù *Bell Journal of
    Economics and Management Science* (4): 141‚Äì183.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Books cited in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Duffie, Darrell. 1988\. *Security Markets‚ÄîStochastic Models*. San Diego: Academic
    Press.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Glasserman, Paul. 2004\. *Monte Carlo Methods in Financial Engineering*. New
    York: Springer Verlag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hilpisch, Yves. 2018\. *Python for Finance*. 2nd ed. Sebastopol: O‚ÄôReilly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hilpisch, Yves. 2015\. *Derivatives Analytics with Python*. Wiley Finance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pliska, Stanley. 1997\. *Introduction to Mathematical Finance.* Malden and
    Oxford: Blackwell Publishers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch06.xhtml#idm44853685071096-marker)) The parameters assumed in this chapter
    are from Longstaff and Schwartz (2001, table 1).
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch06.xhtml#idm44853683423000-marker)) Note that only the numbers on and
    above the diagonal are relevant. Numbers below the diagonal can be ignored. They
    result from the specific vectorized operations implemented on the `ndarray` object.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch06.xhtml#idm44853679632632-marker)) Here, as also often seen in practice,
    there is a large number of cases for which the option expires worthless, that
    is, with a payoff of 0.
  prefs: []
  type: TYPE_NORMAL
