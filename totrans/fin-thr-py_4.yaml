- en: Chapter 4\. Optimality and Equilibrium
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Much of economic theory is based on the premise: given two alternatives, an
    agent can, and will if able, choose a preferred one.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Darrell Duffie (1988)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A portfolio analysis starts with information concerning individual securities.
    It ends with conclusions concerning portfolios as a whole. The purpose of the
    analysis is to find portfolios which best meet the objectives of the investor.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Harry Markowitz (1959)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This chapter is about the modeling of agents and their optimization problems.
    It presents some of the fundamental building blocks of microeconomic theory (see
    Varian (1992)) and financial economics (see Eichberger and Harper (1997)). At
    the core of this chapter is the *expected utility maximization* paradigm, which
    is the dominant way of modeling an agent’s preferences in financial economics.
    Based on this paradigm, two central topics are discussed.
  prefs: []
  type: TYPE_NORMAL
- en: First, we discuss how an agent chooses an optimal investment portfolio given
    their preferences and the initial wealth. This type of problem is typically called
    *optimal portfolio choice*. The approach presented here does not rely on any form
    of simplification as seen with the mean-variance portfolio (MVP) approach and
    the Capital Asset Pricing Model (CAPM) that, for example, reduce the problem of
    choosing investment portfolios to the first and second moments of the return distributions
    of financial assets as well as their covariance.
  prefs: []
  type: TYPE_NORMAL
- en: Second, while prices for financial assets in the previous two chapters have
    been given a priori, this chapter derives them from fundamental principles in
    that it analyzes the *pricing* *of financial assets* based on the optimization
    problem of a so-called *representative agent* in addition to *equilibrium arguments*.
    Loosely speaking, a representative agent can be thought of as the aggregation
    of (infinitely) many agents acting independently in (financial) markets. Conditions
    for the existence of such a representative agent are well-known (see chapter 6
    in Milne (1995))—however, they are not discussed in this chapter because financial
    theory in general simply postulates the existence.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current chapter mainly covers the following topics from finance, mathematics,
    and Python programming. On the Python side, not that many new elements are introduced.
    The basic mathematical and Python tool sets for doing finance in discrete models
    are already introduced and developed in the previous two chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Finance | Mathematics | Python |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Preferences and utility | Utility function | `NumPy` |'
  prefs: []
  type: TYPE_TB
- en: '| Utility maximization | Objective function, budget constraint, Theorem of
    Lagrange | `scipy.optimize.minimize` |'
  prefs: []
  type: TYPE_TB
- en: '| Indifference curves, budget line | Function | `NumPy`, `matplotlib` |'
  prefs: []
  type: TYPE_TB
- en: '| Logarithmic utility | Natural logarithm | `NumPy`, `matplotlib` |'
  prefs: []
  type: TYPE_TB
- en: '| Time-additive utility | Utility function | `NumPy`, `scipy.optimize.minimize`
    |'
  prefs: []
  type: TYPE_TB
- en: '| (time-additive) expected utility | Probability measure, Theorem of Lagrange
    | `NumPy`, `scipy.optimize.minimize` |'
  prefs: []
  type: TYPE_TB
- en: '| Optimal investment portfolio | Theorem of Lagrange, first-order conditions
    | `NumPy`, `scipy.optimize.minimize` |'
  prefs: []
  type: TYPE_TB
- en: '| Equilibrium pricing, representative agent | Theorem of Lagrange, first-order
    conditions | `NumPy`, `scipy.optimize.minimize`, `SymPy` |'
  prefs: []
  type: TYPE_TB
- en: '| Martingale measures in incomplete markets | Set of probability measures |
    `SymPy`, `sy.Symbol`, `sy.solve` |'
  prefs: []
  type: TYPE_TB
- en: '| Market completion by contingent claims | Theorem of Lagrange, first-order
    conditions | `NumPy`, `scipy.optimize.minimize` |'
  prefs: []
  type: TYPE_TB
- en: Utility Maximization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Formally, an agent is modeled by a *utility function*, which orders a set of
    choices the agent is faced with and which is a representation of the agent’s *preferences*
    (see chapter 7 in Varian (1992)). Consider the static economy without uncertainty
    from [Chapter 2](ch02_split_000.xhtml#two_state_economy). In addition, assume
    that an agent is endowed with some initial wealth, <math><mrow><mi>w</mi><mo>∈</mo><msub><mi>ℝ</mi>
    <mrow><mn>>0</mn></mrow></msub></mrow></math> . The agent can decide how much
    of this wealth to spend today, <math alttext="t equals 0"><mrow><mi>t</mi> <mo>=</mo>
    <mn>0</mn></mrow></math> , and how much to save—via bank deposits—for future consumption.
    One can think of an agent faced with the question of how much to save for retirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The agent receives utility from money today, <math alttext="c 0"><msub><mi>c</mi>
    <mn>0</mn></msub></math> , and in one year, <math alttext="c 1"><msub><mi>c</mi>
    <mn>1</mn></msub></math> , according to the utility function:'
  prefs: []
  type: TYPE_NORMAL
- en: <math mode="display"><mrow><mi>U</mi> <mo>:</mo> <msubsup><mi>ℝ</mi> <mrow><mn>≥0</mn></mrow>
    <mn>2</mn></msubsup> <mo>→</mo> <msub><mi>ℝ</mi> <mrow><mn>≥0</mn></mrow></msub>
    <mo>,</mo> <mrow><mo>(</mo> <msub><mi>c</mi> <mn>0</mn></msub> <mo>,</mo> <msub><mi>c</mi>
    <mn>1</mn></msub> <mo>)</mo></mrow> <mo>↦</mo> <mi>u</mi> <mrow><mo>(</mo> <msub><mi>c</mi>
    <mn>0</mn></msub> <mo>,</mo> <msub><mi>c</mi> <mn>1</mn></msub> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, assume <math alttext="u left-parenthesis c 0 comma c 1 right-parenthesis
    equals c 0 dot c 1"><mrow><mi>u</mi> <mrow><mo>(</mo> <msub><mi>c</mi> <mn>0</mn></msub>
    <mo>,</mo> <msub><mi>c</mi> <mn>1</mn></msub> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>c</mi>
    <mn>0</mn></msub> <mo>·</mo> <msub><mi>c</mi> <mn>1</mn></msub></mrow></math>
    —expressing the idea that money today and in one year are substitutes, although
    not perfect ones (if either one is zero, utility is zero as well). What is the
    optimal consumption-saving plan for the agent? Their constrained optimization
    problem formally is:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row  max Underscript c 0 comma c 1 Endscripts
    c 0 dot c 1 2nd Row  s period t period c 0 plus c 1 equals w EndLayout" display="block"><mtable><mtr><mtd><mrow><munder><mo
    movablelimits="true" form="prefix">max</mo> <mrow><msub><mi>c</mi> <mn>0</mn></msub>
    <mo>,</mo><msub><mi>c</mi> <mn>1</mn></msub></mrow></munder> <msub><mi>c</mi>
    <mn>0</mn></msub> <mo>·</mo> <msub><mi>c</mi> <mn>1</mn></msub></mrow></mtd></mtr>
    <mtr><mtd><mrow><mtext>s.t.</mtext> <msub><mi>c</mi> <mn>0</mn></msub> <mo>+</mo>
    <msub><mi>c</mi> <mn>1</mn></msub> <mo>=</mo> <mi>w</mi></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the Theorem of Lagrange (see chapter 5 in Sundaram (1996)), the
    constrained optimization problem can be transformed into an unconstrained one
    of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="max Underscript c 0 comma c 1 comma lamda Endscripts f left-parenthesis
    c 0 comma c 1 comma lamda right-parenthesis equals c 0 dot c 1 minus lamda dot
    left-parenthesis c 0 plus c 1 minus w right-parenthesis" display="block"><mrow><munder><mo
    movablelimits="true" form="prefix">max</mo> <mrow><msub><mi>c</mi> <mn>0</mn></msub>
    <mo>,</mo><msub><mi>c</mi> <mn>1</mn></msub> <mo>,</mo><mi>λ</mi></mrow></munder>
    <mi>f</mi> <mrow><mo>(</mo> <msub><mi>c</mi> <mn>0</mn></msub> <mo>,</mo> <msub><mi>c</mi>
    <mn>1</mn></msub> <mo>,</mo> <mi>λ</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>c</mi>
    <mn>0</mn></msub> <mo>·</mo> <msub><mi>c</mi> <mn>1</mn></msub> <mo>-</mo> <mi>λ</mi>
    <mo>·</mo> <mrow><mo>(</mo> <msub><mi>c</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>c</mi>
    <mn>1</mn></msub> <mo>-</mo> <mi>w</mi> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The first-order necessary conditions for optimality are:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout Enlarged left-brace 1st Row 1st Column StartFraction
    normal partial-differential f Over normal partial-differential c 0 EndFraction
    2nd Column equals 3rd Column c 1 minus lamda equals 0 2nd Row 1st Column StartFraction
    normal partial-differential f Over normal partial-differential c 1 EndFraction
    2nd Column equals 3rd Column c 0 minus lamda equals 0 3rd Row 1st Column StartFraction
    normal partial-differential f Over normal partial-differential lamda EndFraction
    2nd Column equals 3rd Column c 0 plus c 1 minus w equals 0 EndLayout" display="block"><mfenced
    separators="" open="{" close=""><mtable><mtr><mtd columnalign="left"><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><msub><mi>c</mi> <mn>0</mn></msub></mrow></mfrac></mtd> <mtd columnalign="left"><mo>=</mo></mtd>
    <mtd><mrow><msub><mi>c</mi> <mn>1</mn></msub> <mo>-</mo> <mi>λ</mi> <mo>=</mo>
    <mn>0</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><msub><mi>c</mi> <mn>1</mn></msub></mrow></mfrac></mtd> <mtd columnalign="left"><mo>=</mo></mtd>
    <mtd><mrow><msub><mi>c</mi> <mn>0</mn></msub> <mo>-</mo> <mi>λ</mi> <mo>=</mo>
    <mn>0</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><mi>λ</mi></mrow></mfrac></mtd> <mtd columnalign="left"><mo>=</mo></mtd>
    <mtd><mrow><msub><mi>c</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>c</mi> <mn>1</mn></msub>
    <mo>-</mo> <mi>w</mi> <mo>=</mo> <mn>0</mn></mrow></mtd></mtr></mtable></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: From these, one easily derives <math alttext="c 0 equals c 1 equals StartFraction
    w Over 2 EndFraction"><mrow><msub><mi>c</mi> <mn>0</mn></msub> <mo>=</mo> <msub><mi>c</mi>
    <mn>1</mn></msub> <mo>=</mo> <mfrac><mi>w</mi> <mn>2</mn></mfrac></mrow></math>
    as the optimal consumption-saving plan.
  prefs: []
  type: TYPE_NORMAL
- en: 'This optimization problem can be modeled and solved in Python numerically,
    for which <math alttext="w equals 10"><mrow><mi>w</mi> <mo>=</mo> <mn>10</mn></mrow></math>
    shall hold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The utility function with a negative sign to accomplish a maximization through
    minimization.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The initial wealth of the agent to be distributed between today and the future.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The budget constraint as an equality constraint for the `minimize` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The optimization with initial guess and budget constraint.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The optimal consumption-saving plan.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The maximum utility gained through the optimal plan.
  prefs: []
  type: TYPE_NORMAL
- en: Indifference Curves
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The optimal solution from the previous section can be visualized by the means
    of *indifference curves*. An indifference curve is formed by all such combinations
    <math alttext="c equals left-parenthesis c 0 comma c 1 right-parenthesis"><mrow><mi>c</mi>
    <mo>=</mo> <mo>(</mo> <msub><mi>c</mi> <mn>0</mn></msub> <mo>,</mo> <msub><mi>c</mi>
    <mn>1</mn></msub> <mo>)</mo></mrow></math> that give the same utility <math alttext="u
    overbar"><mover accent="true"><mi>u</mi> <mo>¯</mo></mover></math> . The equation
    describing such a curve in <math alttext="left-parenthesis c 0 comma c 1 right-parenthesis"><mrow><mo>(</mo>
    <msub><mi>c</mi> <mn>0</mn></msub> <mo>,</mo> <msub><mi>c</mi> <mn>1</mn></msub>
    <mo>)</mo></mrow></math> space is:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row 1st Column u overbar 2nd Column equals 3rd
    Column c 0 dot c 1 2nd Row 1st Column c 1 2nd Column equals 3rd Column StartFraction
    u overbar Over c 0 EndFraction EndLayout" display="block"><mtable><mtr><mtd><mover
    accent="true"><mi>u</mi> <mo>¯</mo></mover></mtd> <mtd><mo>=</mo></mtd> <mtd><mrow><msub><mi>c</mi>
    <mn>0</mn></msub> <mo>·</mo> <msub><mi>c</mi> <mn>1</mn></msub></mrow></mtd></mtr>
    <mtr><mtd><mrow><mo>⇔</mo> <msub><mi>c</mi> <mn>1</mn></msub></mrow></mtd> <mtd><mo>=</mo></mtd>
    <mtd><mfrac><mover accent="true"><mi>u</mi> <mo>¯</mo></mover> <msub><mi>c</mi>
    <mn>0</mn></msub></mfrac></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The equation describing the line representing the *budget constraint* is:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row 1st Column w 2nd Column equals 3rd Column
    c 0 plus c 1 2nd Row 1st Column c 1 2nd Column equals 3rd Column w minus c 0 EndLayout"
    display="block"><mtable><mtr><mtd><mi>w</mi></mtd> <mtd><mo>=</mo></mtd> <mtd><mrow><msub><mi>c</mi>
    <mn>0</mn></msub> <mo>+</mo> <msub><mi>c</mi> <mn>1</mn></msub></mrow></mtd></mtr>
    <mtr><mtd><mrow><mo>⇔</mo> <msub><mi>c</mi> <mn>1</mn></msub></mrow></mtd> <mtd><mo>=</mo></mtd>
    <mtd><mrow><mi>w</mi> <mo>-</mo> <msub><mi>c</mi> <mn>0</mn></msub></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: The optimization problem is visualized in [Figure 4-1](ch04_split_000.xhtml#opt_01),
    where the optimal plan is given by the dot—this is where the indifference curve
    for <math alttext="u overbar equals 25"><mrow><mover accent="true"><mi>u</mi>
    <mo>¯</mo></mover> <mo>=</mo> <mn>25</mn></mrow></math> is tangent to the line
    representing the budget constraint.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, this translates into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Function for indifference curve.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Function for budget line.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The domain over which to plot both.
  prefs: []
  type: TYPE_NORMAL
- en: '![ftwp 0401](Images/ftwp_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. The utility maximization problem
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Appropriate Utility Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In finance, the utility that an agent gains from money they have available
    at a certain point in time—as a substitute for any other real asset that might
    be bought with the money, for instance—is typically expressed as a function <math><mrow><mi>u</mi><mo>:</mo><msub><mi>ℝ</mi>
    <mrow><mn>≥0</mn></mrow></msub> <mo>→</mo><mi>ℝ</mi></mrow></math>, which is assumed
    to satisfy three conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="u left-parenthesis x right-parenthesis"><mrow><mi>u</mi> <mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></math> is twice differentiable
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d u Over d x EndFraction greater-than 0"><mrow><mfrac><mrow><mi>d</mi><mi>u</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mo>></mo> <mn>0</mn></mrow></math>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d squared u Over d x squared EndFraction less-than-or-equal-to
    0"><mrow><mfrac><mrow><msup><mi>d</mi> <mn>2</mn></msup> <mi>u</mi></mrow> <mrow><mi>d</mi><msup><mi>x</mi>
    <mn>2</mn></msup></mrow></mfrac> <mo>≤</mo> <mn>0</mn></mrow></math>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first condition is a technical prerequisite for the other two. The second
    condition formalizes the idea that more money—everything else being equal—is better
    than less money. Agents are assumed to be insatiable. The third condition states
    that the marginal utility from an additional unit of money is smaller (or the
    same at the maximum) than the marginal utility of the previous marginal unit of
    money. The function is therewith assumed to be increasing and (quasi-)concave.
  prefs: []
  type: TYPE_NORMAL
- en: Logarithmic Utility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section introduces a type of function that is well suited for financial
    analyses based on a utility maximizing agent. Such a function—that satisfies the
    three conditions of the previous section and that is regularly used in finance
    to model the utility an agent receives from money (or consumption)—is the *natural
    logarithm* <math alttext="u left-parenthesis x right-parenthesis equals ln x"><mrow><mi>u</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mo form="prefix">ln</mo> <mi>x</mi></mrow></math>
    . For it, one gets:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d u Over d x EndFraction equals StartFraction 1
    Over x EndFraction greater-than 0 for x element-of double-struck upper R Subscript
    0 Baseline"><mrow><mfrac><mrow><mi>d</mi><mi>u</mi></mrow> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <mo>=</mo> <mfrac><mn>1</mn> <mi>x</mi></mfrac> <mo>></mo> <mn>0</mn> <mtext>for</mtext>
    <mi>x</mi> <mo>∈</mo> <msub><mi>ℝ</mi> <mrow><mo>></mo><mn>0</mn></mrow></msub></mrow></math>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d squared u Over d x squared EndFraction equals
    minus StartFraction 1 Over x squared EndFraction less-than 0"><mrow><mfrac><mrow><msup><mi>d</mi>
    <mn>2</mn></msup> <mi>u</mi></mrow> <mrow><mi>d</mi><msup><mi>x</mi> <mn>2</mn></msup></mrow></mfrac>
    <mo>=</mo> <mo>-</mo> <mfrac><mn>1</mn> <msup><mi>x</mi> <mn>2</mn></msup></mfrac>
    <mo><</mo> <mn>0</mn></mrow></math> for <math><mrow><mi>x</mi><mo>∈</mo><msub><mi>ℝ</mi>
    <mrow><mn>>0</mn></mrow></msub></mrow></math>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Python allows us to visualize the three relevant functions. `NumPy` is used
    in combination with vectorized calculations. [Figure 4-2](ch04_split_000.xhtml#natural_log)
    shows the plot as generated by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Creates an `ndarray` object with floating point numbers between 0.5 and 10 and
    a homogeneous spacing to get 50 values.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Shows a selection of the resulting numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Calculates the values for the utility function.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: And for its first derivative as well as…
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: …for its second derivative.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO3-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a new canvas for plotting and provides sizing parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO3-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Plots the utility function.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](Images/8.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO3-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Plots the first derivative.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](Images/9.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO3-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Plots the second derivative.
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](Images/10.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO3-10)'
  prefs: []
  type: TYPE_NORMAL
- en: Puts a legend in the optimal location (`loc=0`).
  prefs: []
  type: TYPE_NORMAL
- en: '![ftwp 0402](Images/ftwp_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. The natural logarithm function and its first and second derivatives
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Time-Additive Utility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the natural logarithm as a function to model utility of an agent from
    money, the preferences of an agent over consumption-saving plans <math alttext="c
    equals left-parenthesis c 0 comma c 1 right-parenthesis"><mrow><mi>c</mi> <mo>=</mo>
    <mo>(</mo> <msub><mi>c</mi> <mn>0</mn></msub> <mo>,</mo> <msub><mi>c</mi> <mn>1</mn></msub>
    <mo>)</mo></mrow></math> can be described as a time-additive function of the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: <math mode="display"><mrow><mi>U</mi> <mo>:</mo> <msubsup><mi>ℝ</mi> <mrow><mn>≥0</mn></mrow>
    <mn>2</mn></msubsup> <mo>→</mo> <mi>ℝ</mi> <mo>,</mo> <mrow><mo>(</mo> <msub><mi>c</mi>
    <mn>0</mn></msub> <mo>,</mo> <msub><mi>c</mi> <mn>1</mn></msub> <mo>)</mo></mrow>
    <mo>↦</mo> <mo form="prefix">ln</mo> <msub><mi>c</mi> <mn>0</mn></msub> <mo>+</mo>
    <mi>κ</mi> <mo>·</mo> <mo form="prefix">ln</mo> <msub><mi>c</mi> <mn>1</mn></msub></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math><mrow><mi>κ</mi><mo>∈</mo><msub><mi>ℝ</mi> <mrow><mn>≥0</mn></mrow></msub></mrow></math>
    is assumed to take on values <math alttext="0 less-than kappa less-than-or-equal-to
    1"><mrow><mn>0</mn> <mo><</mo> <mi>κ</mi> <mo>≤</mo> <mn>1</mn></mrow></math>
    and represents the *time preference* of the agent. It embodies the idea that money
    and consumption today are valued higher than in one year. At least weakly, 100
    USD now is preferred to 100 USD in one year—no matter what exact function describes
    utility (assuming consistency of preferences over time). It can be thought of
    as a nonmonetary discount factor. It is easily verified that this function satisfies
    the three conditions described previously—it is twice differentiable, increasing,
    and concave—based on the partial derivatives with regard to both <math alttext="c
    0"><msub><mi>c</mi> <mn>0</mn></msub></math> and <math alttext="c 1"><msub><mi>c</mi>
    <mn>1</mn></msub></math> .
  prefs: []
  type: TYPE_NORMAL
- en: 'If the agent has initial wealth of <math alttext="w"><mi>w</mi></math> , their
    constrained optimization problem is:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row  max Underscript c 0 comma c 1 Endscripts
    ln c 0 plus kappa dot ln c 1 2nd Row  s period t period c 0 plus c 1 equals w
    EndLayout" display="block"><mtable><mtr><mtd><mrow><munder><mo movablelimits="true"
    form="prefix">max</mo> <mrow><msub><mi>c</mi> <mn>0</mn></msub> <mo>,</mo><msub><mi>c</mi>
    <mn>1</mn></msub></mrow></munder> <mo form="prefix">ln</mo> <msub><mi>c</mi> <mn>0</mn></msub>
    <mo>+</mo> <mi>κ</mi> <mo>·</mo> <mo form="prefix">ln</mo> <msub><mi>c</mi> <mn>1</mn></msub></mrow></mtd></mtr>
    <mtr><mtd><mrow><mtext>s.t.</mtext> <msub><mi>c</mi> <mn>0</mn></msub> <mo>+</mo>
    <msub><mi>c</mi> <mn>1</mn></msub> <mo>=</mo> <mi>w</mi></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="max Underscript c 0 comma c 1 comma lamda Endscripts f left-parenthesis
    c 0 comma c 1 comma lamda right-parenthesis equals ln c 0 plus kappa dot ln c
    1 minus lamda dot left-parenthesis c 0 plus c 1 minus w right-parenthesis" display="block"><mrow><munder><mo
    movablelimits="true" form="prefix">max</mo> <mrow><msub><mi>c</mi> <mn>0</mn></msub>
    <mo>,</mo><msub><mi>c</mi> <mn>1</mn></msub> <mo>,</mo><mi>λ</mi></mrow></munder>
    <mi>f</mi> <mrow><mo>(</mo> <msub><mi>c</mi> <mn>0</mn></msub> <mo>,</mo> <msub><mi>c</mi>
    <mn>1</mn></msub> <mo>,</mo> <mi>λ</mi> <mo>)</mo></mrow> <mo>=</mo> <mo form="prefix">ln</mo>
    <msub><mi>c</mi> <mn>0</mn></msub> <mo>+</mo> <mi>κ</mi> <mo>·</mo> <mo form="prefix">ln</mo>
    <msub><mi>c</mi> <mn>1</mn></msub> <mo>-</mo> <mi>λ</mi> <mo>·</mo> <mrow><mo>(</mo>
    <msub><mi>c</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>c</mi> <mn>1</mn></msub>
    <mo>-</mo> <mi>w</mi> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The first-order necessary conditions for optimality are:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout Enlarged left-brace 1st Row 1st Column StartFraction
    normal partial-differential f Over normal partial-differential c 0 EndFraction
    2nd Column equals 3rd Column StartFraction 1 Over c 0 EndFraction minus lamda
    equals 0 2nd Row 1st Column StartFraction normal partial-differential f Over normal
    partial-differential c 1 EndFraction 2nd Column equals 3rd Column kappa dot StartFraction
    1 Over c 1 EndFraction minus lamda equals 0 3rd Row 1st Column StartFraction normal
    partial-differential f Over normal partial-differential lamda EndFraction 2nd
    Column equals 3rd Column c 0 plus c 1 minus w equals 0 EndLayout" display="block"><mfenced
    separators="" open="{" close=""><mtable><mtr><mtd columnalign="left"><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><msub><mi>c</mi> <mn>0</mn></msub></mrow></mfrac></mtd> <mtd columnalign="left"><mo>=</mo></mtd>
    <mtd><mrow><mfrac><mn>1</mn> <msub><mi>c</mi> <mn>0</mn></msub></mfrac> <mo>-</mo>
    <mi>λ</mi> <mo>=</mo> <mn>0</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><msub><mi>c</mi> <mn>1</mn></msub></mrow></mfrac></mtd> <mtd columnalign="left"><mo>=</mo></mtd>
    <mtd><mrow><mi>κ</mi> <mo>·</mo> <mfrac><mn>1</mn> <msub><mi>c</mi> <mn>1</mn></msub></mfrac>
    <mo>-</mo> <mi>λ</mi> <mo>=</mo> <mn>0</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><mi>λ</mi></mrow></mfrac></mtd> <mtd columnalign="left"><mo>=</mo></mtd>
    <mtd><mrow><msub><mi>c</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>c</mi> <mn>1</mn></msub>
    <mo>-</mo> <mi>w</mi> <mo>=</mo> <mn>0</mn></mrow></mtd></mtr></mtable></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'From these, one obtains:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row 1st Column StartFraction 1 Over c 0 EndFraction
    2nd Column equals 3rd Column kappa dot StartFraction 1 Over c 1 EndFraction 2nd
    Row 1st Column c 1 2nd Column equals 3rd Column kappa dot c 0 EndLayout" display="block"><mtable><mtr><mtd><mfrac><mn>1</mn>
    <msub><mi>c</mi> <mn>0</mn></msub></mfrac></mtd> <mtd><mo>=</mo></mtd> <mtd><mrow><mi>κ</mi>
    <mo>·</mo> <mfrac><mn>1</mn> <msub><mi>c</mi> <mn>1</mn></msub></mfrac></mrow></mtd></mtr>
    <mtr><mtd><mrow><mo>⇔</mo> <msub><mi>c</mi> <mn>1</mn></msub></mrow></mtd> <mtd><mo>=</mo></mtd>
    <mtd><mrow><mi>κ</mi> <mo>·</mo> <msub><mi>c</mi> <mn>0</mn></msub></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: The optimal consumption-saving plan now reflects the time preference in that
    consumption in one year <math alttext="c 1"><msub><mi>c</mi> <mn>1</mn></msub></math>
    is set to <math alttext="kappa dot c 0"><mrow><mi>κ</mi> <mo>·</mo> <msub><mi>c</mi>
    <mn>0</mn></msub></mrow></math> . It also holds
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row 1st Column c 0 plus kappa dot c 0 2nd Column
    equals 3rd Column w 2nd Row 1st Column c 0 2nd Column equals 3rd Column StartFraction
    w Over 1 plus kappa EndFraction EndLayout" display="block"><mtable><mtr><mtd><mrow><msub><mi>c</mi>
    <mn>0</mn></msub> <mo>+</mo> <mi>κ</mi> <mo>·</mo> <msub><mi>c</mi> <mn>0</mn></msub></mrow></mtd>
    <mtd><mo>=</mo></mtd> <mtd><mi>w</mi></mtd></mtr> <mtr><mtd><mrow><mo>⇔</mo> <msub><mi>c</mi>
    <mn>0</mn></msub></mrow></mtd> <mtd><mo>=</mo></mtd> <mtd><mfrac><mi>w</mi> <mrow><mn>1</mn><mo>+</mo><mi>κ</mi></mrow></mfrac></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row 1st Column StartFraction w Over 1 plus kappa
    EndFraction plus c 1 2nd Column equals 3rd Column w 2nd Row 1st Column c 1 2nd
    Column equals 3rd Column StartFraction kappa dot w Over 1 plus kappa EndFraction
    EndLayout" display="block"><mtable><mtr><mtd><mrow><mfrac><mi>w</mi> <mrow><mn>1</mn><mo>+</mo><mi>κ</mi></mrow></mfrac>
    <mo>+</mo> <msub><mi>c</mi> <mn>1</mn></msub></mrow></mtd> <mtd><mo>=</mo></mtd>
    <mtd><mi>w</mi></mtd></mtr> <mtr><mtd><mrow><mo>⇔</mo> <msub><mi>c</mi> <mn>1</mn></msub></mrow></mtd>
    <mtd><mo>=</mo></mtd> <mtd><mfrac><mrow><mi>κ</mi><mo>·</mo><mi>w</mi></mrow>
    <mrow><mn>1</mn><mo>+</mo><mi>κ</mi></mrow></mfrac></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The budget constraint is binding:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction w Over 1 plus kappa EndFraction plus StartFraction
    kappa dot w Over 1 plus kappa EndFraction equals StartFraction w plus kappa dot
    w Over 1 plus kappa EndFraction equals w" display="block"><mrow><mfrac><mi>w</mi>
    <mrow><mn>1</mn><mo>+</mo><mi>κ</mi></mrow></mfrac> <mo>+</mo> <mfrac><mrow><mi>κ</mi><mo>·</mo><mi>w</mi></mrow>
    <mrow><mn>1</mn><mo>+</mo><mi>κ</mi></mrow></mfrac> <mo>=</mo> <mfrac><mrow><mi>w</mi><mo>+</mo><mi>κ</mi><mo>·</mo><mi>w</mi></mrow>
    <mrow><mn>1</mn><mo>+</mo><mi>κ</mi></mrow></mfrac> <mo>=</mo> <mi>w</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code solves the optimization problem numerically for <math alttext="w
    equals 10"><mrow><mi>w</mi> <mo>=</mo> <mn>10</mn></mrow></math> . The optimal
    plan reflects the time preference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The utility function with a negative sign to accomplish a maximization through
    minimization.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The budget constraint as an equality constraint for the `minimize` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The optimal consumption-saving plan, reflecting the time preference in that
    <math alttext="c 0"><msub><mi>c</mi> <mn>0</mn></msub></math> is higher than <math
    alttext="c 1"><msub><mi>c</mi> <mn>1</mn></msub></math> —by exactly 10%.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The maximum utility gained through the optimal plan.^([1](ch04_split_001.xhtml#idm44853698912344))
  prefs: []
  type: TYPE_NORMAL
- en: Expected Utility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now consider the static two-state economy with *uncertainty*. Assume that an
    agent, endowed with some initial wealth, <math><mrow><mi>w</mi><mo>∈</mo><msub><mi>ℝ</mi>
    <mrow><mn>>0</mn></mrow></msub></mrow></math> , gains utility only through money
    available in one year—but now distinguished in the two states that are possible
    then. This shall represent a *pure investment problem* where all available initial
    wealth shall be optimally invested in the traded financial assets.
  prefs: []
  type: TYPE_NORMAL
- en: Assume that *two financial assets* are traded, a risk-less bond with price process
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper B equals left-parenthesis upper B 0 comma left-parenthesis
    upper B 1 comma upper B 1 right-parenthesis Superscript upper T Baseline right-parenthesis"
    display="block"><mrow><mi>B</mi> <mo>=</mo> <mfenced separators="" open="(" close=")"><msub><mi>B</mi>
    <mn>0</mn></msub> <mo>,</mo> <msup><mrow><mo>(</mo><msub><mi>B</mi> <mn>1</mn></msub>
    <mo>,</mo><msub><mi>B</mi> <mn>1</mn></msub> <mo>)</mo></mrow> <mi>T</mi></msup></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: and a risky stock with price process
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper S equals left-parenthesis upper S 0 comma left-parenthesis
    upper S 1 Superscript u Baseline comma upper S 1 Superscript d Baseline right-parenthesis
    Superscript upper T Baseline right-parenthesis" display="block"><mrow><mi>S</mi>
    <mo>=</mo> <mfenced separators="" open="(" close=")"><msub><mi>S</mi> <mn>0</mn></msub>
    <mo>,</mo> <msup><mrow><mo>(</mo><msubsup><mi>S</mi> <mn>1</mn> <mi>u</mi></msubsup>
    <mo>,</mo><msubsup><mi>S</mi> <mn>1</mn> <mi>d</mi></msubsup> <mo>)</mo></mrow>
    <mi>T</mi></msup></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Financial assets are a means to transfer the initial wealth from today to a
    later point in time. The major decision problem of the agent is to decide what
    to consume in either one of the future states.
  prefs: []
  type: TYPE_NORMAL
- en: 'A model for the investment problem the agent is faced with under uncertainty
    is given by the *expected utility* of the agent that is to be maximized given
    <math alttext="w"><mi>w</mi></math> . The *expected utility function* is given
    by:'
  prefs: []
  type: TYPE_NORMAL
- en: <math mode="display"><mrow><mi>U</mi> <mo>:</mo> <msubsup><mi>ℝ</mi> <mrow><mn>≥0</mn></mrow>
    <mn>2</mn></msubsup> <mo>→</mo> <mi>ℝ</mi> <mo>,</mo> <msub><mi>c</mi> <mn>1</mn></msub>
    <mo>↦</mo> <msup><mi>𝐄</mi> <mi>P</mi></msup> <mrow><mo>(</mo> <mi>u</mi> <mrow><mo>(</mo>
    <msub><mi>c</mi> <mn>1</mn></msub> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: With the *price vector* <math alttext="script upper M 0 equals left-parenthesis
    upper B 0 comma upper S 0 right-parenthesis Superscript upper T"><mrow><msub><mi>ℳ</mi>
    <mn>0</mn></msub> <mo>=</mo> <msup><mrow><mo>(</mo><msub><mi>B</mi> <mn>0</mn></msub>
    <mo>,</mo><msub><mi>S</mi> <mn>0</mn></msub> <mo>)</mo></mrow> <mi>T</mi></msup></mrow></math>
    , the agent can distribute their initial wealth according to
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="script upper M 0 dot phi equals w left right double arrow upper
    B 0 dot b plus upper S 0 dot s equals w" display="block"><mrow><msub><mi>ℳ</mi>
    <mn>0</mn></msub> <mo>·</mo> <mi>ϕ</mi> <mo>=</mo> <mi>w</mi> <mo>⇔</mo> <msub><mi>B</mi>
    <mn>0</mn></msub> <mo>·</mo> <mi>b</mi> <mo>+</mo> <msub><mi>S</mi> <mn>0</mn></msub>
    <mo>·</mo> <mi>s</mi> <mo>=</mo> <mi>w</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: where <math><mrow><mi>ϕ</mi><mo>=</mo><msup><mrow><mo>(</mo><mi>b</mi><mo>,</mo><mi>s</mi><mo>)</mo></mrow>
    <mi>T</mi></msup> <mo>∈</mo><msubsup><mi>ℝ</mi> <mrow><mn>≥0</mn></mrow> <mn>2</mn></msubsup></mrow></math>
    represents the *portfolio* consisting of the risk-less bond and the risky stock
    as composed by the agent. This *budget constraint* will always be binding due
    to the agent being insatiable. Short selling shall not be allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *market payoff matrix* is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="script upper M equals Start 2 By 2 Matrix 1st Row 1st Column
    upper B 1 2nd Column upper S 1 Superscript u Baseline 2nd Row 1st Column upper
    B 1 2nd Column upper S 1 Superscript d EndMatrix" display="block"><mrow><mi>ℳ</mi>
    <mo>=</mo> <mfenced open="(" close=")"><mtable><mtr><mtd><msub><mi>B</mi> <mn>1</mn></msub></mtd>
    <mtd><msubsup><mi>S</mi> <mn>1</mn> <mi>u</mi></msubsup></mtd></mtr> <mtr><mtd><msub><mi>B</mi>
    <mn>1</mn></msub></mtd> <mtd><msubsup><mi>S</mi> <mn>1</mn> <mi>d</mi></msubsup></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money does the agent have available in either state one year from
    today? This is determined by the portfolio the agent chooses to compose:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="c 1 equals script upper M dot phi equals StartBinomialOrMatrix
    upper B 1 Choose upper B 1 EndBinomialOrMatrix dot b plus StartBinomialOrMatrix
    upper S 1 Superscript u Baseline Choose upper S 1 Superscript d Baseline EndBinomialOrMatrix
    dot s" display="block"><mrow><msub><mi>c</mi> <mn>1</mn></msub> <mo>=</mo> <mi>ℳ</mi>
    <mo>·</mo> <mi>ϕ</mi> <mo>=</mo> <mfenced open="(" close=")"><mtable><mtr><mtd><msub><mi>B</mi>
    <mn>1</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>B</mi> <mn>1</mn></msub></mtd></mtr></mtable></mfenced>
    <mo>·</mo> <mi>b</mi> <mo>+</mo> <mfenced open="(" close=")"><mtable><mtr><mtd><msubsup><mi>S</mi>
    <mn>1</mn> <mi>u</mi></msubsup></mtd></mtr> <mtr><mtd><msubsup><mi>S</mi> <mn>1</mn>
    <mi>d</mi></msubsup></mtd></mtr></mtable></mfenced> <mo>·</mo> <mi>s</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: This leads to
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="c 1 equals StartBinomialOrMatrix b dot upper B 1 plus s dot upper
    S 1 Superscript u Baseline Choose b dot upper B 1 plus s dot upper S 1 Superscript
    d EndBinomialOrMatrix" display="block"><mrow><msub><mi>c</mi> <mn>1</mn></msub>
    <mo>=</mo> <mfenced open="(" close=")"><mtable><mtr><mtd><mrow><mi>b</mi> <mo>·</mo>
    <msub><mi>B</mi> <mn>1</mn></msub> <mo>+</mo> <mi>s</mi> <mo>·</mo> <msubsup><mi>S</mi>
    <mn>1</mn> <mi>u</mi></msubsup></mrow></mtd></mtr> <mtr><mtd><mrow><mi>b</mi>
    <mo>·</mo> <msub><mi>B</mi> <mn>1</mn></msub> <mo>+</mo> <mi>s</mi> <mo>·</mo>
    <msubsup><mi>S</mi> <mn>1</mn> <mi>d</mi></msubsup></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout Enlarged left-brace 1st Row 1st Column c 1 Superscript
    u 2nd Column equals 3rd Column b dot upper B 1 plus s dot upper S 1 Superscript
    u 2nd Row 1st Column c 1 Superscript d 2nd Column equals 3rd Column b dot upper
    B 1 plus s dot upper S 1 Superscript d EndLayout" display="block"><mfenced separators=""
    open="{" close=""><mtable><mtr><mtd columnalign="left"><msubsup><mi>c</mi> <mn>1</mn>
    <mi>u</mi></msubsup></mtd> <mtd columnalign="left"><mo>=</mo></mtd> <mtd><mrow><mi>b</mi>
    <mo>·</mo> <msub><mi>B</mi> <mn>1</mn></msub> <mo>+</mo> <mi>s</mi> <mo>·</mo>
    <msubsup><mi>S</mi> <mn>1</mn> <mi>u</mi></msubsup></mrow></mtd></mtr> <mtr><mtd
    columnalign="left"><msubsup><mi>c</mi> <mn>1</mn> <mi>d</mi></msubsup></mtd> <mtd
    columnalign="left"><mo>=</mo></mtd> <mtd><mrow><mi>b</mi> <mo>·</mo> <msub><mi>B</mi>
    <mn>1</mn></msub> <mo>+</mo> <mi>s</mi> <mo>·</mo> <msubsup><mi>S</mi> <mn>1</mn>
    <mi>d</mi></msubsup></mrow></mtd></mtr></mtable></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete decision-making problem—with regard to *optimal portfolio choice*—of
    the agent can then be represented as the following *constrained optimization problem*:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row 1st Column Blank 2nd Column max Underscript
    c 1 Endscripts 3rd Column bold upper E Superscript upper P Baseline left-parenthesis
    u left-parenthesis c 1 right-parenthesis right-parenthesis 2nd Row 1st Column
    left-parenthesis i right-parenthesis w 2nd Column equals 3rd Column script upper
    M 0 dot phi 3rd Row 1st Column left-parenthesis ii right-parenthesis c 1 2nd Column
    equals 3rd Column script upper M dot phi EndLayout" display="block"><mtable><mtr><mtd><munder><mo
    movablelimits="true" form="prefix">max</mo> <msub><mi>c</mi> <mn>1</mn></msub></munder></mtd>
    <mtd><mrow><msup><mi>𝐄</mi> <mi>P</mi></msup> <mrow><mo>(</mo> <mi>u</mi> <mrow><mo>(</mo>
    <msub><mi>c</mi> <mn>1</mn></msub> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></mtd></mtr>
    <mtr><mtd><mrow><mtext>(i)</mtext> <mi>w</mi></mrow></mtd> <mtd><mo>=</mo></mtd>
    <mtd><mrow><msub><mi>ℳ</mi> <mn>0</mn></msub> <mo>·</mo> <mi>ϕ</mi></mrow></mtd></mtr>
    <mtr><mtd><mrow><mtext>(ii)</mtext> <msub><mi>c</mi> <mn>1</mn></msub></mrow></mtd>
    <mtd><mo>=</mo></mtd> <mtd><mrow><mi>ℳ</mi> <mo>·</mo> <mi>ϕ</mi></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: or after substituting for <math alttext="c 1"><msub><mi>c</mi> <mn>1</mn></msub></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row 1st Column Blank 2nd Column max Underscript
    phi Endscripts 3rd Column bold upper E Superscript upper P Baseline left-parenthesis
    u left-parenthesis script upper M dot phi right-parenthesis right-parenthesis
    2nd Row 1st Column w 2nd Column equals 3rd Column script upper M 0 dot phi EndLayout"
    display="block"><mtable><mtr><mtd><munder><mo movablelimits="true" form="prefix">max</mo>
    <mi>ϕ</mi></munder></mtd> <mtd><mrow><msup><mi>𝐄</mi> <mi>P</mi></msup> <mrow><mo>(</mo>
    <mi>u</mi> <mrow><mo>(</mo> <mi>ℳ</mi> <mo>·</mo> <mi>ϕ</mi> <mo>)</mo></mrow>
    <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd><mi>w</mi></mtd> <mtd><mo>=</mo></mtd>
    <mtd><mrow><msub><mi>ℳ</mi> <mn>0</mn></msub> <mo>·</mo> <mi>ϕ</mi></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: According to the Theorem of Lagrange, one can transform this problem into an
    *unconstrained optimization problem* of the form
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="max Underscript b comma s comma lamda Endscripts f left-parenthesis
    b comma s comma lamda right-parenthesis equals bold upper E Superscript upper
    P Baseline left-parenthesis u left-parenthesis b dot upper B 1 plus s dot upper
    S 1 right-parenthesis right-parenthesis minus lamda dot left-parenthesis b dot
    upper B 0 plus s dot upper S 0 minus w right-parenthesis" display="block"><mrow><munder><mo
    movablelimits="true" form="prefix">max</mo> <mrow><mi>b</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>λ</mi></mrow></munder>
    <mi>f</mi> <mrow><mo>(</mo> <mi>b</mi> <mo>,</mo> <mi>s</mi> <mo>,</mo> <mi>λ</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msup><mi>𝐄</mi> <mi>P</mi></msup> <mfenced separators=""
    open="(" close=")"><mi>u</mi> <mo>(</mo> <mi>b</mi> <mo>·</mo> <msub><mi>B</mi>
    <mn>1</mn></msub> <mo>+</mo> <mi>s</mi> <mo>·</mo> <msub><mi>S</mi> <mn>1</mn></msub>
    <mo>)</mo></mfenced> <mo>-</mo> <mi>λ</mi> <mo>·</mo> <mrow><mo>(</mo> <mi>b</mi>
    <mo>·</mo> <msub><mi>B</mi> <mn>0</mn></msub> <mo>+</mo> <mi>s</mi> <mo>·</mo>
    <msub><mi>S</mi> <mn>0</mn></msub> <mo>-</mo> <mi>w</mi> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: where the agent chooses <math alttext="b"><mi>b</mi></math> and <math alttext="s"><mi>s</mi></math>
    to maximize expected utility given the budget constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Expected Utility Theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decades after its formulation and introduction, expected utility theory (EUT)
    is still the dominant decision-making paradigm in finance. One of its major assumptions—that
    agents have full knowledge of possible future states and their probabilities—is
    hardly ever fulfilled in reality. However, EUT is, to many, intellectually appealing
    and leads to “nice” results that are often easy to understand and interpret. For
    more on the problems with this central paradigm in finance, see Hilpisch (2020,
    chapters 3 and 4).
  prefs: []
  type: TYPE_NORMAL
- en: Optimal Investment Portfolio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What does an optimal solution for the expected utility maximizing agent look
    like? In general terms, the answer can be given based on the first-order conditions
    that are necessary and sufficient here for an optimal solution:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout Enlarged left-brace 1st Row 1st Column StartFraction
    normal partial-differential f Over normal partial-differential b EndFraction 2nd
    Column equals 3rd Column 0 2nd Row 1st Column StartFraction normal partial-differential
    f Over normal partial-differential s EndFraction 2nd Column equals 3rd Column
    0 3rd Row 1st Column StartFraction normal partial-differential f Over normal partial-differential
    lamda EndFraction 2nd Column equals 3rd Column 0 EndLayout" display="block"><mfenced
    separators="" open="{" close=""><mtable><mtr><mtd columnalign="left"><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><mi>b</mi></mrow></mfrac></mtd> <mtd columnalign="left"><mo>=</mo></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd columnalign="left"><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><mi>s</mi></mrow></mfrac></mtd> <mtd columnalign="left"><mo>=</mo></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd columnalign="left"><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><mi>λ</mi></mrow></mfrac></mtd> <mtd columnalign="left"><mo>=</mo></mtd>
    <mtd><mn>0</mn></mtd></mtr></mtable></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row 1st Column StartFraction normal partial-differential
    f Over normal partial-differential b EndFraction 2nd Column equals 3rd Column
    p dot upper B 1 dot u prime left-parenthesis b dot upper B 1 plus s dot upper
    S 1 Superscript u Baseline right-parenthesis 2nd Row 1st Column Blank 2nd Column
    plus 3rd Column left-parenthesis 1 minus p right-parenthesis dot upper B 1 dot
    u prime left-parenthesis b dot upper B 1 plus s dot upper S 1 Superscript d Baseline
    right-parenthesis minus lamda dot upper B 0 equals 0 EndLayout" display="block"><mtable><mtr><mtd><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><mi>b</mi></mrow></mfrac></mtd> <mtd><mo>=</mo></mtd> <mtd><mrow><mi>p</mi>
    <mo>·</mo> <msub><mi>B</mi> <mn>1</mn></msub> <mo>·</mo> <msup><mi>u</mi> <mo>'</mo></msup>
    <mfenced separators="" open="(" close=")"><mi>b</mi> <mo>·</mo> <msub><mi>B</mi>
    <mn>1</mn></msub> <mo>+</mo> <mi>s</mi> <mo>·</mo> <msubsup><mi>S</mi> <mn>1</mn>
    <mi>u</mi></msubsup></mfenced></mrow></mtd></mtr> <mtr><mtd><mo>+</mo></mtd> <mtd><mrow><mrow><mo>(</mo>
    <mn>1</mn> <mo>-</mo> <mi>p</mi> <mo>)</mo></mrow> <mo>·</mo> <msub><mi>B</mi>
    <mn>1</mn></msub> <mo>·</mo> <msup><mi>u</mi> <mo>'</mo></msup> <mfenced separators=""
    open="(" close=")"><mi>b</mi> <mo>·</mo> <msub><mi>B</mi> <mn>1</mn></msub> <mo>+</mo>
    <mi>s</mi> <mo>·</mo> <msubsup><mi>S</mi> <mn>1</mn> <mi>d</mi></msubsup></mfenced>
    <mo>-</mo> <mi>λ</mi> <mo>·</mo> <msub><mi>B</mi> <mn>0</mn></msub> <mo>=</mo>
    <mn>0</mn></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row 1st Column StartFraction normal partial-differential
    f Over normal partial-differential s EndFraction 2nd Column equals 3rd Column
    p dot upper S 1 Superscript u Baseline dot u prime left-parenthesis b dot upper
    B 1 plus s dot upper S 1 Superscript u Baseline right-parenthesis 2nd Row 1st
    Column Blank 2nd Column plus 3rd Column left-parenthesis 1 minus p right-parenthesis
    dot upper S 1 Superscript d Baseline dot u prime left-parenthesis b dot upper
    B 1 plus s dot upper S 1 Superscript d Baseline right-parenthesis minus lamda
    dot upper S 0 equals 0 EndLayout" display="block"><mtable><mtr><mtd><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><mi>s</mi></mrow></mfrac></mtd> <mtd><mo>=</mo></mtd> <mtd><mrow><mi>p</mi>
    <mo>·</mo> <msubsup><mi>S</mi> <mn>1</mn> <mi>u</mi></msubsup> <mo>·</mo> <msup><mi>u</mi>
    <mo>'</mo></msup> <mfenced separators="" open="(" close=")"><mi>b</mi> <mo>·</mo>
    <msub><mi>B</mi> <mn>1</mn></msub> <mo>+</mo> <mi>s</mi> <mo>·</mo> <msubsup><mi>S</mi>
    <mn>1</mn> <mi>u</mi></msubsup></mfenced></mrow></mtd></mtr> <mtr><mtd><mo>+</mo></mtd>
    <mtd><mrow><mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <mi>p</mi> <mo>)</mo></mrow>
    <mo>·</mo> <msubsup><mi>S</mi> <mn>1</mn> <mi>d</mi></msubsup> <mo>·</mo> <msup><mi>u</mi>
    <mo>'</mo></msup> <mfenced separators="" open="(" close=")"><mi>b</mi> <mo>·</mo>
    <msub><mi>B</mi> <mn>1</mn></msub> <mo>+</mo> <mi>s</mi> <mo>·</mo> <msubsup><mi>S</mi>
    <mn>1</mn> <mi>d</mi></msubsup></mfenced> <mo>-</mo> <mi>λ</mi> <mo>·</mo> <msub><mi>S</mi>
    <mn>0</mn></msub> <mo>=</mo> <mn>0</mn></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: with the usual notation <math alttext="u prime left-parenthesis x right-parenthesis
    identical-to StartFraction d u Over d x EndFraction"><mrow><msup><mi>u</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>≡</mo> <mfrac><mrow><mi>d</mi><mi>u</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></mrow></math> as well as
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="b dot upper B 0 plus s dot upper S 0 equals w" display="block"><mrow><mi>b</mi>
    <mo>·</mo> <msub><mi>B</mi> <mn>0</mn></msub> <mo>+</mo> <mi>s</mi> <mo>·</mo>
    <msub><mi>S</mi> <mn>0</mn></msub> <mo>=</mo> <mi>w</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Assume logarithmic utility and for the price processes of the two traded financial
    assets <math alttext="upper B equals left-parenthesis 10 comma 11 right-parenthesis"><mrow><mi>B</mi>
    <mo>=</mo> <mo>(</mo> <mn>10</mn> <mo>,</mo> <mn>11</mn> <mo>)</mo></mrow></math>
    and <math alttext="upper S equals left-parenthesis 10 comma left-parenthesis 20
    comma 5 right-parenthesis Superscript upper T Baseline right-parenthesis"><mrow><mi>S</mi>
    <mo>=</mo> <mfenced separators="" open="(" close=")"><mn>10</mn> <mo>,</mo> <msup><mrow><mo>(</mo><mn>20</mn><mo>,</mo><mn>5</mn><mo>)</mo></mrow>
    <mi>T</mi></msup></mfenced></mrow></math> , respectively. With <math alttext="w
    equals 10"><mrow><mi>w</mi> <mo>=</mo> <mn>10</mn></mrow></math> , it holds <math
    alttext="b plus s equals 1"><mrow><mi>b</mi> <mo>+</mo> <mi>s</mi> <mo>=</mo>
    <mn>1</mn></mrow></math> such that the portfolio positions represent percent values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, the `minimize` function from the `scipy.optimize` subpackage is
    also appropriate to solve the investment problem of the agent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The bond price process and…
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: …the stock price process.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The price vector of the two traded financial assets.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The market payoff matrix of the two traded financial assets.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The physical probability measure for the economy.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO5-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The expected utility function with logarithmic utility.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO5-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Some example values for total portfolio weights of 1—diversification pays off.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](Images/8.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO5-12)'
  prefs: []
  type: TYPE_NORMAL
- en: The budget constraint based on the dot product of the price and portfolio vectors.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](Images/9.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO5-13)'
  prefs: []
  type: TYPE_NORMAL
- en: The expected utility maximization problem as a minimization.
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](Images/10.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO5-14)'
  prefs: []
  type: TYPE_NORMAL
- en: The optimal allocation between the bond and the stock.
  prefs: []
  type: TYPE_NORMAL
- en: '[![11](Images/11.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO5-15)'
  prefs: []
  type: TYPE_NORMAL
- en: The optimal expected utility value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![12](Images/12.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO5-17)'
  prefs: []
  type: TYPE_NORMAL
- en: The state-contingent payoff from the optimal portfolio.
  prefs: []
  type: TYPE_NORMAL
- en: Time-Additive Expected Utility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is possible to formulate the decision-making problem of the agent to include
    utility from money today as well:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper U colon upper R Subscript 0 Baseline times double-struck
    upper R Subscript 0 Baseline right-arrow double-struck upper R comma left-parenthesis
    c 0 comma c 1 right-parenthesis right-arrow from bar u left-parenthesis c 0 right-parenthesis
    plus kappa dot bold upper E Superscript upper P Baseline left-parenthesis u left-parenthesis
    c 1 right-parenthesis right-parenthesis" display="block"><mrow><mi>U</mi> <mo>:</mo>
    <msub><mi>R</mi> <mrow><mo>≥</mo><mn>0</mn></mrow></msub> <mo>×</mo> <msub><mi>ℝ</mi>
    <mrow><mo>≥</mo><mn>0</mn></mrow></msub> <mo>→</mo> <mi>ℝ</mi> <mo>,</mo> <mrow><mo>(</mo>
    <msub><mi>c</mi> <mn>0</mn></msub> <mo>,</mo> <msub><mi>c</mi> <mn>1</mn></msub>
    <mo>)</mo></mrow> <mo>↦</mo> <mi>u</mi> <mrow><mo>(</mo> <msub><mi>c</mi> <mn>0</mn></msub>
    <mo>)</mo></mrow> <mo>+</mo> <mi>κ</mi> <mo>·</mo> <msup><mi>𝐄</mi> <mi>P</mi></msup>
    <mrow><mo>(</mo> <mi>u</mi> <mrow><mo>(</mo> <msub><mi>c</mi> <mn>1</mn></msub>
    <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math><math mode="display"><mrow><mi>U</mi>
    <mo>:</mo> <msub><mi>R</mi> <mrow><mn>≥0</mn></mrow></msub> <mo>×</mo> <msub><mi>ℝ</mi>
    <mrow><mn>≥0</mn></mrow></msub> <mo>→</mo> <mi>ℝ</mi> <mo>,</mo> <mrow><mo>(</mo>
    <msub><mi>c</mi> <mn>0</mn></msub> <mo>,</mo> <msub><mi>c</mi> <mn>1</mn></msub>
    <mo>)</mo></mrow> <mo>↦</mo> <mi>u</mi> <mrow><mo>(</mo> <msub><mi>c</mi> <mn>0</mn></msub>
    <mo>)</mo></mrow> <mo>+</mo> <mi>κ</mi> <mo>·</mo> <msup><mi>𝐄</mi> <mi>P</mi></msup>
    <mrow><mo>(</mo> <mi>u</mi> <mrow><mo>(</mo> <msub><mi>c</mi> <mn>1</mn></msub>
    <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'With initial wealth <math alttext="w"><mi>w</mi></math> , the optimization
    problem in unconstrained form becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row 1st Column max Underscript c 0 comma b comma
    s comma lamda Endscripts f left-parenthesis c 0 comma b comma s comma lamda right-parenthesis
    2nd Column equals 3rd Column u left-parenthesis c 0 right-parenthesis plus kappa
    dot bold upper E Superscript upper P Baseline left-parenthesis u left-parenthesis
    b dot upper B 1 plus s dot upper S 1 right-parenthesis right-parenthesis 2nd Row
    1st Column Blank 2nd Column minus 3rd Column lamda dot left-parenthesis c 0 plus
    b dot upper B 0 plus s dot upper S 0 minus w right-parenthesis EndLayout" display="block"><mtable><mtr><mtd><mrow><munder><mo
    movablelimits="true" form="prefix">max</mo> <mrow><msub><mi>c</mi> <mn>0</mn></msub>
    <mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>λ</mi></mrow></munder> <mi>f</mi>
    <mrow><mo>(</mo> <msub><mi>c</mi> <mn>0</mn></msub> <mo>,</mo> <mi>b</mi> <mo>,</mo>
    <mi>s</mi> <mo>,</mo> <mi>λ</mi> <mo>)</mo></mrow></mrow></mtd> <mtd><mo>=</mo></mtd>
    <mtd><mrow><mi>u</mi> <mrow><mo>(</mo> <msub><mi>c</mi> <mn>0</mn></msub> <mo>)</mo></mrow>
    <mo>+</mo> <mi>κ</mi> <mo>·</mo> <msup><mi>𝐄</mi> <mi>P</mi></msup> <mfenced separators=""
    open="(" close=")"><mi>u</mi> <mo>(</mo> <mi>b</mi> <mo>·</mo> <msub><mi>B</mi>
    <mn>1</mn></msub> <mo>+</mo> <mi>s</mi> <mo>·</mo> <msub><mi>S</mi> <mn>1</mn></msub>
    <mo>)</mo></mfenced></mrow></mtd></mtr> <mtr><mtd><mo>-</mo></mtd> <mtd><mrow><mi>λ</mi>
    <mo>·</mo> <mo>(</mo> <msub><mi>c</mi> <mn>0</mn></msub> <mo>+</mo> <mi>b</mi>
    <mo>·</mo> <msub><mi>B</mi> <mn>0</mn></msub> <mo>+</mo> <mi>s</mi> <mo>·</mo>
    <msub><mi>S</mi> <mn>0</mn></msub> <mo>-</mo> <mi>w</mi> <mo>)</mo></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'With the assumptions from before, the optimal solution is derived with Python
    according to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The price vector including the price of 1 for consumption today.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The time preference factor.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The expected utility function taking into account consumption today and the
    time preference.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO6-6)'
  prefs: []
  type: TYPE_NORMAL
- en: This is what the agent consumes today from <math alttext="w"><mi>w</mi></math>
    .
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](ch04_split_000.xhtml#co_optimality_and_equilibrium_CO6-7)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the state-contingent payoff from the bond and the stock position.
  prefs: []
  type: TYPE_NORMAL
- en: Pricing in Complete Markets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, the analysis is changed to a pricing setting based on optimization
    principles. Assume that the two Arrow-Debreu securities are traded in the economy
    with two future states and that the *net supply* for both is one. The two payoff
    vectors form a *standard basis* for <math alttext="double-struck upper R squared"><msup><mi>ℝ</mi>
    <mn>2</mn></msup></math> , and the market payoff matrix is:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="script upper M equals Start 2 By 2 Matrix 1st Row 1st Column
    1 2nd Column 0 2nd Row 1st Column 0 2nd Column 1 EndMatrix" display="block"><mrow><mi>ℳ</mi>
    <mo>=</mo> <mfenced open="(" close=")"><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume now that there is a *representative agent* in the economy that is the
    only one trading the two securities. In an *equilibrium*, the representative agent
    needs to hold the net supply of both securities because there is nobody else.
    The mechanism that ensures equilibrium is the prices of the two securities today,
    that is, the price vector:'
  prefs: []
  type: TYPE_NORMAL
- en: <math mode="display"><mrow><msub><mi>ℳ</mi> <mn>0</mn></msub> <mo>=</mo> <msup><mrow><mo>(</mo><msup><mi>γ</mi>
    <mi>u</mi></msup> <mo>,</mo><msup><mi>γ</mi> <mi>d</mi></msup> <mo>)</mo></mrow>
    <mi>T</mi></msup> <mo>∈</mo> <msubsup><mi>ℝ</mi> <mrow><mn>≥0</mn></mrow> <mn>2</mn></msubsup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: The idea of equilibrium pricing is that this price vector needs to be adjusted
    in a way that the representative agent holds the net supply of all available financial
    assets. This is because otherwise there would be no equilibrium.
  prefs: []
  type: TYPE_NORMAL
- en: With the investment portfolio <math alttext="phi equals left-parenthesis phi
    Superscript u Baseline comma phi Superscript d Baseline right-parenthesis Superscript
    upper T"><mrow><mi>ϕ</mi> <mo>=</mo> <msup><mfenced separators="" open="(" close=")"><msup><mi>ϕ</mi>
    <mi>u</mi></msup> <mo>,</mo><msup><mi>ϕ</mi> <mi>d</mi></msup></mfenced> <mi>T</mi></msup></mrow></math>
    , the problem of the expected utility maximizing, representative agent is
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row  max Underscript phi Endscripts bold upper
    E Superscript upper P Baseline left-parenthesis u left-parenthesis script upper
    M dot phi right-parenthesis right-parenthesis 2nd Row  s period t period script
    upper M 0 dot phi equals w EndLayout" display="block"><mtable><mtr><mtd><mrow><munder><mo
    movablelimits="true" form="prefix">max</mo> <mi>ϕ</mi></munder> <msup><mi>𝐄</mi>
    <mi>P</mi></msup> <mrow><mo>(</mo> <mi>u</mi> <mrow><mo>(</mo> <mi>ℳ</mi> <mo>·</mo>
    <mi>ϕ</mi> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd><mrow><mtext>s.t.</mtext>
    <msub><mi>ℳ</mi> <mn>0</mn></msub> <mo>·</mo> <mi>ϕ</mi> <mo>=</mo> <mi>w</mi></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="max Underscript phi comma lamda Endscripts bold upper E Superscript
    upper P Baseline left-parenthesis u left-parenthesis script upper M dot phi right-parenthesis
    right-parenthesis minus lamda dot left-parenthesis script upper M 0 dot phi minus
    w right-parenthesis" display="block"><mrow><munder><mo movablelimits="true" form="prefix">max</mo>
    <mrow><mi>ϕ</mi><mo>,</mo><mi>λ</mi></mrow></munder> <msup><mi>𝐄</mi> <mi>P</mi></msup>
    <mrow><mo>(</mo> <mi>u</mi> <mrow><mo>(</mo> <mi>ℳ</mi> <mo>·</mo> <mi>ϕ</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>-</mo> <mi>λ</mi> <mo>·</mo> <mrow><mo>(</mo>
    <msub><mi>ℳ</mi> <mn>0</mn></msub> <mo>·</mo> <mi>ϕ</mi> <mo>-</mo> <mi>w</mi>
    <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Due to the special market payoff matrix, this translates into
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row  max Underscript phi Superscript u Baseline
    comma phi Superscript d Baseline Endscripts p dot u left-parenthesis phi Superscript
    u Baseline right-parenthesis plus left-parenthesis 1 minus p right-parenthesis
    dot u left-parenthesis phi Superscript d Baseline right-parenthesis 2nd Row  s
    period t period gamma Superscript u Baseline dot phi Superscript u Baseline plus
    gamma Superscript d Baseline dot phi Superscript d Baseline equals w EndLayout"
    display="block"><mtable><mtr><mtd><mrow><munder><mo movablelimits="true" form="prefix">max</mo>
    <mrow><msup><mi>ϕ</mi> <mi>u</mi></msup> <mo>,</mo><msup><mi>ϕ</mi> <mi>d</mi></msup></mrow></munder>
    <mi>p</mi> <mo>·</mo> <mi>u</mi> <mfenced separators="" open="(" close=")"><msup><mi>ϕ</mi>
    <mi>u</mi></msup></mfenced> <mo>+</mo> <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo>
    <mi>p</mi> <mo>)</mo></mrow> <mo>·</mo> <mi>u</mi> <mfenced separators="" open="("
    close=")"><msup><mi>ϕ</mi> <mi>d</mi></msup></mfenced></mrow></mtd></mtr> <mtr><mtd><mrow><mtext>s.t.</mtext>
    <msup><mi>γ</mi> <mi>u</mi></msup> <mo>·</mo> <msup><mi>ϕ</mi> <mi>u</mi></msup>
    <mo>+</mo> <msup><mi>γ</mi> <mi>d</mi></msup> <mo>·</mo> <msup><mi>ϕ</mi> <mi>d</mi></msup>
    <mo>=</mo> <mi>w</mi></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="max Underscript phi Superscript u Baseline comma phi Superscript
    d Baseline comma lamda Endscripts f left-parenthesis phi Superscript u Baseline
    comma phi Superscript d Baseline comma lamda right-parenthesis equals p dot u
    left-parenthesis phi Superscript u Baseline right-parenthesis plus left-parenthesis
    1 minus p right-parenthesis dot u left-parenthesis phi Superscript d Baseline
    right-parenthesis minus lamda dot left-parenthesis gamma Superscript u Baseline
    dot phi Superscript u Baseline plus gamma Superscript d Baseline dot phi Superscript
    d Baseline minus w right-parenthesis" display="block"><mrow><munder><mo movablelimits="true"
    form="prefix">max</mo> <mrow><msup><mi>ϕ</mi> <mi>u</mi></msup> <mo>,</mo><msup><mi>ϕ</mi>
    <mi>d</mi></msup> <mo>,</mo><mi>λ</mi></mrow></munder> <mi>f</mi> <mrow><mo>(</mo>
    <msup><mi>ϕ</mi> <mi>u</mi></msup> <mo>,</mo> <msup><mi>ϕ</mi> <mi>d</mi></msup>
    <mo>,</mo> <mi>λ</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>p</mi> <mo>·</mo> <mi>u</mi>
    <mfenced separators="" open="(" close=")"><msup><mi>ϕ</mi> <mi>u</mi></msup></mfenced>
    <mo>+</mo> <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <mi>p</mi> <mo>)</mo></mrow>
    <mo>·</mo> <mi>u</mi> <mfenced separators="" open="(" close=")"><msup><mi>ϕ</mi>
    <mi>d</mi></msup></mfenced> <mo>-</mo> <mi>λ</mi> <mo>·</mo> <mfenced separators=""
    open="(" close=")"><msup><mi>γ</mi> <mi>u</mi></msup> <mo>·</mo> <msup><mi>ϕ</mi>
    <mi>u</mi></msup> <mo>+</mo> <msup><mi>γ</mi> <mi>d</mi></msup> <mo>·</mo> <msup><mi>ϕ</mi>
    <mi>d</mi></msup> <mo>-</mo> <mi>w</mi></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The three first-order conditions for the unconstrained problem are:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout Enlarged left-brace 1st Row  StartFraction normal
    partial-differential f Over normal partial-differential phi Superscript u Baseline
    EndFraction equals p dot u prime left-parenthesis phi Superscript u Baseline right-parenthesis
    minus lamda dot gamma Superscript u Baseline equals 0 2nd Row  StartFraction normal
    partial-differential f Over normal partial-differential phi Superscript d Baseline
    EndFraction equals left-parenthesis 1 minus p right-parenthesis dot u prime left-parenthesis
    phi Superscript d Baseline right-parenthesis minus lamda dot gamma Superscript
    d Baseline equals 0 3rd Row  StartFraction normal partial-differential f Over
    normal partial-differential lamda EndFraction equals gamma Superscript u Baseline
    dot phi Superscript u Baseline plus gamma Superscript d Baseline dot phi Superscript
    d Baseline minus w equals 0 EndLayout" display="block"><mfenced separators=""
    open="{" close=""><mtable><mtr><mtd columnalign="left"><mrow><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><msup><mi>ϕ</mi> <mi>u</mi></msup></mrow></mfrac> <mo>=</mo> <mi>p</mi>
    <mo>·</mo> <msup><mi>u</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <msup><mi>ϕ</mi>
    <mi>u</mi></msup> <mo>)</mo></mrow> <mo>-</mo> <mi>λ</mi> <mo>·</mo> <msup><mi>γ</mi>
    <mi>u</mi></msup> <mo>=</mo> <mn>0</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><msup><mi>ϕ</mi> <mi>d</mi></msup></mrow></mfrac> <mo>=</mo> <mrow><mo>(</mo>
    <mn>1</mn> <mo>-</mo> <mi>p</mi> <mo>)</mo></mrow> <mo>·</mo> <msup><mi>u</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <msup><mi>ϕ</mi> <mi>d</mi></msup> <mo>)</mo></mrow>
    <mo>-</mo> <mi>λ</mi> <mo>·</mo> <msup><mi>γ</mi> <mi>d</mi></msup> <mo>=</mo>
    <mn>0</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><mi>λ</mi></mrow></mfrac> <mo>=</mo> <msup><mi>γ</mi> <mi>u</mi></msup>
    <mo>·</mo> <msup><mi>ϕ</mi> <mi>u</mi></msup> <mo>+</mo> <msup><mi>γ</mi> <mi>d</mi></msup>
    <mo>·</mo> <msup><mi>ϕ</mi> <mi>d</mi></msup> <mo>-</mo> <mi>w</mi> <mo>=</mo>
    <mn>0</mn></mrow></mtd></mtr></mtable></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'What consequences for the prices <math alttext="script upper M 0"><msub><mi>ℳ</mi>
    <mn>0</mn></msub></math> follow from these optimality conditions? The first is
    with regard to the *relative price* of the two Arrow-Debreu securities:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction gamma Superscript u Baseline Over gamma Superscript
    d Baseline EndFraction equals StartFraction p dot u prime left-parenthesis phi
    Superscript u Baseline right-parenthesis Over left-parenthesis 1 minus p right-parenthesis
    dot u prime left-parenthesis phi Superscript d Baseline right-parenthesis EndFraction"
    display="block"><mrow><mfrac><msup><mi>γ</mi> <mi>u</mi></msup> <msup><mi>γ</mi>
    <mi>d</mi></msup></mfrac> <mo>=</mo> <mfrac><mrow><mi>p</mi><mo>·</mo><msup><mi>u</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo><msup><mi>ϕ</mi> <mi>u</mi></msup> <mo>)</mo></mrow></mrow>
    <mrow><mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>p</mi><mo>)</mo></mrow><mo>·</mo><msup><mi>u</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo><msup><mi>ϕ</mi> <mi>d</mi></msup> <mo>)</mo></mrow></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The relative price is fully determined by the probabilities for the two states
    to occur and the marginal utilities gained from consumption in the two states.
    Factoring in that *in equilibrium* <math alttext="phi Superscript u Baseline equals
    phi Superscript d Baseline equals 1"><mrow><msup><mi>ϕ</mi> <mi>u</mi></msup>
    <mo>=</mo> <msup><mi>ϕ</mi> <mi>d</mi></msup> <mo>=</mo> <mn>1</mn></mrow></math>
    must hold, the relative price is determined by the probability measure only:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction gamma Superscript u Baseline Over gamma Superscript
    d Baseline EndFraction equals StartFraction p Over left-parenthesis 1 minus p
    right-parenthesis EndFraction" display="block"><mrow><mfrac><msup><mi>γ</mi> <mi>u</mi></msup>
    <msup><mi>γ</mi> <mi>d</mi></msup></mfrac> <mo>=</mo> <mfrac><mi>p</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>p</mi><mo>)</mo></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'With this additional condition, one also obtains:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="gamma Superscript u Baseline plus gamma Superscript d Baseline
    equals w" display="block"><mrow><msup><mi>γ</mi> <mi>u</mi></msup> <mo>+</mo>
    <msup><mi>γ</mi> <mi>d</mi></msup> <mo>=</mo> <mi>w</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: While the relative price is determined by the probability measure in this case,
    the absolute prices are determined by the initial wealth available. This is intuitively
    appealing in that the prices should be higher the more initial wealth there is,
    given that the net supply for two securities is fixed.
  prefs: []
  type: TYPE_NORMAL
- en: Normalizing initial wealth to <math alttext="w equals 1"><mrow><mi>w</mi> <mo>=</mo>
    <mn>1</mn></mrow></math> , for instance, fixes the prices via
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="gamma Superscript u Baseline equals 1 minus gamma Superscript
    d" display="block"><mrow><msup><mi>γ</mi> <mi>u</mi></msup> <mo>=</mo> <mn>1</mn>
    <mo>-</mo> <msup><mi>γ</mi> <mi>d</mi></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: to finally arrive at the equilibrium prices of
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout Enlarged left-brace 1st Row  gamma Superscript u
    Baseline equals p 2nd Row  gamma Superscript d Baseline equals 1 minus p EndLayout"
    display="block"><mfenced separators="" open="{" close=""><mtable><mtr><mtd columnalign="left"><mrow><msup><mi>γ</mi>
    <mi>u</mi></msup> <mo>=</mo> <mi>p</mi></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><msup><mi>γ</mi>
    <mi>d</mi></msup> <mo>=</mo> <mn>1</mn> <mo>-</mo> <mi>p</mi></mrow></mtd></mtr></mtable></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: or the equilibrium price vector <math alttext="script upper M 0 Superscript
    asterisk Baseline equals left-parenthesis p comma 1 minus p right-parenthesis
    Superscript upper T"><mrow><msubsup><mi>ℳ</mi> <mn>0</mn> <mo>*</mo></msubsup>
    <mo>=</mo> <msup><mrow><mo>(</mo><mi>p</mi><mo>,</mo><mn>1</mn><mo>-</mo><mi>p</mi><mo>)</mo></mrow>
    <mi>T</mi></msup></mrow></math> .
  prefs: []
  type: TYPE_NORMAL
- en: Arbitrage Pricing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What about arbitrage prices of contingent claims given the equilibrium price
    vector <math alttext="script upper M 0 Superscript asterisk"><msubsup><mi>ℳ</mi>
    <mn>0</mn> <mo>*</mo></msubsup></math> ? In complete markets, in which every contingent
    claim is attainable, the price of any such attainable contingent claim <math><mrow><msub><mi>C</mi>
    <mn>1</mn></msub> <mo>∈</mo><mi>𝔸</mi><mo>=</mo><msubsup><mi>ℝ</mi> <mrow><mn>≥0</mn></mrow>
    <mn>2</mn></msubsup></mrow></math> is then given by:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper C 0 equals script upper M 0 Superscript asterisk Baseline
    dot upper C 1 equals gamma Superscript u Baseline dot upper C 1 Superscript u
    Baseline plus gamma Superscript d Baseline dot upper C 1 Superscript d" display="block"><mrow><msub><mi>C</mi>
    <mn>0</mn></msub> <mo>=</mo> <msubsup><mi>ℳ</mi> <mn>0</mn> <mo>*</mo></msubsup>
    <mo>·</mo> <msub><mi>C</mi> <mn>1</mn></msub> <mo>=</mo> <msup><mi>γ</mi> <mi>u</mi></msup>
    <mo>·</mo> <msubsup><mi>C</mi> <mn>1</mn> <mi>u</mi></msubsup> <mo>+</mo> <msup><mi>γ</mi>
    <mi>d</mi></msup> <mo>·</mo> <msubsup><mi>C</mi> <mn>1</mn> <mi>d</mi></msubsup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: This is because the replication portfolio is simply the state-contingent payoff
    itself <math alttext="phi equals upper C 1"><mrow><mi>ϕ</mi> <mo>=</mo> <msub><mi>C</mi>
    <mn>1</mn></msub></mrow></math> in the special case of two Arrow-Debreu securities.
    The prices of Arrow-Debreu securities are therefore also called *state prices*
    because they represent the price for one unit of currency (consumption) in a certain
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Martingale Pricing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How does the unique martingale measure look for the current economy? The condition
    for the martingale measure <math alttext="upper Q"><mi>Q</mi></math> is that it
    makes all discounted price processes of traded financial assets a martingale.
    In matrix form, the conditions are:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="script upper M 0 Superscript asterisk Baseline equals StartFraction
    1 Over 1 plus i EndFraction dot bold upper E Superscript upper Q Baseline left-parenthesis
    script upper M right-parenthesis" display="block"><mrow><msubsup><mi>ℳ</mi> <mn>0</mn>
    <mo>*</mo></msubsup> <mo>=</mo> <mfrac><mn>1</mn> <mrow><mn>1</mn><mo>+</mo><mi>i</mi></mrow></mfrac>
    <mo>·</mo> <msup><mi>𝐄</mi> <mi>Q</mi></msup> <mrow><mo>(</mo> <mi>ℳ</mi> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'More explicitly, one gets:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout Enlarged left-brace 1st Row 1st Column p dot left-parenthesis
    1 plus i right-parenthesis 2nd Column equals 3rd Column q 2nd Row 1st Column left-parenthesis
    1 minus p right-parenthesis dot left-parenthesis 1 plus i right-parenthesis 2nd
    Column equals 3rd Column 1 minus q EndLayout" display="block"><mfenced separators=""
    open="{" close=""><mtable><mtr><mtd columnalign="left"><mrow><mi>p</mi> <mo>·</mo>
    <mo>(</mo> <mn>1</mn> <mo>+</mo> <mi>i</mi> <mo>)</mo></mrow></mtd> <mtd columnalign="left"><mo>=</mo></mtd>
    <mtd><mi>q</mi></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mo>(</mo> <mn>1</mn>
    <mo>-</mo> <mi>p</mi> <mo>)</mo> <mo>·</mo> <mo>(</mo> <mn>1</mn> <mo>+</mo> <mi>i</mi>
    <mo>)</mo></mrow></mtd> <mtd columnalign="left"><mo>=</mo></mtd> <mtd><mrow><mn>1</mn>
    <mo>-</mo> <mi>q</mi></mrow></mtd></mtr></mtable></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: From these, <math alttext="i equals 0"><mrow><mi>i</mi> <mo>=</mo> <mn>0</mn></mrow></math>
    follows and also <math alttext="q equals p"><mrow><mi>q</mi> <mo>=</mo> <mi>p</mi></mrow></math>
    . The physical probability measure makes all probabilities already a martingale.
    The other way around, the prices for the two Arrow-Debreu securities are set in
    equilibrium in a way such that the discounted price processes are martingales.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every attainable contingent claim <math alttext="upper C 1 element-of double-struck
    upper A"><mrow><msub><mi>C</mi> <mn>1</mn></msub> <mo>∈</mo> <mi>𝔸</mi></mrow></math>
    can be priced by simply taking the expectation under the physical probability
    measure in this special kind of representative agent economy. Formally, this translates
    into:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper C 0 equals bold upper E Superscript upper P Baseline left-parenthesis
    upper C 1 right-parenthesis" display="block"><mrow><msub><mi>C</mi> <mn>0</mn></msub>
    <mo>=</mo> <msup><mi>𝐄</mi> <mi>P</mi></msup> <mrow><mo>(</mo> <msub><mi>C</mi>
    <mn>1</mn></msub> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Risk-Less Interest Rate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Why is the equilibrium risk-less interest rate zero? The answer is quite simple:
    because there is no risk-less financial asset traded that fixes another interest
    rate. Consider a *risk-less financial asset* paying 1 in every state <math alttext="upper
    B 1 equals left-parenthesis 1 comma 1 right-parenthesis Superscript upper T"><mrow><msub><mi>B</mi>
    <mn>1</mn></msub> <mo>=</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>)</mo></mrow>
    <mi>T</mi></msup></mrow></math> . The *arbitrage price* for this financial asset
    is'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper B 0 equals script upper M 0 Superscript asterisk Baseline
    dot upper B 1 equals p plus left-parenthesis 1 minus p right-parenthesis equals
    1" display="block"><mrow><msub><mi>B</mi> <mn>0</mn></msub> <mo>=</mo> <msubsup><mi>ℳ</mi>
    <mn>0</mn> <mo>*</mo></msubsup> <mo>·</mo> <msub><mi>B</mi> <mn>1</mn></msub>
    <mo>=</mo> <mi>p</mi> <mo>+</mo> <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <mi>p</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mn>1</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: implying a risk-less interest rate of <math alttext="i equals 0"><mrow><mi>i</mi>
    <mo>=</mo> <mn>0</mn></mrow></math> . Any other price <math alttext="0 less-than
    upper B 0 less-than 1"><mrow><mn>0</mn> <mo><</mo> <msub><mi>B</mi> <mn>0</mn></msub>
    <mo><</mo> <mn>1</mn></mrow></math> , implying a positive risk-less interest rate,
    would also imply arbitrage opportunities.
  prefs: []
  type: TYPE_NORMAL
- en: A Numerical Example (I)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The equilibrium pricing analysis so far rests on a number of simplifying assumptions
    allowing for elegant solutions and simple relations. Consider now a case with
    the somehow more realistic numerical assumptions as used multiple times before.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, assume expected utility maximization based on logarithmic utility
    for the representative agent. Assume further price processes for the risk-less
    bond of
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper B equals left-parenthesis upper B 0 comma left-parenthesis
    11 comma 11 right-parenthesis Superscript upper T Baseline right-parenthesis"
    display="block"><mrow><mi>B</mi> <mo>=</mo> <mfenced separators="" open="(" close=")"><msub><mi>B</mi>
    <mn>0</mn></msub> <mo>,</mo> <msup><mrow><mo>(</mo><mn>11</mn><mo>,</mo><mn>11</mn><mo>)</mo></mrow>
    <mi>T</mi></msup></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: and for the risky stock of
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper S equals left-parenthesis upper S 0 comma left-parenthesis
    20 comma 5 right-parenthesis Superscript upper T Baseline right-parenthesis" display="block"><mrow><mi>S</mi>
    <mo>=</mo> <mfenced separators="" open="(" close=")"><msub><mi>S</mi> <mn>0</mn></msub>
    <mo>,</mo> <msup><mrow><mo>(</mo><mn>20</mn><mo>,</mo><mn>5</mn><mo>)</mo></mrow>
    <mi>T</mi></msup></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The market payoff matrix accordingly is:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="script upper M equals Start 2 By 2 Matrix 1st Row 1st Column
    11 2nd Column 20 2nd Row 1st Column 11 2nd Column 5 EndMatrix" display="block"><mrow><mi>ℳ</mi>
    <mo>=</mo> <mfenced open="(" close=")"><mtable><mtr><mtd><mn>11</mn></mtd> <mtd><mn>20</mn></mtd></mtr>
    <mtr><mtd><mn>11</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: The physical probability measure is given by <math alttext="upper P equals left-parenthesis
    p comma left-parenthesis 1 minus p right-parenthesis right-parenthesis Superscript
    upper T"><mrow><mi>P</mi> <mo>=</mo> <msup><mfenced separators="" open="(" close=")"><mi>p</mi><mo>,</mo><mo>(</mo><mn>1</mn><mo>-</mo><mi>p</mi><mo>)</mo></mfenced>
    <mi>T</mi></msup></mrow></math> with <math alttext="p equals one-third"><mrow><mi>p</mi>
    <mo>=</mo> <mfrac><mn>1</mn> <mn>3</mn></mfrac></mrow></math> . The net supply
    of the risk-less bond is <math alttext="b equals 1"><mrow><mi>b</mi> <mo>=</mo>
    <mn>1</mn></mrow></math> , and it is <math alttext="s equals 1"><mrow><mi>s</mi>
    <mo>=</mo> <mn>1</mn></mrow></math> for the risky stock. The initial wealth the
    agent has available shall be <math alttext="w equals 15"><mrow><mi>w</mi> <mo>=</mo>
    <mn>15</mn></mrow></math> .
  prefs: []
  type: TYPE_NORMAL
- en: The problem of the representative agent is
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="max Underscript phi comma lamda Endscripts f left-parenthesis
    phi comma lamda right-parenthesis equals bold upper E Superscript upper P Baseline
    left-parenthesis u left-parenthesis script upper M dot phi right-parenthesis right-parenthesis
    minus lamda dot left-parenthesis script upper M 0 dot phi minus w right-parenthesis"
    display="block"><mrow><munder><mo movablelimits="true" form="prefix">max</mo>
    <mrow><mi>ϕ</mi><mo>,</mo><mi>λ</mi></mrow></munder> <mi>f</mi> <mrow><mo>(</mo>
    <mi>ϕ</mi> <mo>,</mo> <mi>λ</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>𝐄</mi>
    <mi>P</mi></msup> <mfenced separators="" open="(" close=")"><mi>u</mi> <mo>(</mo>
    <mi>ℳ</mi> <mo>·</mo> <mi>ϕ</mi> <mo>)</mo></mfenced> <mo>-</mo> <mi>λ</mi> <mo>·</mo>
    <mfenced separators="" open="(" close=")"><msub><mi>ℳ</mi> <mn>0</mn></msub> <mo>·</mo>
    <mi>ϕ</mi> <mo>-</mo> <mi>w</mi></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="max Underscript b comma s comma lamda Endscripts f left-parenthesis
    b comma s comma lamda right-parenthesis equals bold upper E Superscript upper
    P Baseline left-parenthesis u left-parenthesis b dot upper B 1 plus s dot upper
    S 1 right-parenthesis right-parenthesis minus lamda dot left-parenthesis b dot
    upper B 0 plus s dot upper S 0 minus w right-parenthesis" display="block"><mrow><munder><mo
    movablelimits="true" form="prefix">max</mo> <mrow><mi>b</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>λ</mi></mrow></munder>
    <mi>f</mi> <mrow><mo>(</mo> <mi>b</mi> <mo>,</mo> <mi>s</mi> <mo>,</mo> <mi>λ</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msup><mi>𝐄</mi> <mi>P</mi></msup> <mfenced separators=""
    open="(" close=")"><mi>u</mi> <mo>(</mo> <mi>b</mi> <mo>·</mo> <msub><mi>B</mi>
    <mn>1</mn></msub> <mo>+</mo> <mi>s</mi> <mo>·</mo> <msub><mi>S</mi> <mn>1</mn></msub>
    <mo>)</mo></mfenced> <mo>-</mo> <mi>λ</mi> <mo>·</mo> <mfenced separators="" open="("
    close=")"><mi>b</mi> <mo>·</mo> <msub><mi>B</mi> <mn>0</mn></msub> <mo>+</mo>
    <mi>s</mi> <mo>·</mo> <msub><mi>S</mi> <mn>0</mn></msub> <mo>-</mo> <mi>w</mi></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The three first-order conditions are:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout Enlarged left-brace 1st Row  StartFraction normal
    partial-differential f Over normal partial-differential b EndFraction equals bold
    upper E Superscript upper P Baseline left-parenthesis upper B 1 dot u prime left-parenthesis
    b dot upper B 1 plus s dot upper S 1 right-parenthesis right-parenthesis minus
    lamda dot upper B 0 equals 0 2nd Row  StartFraction normal partial-differential
    f Over normal partial-differential s EndFraction equals bold upper E Superscript
    upper P Baseline left-parenthesis upper S 1 dot u prime left-parenthesis b dot
    upper B 1 plus s dot upper S 1 right-parenthesis right-parenthesis minus lamda
    dot upper S 0 equals 0 3rd Row  StartFraction normal partial-differential f Over
    normal partial-differential lamda EndFraction equals b dot upper B 0 plus s dot
    upper S 0 minus w equals 0 EndLayout" display="block"><mfenced separators="" open="{"
    close=""><mtable><mtr><mtd columnalign="left"><mrow><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><mi>b</mi></mrow></mfrac> <mo>=</mo> <msup><mi>𝐄</mi> <mi>P</mi></msup>
    <mfenced separators="" open="(" close=")"><msub><mi>B</mi> <mn>1</mn></msub> <mo>·</mo>
    <msup><mi>u</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>b</mi> <mo>·</mo> <msub><mi>B</mi>
    <mn>1</mn></msub> <mo>+</mo> <mi>s</mi> <mo>·</mo> <msub><mi>S</mi> <mn>1</mn></msub>
    <mo>)</mo></mrow></mfenced> <mo>-</mo> <mi>λ</mi> <mo>·</mo> <msub><mi>B</mi>
    <mn>0</mn></msub> <mo>=</mo> <mn>0</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><mi>s</mi></mrow></mfrac> <mo>=</mo> <msup><mi>𝐄</mi> <mi>P</mi></msup>
    <mfenced separators="" open="(" close=")"><msub><mi>S</mi> <mn>1</mn></msub> <mo>·</mo>
    <msup><mi>u</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>b</mi> <mo>·</mo> <msub><mi>B</mi>
    <mn>1</mn></msub> <mo>+</mo> <mi>s</mi> <mo>·</mo> <msub><mi>S</mi> <mn>1</mn></msub>
    <mo>)</mo></mrow></mfenced> <mo>-</mo> <mi>λ</mi> <mo>·</mo> <msub><mi>S</mi>
    <mn>0</mn></msub> <mo>=</mo> <mn>0</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><mi>λ</mi></mrow></mfrac> <mo>=</mo> <mi>b</mi> <mo>·</mo> <msub><mi>B</mi>
    <mn>0</mn></msub> <mo>+</mo> <mi>s</mi> <mo>·</mo> <msub><mi>S</mi> <mn>0</mn></msub>
    <mo>-</mo> <mi>w</mi> <mo>=</mo> <mn>0</mn></mrow></mtd></mtr></mtable></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The *relative price* for the two financial assets according to the optimality
    conditions—and taking into account the net supply of one for both financial assets
    as well as the logarithmic utility—is:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row 1st Column StartFraction upper S 0 Over upper
    B 0 EndFraction 2nd Column equals 3rd Column StartFraction bold upper E Superscript
    upper P Baseline left-parenthesis upper S 1 dot u prime left-parenthesis b dot
    upper B 1 plus s dot upper S 1 right-parenthesis right-parenthesis Over bold upper
    E Superscript upper P Baseline left-parenthesis upper B 1 dot u prime left-parenthesis
    b dot upper B 1 plus s dot upper S 1 right-parenthesis right-parenthesis EndFraction
    2nd Row 1st Column Blank 2nd Column equals 3rd Column StartStartFraction bold
    upper E Superscript upper P Baseline left-parenthesis StartFraction upper S 1
    Over upper B 1 plus upper S 1 EndFraction right-parenthesis OverOver bold upper
    E Superscript upper P Baseline left-parenthesis StartFraction upper B 1 Over upper
    B 1 plus upper S 1 EndFraction right-parenthesis EndEndFraction identical-to zeta
    EndLayout" display="block"><mtable><mtr><mtd><mfrac><msub><mi>S</mi> <mn>0</mn></msub>
    <msub><mi>B</mi> <mn>0</mn></msub></mfrac></mtd> <mtd><mo>=</mo></mtd> <mtd><mfrac><mrow><msup><mi>𝐄</mi>
    <mi>P</mi></msup> <mfenced separators="" open="(" close=")"><msub><mi>S</mi> <mn>1</mn></msub>
    <mo>·</mo><msup><mi>u</mi> <mo>'</mo></msup> <mrow><mo>(</mo><mi>b</mi><mo>·</mo><msub><mi>B</mi>
    <mn>1</mn></msub> <mo>+</mo><mi>s</mi><mo>·</mo><msub><mi>S</mi> <mn>1</mn></msub>
    <mo>)</mo></mrow></mfenced></mrow> <mrow><msup><mi>𝐄</mi> <mi>P</mi></msup> <mfenced
    separators="" open="(" close=")"><msub><mi>B</mi> <mn>1</mn></msub> <mo>·</mo><msup><mi>u</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo><mi>b</mi><mo>·</mo><msub><mi>B</mi> <mn>1</mn></msub>
    <mo>+</mo><mi>s</mi><mo>·</mo><msub><mi>S</mi> <mn>1</mn></msub> <mo>)</mo></mrow></mfenced></mrow></mfrac></mtd></mtr>
    <mtr><mtd><mo>=</mo></mtd> <mtd><mrow><mfrac><mrow><msup><mi>𝐄</mi> <mi>P</mi></msup>
    <mfenced separators="" open="(" close=")"><mfrac><msub><mi>S</mi> <mn>1</mn></msub>
    <mrow><msub><mi>B</mi> <mn>1</mn></msub> <mo>+</mo><msub><mi>S</mi> <mn>1</mn></msub></mrow></mfrac></mfenced></mrow>
    <mrow><msup><mi>𝐄</mi> <mi>P</mi></msup> <mfenced separators="" open="(" close=")"><mfrac><msub><mi>B</mi>
    <mn>1</mn></msub> <mrow><msub><mi>B</mi> <mn>1</mn></msub> <mo>+</mo><msub><mi>S</mi>
    <mn>1</mn></msub></mrow></mfrac></mfenced></mrow></mfrac> <mo>≡</mo> <mi>ζ</mi></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the budget constraint to the mix fixes not only the *relative price*
    <math alttext="zeta"><mi>ζ</mi></math> but also the absolute price levels:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper B 0 plus zeta dot upper B 0 equals w left right double
    arrow upper B 0 equals StartFraction w Over 1 plus zeta EndFraction" display="block"><mrow><msub><mi>B</mi>
    <mn>0</mn></msub> <mo>+</mo> <mi>ζ</mi> <mo>·</mo> <msub><mi>B</mi> <mn>0</mn></msub>
    <mo>=</mo> <mi>w</mi> <mo>⇔</mo> <msub><mi>B</mi> <mn>0</mn></msub> <mo>=</mo>
    <mfrac><mi>w</mi> <mrow><mn>1</mn><mo>+</mo><mi>ζ</mi></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, these considerations translate into simple vectorized operations
    using `NumPy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The probability measure.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The price ratio `zeta` given optimality conditions.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO7-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The initial wealth.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO7-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The equilibrium price level of the risk-less bond given the price ratio `zeta`
    and initial wealth `w`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO7-8)'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting equilibrium price level of the risky stock.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO7-10)'
  prefs: []
  type: TYPE_NORMAL
- en: The budget constraint is binding.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO7-11)'
  prefs: []
  type: TYPE_NORMAL
- en: The equilibrium interest rate given the price level for the risk-less bond.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](Images/8.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO7-13)'
  prefs: []
  type: TYPE_NORMAL
- en: The equilibrium expected rate of return of the risky stock.
  prefs: []
  type: TYPE_NORMAL
- en: 'Equilibrium pricing does not lead in this case to the discounted price processes
    being martingales under the physical probability measure. The *martingale measure*
    is easily derived, however. The analysis uses the [`SymPy`](http://sympy.org)
    package for symbolic computations with Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Imports the symbolic computation package `SymPy`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the symbol `q`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Formulating the equation for `q` given the martingale condition.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO8-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The equation simplified.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO8-5)'
  prefs: []
  type: TYPE_NORMAL
- en: This solves the equation numerically.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO8-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting martingale measure.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO8-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Both discounted price processes are martingales under `Q`.
  prefs: []
  type: TYPE_NORMAL
- en: Pricing in Incomplete Markets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How does representative agent pricing work in *incomplete markets*? The answer
    fortunately is: exactly the same way as in complete markets.'
  prefs: []
  type: TYPE_NORMAL
- en: Assume the two date, three-state economy in which a *risk-less bond* with price
    process
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper B equals left-parenthesis upper B 0 comma left-parenthesis
    11 comma 11 comma 11 right-parenthesis Superscript upper T Baseline right-parenthesis"
    display="block"><mrow><mi>B</mi> <mo>=</mo> <mfenced separators="" open="(" close=")"><msub><mi>B</mi>
    <mn>0</mn></msub> <mo>,</mo> <msup><mrow><mo>(</mo><mn>11</mn><mo>,</mo><mn>11</mn><mo>,</mo><mn>11</mn><mo>)</mo></mrow>
    <mi>T</mi></msup></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: and a *risky stock* with price process
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper S equals left-parenthesis upper S 0 comma left-parenthesis
    20 comma 10 comma 5 right-parenthesis Superscript upper T Baseline right-parenthesis"
    display="block"><mrow><mi>S</mi> <mo>=</mo> <mfenced separators="" open="(" close=")"><msub><mi>S</mi>
    <mn>0</mn></msub> <mo>,</mo> <msup><mrow><mo>(</mo><mn>20</mn><mo>,</mo><mn>10</mn><mo>,</mo><mn>5</mn><mo>)</mo></mrow>
    <mi>T</mi></msup></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: are traded. The physical probability measure is <math alttext="upper P equals
    left-parenthesis p comma p comma p right-parenthesis Superscript upper T"><mrow><mi>P</mi>
    <mo>=</mo> <msup><mrow><mo>(</mo><mi>p</mi><mo>,</mo><mi>p</mi><mo>,</mo><mi>p</mi><mo>)</mo></mrow>
    <mi>T</mi></msup></mrow></math> , with <math alttext="p equals one-third"><mrow><mi>p</mi>
    <mo>=</mo> <mfrac><mn>1</mn> <mn>3</mn></mfrac></mrow></math> . Everything else
    shall be as in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Formally, the optimization problem of the representative agent does not change:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="max Underscript b comma s comma lamda Endscripts f left-parenthesis
    b comma s comma lamda right-parenthesis equals bold upper E Superscript upper
    P Baseline left-parenthesis u left-parenthesis b dot upper B 1 plus s dot upper
    S 1 right-parenthesis right-parenthesis minus lamda dot left-parenthesis b dot
    upper B 0 plus s dot upper S 0 minus w right-parenthesis" display="block"><mrow><munder><mo
    movablelimits="true" form="prefix">max</mo> <mrow><mi>b</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>λ</mi></mrow></munder>
    <mi>f</mi> <mrow><mo>(</mo> <mi>b</mi> <mo>,</mo> <mi>s</mi> <mo>,</mo> <mi>λ</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msup><mi>𝐄</mi> <mi>P</mi></msup> <mfenced separators=""
    open="(" close=")"><mi>u</mi> <mo>(</mo> <mi>b</mi> <mo>·</mo> <msub><mi>B</mi>
    <mn>1</mn></msub> <mo>+</mo> <mi>s</mi> <mo>·</mo> <msub><mi>S</mi> <mn>1</mn></msub>
    <mo>)</mo></mfenced> <mo>-</mo> <mi>λ</mi> <mo>·</mo> <mfenced separators="" open="("
    close=")"><mi>b</mi> <mo>·</mo> <msub><mi>B</mi> <mn>0</mn></msub> <mo>+</mo>
    <mi>s</mi> <mo>·</mo> <msub><mi>S</mi> <mn>0</mn></msub> <mo>-</mo> <mi>w</mi></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Nor does the formula for the relative price change:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row 1st Column StartFraction upper S 0 Over upper
    B 0 EndFraction 2nd Column equals 3rd Column StartStartFraction bold upper E Superscript
    upper P Baseline left-parenthesis StartFraction upper S 1 Over upper B 1 plus
    upper S 1 EndFraction right-parenthesis OverOver bold upper E Superscript upper
    P Baseline left-parenthesis StartFraction upper B 1 Over upper B 1 plus upper
    S 1 EndFraction right-parenthesis EndEndFraction identical-to zeta EndLayout"
    display="block"><mtable><mtr><mtd><mfrac><msub><mi>S</mi> <mn>0</mn></msub> <msub><mi>B</mi>
    <mn>0</mn></msub></mfrac></mtd> <mtd><mo>=</mo></mtd> <mtd><mrow><mfrac><mrow><msup><mi>𝐄</mi>
    <mi>P</mi></msup> <mfenced separators="" open="(" close=")"><mfrac><msub><mi>S</mi>
    <mn>1</mn></msub> <mrow><msub><mi>B</mi> <mn>1</mn></msub> <mo>+</mo><msub><mi>S</mi>
    <mn>1</mn></msub></mrow></mfrac></mfenced></mrow> <mrow><msup><mi>𝐄</mi> <mi>P</mi></msup>
    <mfenced separators="" open="(" close=")"><mfrac><msub><mi>B</mi> <mn>1</mn></msub>
    <mrow><msub><mi>B</mi> <mn>1</mn></msub> <mo>+</mo><msub><mi>S</mi> <mn>1</mn></msub></mrow></mfrac></mfenced></mrow></mfrac>
    <mo>≡</mo> <mi>ζ</mi></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, only the future price vectors of the financial assets and the vector
    representing the probability measure need to be adjusted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The probability measure.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The relative price `zeta` given optimality conditions.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO9-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The initial wealth.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO9-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The equilibrium price level of the risk-less bond given the price ratio `zeta`
    and initial wealth `w`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO9-8)'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting equilibrium price level of the risky stock.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO9-10)'
  prefs: []
  type: TYPE_NORMAL
- en: The budget constraint is binding.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO9-11)'
  prefs: []
  type: TYPE_NORMAL
- en: The equilibrium interest rate given the price level for the risk-less bond.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](Images/8.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO9-13)'
  prefs: []
  type: TYPE_NORMAL
- en: The equilibrium expected rate of return of the risky stock.
  prefs: []
  type: TYPE_NORMAL
- en: Representative Agent Pricing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pricing of securities based on the optimization calculus of a representative
    agent is one approach that applies to both complete and incomplete markets. Instead
    of adjusting markets—for example, via market completion based on additional securities—additional
    assumptions are made with regard to the representative agent. For example, the
    initial wealth of the agent is required to arrive at specific, absolute prices
    for the securities instead of only relative prices.
  prefs: []
  type: TYPE_NORMAL
- en: Martingale Measures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although representative agent pricing works in incomplete markets the same way
    as in complete ones, it unfortunately does not directly solve the problem of pricing
    contingent claims that are not attainable. There are still infinitely many martingale
    measures that are consistent with the market.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python code that follows shows that there are infinitely many martingale
    measures that are consistent with the equilibrium price processes as derived in
    the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the symbols `qu` and `qm`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO10-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Formulating the equation for `qu` and `qm` given the martingale condition.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO10-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The equation simplified.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO10-5)'
  prefs: []
  type: TYPE_NORMAL
- en: This solves the equation numerically, providing a set of solutions as the result;
    this does not take into account the conditions <math alttext="0 less-than-or-equal-to
    q Superscript u Baseline comma q Superscript d Baseline less-than-or-equal-to
    1"><mrow><mn>0</mn> <mo>≤</mo> <msup><mi>q</mi> <mi>u</mi></msup> <mo>,</mo> <msup><mi>q</mi>
    <mi>d</mi></msup> <mo>≤</mo> <mn>1</mn></mrow></math> .
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO10-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The relationship between `qu` and `qm` as the solution—indicating infinitely
    many solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Martingale Measure in Incomplete Markets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Martingale pricing is a convenient and elegant approach in complete markets
    to value contingent claims. In incomplete markets, there are in general *infinitely
    many* martingale measures that are consistent with the market. In practice, one
    often solves this issue by relying on publicly observed market prices for liquidly
    trading contingent claims, such as plain vanilla European put or call options.
    These prices are used to calibrate model parameters or the martingale measure
    directly to be consistent with the market. For more background information and
    details about model calibration, see Hilpisch (2015).
  prefs: []
  type: TYPE_NORMAL
- en: Equilibrium Pricing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What about pricing contingent claims? If they are *attainable* through replication
    portfolios composed of traded financial assets, their price can be fixed by the
    *usual arbitrage argument*. What if a contingent claim is *not attainable*? In
    the simple incomplete market setting currently under investigation, this can only
    mean that the payoff vector is linearly independent of the two future price vectors
    of the traded financial assets. This in turn implies that the introduction of
    a contingent claim with such a payoff vector is *market completing*—because three
    linearly independent vectors form in any case a basis of <math alttext="double-struck
    upper R cubed"><msup><mi>ℝ</mi> <mn>3</mn></msup></math> .
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the market payoff matrix from the first two Arrow-Debreu securities,
    each available at a net supply of one:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="script upper M equals Start 3 By 2 Matrix 1st Row 1st Column
    1 2nd Column 0 2nd Row 1st Column 0 2nd Column 1 3rd Row 1st Column 0 2nd Column
    0 EndMatrix" display="block"><mrow><mi>ℳ</mi> <mo>=</mo> <mfenced open="(" close=")"><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'This market is obviously incomplete because the two securities do not span
    <math alttext="double-struck upper R cubed"><msup><mi>ℝ</mi> <mn>3</mn></msup></math>
    . Introducing a contingent claim with net supply of one that pays one unit of
    currency in the <math alttext="d"><mi>d</mi></math> state—that is, a contingent
    claim that pays exactly what the third Arrow-Debreu security would pay—completes
    the market as seen by the resulting payoff matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="script upper M equals Start 3 By 3 Matrix 1st Row 1st Column
    1 2nd Column 0 3rd Column 0 2nd Row 1st Column 0 2nd Column 1 3rd Column 0 3rd
    Row 1st Column 0 2nd Column 0 3rd Column 1 EndMatrix" display="block"><mrow><mi>ℳ</mi>
    <mo>=</mo> <mfenced open="(" close=")"><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: The three payoff vectors now form a standard basis of the <math alttext="double-struck
    upper R cubed"><msup><mi>ℝ</mi> <mn>3</mn></msup></math> .
  prefs: []
  type: TYPE_NORMAL
- en: 'Formally, the optimization problem of the representative agent is the same
    as before:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row  max Underscript phi Endscripts bold upper
    E Superscript upper P Baseline left-parenthesis u left-parenthesis script upper
    M dot phi right-parenthesis right-parenthesis 2nd Row  s period t period script
    upper M 0 dot phi equals w EndLayout" display="block"><mtable><mtr><mtd><mrow><munder><mo
    movablelimits="true" form="prefix">max</mo> <mi>ϕ</mi></munder> <msup><mi>𝐄</mi>
    <mi>P</mi></msup> <mrow><mo>(</mo> <mi>u</mi> <mrow><mo>(</mo> <mi>ℳ</mi> <mo>·</mo>
    <mi>ϕ</mi> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd><mrow><mtext>s.t.</mtext>
    <msub><mi>ℳ</mi> <mn>0</mn></msub> <mo>·</mo> <mi>ϕ</mi> <mo>=</mo> <mi>w</mi></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: Here, <math alttext="script upper M 0 equals left-parenthesis gamma Superscript
    u Baseline comma gamma Superscript m Baseline comma gamma Superscript d Baseline
    right-parenthesis Superscript upper T"><mrow><msub><mi>ℳ</mi> <mn>0</mn></msub>
    <mo>=</mo> <msup><mfenced separators="" open="(" close=")"><msup><mi>γ</mi> <mi>u</mi></msup>
    <mo>,</mo><msup><mi>γ</mi> <mi>m</mi></msup> <mo>,</mo><msup><mi>γ</mi> <mi>d</mi></msup></mfenced>
    <mi>T</mi></msup></mrow></math> as the state price vector and <math alttext="phi
    equals left-parenthesis 1 comma 1 comma 1 right-parenthesis Superscript upper
    T"><mrow><mi>ϕ</mi> <mo>=</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>)</mo></mrow>
    <mi>T</mi></msup></mrow></math> as the market portfolio.
  prefs: []
  type: TYPE_NORMAL
- en: 'In explicit form, the unconstrained optimization problem according to the Theorem
    of Lagrange is:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row 1st Column max Underscript phi Superscript
    u Baseline comma phi Superscript m Baseline comma phi Superscript d Baseline comma
    lamda Endscripts f left-parenthesis phi Superscript u Baseline comma phi Superscript
    m Baseline comma phi Superscript d Baseline comma lamda right-parenthesis 2nd
    Column equals 3rd Column p Superscript u Baseline dot u left-parenthesis phi Superscript
    u Baseline right-parenthesis plus p Superscript m Baseline dot u left-parenthesis
    phi Superscript m Baseline right-parenthesis plus p Superscript d Baseline dot
    u left-parenthesis phi Superscript d Baseline right-parenthesis 2nd Row 1st Column
    Blank 2nd Column minus 3rd Column lamda dot left-parenthesis gamma Superscript
    u Baseline dot phi Superscript u Baseline plus gamma Superscript m Baseline dot
    phi Superscript m Baseline plus gamma Superscript d Baseline dot phi Superscript
    d Baseline minus w right-parenthesis EndLayout" display="block"><mtable><mtr><mtd><mrow><munder><mo
    movablelimits="true" form="prefix">max</mo> <mrow><msup><mi>ϕ</mi> <mi>u</mi></msup>
    <mo>,</mo><msup><mi>ϕ</mi> <mi>m</mi></msup> <mo>,</mo><msup><mi>ϕ</mi> <mi>d</mi></msup>
    <mo>,</mo><mi>λ</mi></mrow></munder> <mi>f</mi> <mrow><mo>(</mo> <msup><mi>ϕ</mi>
    <mi>u</mi></msup> <mo>,</mo> <msup><mi>ϕ</mi> <mi>m</mi></msup> <mo>,</mo> <msup><mi>ϕ</mi>
    <mi>d</mi></msup> <mo>,</mo> <mi>λ</mi> <mo>)</mo></mrow></mrow></mtd> <mtd><mo>=</mo></mtd>
    <mtd><mrow><msup><mi>p</mi> <mi>u</mi></msup> <mo>·</mo> <mi>u</mi> <mfenced separators=""
    open="(" close=")"><msup><mi>ϕ</mi> <mi>u</mi></msup></mfenced> <mo>+</mo> <msup><mi>p</mi>
    <mi>m</mi></msup> <mo>·</mo> <mi>u</mi> <mfenced separators="" open="(" close=")"><msup><mi>ϕ</mi>
    <mi>m</mi></msup></mfenced> <mo>+</mo> <msup><mi>p</mi> <mi>d</mi></msup> <mo>·</mo>
    <mi>u</mi> <mfenced separators="" open="(" close=")"><msup><mi>ϕ</mi> <mi>d</mi></msup></mfenced></mrow></mtd></mtr>
    <mtr><mtd><mo>-</mo></mtd> <mtd><mrow><mi>λ</mi> <mo>·</mo> <mfenced separators=""
    open="(" close=")"><msup><mi>γ</mi> <mi>u</mi></msup> <mo>·</mo> <msup><mi>ϕ</mi>
    <mi>u</mi></msup> <mo>+</mo> <msup><mi>γ</mi> <mi>m</mi></msup> <mo>·</mo> <msup><mi>ϕ</mi>
    <mi>m</mi></msup> <mo>+</mo> <msup><mi>γ</mi> <mi>d</mi></msup> <mo>·</mo> <msup><mi>ϕ</mi>
    <mi>d</mi></msup> <mo>-</mo> <mi>w</mi></mfenced></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The four first-order conditions for the unconstrained problem are:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout Enlarged left-brace 1st Row  StartFraction normal
    partial-differential f Over normal partial-differential phi Superscript u Baseline
    EndFraction equals p Superscript u Baseline dot u prime left-parenthesis phi Superscript
    u Baseline right-parenthesis minus lamda dot gamma Superscript u Baseline equals
    0 2nd Row  StartFraction normal partial-differential f Over normal partial-differential
    phi Superscript m Baseline EndFraction equals p Superscript m Baseline dot u prime
    left-parenthesis phi Superscript m Baseline right-parenthesis minus lamda dot
    gamma Superscript m Baseline equals 0 3rd Row  StartFraction normal partial-differential
    f Over normal partial-differential phi Superscript d Baseline EndFraction equals
    p Superscript d Baseline dot u prime left-parenthesis phi Superscript d Baseline
    right-parenthesis minus lamda dot gamma Superscript d Baseline equals 0 4th Row  StartFraction
    normal partial-differential f Over normal partial-differential lamda EndFraction
    equals gamma Superscript u Baseline dot phi Superscript u Baseline plus gamma
    Superscript m Baseline dot phi Superscript m Baseline plus gamma Superscript d
    Baseline dot phi Superscript d Baseline minus w equals 0 EndLayout" display="block"><mfenced
    separators="" open="{" close=""><mtable><mtr><mtd columnalign="left"><mrow><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><msup><mi>ϕ</mi> <mi>u</mi></msup></mrow></mfrac> <mo>=</mo> <msup><mi>p</mi>
    <mi>u</mi></msup> <mo>·</mo> <msup><mi>u</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <msup><mi>ϕ</mi> <mi>u</mi></msup> <mo>)</mo></mrow> <mo>-</mo> <mi>λ</mi> <mo>·</mo>
    <msup><mi>γ</mi> <mi>u</mi></msup> <mo>=</mo> <mn>0</mn></mrow></mtd></mtr> <mtr><mtd
    columnalign="left"><mrow><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow> <mrow><mi>∂</mi><msup><mi>ϕ</mi>
    <mi>m</mi></msup></mrow></mfrac> <mo>=</mo> <msup><mi>p</mi> <mi>m</mi></msup>
    <mo>·</mo> <msup><mi>u</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <msup><mi>ϕ</mi>
    <mi>m</mi></msup> <mo>)</mo></mrow> <mo>-</mo> <mi>λ</mi> <mo>·</mo> <msup><mi>γ</mi>
    <mi>m</mi></msup> <mo>=</mo> <mn>0</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><msup><mi>ϕ</mi> <mi>d</mi></msup></mrow></mfrac> <mo>=</mo> <msup><mi>p</mi>
    <mi>d</mi></msup> <mo>·</mo> <msup><mi>u</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <msup><mi>ϕ</mi> <mi>d</mi></msup> <mo>)</mo></mrow> <mo>-</mo> <mi>λ</mi> <mo>·</mo>
    <msup><mi>γ</mi> <mi>d</mi></msup> <mo>=</mo> <mn>0</mn></mrow></mtd></mtr> <mtr><mtd
    columnalign="left"><mrow><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow> <mrow><mi>∂</mi><mi>λ</mi></mrow></mfrac>
    <mo>=</mo> <msup><mi>γ</mi> <mi>u</mi></msup> <mo>·</mo> <msup><mi>ϕ</mi> <mi>u</mi></msup>
    <mo>+</mo> <msup><mi>γ</mi> <mi>m</mi></msup> <mo>·</mo> <msup><mi>ϕ</mi> <mi>m</mi></msup>
    <mo>+</mo> <msup><mi>γ</mi> <mi>d</mi></msup> <mo>·</mo> <msup><mi>ϕ</mi> <mi>d</mi></msup>
    <mo>-</mo> <mi>w</mi> <mo>=</mo> <mn>0</mn></mrow></mtd></mtr></mtable></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'For the relative prices, one gets:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout Enlarged left-brace 1st Row  StartFraction gamma
    Superscript u Baseline Over gamma Superscript m Baseline EndFraction equals StartFraction
    p Superscript u Baseline dot u prime left-parenthesis phi Superscript u Baseline
    right-parenthesis Over p Superscript m Baseline dot u prime left-parenthesis phi
    Superscript m Baseline right-parenthesis EndFraction 2nd Row  StartFraction gamma
    Superscript u Baseline Over gamma Superscript d Baseline EndFraction equals StartFraction
    p Superscript u Baseline dot u prime left-parenthesis phi Superscript u Baseline
    right-parenthesis Over p Superscript d Baseline dot u prime left-parenthesis phi
    Superscript d Baseline right-parenthesis EndFraction EndLayout" display="block"><mfenced
    separators="" open="{" close=""><mtable><mtr><mtd columnalign="left"><mrow><mfrac><msup><mi>γ</mi>
    <mi>u</mi></msup> <msup><mi>γ</mi> <mi>m</mi></msup></mfrac> <mo>=</mo> <mfrac><mrow><msup><mi>p</mi>
    <mi>u</mi></msup> <mo>·</mo><msup><mi>u</mi> <mo>'</mo></msup> <mrow><mo>(</mo><msup><mi>ϕ</mi>
    <mi>u</mi></msup> <mo>)</mo></mrow></mrow> <mrow><msup><mi>p</mi> <mi>m</mi></msup>
    <mo>·</mo><msup><mi>u</mi> <mo>'</mo></msup> <mrow><mo>(</mo><msup><mi>ϕ</mi>
    <mi>m</mi></msup> <mo>)</mo></mrow></mrow></mfrac></mrow></mtd></mtr> <mtr><mtd
    columnalign="left"><mrow><mfrac><msup><mi>γ</mi> <mi>u</mi></msup> <msup><mi>γ</mi>
    <mi>d</mi></msup></mfrac> <mo>=</mo> <mfrac><mrow><msup><mi>p</mi> <mi>u</mi></msup>
    <mo>·</mo><msup><mi>u</mi> <mo>'</mo></msup> <mrow><mo>(</mo><msup><mi>ϕ</mi>
    <mi>u</mi></msup> <mo>)</mo></mrow></mrow> <mrow><msup><mi>p</mi> <mi>d</mi></msup>
    <mo>·</mo><msup><mi>u</mi> <mo>'</mo></msup> <mrow><mo>(</mo><msup><mi>ϕ</mi>
    <mi>d</mi></msup> <mo>)</mo></mrow></mrow></mfrac></mrow></mtd></mtr></mtable></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Through these, the third relative price is fixed as well. With logarithmic
    utility and an initial wealth fixed at <math alttext="w equals 1"><mrow><mi>w</mi>
    <mo>=</mo> <mn>1</mn></mrow></math> , one finally arrives in this special case
    at:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout Enlarged left-brace 1st Row  gamma Superscript u
    Baseline equals p Superscript u Baseline 2nd Row  gamma Superscript m Baseline
    equals p Superscript m Baseline 3rd Row  gamma Superscript d Baseline equals p
    Superscript d EndLayout" display="block"><mfenced separators="" open="{" close=""><mtable><mtr><mtd
    columnalign="left"><mrow><msup><mi>γ</mi> <mi>u</mi></msup> <mo>=</mo> <msup><mi>p</mi>
    <mi>u</mi></msup></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><msup><mi>γ</mi>
    <mi>m</mi></msup> <mo>=</mo> <msup><mi>p</mi> <mi>m</mi></msup></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><msup><mi>γ</mi> <mi>d</mi></msup> <mo>=</mo>
    <msup><mi>p</mi> <mi>d</mi></msup></mrow></mtd></mtr></mtable></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: The equilibrium price vector is <math alttext="script upper M 0 Superscript
    asterisk Baseline equals left-parenthesis p Superscript u Baseline comma p Superscript
    m Baseline comma p Superscript d Baseline right-parenthesis Superscript upper
    T"><mrow><msubsup><mi>ℳ</mi> <mn>0</mn> <mo>*</mo></msubsup> <mo>=</mo> <msup><mrow><mo>(</mo><msup><mi>p</mi>
    <mi>u</mi></msup> <mo>,</mo><msup><mi>p</mi> <mi>m</mi></msup> <mo>,</mo><msup><mi>p</mi>
    <mi>d</mi></msup> <mo>)</mo></mrow> <mi>T</mi></msup></mrow></math> , which equals
    the vector representing the probability measure. This in turn implies that all
    discounted price processes are martingales under the physical probability measure.
  prefs: []
  type: TYPE_NORMAL
- en: A Numerical Example (II)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Getting back to the numerical example from before: assume expected utility
    maximization based on *logarithmic utility* for the representative agent. Assume
    further price processes for the *risk-less bond* of'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper B equals left-parenthesis upper B 0 comma left-parenthesis
    11 comma 11 comma 11 right-parenthesis Superscript upper T Baseline right-parenthesis"
    display="block"><mrow><mi>B</mi> <mo>=</mo> <mfenced separators="" open="(" close=")"><msub><mi>B</mi>
    <mn>0</mn></msub> <mo>,</mo> <msup><mrow><mo>(</mo><mn>11</mn><mo>,</mo><mn>11</mn><mo>,</mo><mn>11</mn><mo>)</mo></mrow>
    <mi>T</mi></msup></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: and for the *risky stock* of
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper S equals left-parenthesis upper S 0 comma left-parenthesis
    20 comma 10 comma 5 right-parenthesis Superscript upper T Baseline right-parenthesis"
    display="block"><mrow><mi>S</mi> <mo>=</mo> <mfenced separators="" open="(" close=")"><msub><mi>S</mi>
    <mn>0</mn></msub> <mo>,</mo> <msup><mrow><mo>(</mo><mn>20</mn><mo>,</mo><mn>10</mn><mo>,</mo><mn>5</mn><mo>)</mo></mrow>
    <mi>T</mi></msup></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The market payoff matrix is:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="script upper M equals Start 3 By 2 Matrix 1st Row 1st Column
    11 2nd Column 20 2nd Row 1st Column 11 2nd Column 10 3rd Row 1st Column 11 2nd
    Column 5 EndMatrix" display="block"><mrow><mi>ℳ</mi> <mo>=</mo> <mfenced open="("
    close=")"><mtable><mtr><mtd><mn>11</mn></mtd> <mtd><mn>20</mn></mtd></mtr> <mtr><mtd><mn>11</mn></mtd>
    <mtd><mn>10</mn></mtd></mtr> <mtr><mtd><mn>11</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: The physical probability measure is given by <math alttext="upper P equals left-parenthesis
    p comma p comma p right-parenthesis Superscript upper T"><mrow><mi>P</mi> <mo>=</mo>
    <msup><mfenced separators="" open="(" close=")"><mi>p</mi><mo>,</mo><mi>p</mi><mo>,</mo><mi>p</mi></mfenced>
    <mi>T</mi></msup></mrow></math> , with <math alttext="p equals one-third"><mrow><mi>p</mi>
    <mo>=</mo> <mfrac><mn>1</mn> <mn>3</mn></mfrac></mrow></math> . The net supply
    of the risk-less bond is <math alttext="b equals 1"><mrow><mi>b</mi> <mo>=</mo>
    <mn>1</mn></mrow></math> , and it is <math alttext="s equals 1"><mrow><mi>s</mi>
    <mo>=</mo> <mn>1</mn></mrow></math> for the risky stock. The initial wealth the
    agent has available shall be <math alttext="w equals 15"><mrow><mi>w</mi> <mo>=</mo>
    <mn>15</mn></mrow></math> .
  prefs: []
  type: TYPE_NORMAL
- en: A contingent claim is introduced with payoff <math alttext="upper C 1 equals
    left-parenthesis 5 comma 0 comma 0 right-parenthesis Superscript upper T"><mrow><msub><mi>C</mi>
    <mn>1</mn></msub> <mo>=</mo> <msup><mrow><mo>(</mo><mn>5</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>)</mo></mrow>
    <mi>T</mi></msup></mrow></math> and a net supply of <math alttext="c equals 1"><mrow><mi>c</mi>
    <mo>=</mo> <mn>1</mn></mrow></math> .
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, the problem of the representative agent is:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="max Underscript phi comma lamda Endscripts f left-parenthesis
    phi comma lamda right-parenthesis equals bold upper E Superscript upper P Baseline
    left-parenthesis u left-parenthesis script upper M dot phi right-parenthesis right-parenthesis
    minus lamda dot left-parenthesis script upper M 0 dot phi minus w right-parenthesis"
    display="block"><mrow><munder><mo movablelimits="true" form="prefix">max</mo>
    <mrow><mi>ϕ</mi><mo>,</mo><mi>λ</mi></mrow></munder> <mi>f</mi> <mrow><mo>(</mo>
    <mi>ϕ</mi> <mo>,</mo> <mi>λ</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>𝐄</mi>
    <mi>P</mi></msup> <mfenced separators="" open="(" close=")"><mi>u</mi> <mo>(</mo>
    <mi>ℳ</mi> <mo>·</mo> <mi>ϕ</mi> <mo>)</mo></mfenced> <mo>-</mo> <mi>λ</mi> <mo>·</mo>
    <mfenced separators="" open="(" close=")"><msub><mi>ℳ</mi> <mn>0</mn></msub> <mo>·</mo>
    <mi>ϕ</mi> <mo>-</mo> <mi>w</mi></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="max Underscript b comma s comma c comma lamda Endscripts f left-parenthesis
    b comma s comma lamda right-parenthesis equals bold upper E Superscript upper
    P Baseline left-parenthesis u left-parenthesis b dot upper B 1 plus s dot upper
    S 1 plus c dot upper C 1 right-parenthesis right-parenthesis minus lamda dot left-parenthesis
    b dot upper B 0 plus s dot upper S 0 plus c dot upper C 0 minus w right-parenthesis"
    display="block"><mrow><munder><mo movablelimits="true" form="prefix">max</mo>
    <mrow><mi>b</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>c</mi><mo>,</mo><mi>λ</mi></mrow></munder>
    <mi>f</mi> <mrow><mo>(</mo> <mi>b</mi> <mo>,</mo> <mi>s</mi> <mo>,</mo> <mi>λ</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msup><mi>𝐄</mi> <mi>P</mi></msup> <mfenced separators=""
    open="(" close=")"><mi>u</mi> <mo>(</mo> <mi>b</mi> <mo>·</mo> <msub><mi>B</mi>
    <mn>1</mn></msub> <mo>+</mo> <mi>s</mi> <mo>·</mo> <msub><mi>S</mi> <mn>1</mn></msub>
    <mo>+</mo> <mi>c</mi> <mo>·</mo> <msub><mi>C</mi> <mn>1</mn></msub> <mo>)</mo></mfenced>
    <mo>-</mo> <mi>λ</mi> <mo>·</mo> <mfenced separators="" open="(" close=")"><mi>b</mi>
    <mo>·</mo> <msub><mi>B</mi> <mn>0</mn></msub> <mo>+</mo> <mi>s</mi> <mo>·</mo>
    <msub><mi>S</mi> <mn>0</mn></msub> <mo>+</mo> <mi>c</mi> <mo>·</mo> <msub><mi>C</mi>
    <mn>0</mn></msub> <mo>-</mo> <mi>w</mi></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The four first-order conditions are:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout Enlarged left-brace 1st Row  StartFraction normal
    partial-differential f Over normal partial-differential b EndFraction equals bold
    upper E Superscript upper P Baseline left-parenthesis upper B 1 dot u prime left-parenthesis
    b dot upper B 1 plus s dot upper S 1 plus c dot upper C 1 right-parenthesis right-parenthesis
    minus lamda dot upper B 0 equals 0 2nd Row  StartFraction normal partial-differential
    f Over normal partial-differential s EndFraction equals bold upper E Superscript
    upper P Baseline left-parenthesis upper S 1 dot u prime left-parenthesis b dot
    upper B 1 plus s dot upper S 1 plus c dot upper C 1 right-parenthesis right-parenthesis
    minus lamda dot upper S 0 equals 0 3rd Row  StartFraction normal partial-differential
    f Over normal partial-differential c EndFraction equals bold upper E Superscript
    upper P Baseline left-parenthesis upper C 1 dot u prime left-parenthesis b dot
    upper B 1 plus s dot upper S 1 plus c dot upper C 1 right-parenthesis right-parenthesis
    minus lamda dot upper C 0 equals 0 4th Row  StartFraction normal partial-differential
    f Over normal partial-differential lamda EndFraction equals b dot upper B 0 plus
    s dot upper S 0 plus c dot upper C 0 minus w equals 0 EndLayout" display="block"><mfenced
    separators="" open="{" close=""><mtable><mtr><mtd columnalign="left"><mrow><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><mi>b</mi></mrow></mfrac> <mo>=</mo> <msup><mi>𝐄</mi> <mi>P</mi></msup>
    <mfenced separators="" open="(" close=")"><msub><mi>B</mi> <mn>1</mn></msub> <mo>·</mo>
    <msup><mi>u</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>b</mi> <mo>·</mo> <msub><mi>B</mi>
    <mn>1</mn></msub> <mo>+</mo> <mi>s</mi> <mo>·</mo> <msub><mi>S</mi> <mn>1</mn></msub>
    <mo>+</mo> <mi>c</mi> <mo>·</mo> <msub><mi>C</mi> <mn>1</mn></msub> <mo>)</mo></mrow></mfenced>
    <mo>-</mo> <mi>λ</mi> <mo>·</mo> <msub><mi>B</mi> <mn>0</mn></msub> <mo>=</mo>
    <mn>0</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><mi>s</mi></mrow></mfrac> <mo>=</mo> <msup><mi>𝐄</mi> <mi>P</mi></msup>
    <mfenced separators="" open="(" close=")"><msub><mi>S</mi> <mn>1</mn></msub> <mo>·</mo>
    <msup><mi>u</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>b</mi> <mo>·</mo> <msub><mi>B</mi>
    <mn>1</mn></msub> <mo>+</mo> <mi>s</mi> <mo>·</mo> <msub><mi>S</mi> <mn>1</mn></msub>
    <mo>+</mo> <mi>c</mi> <mo>·</mo> <msub><mi>C</mi> <mn>1</mn></msub> <mo>)</mo></mrow></mfenced>
    <mo>-</mo> <mi>λ</mi> <mo>·</mo> <msub><mi>S</mi> <mn>0</mn></msub> <mo>=</mo>
    <mn>0</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><mi>c</mi></mrow></mfrac> <mo>=</mo> <msup><mi>𝐄</mi> <mi>P</mi></msup>
    <mfenced separators="" open="(" close=")"><msub><mi>C</mi> <mn>1</mn></msub> <mo>·</mo>
    <msup><mi>u</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>b</mi> <mo>·</mo> <msub><mi>B</mi>
    <mn>1</mn></msub> <mo>+</mo> <mi>s</mi> <mo>·</mo> <msub><mi>S</mi> <mn>1</mn></msub>
    <mo>+</mo> <mi>c</mi> <mo>·</mo> <msub><mi>C</mi> <mn>1</mn></msub> <mo>)</mo></mrow></mfenced>
    <mo>-</mo> <mi>λ</mi> <mo>·</mo> <msub><mi>C</mi> <mn>0</mn></msub> <mo>=</mo>
    <mn>0</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow>
    <mrow><mi>∂</mi><mi>λ</mi></mrow></mfrac> <mo>=</mo> <mi>b</mi> <mo>·</mo> <msub><mi>B</mi>
    <mn>0</mn></msub> <mo>+</mo> <mi>s</mi> <mo>·</mo> <msub><mi>S</mi> <mn>0</mn></msub>
    <mo>+</mo> <mi>c</mi> <mo>·</mo> <msub><mi>C</mi> <mn>0</mn></msub> <mo>-</mo>
    <mi>w</mi> <mo>=</mo> <mn>0</mn></mrow></mtd></mtr></mtable></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The *relative prices* for the three financial assets are fixed through:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout Enlarged left-brace 1st Row 1st Column StartFraction
    upper S 0 Over upper B 0 EndFraction 2nd Column equals 3rd Column StartStartFraction
    bold upper E Superscript upper P Baseline left-parenthesis StartFraction upper
    S 1 Over upper B 1 plus upper S 1 plus upper C 1 EndFraction right-parenthesis
    OverOver bold upper E Superscript upper P Baseline left-parenthesis StartFraction
    upper B 1 Over upper B 1 plus upper S 1 plus upper C 1 EndFraction right-parenthesis
    EndEndFraction identical-to zeta 1 2nd Row 1st Column StartFraction upper C 0
    Over upper B 0 EndFraction 2nd Column equals 3rd Column StartStartFraction bold
    upper E Superscript upper P Baseline left-parenthesis StartFraction upper C 1
    Over upper B 1 plus upper S 1 plus upper C 1 EndFraction right-parenthesis OverOver
    bold upper E Superscript upper P Baseline left-parenthesis StartFraction upper
    B 1 Over upper B 1 plus upper S 1 plus upper C 1 EndFraction right-parenthesis
    EndEndFraction identical-to zeta 2 EndLayout" display="block"><mfenced separators=""
    open="{" close=""><mtable><mtr><mtd columnalign="left"><mfrac><msub><mi>S</mi>
    <mn>0</mn></msub> <msub><mi>B</mi> <mn>0</mn></msub></mfrac></mtd> <mtd columnalign="left"><mo>=</mo></mtd>
    <mtd><mrow><mfrac><mrow><msup><mi>𝐄</mi> <mi>P</mi></msup> <mfenced separators=""
    open="(" close=")"><mfrac><msub><mi>S</mi> <mn>1</mn></msub> <mrow><msub><mi>B</mi>
    <mn>1</mn></msub> <mo>+</mo><msub><mi>S</mi> <mn>1</mn></msub> <mo>+</mo><msub><mi>C</mi>
    <mn>1</mn></msub></mrow></mfrac></mfenced></mrow> <mrow><msup><mi>𝐄</mi> <mi>P</mi></msup>
    <mfenced separators="" open="(" close=")"><mfrac><msub><mi>B</mi> <mn>1</mn></msub>
    <mrow><msub><mi>B</mi> <mn>1</mn></msub> <mo>+</mo><msub><mi>S</mi> <mn>1</mn></msub>
    <mo>+</mo><msub><mi>C</mi> <mn>1</mn></msub></mrow></mfrac></mfenced></mrow></mfrac>
    <mo>≡</mo> <msub><mi>ζ</mi> <mn>1</mn></msub></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mfrac><msub><mi>C</mi>
    <mn>0</mn></msub> <msub><mi>B</mi> <mn>0</mn></msub></mfrac></mtd> <mtd columnalign="left"><mo>=</mo></mtd>
    <mtd><mrow><mfrac><mrow><msup><mi>𝐄</mi> <mi>P</mi></msup> <mfenced separators=""
    open="(" close=")"><mfrac><msub><mi>C</mi> <mn>1</mn></msub> <mrow><msub><mi>B</mi>
    <mn>1</mn></msub> <mo>+</mo><msub><mi>S</mi> <mn>1</mn></msub> <mo>+</mo><msub><mi>C</mi>
    <mn>1</mn></msub></mrow></mfrac></mfenced></mrow> <mrow><msup><mi>𝐄</mi> <mi>P</mi></msup>
    <mfenced separators="" open="(" close=")"><mfrac><msub><mi>B</mi> <mn>1</mn></msub>
    <mrow><msub><mi>B</mi> <mn>1</mn></msub> <mo>+</mo><msub><mi>S</mi> <mn>1</mn></msub>
    <mo>+</mo><msub><mi>C</mi> <mn>1</mn></msub></mrow></mfrac></mfenced></mrow></mfrac>
    <mo>≡</mo> <msub><mi>ζ</mi> <mn>2</mn></msub></mrow></mtd></mtr></mtable></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the *budget constraint* to the mix fixes not only the relative prices
    <math alttext="zeta 1"><msub><mi>ζ</mi> <mn>1</mn></msub></math> and <math alttext="zeta
    2"><msub><mi>ζ</mi> <mn>2</mn></msub></math> but also the absolute price levels:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper B 0 plus zeta 1 dot upper B 0 plus zeta 2 dot upper B 0
    equals w left right double arrow upper B 0 equals StartFraction w Over 1 plus
    zeta 1 plus zeta 2 EndFraction" display="block"><mrow><msub><mi>B</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>ζ</mi> <mn>1</mn></msub> <mo>·</mo> <msub><mi>B</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>ζ</mi> <mn>2</mn></msub> <mo>·</mo> <msub><mi>B</mi> <mn>0</mn></msub>
    <mo>=</mo> <mi>w</mi> <mo>⇔</mo> <msub><mi>B</mi> <mn>0</mn></msub> <mo>=</mo>
    <mfrac><mi>w</mi> <mrow><mn>1</mn><mo>+</mo><msub><mi>ζ</mi> <mn>1</mn></msub>
    <mo>+</mo><msub><mi>ζ</mi> <mn>2</mn></msub></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The adjustments to the Python code are only minor compared to the complete
    markets case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The probability measure.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO11-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The payoff vectors.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO11-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The first relative price.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO11-8)'
  prefs: []
  type: TYPE_NORMAL
- en: The second relative price.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO11-10)'
  prefs: []
  type: TYPE_NORMAL
- en: The initial wealth…
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO11-11)'
  prefs: []
  type: TYPE_NORMAL
- en: …and the resulting price for the risk-less bond.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO11-13)'
  prefs: []
  type: TYPE_NORMAL
- en: The equilibrium price for the risky stock.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](Images/8.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO11-15)'
  prefs: []
  type: TYPE_NORMAL
- en: The equilibrium price for the contingent claim.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](Images/9.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO11-17)'
  prefs: []
  type: TYPE_NORMAL
- en: The budget constraint is binding.
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](Images/10.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO11-18)'
  prefs: []
  type: TYPE_NORMAL
- en: The risk-less interest rate.
  prefs: []
  type: TYPE_NORMAL
- en: '[![11](Images/11.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO11-20)'
  prefs: []
  type: TYPE_NORMAL
- en: The equilibrium expected rate of return for the risky stock.
  prefs: []
  type: TYPE_NORMAL
- en: '[![12](Images/12.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO11-22)'
  prefs: []
  type: TYPE_NORMAL
- en: The equilibrium expected rate of return for the contingent claim.
  prefs: []
  type: TYPE_NORMAL
- en: 'That the introduction of the contingent claim—as a third traded financial asset—is
    market completing can be seen by the fact that there is now a unique martingale
    measure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The new market payoff matrix including the contingent claim.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO12-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The vector with the prices of the three financial assets/contingent claims.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO12-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This solves for the vector `Q` representing the martingale measure <math alttext="upper
    Q"><mi>Q</mi></math> (note the use of the transpose operator `.T`).
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO12-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The solution vector whose components add up to 1.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](ch04_split_001.xhtml#co_optimality_and_equilibrium_CO12-7)'
  prefs: []
  type: TYPE_NORMAL
- en: A final check whether all discounted price processes are indeed martingales.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter is concerned with the modeling of agents and their optimization
    problems, mainly on the basis of the expected utility maximization approach. Two
    central topics are discussed: *optimal portfolio choice* and *equilibrium pricing
    of financial assets and contingent claims* in complete and incomplete markets.
    While in the first case the prices are given and the quantities in the investment
    portfolio are chosen, in the latter case the quantities to be held in the investment
    portfolio are fixed, and the prices are adjusted for this to be optimal for the
    representative agent. Python proves once again a powerful ecosystem with helpful
    packages to model and solve the related optimization problems.'
  prefs: []
  type: TYPE_NORMAL
- en: Although the model economies in this and the previous two chapters are admittedly
    simplistic, the techniques and methods introduced carry over to *general static
    model economies*, that is, those having many more—even countably infinite—different
    future states (instead of two or three only). With some additional formalism,
    they even carry over to *dynamic economies* with many—potentially countably infinite—relevant
    points in time (instead of just two).
  prefs: []
  type: TYPE_NORMAL
- en: Further Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Books cited in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Duffie, Darrell. 1988\. *Security Markets—Stochastic Models*. San Diego: Academic
    Press.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Eichberger, Jürgen and Ian Harper. 1997\. *Financial Economics*. New York:
    Oxford University Press.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hilpisch, Yves. 2020\. *Artificial Intelligence in Finance*. Sebastopol: O’Reilly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hilpisch, Yves. 2015\. *Derivatives Analytics with Python*. Wiley Finance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Markowitz, Harry. 1959\. *Portfolio Selection—Efficient Diversification of
    Investments*. New York: John Wiley & Sons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Milne, Frank. 1995\. *Finance Theory and Asset Pricing*. New York: Oxford University
    Press.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sundaram, Rangarajan. 1996\. *A First Course in Optimization Theory.* Cambridge
    University Press, Cambridge.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Varian, Hal. 1992\. *Microeconomic Analysis*. 3rd ed. New York and London:
    W.W. Norton & Company.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch04_split_000.xhtml#idm44853698912344-marker)) Utility is only to be
    understood in *ordinal terms*, that is, in terms of bringing different plans into
    a certain order. A comparison of this numerical value with the optimal one from
    before does not make any sense because the utility functions are different.
  prefs: []
  type: TYPE_NORMAL
