- en: Chapter 2\. Some Mechanics of C++
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。C++ 的一些机制
- en: Just about any programming language will have some form of an array structure
    for storing collections of like types. In C++, there are a handful of options
    for this purpose, but it is the Standard Library `vector` container that is by
    far the most-used type. In this chapter, we will see how a `vector` can conveniently
    represent a vector of real numbers in the mathematical sense. We will also go
    through the basics of creating and using a `vector` and its key member functions,
    as it will tie in well with iterative statements, such as counted loops and `while`
    statements, also to be covered in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何编程语言都会有一种数组结构来存储类似类型的集合。在 C++ 中，有一些选项可用于此目的，但是标准库 `vector` 容器是远远最常用的类型。在本章中，我们将看到一个
    `vector` 如何方便地表示数学意义上的实数向量。我们还将介绍创建和使用 `vector` 以及其关键成员函数的基础知识，因为它与计数循环和 `while`
    语句等迭代语句有很好的联系，这些也将在本章中介绍。
- en: Control structures, include both iterative statements and conditional. Conditional
    branching in C++ can be implemented in `if` statements, similar to other languages,
    as well as in what are called `switch` statements. A good complementary topic
    related to the `switch` statement is that of enumerated types (enums), particularly
    the more modern *enum classes* that were added in C++11\. Enum classes are also
    well-suited for facilitating data input to and output from financial models.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 控制结构，包括迭代语句和条件语句。在 C++ 中，条件分支可以通过 `if` 语句实现，类似于其他语言，以及所谓的 `switch` 语句。与 `switch`
    语句相关的一个很好的补充主题是枚举类型（enums），特别是在 C++11 中添加的更现代的 *enum classes* 。枚举类也非常适用于便利地输入和输出金融模型的数据。
- en: Finally, we will wrap up with a summary of aliases that can be used in C++,
    and why they are important. This includes type aliases that can add clarity to
    the code, in place of longer and sometimes more cryptic templated types. References
    and pointers allow you to access and modify objects without the overhead of object
    copy, although pointers have wider-ranging uses as well.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将总结可在 C++ 中使用的别名，并解释它们的重要性。这包括可以在代码中增加清晰度的类型别名，以代替更长并且有时更神秘的模板类型。引用和指针允许您访问和修改对象，而不需要对象复制的开销，尽管指针也有更广泛的用途。
- en: The `vector` Container
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`vector` 容器'
- en: The `vector` container in the C++ Standard Library is the go-to choice for storing
    and managing an indexed array of like types. It is particularly useful for managing
    vectors of real numbers that are ubiquitous in quantitative work, with `double`
    types representing the numerical values.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 标准库中的 `vector` 容器是存储和管理类似类型的索引数组的首选选择。它特别适用于管理量化工作中广泛存在的实数向量，`double` 类型表示数值。
- en: Note
  id: totrans-6
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Historical Note**: A `vector` is more specifically part of what is called
    the Standard Template Library (STL). The STL was developed independently of Bjarne
    Stroupstrup’s early efforts in the 1980’s and 90’s to design and produce C++,
    by researcher Alexander Stepanov. The history behind acceptance the STL and its
    acceptance into the C++ Standard is a very interesting one [[see Kalb/Azman]],
    but the upshot is the STL – based on generic programming – was accepted into the
    theretofore object-oriented focused C++ for its first ISO standard release in
    1998.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**历史注释**：`vector` 更具体地说是所谓的标准模板库（STL）的一部分。STL 是在1980年代和90年代，由研究员亚历山大·斯蒂帕诺夫独立开发的，与
    Bjarne Stroupstrup 早期努力设计和生产 C++ 的努力是无关的。关于 STL 的被接纳和它被纳入 C++ 标准的历史是一个非常有趣的故事[[参见
    Kalb/Azman]]，但总结是基于通用编程的 STL 在1998年被接纳为 C++ 的首个 ISO 标准版本。'
- en: Being a generic container, `std::vector` can hold elements of a common arbitrary
    type, ranging from plain old data (POD) types such as `double` and `int`, to objects
    of user-defined and library classes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个通用容器，`std::vector` 可以保存来自于普通任意类型的元素，从普通数据（POD）类型如 `double` 和 `int`，到用户定义和库类的对象。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The type to be held is indicated inside the angle brackets.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存的类型在尖括号内指示。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The angle brackets indicate the *template parameter*. Templates are the means
    by which C++ implements generic programming. This topic will be discussed in further
    detail in Chapter 7.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尖括号表示 *模板参数*。模板是 C++ 实现通用编程的手段。这个主题将在第7章中进一步讨论。
- en: Setting and Accessing Elements of a `vector`
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置和访问 `vector` 的元素
- en: An STL `vector` essentially encapsulates and manages a dynamic array, meaning
    that elements can be appended to it or removed from it after it is constructed.
    The `vector` also supports random access, meaning an element can be accessed,
    and moreover modified, by the index of the element. Like everything else in C++,
    a `vector` is zero-indexed, meaning that the index of its first position is index
    0, and its last position is index *n* - 1, if it holds *n* elements.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: STL的`vector`本质上封装和管理动态数组，这意味着在构造后可以向其中追加或从中移除元素。`vector`还支持随机访问，意味着可以访问和修改元素的索引。和C++中的所有其他内容一样，`vector`是从零开始索引的，这意味着它的第一个位置的索引是0，最后一个位置的索引是*n*
    - 1，如果它包含*n*个元素。
- en: Creating a `vector` and Using its Index
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个`vector`并使用它的索引
- en: The following instruction will create a vector holding three real numbers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下指令将创建一个持有三个实数的向量。
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `vector` can be populated element by element as shown here. Note that indexing
    starts with zero rather than one.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector`可以像这里展示的那样逐个元素填充。注意索引从零开始而不是从一开始。'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The index is indicated by square brackets. We can also change the values by
    simply reassigning an element to a new value; viz,
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号表示索引。我们还可以通过简单地将元素重新分配给一个新值来改变值；即，
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It is also possible to initialize vectors using *uniform initialization* introduced
    in C++11\. Also known *as braced initialization*, use of the assignment operator
    is optional:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用C++11引入的*统一初始化*初始化向量。也称为*花括号初始化*，使用赋值操作符是可选的：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The addition of uniform initialization to C++11 has had a significant impact
    on the language, beyond simply initializing a vector. It has some interesting
    and convenient properties that will be discussed in Chapter 4.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中增加统一初始化对语言产生了重大影响，不仅仅是初始化向量。它具有一些有趣和方便的特性，将在第4章中讨论。
- en: Member Functions
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 成员函数
- en: 'As `vector` is a class, it holds a number of public member functions, including
    three: `at`, `size`, and `push_back`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`vector`是一个类，它包含许多公共成员函数，包括`at`、`size`和`push_back`三个函数。
- en: The `at` Function
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`at`函数'
- en: The `at` function essentially performs the same roles as the square bracket
    operator, namely access of an element for a given index, or to modify the element.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`at`函数本质上扮演与方括号操作符相同的角色，即为给定索引访问元素，或修改元素。'
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The difference between using the square bracket operator and the `at` function
    is the latter performs bound checking. Two examples are
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方括号操作符和`at`函数的区别在于后者执行边界检查。两个例子是
- en: Attempting to access an element that exceeds the maximum index; eg,
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试访问超过最大索引的元素；例如，
- en: '[PRE6]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Attempting to use a negative index value
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用负索引值
- en: '[PRE7]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In each case, an exception will be thrown that can be used in error handling.
    Otherwise, you can just think of `at` and `[.]` as the same.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，都会抛出一个异常，可以用于错误处理。否则，你可以认为`at`和`[.]`是相同的。
- en: The `size` Function
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`size` 函数'
- en: 'The name of this member function makes it fairly obvious what it does: it returns
    the number of elements held by a `vector`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此成员函数的名称使它的作用相当明显：它返回一个`vector`持有的元素数量：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You may notice this is the first time we have used the `auto` keyword. What
    this does is automatically deduce the type returned from the `size` function.
    We will see in future cases how useful `auto` can be, but here, it helps us get
    around the fact that the maximum size of a `std::vector` container will vary depending
    upon compiler settings and the platform you are using. The type will be some form
    of an unsigned (non-negative) integer, of which there are multiple sizes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到这是我们第一次使用`auto`关键字。它自动推断从`size`函数返回的类型。我们将在以后的案例中看到`auto`有多么有用，但在这里，它帮助我们规避了`std::vector`容器的最大大小因编译器设置和使用平台而异的事实。该类型将是某种形式的无符号（非负）整数，有多种大小。
- en: So as to not get into the weeds here, we don’t need to be concerned with the
    specific unsigned type here, so we can mostly just use `auto` for the return type
    of the `size` member function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在这里陷入细节，我们不需要关注具体的无符号类型，因此我们可以大多数情况下只使用`auto`作为`size`成员函数的返回类型。
- en: The `push_back` Function
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`push_back` 函数'
- en: This function will append elements to a `vector`; that is, new elements are
    “pushed onto the back” of the container.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将元素追加到一个`vector`中；也就是说，新元素被“推到容器的后面”。
- en: 'For example, we can append a new element to the `vector v` above, say 47.44:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在上述的`vector v`中追加一个新元素，比如说47.44：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, `v` contains four values: 10.6, 58.63, 0.84, 47.44, with `v[3]` (fourth
    element, using 0-indexing) equal to the new value.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`v`包含四个值：10.6, 58.63, 0.84, 47.44，其中`v[3]`（第四个元素，使用0索引）等于新值。
- en: We can also append values to an empty vector. At the outset, we defined
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以向空向量追加值。一开始，我们定义了
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, if we append a value,
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们追加一个值，
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`x` now contains the value 3.08 in its index 0 position and contains one element.
    This can be repeated arbitrarily many times:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`现在在其索引0位置包含值3.08，并包含一个元素。这可以任意重复多次：'
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To close the discussion on `push_back`, there is one potential gotcha to be
    aware of,
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`push_back`的讨论到此结束，还有一个需要注意的潜在问题，
- en: 'Suppose we create a `vector` of integers with three elements:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们创建了一个整数`vector`，其中包含三个元素：
- en: '`vector <int> ints(3);`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector <int> ints(3);`'
- en: 'Now, each element will hold the default value of an `int` type: 0.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个元素将保持`int`类型的默认值：0。
- en: 'If we then apply the `push_back` function to append, say, 5:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们然后应用`push_back`函数来追加，比如说，5：
- en: '`ints.push_back(5);`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`ints.push_back(5);`'
- en: this value will be appended as a *new element* following the third zero; ie,
    the vector now contains four elements.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值将作为第三个零后的*新元素*追加到向量中；即，向量现在包含四个元素。
- en: '`0 0 0 5`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`0 0 0 5`'
- en: To put a value into any of the first three positions, you will need to use the
    index explicitly; eg
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要将值放入前三个位置中的任何一个，您需要显式使用索引；例如
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Concluding Remarks on STL `vector`s
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于STL `vector`的总结说明
- en: In the examples above, we only used plain old numerical types `double` and `int`.
    Vectors of real numbers are of course fundamental for computational work, but
    keep in mind an STL `vector` is generic, in that it can hold elements of any valid
    type, including objects rather than just numerical data types, as we shall see
    in more advanced contexts.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们只使用了普通的数值类型`double`和`int`。当然，对于计算工作，实数向量是基础，但请记住STL `vector`是通用的，可以容纳任何有效类型的元素，包括对象，而不仅仅是数值数据类型，这将在更高级的上下文中看到。
- en: Also, as mentioned earlier, in real-world production level programming, inputs
    are taken from function arguments that come from market and product data, and
    user input, not hard-coded values as seen in the previous examples. One might
    find vectors set with fixed numerical values in test functions, but they should
    be avoided in production code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如前面提到的，在实际的生产级别编程中，输入来自于市场和产品数据以及用户输入的函数参数，而不是像前面示例中看到的硬编码的值。你可能会在测试函数中找到设置了固定数值的向量，但在生产代码中应避免使用它们。
- en: The Standard Library contains additional STL containers, plus a large set of
    STL *algorithms*that are now a core component of modern C++ programming. These
    will be discussed in greater detail in Chapter 7, and becoming familiar with the
    basics of the `vector` container now will make this material more accessible when
    we get to it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库包含额外的STL容器，以及现代C++编程的核心组成部分之一的大量STL *算法*。这些将在第7章更详细地讨论，并且现在熟悉`vector`容器的基础知识将使这些材料在我们讨论它时更易于理解。
- en: Finally, to reiterate, prefer using an STL `vector` over a dynamic C-style array
    using `new` and `delete`. There is no performance benefit to using the latter,
    and memory management is all encapsulated inside the `vector` class, freeing the
    developer from risks due to memory leaks.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，重申一下，优先使用STL `vector`而不是使用`new`和`delete`创建动态C风格数组。使用后者没有性能优势，并且内存管理完全封装在`vector`类中，解放开发人员免受内存泄漏风险。
- en: Enum Constants and Classes
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举常量和类
- en: '*Enumerated constants*, more commonly called enums for short, map text to integers.
    Prior to C++11, enums were a great means of making it clearer for us mere mortals
    to comprehend integer codes by representing them in (contiguous) words. It was
    also far more efficient for the machine to process integers rather than bulkier
    `std::string` objects that take up more memory. And finally, errors caused by
    typos in quoted characters and stray strings could be avoided.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*枚举常量*，简称为枚举，将文本映射到整数。在C++11之前，枚举是一种很好的方法，使我们这些凡人更容易理解整数代码，通过用（连续的）单词表示它们。对于机器来说，处理整数要比处理占用更多内存的`std::string`对象更有效率。最后，通过在引号字符和杂乱的字符串中避免拼写错误，也可以避免错误。'
- en: The C++11 Standard improved on this further with *enum classes*. These remove
    ambiguities that can occur with overlapping integer values when using regular
    enum constants, while preserving the advantages.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: C++11标准进一步改进了这一点，引入了*枚举类*。这些移除了使用普通枚举常量时可能发生的重叠整数值的歧义，同时保留了优势。
- en: We will discuss the motivation for preferring the more modern enum classes over
    integer-based enums. In the next section we will see how they can be used to our
    advantage in conditional statements. Later on, they will prove useful in making
    data input and output with financial models more robust.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论更倾向于现代枚举类而不是基于整数的枚举的动机。在接下来的部分中，我们将看到它们如何在条件语句中对我们有利。后来，在使用金融模型进行数据输入和输出时，它们将证明是有用的。
- en: Enum Constants
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举常量
- en: Enums allow us to pass around identifiers, classifications, indicators etc in
    text representation, while behind the scenes, the compiler recognizes them as
    integers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举允许我们在文本表示中传递标识符、分类、指标等，而在幕后，编译器将其识别为整数。
- en: 'As an example, we can create an enum called `OptionType` that will indicate
    the types of option deals that are allowed in a simple trading system, eg European,
    American, Bermudan, and Asian. The `enum` type is declared; then, inside the braces,
    the allowable types are defined, separated by commas. By default, each will be
    assigned an integer value starting at zero and incremented by one (remember that
    indexing in C++ is zero-based). The closing brace must be followed by a semicolon.
    In code, we would write:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建一个名为`OptionType`的枚举，该枚举将指示简单交易系统中允许的期权交易类型，例如欧式、美式、百慕大和亚洲。声明`enum`类型；然后，在大括号内定义允许的类型，用逗号分隔。默认情况下，每个类型将被赋予一个从零开始逐一增加的整数值（记住，C++中的索引是从零开始的）。闭括号后必须跟着一个分号。在代码中，我们会这样写：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can then verify that in place of each option type, its corresponding integer
    value is given:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证每种选项类型的对应整数值：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Checking the output, we get:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 检查输出，我们得到：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So, we can see how the program treats the text representations as integers.
    Note that these text labels are *not* enclosed in quotation marks, as they ultimately
    represent integer types, not strings.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到程序将文本表示视为整数。请注意，这些文本标签*不*用引号括起来，因为它们最终代表的是整数类型，而不是字符串。
- en: Potential Conflicts with Enums
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举可能的冲突
- en: As discussed at the outset, for any `enum` type, the default integer assignments
    start at zero and then are incremented by one for each type member. Therefore,
    it is possible that two enumerated constants from two different types could be
    numerically equal. For example, suppose we define two different `enum` types,
    called `Football` and `Baseball`, representing the defensive positions in each
    sport. By default, the baseball positions start with 0 for the pitcher and are
    incremented by one for each in the list. The same goes for the football positions,
    starting with defensive tackle. The integer constants are provided in the comments.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如一开始讨论的那样，对于任何`enum`类型，默认的整数赋值从零开始，然后每个类型成员递增一。因此，两个来自两种不同类型的枚举常量可能在数字上相等。例如，假设我们定义了两种不同的`enum`类型，称为`Football`和`Baseball`，分别表示每种运动的防守位置。默认情况下，棒球位置从投手开始为0，并逐一增加到列表中的每个位置。橄榄球位置也是如此，从防守后卫开始。在注释中提供了整数常量。
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we could compare `Defensive_End` and `First_Baseman`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们可以比较`Defensive_End`和`First_Baseman`：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Our result would be nonsense:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果将是无意义的：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is because both positions map to an integer value of 2.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为这两个位置都映射到整数值2。
- en: A quick fix, and one that was often employed prior to C++11, would be to reindex
    each set of enums; eg,
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个快速的修复，以及在C++11之前经常使用的方法，将是重新索引每组枚举；例如，
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, if we compare `Defensive_End` and `First_Baseman`, they will no longer
    be equal, because 202 ≠ 102\. Still, in large code bases there might be hundreds
    of enum definitions, so it would not be out of the question for an overlap to
    slip in and cause errors. Enum classes, introduced in C++11, eliminate this risk.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们比较`Defensive_End`和`First_Baseman`，它们将不再相等，因为202 ≠ 102。尽管如此，在大型代码库中可能有数百个枚举定义，因此可能会出现重叠并导致错误。C++11引入的枚举类消除了这种风险。
- en: Enum Classes
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举类
- en: 'A new and more robust way to avoid `enum` overlaps was introduced in C++11
    that eliminates the integer representation altogether. The other benefits of enums,
    such as avoiding cryptic numerical codes and larger string objects, still remain,
    but the conflicts are avoided by using what is called an *enum class*. As an example,
    we can define bond and futures contract categories within enum classes, as shown
    here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中引入了一种新的更健壮的方法，可以避免`enum`重叠，这种方法完全消除了整数表示。枚举的其他好处，如避免晦涩的数字代码和更大的字符串对象，仍然存在，但通过使用所谓的*enum
    class*避免了冲突。例如，我们可以在枚举类中定义债券和期货合同的类别，如下所示：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that we no longer need to manually set integer values to avoid conflicts
    as we did with regular enums.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们现在不再需要手动设置整数值以避免冲突，就像我们在常规枚举中所做的那样。
- en: 'Attempting to compare members of two different enum classes -- such as a `Bond`
    and a `Futures_Contract` position, will now result in a compiler error. For example,
    the following will not even compile:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试比较两个不同枚举类的成员，例如 `Bond` 和 `Futures_Contract` 位置，现在将导致编译器错误。例如，以下内容甚至不会编译：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This works to our advantage, as it is much better to catch an error at compile
    time rather than runtime. Modern best practices now maintain that we should prefer
    using enum classes rather than enumerated constants [[refer to ISO Guidelines]].
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们有利，因为在编译时捕获错误要比在运行时更好。现代最佳实践现在认为，我们应该优先使用枚举类而不是枚举常量[[参考 ISO 指南]]。
- en: Control Structures
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制结构
- en: 'Control structures consist of two categories:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 控制结构包括两个类别：
- en: Conditional branching, such as `if` statements
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件分支，例如 `if` 语句
- en: Iterative controls that repeat a set of commands in a loop
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代控制循环中重复一组命令
- en: In C++, the code that pertains to a given condition or sequence is contained
    in a block defined by braces. Similar to a function, variables declared within
    a block will go out of scope when the block terminates. These structures can also
    be nested within one another.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，与给定条件或序列相关的代码包含在由大括号定义的块中。类似于函数，块内声明的变量在块终止时将超出范围。这些结构也可以嵌套在彼此内部。
- en: It was assumed in the previous section on enums and enum classes that you are
    familiar with the basics of `if` conditions, but here you can read through a more
    comprehensive review of conditional and iterative constructs that will be utilized
    heavily from here on out. Both depend on logical operators determining a true
    or false condition, so before launching into our tour of control structures, a
    quick review of logical operators and Boolean types are in order.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节关于枚举和枚举类中，我们假设你已经熟悉了 `if` 条件的基础知识，但在这里，你可以阅读更全面的条件和迭代结构的回顾，这些将从现在开始广泛使用。两者都依赖于逻辑运算符来确定真或假条件，因此在控制结构的探索之前，有必要快速复习一下逻辑运算符和布尔类型。
- en: The C++ boolean type, represented represented by `bool`, can store a value of
    either `true` or `false`. Behind the scenes, a `bool` type has a size of one byte
    and may store only `1` for `true`, or `0` for `false`. Note that `true` and `false`
    are not placed in quotations, as ;ole enums they are not character types. They
    represent fixed integer values.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 的布尔类型，由 `bool` 表示，可以存储 `true` 或 `false` 的值。在幕后，`bool` 类型具有一个字节的大小，并且只能存储
    `1` 表示 `true`，或 `0` 表示 `false`。请注意，`true` 和 `false` 没有放在引号中，因为它们不是字符类型。它们代表固定的整数值。
- en: 'The C++ operators for equality and inequalities will return a `bool` type based
    on whether the result is true or false. They are as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 的相等和不等运算符将根据结果是真还是假返回 `bool` 类型。它们如下所示：
- en: '`<, >` Strict inequality'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<, >` 严格不等'
- en: '`<=, >=` Inclusive inequality'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<=, >=` 包含不等'
- en: '`==` Equality'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`==` 相等'
- en: '`!=` Not equals'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!=` 不等于'
- en: '*And* and *Or* operations are represented by `&&` and `||` respectively.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*And* 和 *Or* 操作分别用 `&&` 和 `||` 表示。'
- en: Examples will follow in the next section on conditional branching.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 示例将在下一节关于条件分支中展示。
- en: Conditional Branching
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件分支
- en: C++ supports both the usual `if` based logic found in most other languages,
    and `switch`/`case` statements that offer a cleaner alternative to multiple `else
    if` conditions in special cases.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 支持大多数其他语言中常见的基于 `if` 的逻辑，以及 `switch`/`case` 语句，后者在特定情况下提供了对多个 `else if`
    条件的更清晰替代方法。
- en: '`if` and Related Conditions'
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`if` 和相关条件'
- en: The usual conditional branching statements
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的条件分支语句
- en: '`if (condition) then (action)`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if (condition) then (action)`'
- en: '`if (condition) then (action), else (default action)`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if (condition) then (action), else (default action)`'
- en: '`if (condition 1) then (action 1),`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if (condition 1) then (action 1),`'
- en: '`else if (condition 2) then (action 2)`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`else if (condition 2) then (action 2)`'
- en: '`...`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`...`'
- en: '`else if (condition n) then (action n)`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`else if (condition n) then (action n)`'
- en: '`else (default action)`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`else (default action)`'
- en: are represented by the following C++ syntax. Each condition, whether it be `if`,
    `else if`, or `else`, the code that gets executed for a `true` condition is contained
    within a separate body, indicated by open and closed braces.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由以下C++语法表示。每个条件，无论是 `if`、`else if` 还是 `else`，在执行为 `true` 的条件时，都包含在单独的主体内，用大括号表示。
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Tip
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: In conditional statements containing `else if`, it is a best practice to include
    a default `else` block at the end. Without it, code may build without any complaints
    from the compiler and run just fine, but its execution could very easily result
    in unexpected behavior that can cause major headaches in larger and more realistic
    code bases.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含`else if`的条件语句中，最佳实践是在最后包括一个默认的`else`块。如果没有，代码可能会编译无误并正常运行，但其执行可能会导致意外行为，在更大和更实际的代码库中可能会引起严重问题。
- en: 'Utilizing the inequality operators introduced above, we can then write some
    simple examples with all three variations on the `if` statement theme:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 利用上述介绍的不等运算符，我们可以写一些关于`if`语句主题的简单示例的所有三种变体：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Warning
  id: totrans-132
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Due to the nature of floating point numerical representation and arithmetic,
    one should never test for exact equality between two `double` types, nor should
    floating point types be compared identically to zero. These cases will be covered
    later in a separate context.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浮点数数值表示和算术的特性，永远不应该测试两个`double`类型之间的精确相等性，也不应该将浮点类型与零完全相同地比较。这些情况将在另一个上下文中进一步讨论。
- en: 'The operators for logical AND and OR can also be used within conditional arguments.
    For example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑AND和OR运算符也可以在条件参数中使用。例如：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that in the last `else if` condition, we put the AND condition inside round
    brackets, as OR takes precedence over AND. [[cppreference.com](https://en.cppreference.com/w/cpp/language/operator_precedence)]
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在最后的`else if`条件中，我们将AND条件放在圆括号内，因为OR比AND具有更高的优先级。[[cppreference.com](https://en.cppreference.com/w/cpp/language/operator_precedence)]
- en: 'Finally, we can assign logical conditions to `bool` variables, and used within
    `if` conditions, as shown here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将逻辑条件赋给`bool`变量，并在`if`条件中使用，如下所示：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that a boolean variable can be negated simply by preceding it with the
    `!` operator, as shown in the first `else if` condition above.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，布尔变量可以通过在其前面加上`!`运算符来取反，如上面第一个`else if`条件所示。
- en: Warning
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: A common trap is to mistakenly use `=` to test equality instead of `==`. The
    former is the assignment operator and will cause unexpected behavior in this case.
    Be sure to use `==` when testing for equality.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的陷阱是错误地使用`=`来测试相等性，而不是`==`。前者是赋值运算符，在这种情况下会导致意外行为。确保在测试相等性时使用`==`。
- en: Ternary `if` Statement
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三元`if`语句
- en: 'There is also a convenient one-line shortcut for short and sweet `if-else`
    combinations. The syntax is as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种方便的单行快捷方式来表示简洁的`if-else`组合。语法如下：
- en: '*type* `var = ` *logical condition* `? var_val_true`(if `true`) : `var_val_false`(if
    `false`);'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型* `var = ` *逻辑条件* `? var_val_true`(如果`true`) : `var_val_false`(如果`false`);'
- en: In English, this means if _*logical condition*_ is `true`, assign the value
    `var` to `var_val_true`; otherwise, assign it to `var_val_false`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，这意味着如果_*逻辑条件*_为`true`，则将`var`的值分配给`var_val_true`；否则，分配给`var_val_false`。
- en: 'A code example should make this clearer:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例应当更加清晰：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So, in this example, `result` would be assigned the value of sin(3.14), or approximately
    zero.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个例子中，`result`将被赋予sin(3.14)的值，即大约为零。
- en: The `switch`/`case` Statement
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`switch`/`case`语句'
- en: Also known as just a `switch` statement, this control sequence allows us to
    eliminate some of the clutter that comes with multiple `else if` clauses, but
    for the particular case of branching on the *state* of a single integer type,
    or alternatively, either an enum that maps to an integer, or an enum class member.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 也称为`switch`语句，这种控制序列允许我们消除多个`else if`子句带来的一些混乱，但对于单个整数类型的*state*的分支的特定情况，或者替代地，映射到整数的枚举，或枚举类成员。
- en: For each possible `case`, the command that follows the matching state is executed.
    As with the `else` condition above, a `default` action should be provided at the
    end to catch cases that do not fall into any of the given categories, or handle
    the error if no other possibilities are admissible.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一个可能的`case`，执行与匹配状态相对应的命令。与上述`else`条件类似，最后应该提供一个`default`动作，以捕捉不属于任何给定类别或处理无法通过的错误情况。
- en: As a first example, consider a case where we pretend an integer condition represents
    a type of option, and in place of each `cout`, the action would be to call a corresponding
    pricing model. This will render our code more readable and maintainable than using
    multiple `else if` statements.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个示例，考虑一个假设整数条件表示选项类型的情况，在每个`cout`的位置，操作将是调用相应的定价模型。这将使我们的代码比使用多个`else if`语句更具可读性和可维护性。
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After each case, the `break` statement instructs the program to exit the `switch`
    statement once the corresponding code for a particular state is executed. So if
    `x` is `1`, a lattice model would be called to price an American option, and then
    control would pass out of the body of the `switch` statement rather than checking
    if `x` is `2`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 每个情况结束后，`break` 语句指示程序在执行特定状态的相应代码后退出 `switch` 语句。因此，如果 `x` 是 `1`，则会调用格点模型来定价美式期权，然后控制将传出
    `switch` 语句的主体，而不是检查 `x` 是否为 `2`。
- en: 'There are also cases where one might want to drop down to the next step if
    the same action is desired for multiple states. For example, in (American) football,
    if a drive stalls, the offense punts the ball on fourth down and no points are
    scored. If the team scores, however, it might have kicked a field goal for three
    points, or scored a touchdown with three possible outcomes:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些情况下，如果对多个状态执行相同的操作，则可能希望转到下一步。例如，在（美式）橄榄球中，如果进攻停滞，进攻方在第四次进攻失败时会将球踢出，不会得分。然而，如果球队得分，可能会踢出三分球，或者得分进攻有三种可能结果：
- en: Miss the extra point(s) -- Result is six points
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未中额外一分 -- 结果是六分
- en: Kick the extra point -- Result is seven points
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 踢额外一分 -- 结果是七分
- en: Score a two-point conversion -- Result is eight points
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行两分转换 -- 结果是八分
- en: 'No matter how a team scores, it kicks the ball off to their opponent, so for
    cases 3, 6, 7, and 8, we just drop down through each case until we hit the kickoff.
    This quasi-Bayesian logic could then be implemented with the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 无论球队如何得分，都会将球踢给对手，因此对于情况3、6、7和8，我们只需逐个遍历每种情况，直到踢球。这种准贝叶斯逻辑可以通过以下代码实现：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'An obvious pre-C++11 alternative for the `switch` on option pricing `case`s
    would be to substitute in the corresponding enums for the integer codes, thus
    making the logic even easier to understand for human consumption (`cout` messages
    remain the same):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++11 之前，用于期权定价 `case` 的 `switch` 的明显替代方案是用相应的枚举替换整数代码，从而使逻辑对人类更易理解（`cout`
    消息保持不变）：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'However, modern ISO Guidelines now favor using enum classes, for the reasons
    demonstrated above with integer conflicts. So, we just substitute the `Options_Contract`
    enum class into the preceding example to get:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现代 ISO 指南现在更倾向于使用枚举类，原因如上所示，存在整数冲突。因此，我们只需将 `Options_Contract` 枚举类替换到前面的示例中即可得到：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Iterative Statements
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代语句
- en: 'In C++, there are two built-in language features that enable looping logic
    and iteration:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，有两个内置语言特性可以实现循环逻辑和迭代：
- en: '`while` and `do...while` loops'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while` 和 `do...while` 循环'
- en: '`for` loops (including range-based `for` loops)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环（包括基于范围的 `for` 循环）'
- en: These iterative commands will execute a repeated block of code over a set of
    values or objects based on a fixed count, while a logical condition is true, or
    over a range of elements held by a `vector`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些迭代命令将根据固定计数、逻辑条件为真或在 `vector` 中保存的一系列元素的范围上执行一段重复的代码块。
- en: '`while` and `do...while` Loops'
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`while` 和 `do...while` 循环'
- en: 'The essential workflow behind a `while` loop is to repeat a block of code *while*
    a logical expression is `true` (or alternatively, whilst `false`). The following
    simple example demonstrates a simple `while` loop, where the incremented value
    of an integer is output to the screen while its value remains strictly less than
    some fixed maximum value:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环背后的基本工作流程是在逻辑表达式为 `true`（或者在 `false` 的情况下）时重复执行一段代码块。以下简单示例演示了一个简单的
    `while` 循环，其中递增的整数值在其值严格小于某个固定最大值时输出到屏幕：'
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Our logical condition is for `i` to be strictly less than the value `max`. As
    long as this condition holds, the value of `i` will be incremented
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的逻辑条件是 `i` 严格小于值 `max`。只要这个条件成立，`i` 的值将被递增
- en: 'A `do...while` loop is similar, except that by placing the `while` condition
    at the end, it guarantees that at least one iteration of the loop will be executed.
    For example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`do...while` 循环类似，只是通过将 `while` 条件放在末尾，可以保证循环至少执行一次。例如：'
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that even if `max` had been set to zero or less, there would still be one
    trip through the `do...while` loop, as the maximum condition is not checked until
    the end. This is the distinction that separates it from the simpler `while` loop.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使 `max` 设置为零或更小，仍会有一次通过 `do...while` 循环的行程，因为最大条件直到最后才会被检查。这是将其与更简单的 `while`
    循环区分开的特点。
- en: In time, we will see looping examples that involve more interesting mathematics
    and financial applications.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们将看到涉及更有趣的数学和金融应用的循环示例。
- en: The `for` Loop
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`for`循环'
- en: 'This construct is another form of iteration over a countable range. The form
    that is employed in C++ can be summarized in the following pseudocode example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构是迭代计数范围的另一种形式。C++中使用的形式可以用以下伪代码示例概括：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The syntax here is important, namely the semicolons separating the three expressions
    in the `for` argument. Breaking this down into parts a, b, and c, we would have
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的语法很重要，特别是在`for`参数中分隔三个表达式的分号。将其分解为a、b和c部分，我们会有：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Each of these parts is typically dependent on some form of a counter, such as
    an `int i` counter as seen in the `while` statement; however, we now move this
    index into the argument of the `for` statement, which allows us to remove the
    increment from the body of the loop. The (a) part determines the starting value
    of the counter, (b) indicates where to stop, and (c) enforces how the counter
    is increased or decreased.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分通常依赖于某种形式的计数器，例如在`while`语句中看到的`int i`计数器；然而，现在我们将此索引移到`for`语句的参数中，这允许我们将增量从循环体中移除。（a）部分确定计数器的起始值，（b）指示停止的位置，（c）强制计数器如何增加或减少。
- en: 'For example, we could rewrite the `while` example above using a `for` loop
    as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用`for`循环将上面的`while`示例重写如下：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The results will be exactly the same as the those in the `while` loop examples.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将与`while`循环示例中的结果完全相同。
- en: There technically is a difference between the pre- and post- increment operator
    that can affect other uses, but either `++i` with `i++` in the `for` will work
    identically. It is generally preferred to use `++i`
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从技术上讲，前增量运算符和后增量运算符之间存在影响其他用途的差异，但在`for`中使用`++i`或`i++`将完全相同。通常更倾向于使用`++i`。
- en: It is also legal to have a `for` loop where a decrement (`--`) is used to decrease
    the index value down to some minimum value.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，可以使用递减（`--`）减少索引值到某个最小值的`for`循环是合法的。
- en: '`break` and `continue`'
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`break`和`continue`'
- en: In iterative loops, it is sometimes necessary to break out of a loop before
    a maximum or minimum index value is attained, or before the specified logical
    condition would otherwise terminate the iteration. A prime example in computational
    finance is barrier option pricing using Monte Carlo simulation. The simulation
    paths will typically have the same number of time steps; however, in the case
    of an up-and-out barrier option, for example, we would need to break out of the
    loop if the underlying asset price rose above the barrier level.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代循环中，有时需要在达到最大或最小索引值之前或在指定的逻辑条件终止迭代之前退出循环。在计算金融中的一个典型例子是使用蒙特卡罗模拟定价障碍期权。模拟路径通常具有相同数量的时间步长；然而，在例如敲出障碍期权的情况下，如果基础资产价格上涨到障碍水平以上，我们需要退出循环。
- en: 'This is accomplished by applying the same `break` command as used in `switch`
    statements. A simple example is shown here, which also demonstrates nesting an
    `if` condition inside a `for` block:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用与`switch`语句中相同的`break`命令来实现。这里展示了一个简单的示例，还演示了在`for`块中嵌套`if`条件：
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Once `i` is incremented to 11, the `if` statement is true, so the `break` command
    is called, causing the program control to exit the `for` loop.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`i`增加到11，`if`语句为真，因此调用`break`命令，导致程序控制退出`for`循环。
- en: There is also the `continue` keyword that can be used to continue the process
    of the loop, but since this is the default behavior of a loop anyway, its usefulness
    is limited.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`continue`关键字，可以用来继续循环的过程，但由于这已经是循环的默认行为，它的用处有限。
- en: Nested Loops
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套循环
- en: In addition to nesting `if` conditions inside loops, it is also possible to
    nest iterative blocks inside other blocks, whether they be `for` or `while` loop.
    In quantitative programming, it is easy to find oneself writing double and sometimes
    even triple nested loops when implementing common numerical routines and financial
    models. This type of coding, however, can become complex and error prone in a
    hurry, so one needs to take special precautions, as well as consider alternatives
    we will take up later.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在循环内部嵌套`if`条件外，在其他块中嵌套迭代块（无论是`for`还是`while`循环）也是可能的。在量化编程中，当实现常见的数值例程和金融模型时，很容易发现自己编写双甚至三重嵌套循环。然而，这种编码方式可能会迅速变得复杂且容易出错，因此需要采取特殊预防措施，并考虑稍后我们将讨论的替代方案。
- en: Range-Based `for` Loops
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于范围的`for`循环
- en: Prior to C++11, iterating through a `vector` would involve using the index as
    the counter, up to the number its elements.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++11 之前，通过使用索引作为计数器来遍历 `vector`。
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Range-based `for` loops, introduced in C++11, make this more functional and
    elegant. Instead of explicitly using the `vector` index, a range-based for loop
    simply says “for every element `elem` in `v`, do something with it”:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 引入于 C++11 的基于范围的 `for` 循环使得代码更加函数化和优雅。而不是显式地使用 `vector` 的索引，基于范围的 `for` 循环只需说“对于
    `v` 中的每个元素 `elem`，做某事”。
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As a trivial example, calculate the sum of the elements:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个简单的例子，计算元素的总和：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: And we are done. No worries about making a mistake with the index, there is
    less to type, and the code more obviously expresses what it is doing. The ISO
    Guidelines in fact tell us to prefer using range-based `for` loops with `vector`
    objects, as well as other STL containers that will be discussed in Chapter 7.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了。不用担心索引错误，输入更少，代码更明显地表达了它正在做的事情。实际上，ISO 指南告诉我们要优先使用基于范围的 `for` 循环与 `vector`
    对象，以及其他将在第 7 章讨论的 STL 容器。
- en: Aliases
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 别名
- en: Aliasing can take on several forms, the first being one of convenience, namely
    *type aliasing*, where commonly used parameterized type names can be assigned
    to a shorter and more descriptive alias names.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 别名可以采用多种形式，第一种是便利性的形式，即“类型别名”，其中常用的参数化类型名称可以分配给更短且更具描述性的别名。
- en: In addition, *reference aliases* help to avoid copies of objects being created
    when they are passed into functions, often resulting in significant speedup at
    runtime.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，“引用别名”有助于避免在将对象传递到函数时创建对象的副本，通常会在运行时显著加快速度。
- en: '*Pointers* can also be considered as aliases, particularly useful for representing
    an active object in class design (the `this` pointer in Chapter 4). Pointers (and
    now smart pointers) can also be used for allocating memory that persists, but
    this is a separate and deeper discussion that will be deferred until Chapter 6.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 指针也可以被视为别名，特别是用于类设计中表示活动对象（第 4 章中的 `this` 指针）。指针（现在还有智能指针）也可以用于分配持久性内存，但这是一个单独且更深入的讨论，将推迟到第
    6 章。
- en: Both references and pointers can help facilitate the *object-oriented programming*
    concepts of *inheritance* and *composition* that will be presented in subsequent
    chapters.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 引用和指针都可以帮助促进将在后续章节中介绍的“面向对象编程”的概念中的“继承”和“组合”。
- en: Type Aliases
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型别名
- en: '`std::vector<double>` objects are ubiquitous in quantitative code for fairly
    obvious reasons. Because it is used so much, it is common to assign a type alias
    to it, such as `RealVector`. This better expresses what it is mathematically,
    plus we don’t need to bother with as much typing.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在数量代码中，`std::vector<double>` 对象因其显而易见的原因而无处不在。由于它使用如此频繁，通常会为其分配一个类型别名，例如 `RealVector`。这更好地表达了它在数学上的含义，而且我们不需要输入太多。
- en: 'Using modern C++, we can define the alias `RealVector` by simply defining it
    as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现代 C++，我们可以通过简单地定义别名 `RealVector` 来定义别名。
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, we could just write, for example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以简单地写：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As long as the alias is defined before it is used in the code, then it’s fair
    game.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 只要在代码中使用之前定义了别名，那么就可以使用它了。
- en: Prior to C++11, this application of the `using` command did not exist, so type
    aliasing was accomplished by using the `typedef` command; eg,
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++11 之前，不存在 `using` 命令的这种应用，因此类型别名是通过使用 `typedef` 命令来实现的；例如，
- en: '[PRE45]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is also valid C++ and is still found in many modern code bases, but the
    `using` form is preferable per the modern ISO Guidelines. The detailed reason
    for this is outside the scope of this book, but the upshot is `using` can be used
    to define aliases of generic templated types (eg, not just `double` parameters
    as above), while `typedef` cannot.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是有效的 C++，仍然存在于许多现代代码库中，但根据现代 ISO 指南，使用 `using` 形式更可取。详细原因超出本书范围，但要点是 `using`
    可用于定义通用模板类型的别名（例如，不仅限于上述的 `double` 参数），而 `typedef` 不能。
- en: References
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用
- en: 'A reference, put simply, provides an alias for a *variable*, rather than a
    type. Once a reference is defined, then accessing or modifying it is exactly the
    same as using the original variable. A reference is created by placing an ampersand
    between the type name and the reference name before assigning it to the original
    variable. For example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地说，引用为“变量”提供了别名，而不是类型。一旦定义了引用，访问或修改它与使用原始变量完全相同。通过在类型名称和引用名称之间放置一个和符号来创建引用，然后将其分配给原始变量。例如：
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'At this point, both `original` and `ref` would return 15 if accessed in a function
    or assigned to another variable. However, reassigning `original` to 12 would also
    mean `ref` now returns 12\. Similarly, reassigning `ref` would change the value
    held by `original`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果在函数中访问或分配给另一个变量，`original`和`ref`都将返回15。然而，重新将`original`重新分配为12也意味着现在`ref`返回12。同样，重新分配`ref`会改变由`original`保存的值：
- en: '[PRE47]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It is important to note that a reference must be assigned at the same time it
    is declared. For example,
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，引用必须在声明时同时进行分配。例如，
- en: '[PRE48]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: would be nonsense as there is nothing to which it refers, and the code would
    fail to compile. Also, once a reference is defined, it cannot be reassigned to
    another variable for the remainder of its lifetime.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 将是无意义的，因为没有任何东西与其引用，代码将无法编译。此外，一旦定义了引用，就不能再将其重新分配给另一个变量直至其生命周期结束。
- en: Using a reference for a plain old numerical type is trivial, but they become
    important when passing large objects into a function, so as to avoid object copy
    that can decimate a program’s runtime performance.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于普通的数值类型，使用引用是微不足道的，但当将大对象传递到函数中时，它们变得很重要，以避免可能会使程序运行时性能严重下降的对象复制。
- en: Suppose we have a `std::vector` containing 2000 option contract objects? By
    passing it as a reference into a function, the original object itself can be accessed
    without copying it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含2000个期权合约对象的`std::vector`？通过将其作为引用传递到函数中，可以访问原始对象本身而无需复制它。
- en: There is one caveat, however. Remember that if a reference is modified, so is
    the original variable to which it refers. For this reason, one can just make the
    reference argument `const`. Then, any attempt to modify the reference will be
    prevented by the compiler.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个需要注意的地方。请记住，如果修改了引用，原始变量也会被修改。因此，可以将引用参数设为`const`。然后，编译器将阻止对引用的任何修改尝试。
- en: 'For example, here are two functions that take in a `std::vector<int>` object
    as a reference argument. The first one returns the sum of the elements, so there
    is no modification of the elements attempted. The second one, however, attempts
    to reset each element to twice its value and then sum the elements. This will
    result in a compiler error – much better than a runtime error – and prevent the
    operations from ever being executed:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里有两个函数，它们将`std::vector<int>`对象作为引用参数。第一个函数返回元素的总和，因此不会尝试修改元素。然而，第二个函数尝试将每个元素重置为其两倍值然后返回元素的总和。这将导致编译器错误
    - 这比运行时错误好得多 - 并阻止操作被执行：
- en: '[PRE49]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-233
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It is also possible to pass a function argument as non-`const` reference, with
    the intent to modify it in place. In this case, one would typically make the return
    type `void`, instead of returning a modified variable. This is rarely justified
    anymore in modern C++ due to *return value optimization* (*RVO*). With RVO, objects
    by default are returned “in place” rather than as copies from functions. This
    is now a requirement for compilers per the ISO standards, beginning with C++11.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以将函数参数作为非`const`引用传递，以便在原地修改它。在这种情况下，一般会将返回类型设置为`void`，而不是返回修改后的变量。在现代C++中这种做法已经很少有正当理由，因为*返回值优化*（*RVO*）使得对象默认以“原地返回”的方式而不是作为函数的副本返回。这已经成为编译器根据ISO标准（从C++11开始）的要求。
- en: One final point about references relates to managed languages such as Java and
    C#, in that the default behavior is to pass objects by non-constant reference.
    In C++ the default is to pass by value; hence, one must specifically instruct
    the compiler to expect a function argument as a reference with the `&`. This is
    an adjustment that a programmer needs to make if switching between C++ and a managed
    language.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 关于引用的最后一点与Java和C#等托管语言相关，其中默认行为是通过非常量引用传递对象。在C++中，默认是按值传递；因此，如果在C++和托管语言之间切换，必须明确指示编译器期望一个引用的函数参数。这是程序员在切换时需要进行的调整。
- en: Pointers
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针
- en: A *pointer* in C++ shares some similarities with a reference, in that it can
    also be an alias to another variable, but rather than being permanently tied to
    a variable throughout its lifetime, a pointer *points* to a memory address containing
    the variable’s contents, and it can be redirected to another memory address containing
    another variable.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，*指针*与引用有一些相似之处，它也可以是对另一个变量的别名，但它不像引用那样在其生命周期内永久绑定到变量。指针*指向*包含变量内容的内存地址，并且可以重定向到包含另一个变量的另一个内存地址。
- en: 'This unfortunately can be confusing, as a memory address of a variable is also
    indicated by the `&` operator, in addition to another operator `*` that is used
    to declare a pointer. A simple example illustrates this. First, declare and assign
    an integer variable:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这可能会让人困惑，因为变量的内存地址也是通过`&`运算符来表示的，除了另一个用于声明指针的运算符`*`。 一个简单的例子说明了这一点。 首先，声明并分配一个整数变量：
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, declare a pointer to an integer, using the `*` operator:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`*`运算符声明一个指向整数的指针：
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This says to create a variable that will be a *pointer to an* `int` *type*,
    but don’t point to anything specific yet; this comes in the next step:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着创建一个变量，它将是`int`类型的*指针*，但是还没有指向任何具体的东西; 这将在下一步中进行：
- en: '[PRE52]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `&` operator in this case means *the address of* `x`. `xp` now points at
    the memory address that contains the contents of `x`, namely 42\. Note that this
    usage of `&` has a different meaning than declaring a reference.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`&`运算符意味着`x`的地址。 `xp`现在指向包含`x`内容的内存地址，即42。 请注意，此处的`&`用法与声明引用的含义不同。
- en: We can now access the contents of this memory address by *dereferencing* `xp`
    by applying the `*` operator. If we put
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用`*`运算符来对`xp`*dereferencing*，现在我们可以访问该内存地址的内容。 如果我们把
- en: '[PRE53]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: the output would be 42, just as if we had applied `std::cout` to the variable
    `x`. Note the `*` operator is used in a different context here, accessing the
    contents of memory rather than declaring a pointer.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是42，就像我们对变量`x`应用了`std::cout`一样。 注意这里的`*`运算符在这里使用的是不同的上下文，访问内存的内容而不是声明指针。
- en: We can also means we can change the value of `x`. For example, putting
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以意味着我们可以更改`x`的值。 例如，放置
- en: '[PRE54]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: then both `*xp` and `x` will return the value 25, rather than 42.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`*xp`和`x`都将返回值25，而不是42。
- en: 'It is also possible to *reassign* the pointer `xp` to a different memory address;
    this is not possible to do with a reference. Suppose we have a different integer
    variable `y` and we reassign `xp` to point to the address of `y`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以*重新分配*指针`xp`到不同的内存地址; 这是无法使用引用进行的。 假设我们有一个不同的整数变量`y`，我们将`xp`重新分配到指向`y`的地址：
- en: '[PRE55]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now, `*xp` will return 106 rather than 25, but `x` is still equal to 25.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`*xp`将返回106而不是25，但`x`仍然等于25。
- en: Note
  id: totrans-254
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`xp`, as opposed to `*xp`, will return the hexadecimal value that represents
    the address of the first byte in memory containing the contents of `y`.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`xp`，而不是`*xp`，将返回一个十六进制值，表示内存中包含`y`内容的第一个字节的地址。'
- en: 'Similar to references, pointers can be used with objects. If we have a class
    `SomeClass` with a member function, say `some_fcn`, then we can define a pointer
    to a `SomeClass` object:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 与引用类似，指针也可以与对象一起使用。 如果我们有一个类`SomeClass`，其中有一个成员函数，例如`some_fcn`，那么我们可以定义一个指向`SomeClass`对象的指针：
- en: '[PRE56]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As it’s obvious that `ptr_sc` will point to a `SomeClass` object, we can use
    the `auto` keyword without obscuring its context.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于明显`ptr_sc`将指向一个`SomeClass`对象，我们可以使用`auto`关键字而不会使其上下文含糊不清。
- en: 'Suppose also that `SomeClass` has a member function `some_fcn`. This function
    can be invoked by dereferencing `ptr_sc` and then calling it in the usual way:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`SomeClass`也有一个成员函数`some_fcn`。 通过解引用`ptr_sc`然后以通常的方式调用它：
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'More common, however, is to use the indirection operator, indicated by an arrow:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 然而更常见的是使用箭头表示的间接运算符：
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is all we will need to know about pointers for now. More specifically,
    these examples take place in stack memory, and they are automatically deleted
    when the function or control block in which they are defined terminates. More
    advanced usage will be presented later.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们现在所需了解关于指针的一切。 更具体地说，这些示例发生在堆栈内存中，并且在定义它们的函数或控制块终止时会自动删除。 更高级的用法将稍后介绍。
- en: Note
  id: totrans-264
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Pointers can also point to memory allocated in heap memory, which allows the
    value or object to persist in memory outside the scope of a function or control
    block. This becomes relevant in certain situations related to object-oriented
    programming and requires and extra care. Moreover, C++11 introduced smart pointers
    into the Standard Library. These topics will be presented in Chapter 5.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 指针还可以指向在堆内存中分配的内存，这使得值或对象可以在函数或控制块的范围之外的内存中保持持久。 这在涉及面向对象编程的某些情况下非常重要，并且需要额外注意。
    此外，C++11在标准库中引入了智能指针。 这些主题将在第5章中介绍。
- en: Function and Operator Overloading
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数和运算符重载
- en: A key feature of C++, as well as other modern programming languages, is implementing
    different versions of the same function name, distinguished by different sets
    of input arguments. This is known as *function overloading*. A related feature
    that is very convenient to us as quantitative programmers is *operator overloading*,
    where we can define an operation for specific types, such as vector multiplication.
    Operator overloading is not supported in as many languages as function overloading;
    for example, it exists in C++ and C#, but it is not an option in Java.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: C++的一个关键特性，以及其他现代编程语言的特性，是实现同一函数名的不同版本，通过不同的输入参数集合进行区分。这被称为*函数重载*。作为量化程序员非常方便的相关特性是*运算符重载*，我们可以为特定类型定义操作，比如向量乘法。运算符重载并不像函数重载那样被多种语言支持；例如，在Java中就不支持。
- en: Function Overloading
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数重载
- en: To illustrate function overloading, let’s look at an example of two versions
    of a `sum` function, one of which returns a `double` type, while the other returns
    a `vector<double>`. The first version is trivial, just summing two real numbers.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明函数重载，让我们看一个`sum`函数的示例，它有两个版本，一个返回`double`类型，另一个返回`vector<double>`。第一个版本很简单，只是对两个实数求和。
- en: '[PRE59]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The second version, however, will take in two `std::vector<double>` objects
    and return a vector containing the sum of its elements.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第二个版本将接受两个`std::vector<double>`对象，并返回一个包含其元素和的向量。
- en: '[PRE60]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As we can see, the two functions perform two distinct tasks, and have different
    return types, based on the types of arguments.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，这两个函数执行两个不同的任务，并且根据参数类型具有不同的返回类型。
- en: 'Overloaded functions can also be distinguished based on the *number of arguments*
    of the same type, as well as return the same type. For example (trivially), we
    could define a `sum` function that takes in three real numbers:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 重载函数还可以根据*相同类型的参数数量*进行区分，并返回相同类型。例如（显然），我们可以定义一个接受三个实数的`sum`函数：
- en: '[PRE61]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now, if we put in our `main()` function the following,
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在`main()`函数中输入以下内容，
- en: '[PRE62]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: the respective overloaded functions will be called.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 将调用相应的重载函数。
- en: Operator Overloading
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符重载
- en: C++ provides the standard mathematical operators for integer and floating type
    numerical values. The Standard Library also provides the `+` operator for `std::string`
    types, which will concatenate them. However, there are no operators provided for
    `std::vector`, for example. So, if we want to compute an element-by-element sum
    of two vectors, or calculate a dot product, we’re on our own.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: C++为整数和浮点数提供了标准的数学运算符。标准库还为`std::string`类型提供了`+`运算符，用于连接它们。然而，例如对于`std::vector`，并未提供运算符。因此，如果我们想要计算两个向量的逐元素求和，或者计算点积，我们就得自己动手。
- en: We could just use the `sum` overload for two vectors as shown above for vector
    addition, and write a new function called `dot_product` for vector multiplication.
    However, C++ provides us with a more naturally mathematical approach, namely *operator*
    *overloading*.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像上面显示的向量加法一样，使用`sum`重载，然后编写一个名为`dot_product`的新函数来进行向量乘法。然而，C++为我们提供了一个更自然的数学方法，即*运算符重载*。
- en: 'For a vector sum, the addition operator replaces the `sum` overload as shown
    below. The body of the function remains the same:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 对于向量求和，加法运算符取代了如下所示的`sum`重载。函数体保持不变：
- en: '[PRE63]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Similarly, for the dot product, which returns a scalar (`double`), overload
    the `*` operator:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，对于返回标量(`double`)的点积，重载`*`运算符：
- en: '[PRE64]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Then, for two vectors `x` and `y`, say
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于两个向量`x`和`y`，例如
- en: '[PRE65]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'the overloaded operators would perform vector addition and multiplication:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 重载的运算符将执行向量加法和乘法：
- en: '[PRE66]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: For `double` types, the compiler knows to apply the language-provided operators
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`double`类型，编译器知道要应用语言提供的运算符
- en: '[PRE67]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note
  id: totrans-292
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For simultaneous iteration over two `vector` objects, at this stage we need
    to revert to an indexed `for` loop. There are more elegant ways to do this that
    avoid the index but require additional background that will be presented in Chapter
    7.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于同时迭代两个`vector`对象，在这个阶段我们需要回到索引的`for`循环。有更优雅的方法可以避免索引，但需要额外的背景，这将在第7章中介绍。
- en: For the error condition where `x.size() != y.size()`, for now we are simply
    returning an empty vector for the vector sum, and 0 for the dot product. Exceptions
    would be more appropriate for production code.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`x.size() != y.size()`的错误条件，目前我们只是返回空向量作为向量和的结果，以及返回0作为点积的结果。在生产代码中，异常更为合适。
- en: As for other examples, if we were to write a `Matrix` class, we would also want
    to overload operators `+`, `-`, and `*`. For a `Date` class, we could define `-`
    to return the number of days between two dates. Operator overloading is thus very
    convenient for mathematical and financial programming. We will utilize it in various
    contexts going forward.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 至于其他示例，如果我们编写一个`Matrix`类，我们还希望重载运算符`+`、`-`和`*`。对于`Date`类，我们可以定义`-`来返回两个日期之间的天数。因此，运算符重载在数学和金融编程中非常方便。我们将在以后的各种上下文中使用它。
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has covered a fairly lengthy list of topics, starting with the
    `std::vector` container class in the Standard Template Library (STL). `std::vector`
    is ubiquitous in quantitative programming, for (good) reasons that will be covered
    in Chapter 7, along with STL iterators and algorithms that can make C++ code more
    elegant, reliable, and efficient. At this point, however, the goal is to be familiar
    with `std::vector` as a dynamic array of real numbers.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了一系列相当广泛的主题，从标准模板库（STL）中的`std::vector`容器类开始。`std::vector`在量化编程中无处不在，其（良好的）原因将在第7章详细讨论，同时还包括STL迭代器和算法，这些可以使C++代码更加优雅、可靠和高效。然而，目前的目标是熟悉`std::vector`作为动态数组的实现。
- en: 'Aliases come in three different varieties: type aliases (`using`), references,
    and pointers. `using` saves us from having to type out long type names, such as
    `RealVector` in place of the oft-used `std::vector<double>`. References in C++
    are mostly used in passing `const` reference objects as function arguments, avoiding
    object copying that can degrade performance, while preventing the object from
    being modified inside the function. Pointers have several important applications
    beyond being mere aliases that will be presented in due course, along with smart
    pointers that were added to the Standard Library beginning with C++11.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 别名有三种不同的形式：类型别名（`using`）、引用和指针。`using`使我们无需键入长类型名称，例如常用的`std::vector<double>`中的`RealVector`。在C++中，引用主要用于将`const`引用对象作为函数参数传递，避免了可能降低性能的对象复制，并防止在函数内修改对象。指针除了作为纯粹的别名外，还有几个重要的应用场景，这些将在适当的时候介绍，同时还包括从C++11开始添加到标准库的智能指针。
- en: Function overloading is a natural fit for mathematical programming, and operator
    overloading even more so for objects such as matrices and vectors that are ubiquitous
    in quantitative programming. This is another topic that will be extended in object-oriented
    programming in Chapter 4.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 函数重载对数学编程非常适合，对于如矩阵和向量这样在量化编程中无处不在的对象，运算符重载更是如此。这是另一个将在第4章的面向对象编程中进一步扩展的主题。
- en: References
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用
- en: '[1] CppReference: `https://en.cppreference.com/w/cpp/language/operator_precedence]`'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] CppReference: `https://en.cppreference.com/w/cpp/language/operator_precedence`'
- en: '[2] Stroustrup 4E (not directly referenced)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] Stroustrup 4E（未直接引用）'
