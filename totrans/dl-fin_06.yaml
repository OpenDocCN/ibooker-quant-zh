- en: Chapter 6\. Introductory Python for Data Science
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the final chapter before we dive into the realm of machine and deep
    learning. This chapter is optional for experienced Python developers but is important
    for anyone without a solid programming background. Understanding the intuition
    behind the algorithms is a great advantage, but that knowledge will not get you
    far if you fail to properly implement the algorithms. After all, these algorithms
    need to be coded to work and do not function manually, so you need to understand
    the basic syntax and how to manipulate and transform data.
  prefs: []
  type: TYPE_NORMAL
- en: As the book is not meant to be an A–Z guide to programming in Python, this chapter
    only focuses on some of the essentials and a few additional techniques that should
    help you smoothly navigate the subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Code* is defined as a set of instructions designed to be executed by a computer.
    Generally, specific syntax is required so that the computer applies the set of
    instructions without errors. There are many coding languages, and they are divided
    into two broad categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Low-level coding languages
  prefs: []
  type: TYPE_NORMAL
- en: These are machine languages usually used to write operating systems and firmware.
    They are very difficult to read. These languages have a sizable level of control
    over hardware. Assembly language is an example of a low-level language.
  prefs: []
  type: TYPE_NORMAL
- en: High-level coding languages
  prefs: []
  type: TYPE_NORMAL
- en: These are user-friendly languages (with a high level of abstraction). They are
    generally used to code programs and software. Examples of high-level languages
    include Python and Julia.
  prefs: []
  type: TYPE_NORMAL
- en: The coding language used in this book is Python, a popular and versatile language
    with many advantages and wide adoption in the research and professional trading
    communities. As you have probably gathered from the chapter’s title, you will
    get an introduction to Python and to the tools you need to start building your
    own scripts. But before that, you need to download Python.
  prefs: []
  type: TYPE_NORMAL
- en: A *Python interpreter* is software used to write and execute code written using
    Python syntax. I use Spyder. Some people may be more familiar with other interpreters
    such as Jupyter and PyCharm, but the process is the same. You can download Spyder
    from the [official website](https://oreil.ly/Vlh4c) or, even better, download
    it as part of a bigger package called [Anaconda](https://oreil.ly/nI8Ed), which
    facilitates installation and offers more tools. Note that Spyder is open source
    and free to use.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-1](#figure-6-1) shows Python’s console, where the output of the code
    appears.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. Spyder’s console
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Python files have the extension *.py*, and they allow you to save the code and
    refer to it at a later stage. You can also open multiple files of code and navigate
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The outline of this chapter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the language of Python and how to write error-free code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how to use control flow and its importance with time series analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand libraries and functions and their role in facilitating coding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand different types of errors and how to handle them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how to use data manipulation libraries such as *numpy* and *pandas*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, see how to import historical financial time series data into Python
    so that it gets analyzed with the proper tools (those we already discussed as
    well as those we will discuss in coming chapters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic Operations and Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Syntax* is the set of rules that define the structure of statements needed
    to write code that functions. When you are communicating with a computer, you
    have to make sure it understands you, so having a solid understanding of syntax
    is important.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Comments* are nonexecutable code used to explain the executable code that
    follows. Comments are used so that other programmers understand the code. Comments
    in Python are preceded by a hash sign (**#**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Make sure you understand that comments are nonexecutable. This means that when
    you run (execute) the code, they will be ignored by the interpreter and will not
    return an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you need to write documentation for your code, which may require
    multiple lines of code (even paragraphs, in some instances). Writing the hash
    sign at every line can be tedious and cluttersome. This is why there is a way
    to write long comments. To do this, write your comment between three single quotation
    marks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is worth noting that triple quotes are called *docstrings* and are not really
    comments (according to the official Python documentation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s discuss variables and constants. A *constant* is a fixed value that does
    not change, whereas a *variable* takes on different values given an event. A constant
    can be the number 6, while a variable can be the letter *x*, which takes on any
    number given a set of conditions or a state. A variable is defined using the `=`
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Running (executing) the previous code will store the variable `x` with its
    respective value in the variable explorer. Simultaneously, the output of the code
    will be `6`. Variables are case sensitive. Therefore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A variable declaration cannot start with a number, but a number can be included
    in the middle or the end of a variable declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Variables can also contain underscores but nothing else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It is highly recommended that variables have short and straightforward names.
    For example, consider creating a variable that holds the lookback period of a
    certain moving average (a technical indicator introduced in [Chapter 5](ch05.html#ch05)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several different data types with different characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Numerical data types*'
  prefs: []
  type: TYPE_NORMAL
- en: This is the simplest data type, formed exclusively from numbers. Numerical data
    types are divided into integers, float numbers, and complex numbers. *Integers*
    are simple whole numbers (positive or negative), such as 6 and –19\. *Float numbers*
    are more precise than integers as they incorporate the values after the comma,
    for example, 2.7 and –8.09\. *Complex numbers* include imaginary numbers.^([1](ch06.html#id561))
  prefs: []
  type: TYPE_NORMAL
- en: '*Strings*'
  prefs: []
  type: TYPE_NORMAL
- en: As you saw previously with comments and docstrings, it is possible to write
    text next to the code without it interfering with the execution process. *Strings*
    are text structures that represent sequences of characters. Strings can be inputs
    and arguments of functions and not necessarily just comments.
  prefs: []
  type: TYPE_NORMAL
- en: '*Booleans*'
  prefs: []
  type: TYPE_NORMAL
- en: A Boolean is a binary (true or false) data type used to evaluate the truth value
    of the given expression or condition. For example, you can use Booleans to evaluate
    whether the market price is above or below the 100-period moving average.
  prefs: []
  type: TYPE_NORMAL
- en: '*Data collection*'
  prefs: []
  type: TYPE_NORMAL
- en: These are sequences that contain multiple datasets, each having a different
    and unique usage. An *array* is a sequence of elements of the same type (mostly
    numerical). Arrays will be used frequently in this book (with a Python library
    called *numpy* that is discussed in this chapter). A *dataframe* is a two-dimensional
    table of structured data that is also frequently used in this book (with a Python
    library called *pandas* also discussed in this chapter). A *set* is a sequence
    of unordered elements. A *list* is an ordered collection of elements that can
    be of different data types. A *tuple* is an ordered, immutable collection of elements
    that may be of different data types. It is used for storing a fixed sequence of
    values. A *dictionary* represents a collection of key-value pairs grouped together.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows a few examples of the numerical data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows (note that the two created variables will appear
    in the variable explorer):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings are simply text. The most commonly used example to explain a string
    is the phrase “Hello World”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Strings can also be used as arguments in functions, as you will see later in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Booleans are either true or false values. The following code snippet shows
    an example of using them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the previous code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s discuss how operators work. You already saw an example of an operator:
    the assignment operator `=` used to define variables. *Operators* perform special
    mathematical and other tasks between variables, constants, and even data structures.
    There are different types of operators. Let’s start with *arithmetic operators*,
    as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The next type of operator is the *comparison operators*. These are used to
    compare different elements. They are mostly used in control flow events, as explained
    in the next section of this chapter. The following snippet shows a few comparison
    operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Logical operators* combine two or more conditions that are later evaluated.
    There are three logical operators: `and`, `or`, and `not`. The following code
    block shows an example of logical operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Data collection structures (arrays and dataframes) are discussed in a later
    section, as they require an in-depth presentation due to their complexity and
    unique tools. Let’s end this section with code that combines what has been discussed
    so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Control Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conditional statements form the first part of what is known as *control flow*
    (the second part is *loops*, discussed shortly). *Conditional statements* are
    the ancestors of today’s artificial intelligence as they only execute code if
    certain conditions are met.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conditional statements are managed using `if`, `elif`, and `else`. Take the
    following code snippet as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, conditional statements start with `if`. Then, for every new unique
    and specific condition, `elif` is used (which is a fusion of *else if*), until
    it makes sense to use the rest of the probability universe as a condition on its
    own, which is used by the `else` statement. Note that the `else` statement does
    not need a condition, as it exists to cover the rest of the uncovered universe.
  prefs: []
  type: TYPE_NORMAL
- en: '*Loops* are used to execute blocks of code repeatedly until a predefined condition
    is met. Loops are heavily used with time series to calculate indicators, verify
    states, and backtest trading strategies.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Loops are managed using `for` (for iterating over a finite and defined sequence
    or a range of elements) and `while` (used to continue the iteration until a condition
    is met) statements. For example, the following code prints the values `{1, 2,
    3, 4}` using a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `for` loop when translated is simply saying that for every element called
    `i` (or any other letter depending on the coder) in the range that starts at 1
    and ends at 5 (excluded), print the value of `i` at every loop (hence, in the
    first loop the value of `i` is equal to 1, and in the second loop it is equal
    to 2).
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop says that, starting from a value of `i = 1`, while looping,
    print its value and then add 1 to it before finishing the first loop. End the
    loop when `i` becomes greater than 4.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Theoretically, a `while` loop is infinite until told otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth noting that `i = i + 1` can also be expressed as `i += 1`. The
    goal of an algorithm is the ability to apply many operations recursively in an
    objective way, which makes loops extremely useful, especially when combined with
    conditional statements. Let’s look at an example of a financial time series:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a range of values to simulate hypothetical prices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loop through the range of the data while creating the condition that if the
    price rose since the preceding period, print 1\. Similarly, if the price fell
    since the preceding period, print –1\. Last, print 0 if the price didn’t change
    from the preceding period.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This can be done with the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The code defines a list of values (in this case, a time series called `time_series`),
    then loops around its length using the `len()` function to apply the conditions.
    Notice how at every loop, the current time step is referred to as `i`, thus making
    the previous time step `i – 1`.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries and Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *library* in Python is a group of prewritten code that offers functionality
    to facilitate the creation of applications. *Modules*, which are individual Python
    files with reusable code and data that can be imported and used in other Python
    code, are commonly found in libraries. A module is therefore a single Python file
    that contains functions and other types of code that may be used and imported
    by other Python programs. Large codebases are often easier to manage and maintain
    by using modules to divide similar code into different files.
  prefs: []
  type: TYPE_NORMAL
- en: Coding is all about simplifying tasks and making them clearer. Functions are
    essential in this regard. A *function* is a block of reusable code that performs
    a specific task when called. It only needs to be defined once. When you have a
    recurring task such as calculating a moving average of a time series, you can
    use a function so that you do not have to write the moving-average code all over
    again every time you want to use it. Instead, you define the function with the
    original code and then call it whenever you need to calculate the moving average.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple functions form a module, and multiple modules form a library. A library
    is generally theme oriented. For example, in this book the *sklearn* library will
    be used with machine learning models. Similarly, data manipulation and importing
    are done using *numpy* and *pandas*, two libraries discussed in a later section
    of this chapter. Plotting and charting are done using the *matplotlib* library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Libraries must be imported to the Python interpreter before you can use them
    (this is the equivalent of acknowledging their existence). The syntax for doing
    this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes you need to import just one function or module from a library. For
    this, you don’t need to import the entire library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code says that *math* is a Python library that harbors many mathematical
    functions, namely the `sqrt` function, which is used to find the square root of
    a given number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to define a function. A function is defined using `def` followed
    by the name of the function and any optional arguments. The following example
    creates a function that sums any two given variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '*Calling* a function means executing what it’s supposed to do. In other words,
    calling a function is simply using it. The timeline of a function is getting defined
    and then getting called.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to import a function from a library and use its functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As a side note, the *factorial* operation is a mathematical operation that is
    used to calculate the product of all positive integers from 1 up to a certain
    number (which is the argument requested in `math.factorial()`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Libraries may not be as easy as one plus one. Sometimes external libraries
    require installation first before they can be imported to the Python interpreter.
    Installation can be done through the prompt using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall [Chapter 3](ch03.html#ch03), where the maximal information coefficient
    (MIC) was discussed. To calculate the MIC, you can use the following code (after
    having defined the sine and cosine waves):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Importing the library directly will likely lead to an error as it has not been
    `pip` installed. Therefore, you must install the library first using the following
    syntax at the prompt (not in the Python interpreter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You may need to update Microsoft Visual C++ (to version 14.0 or greater) to
    avoid any errors in trying to run the *minepy* library.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to read the documentation that comes with libraries in
    order to use them correctly. A library’s documentation will explain the aim of
    the functions as well as what types of arguments each function can accept (e.g.,
    strings or numerics).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s return now to the topic of functions. A function can have a `return` statement
    that allows the result to be stored in a variable so that it can be used in other
    parts of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take two simple examples and then discuss them step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code defines the `sum_operation` function with two arguments,
    then stores the operation in a variable called `final_sum` before returning it
    so that it can be stored externally. Next, a new variable called `summed_value`
    is defined as the output of the function. Finally, another variable is created,
    `double_summed_value`, that is the result of `summed_value` multiplied by 2\.
    This is an example of how to use results from functions as variables in external
    operations. Now let’s consider an example of a nested function (while keeping
    in mind the previously defined `sum_operation` function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet defines a function called `square_summed_value`,
    which takes on two arguments. Furthermore, it uses a nested function, which in
    this case is `sum_operation`. The result of the nested function is once again
    stored in a variable called `final_sum`, which is used as an input in finding
    the `squared_sum` variable. The variable is found as `final_sum` to the power
    of two.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s end the section with common libraries in Python and machine learning
    (other than *numpy* and *pandas*):'
  prefs: []
  type: TYPE_NORMAL
- en: '*matplotlib*: For plotting and visualizing data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*sklearn*: For machine learning models'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*scipy*: For scientific computing and optimization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*keras*: For neural networks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*math*: For using mathematical tools such as square roots'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*random*: For generating random variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*requests*: For making HTTP requests used in web scraping'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception Handling and Errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Quite often, errors occur when the code is executed and the interpreter finds
    an obstacle that prevents it from continuing further. The most basic error is
    the `SyntaxError`, which occurs when there are misspelled words or missing elements
    that make the code unintelligible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the previous code, there is a missing parenthesis at the
    end of the second code line, which is not understood by the interpreter. This
    type of error is likely to be your most common one. Another common error is the
    `NameError`, which occurs when failing to define a variable before executing a
    code that contains it. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The previous code will give you a `NameError` because the interpreter does not
    know the value of `x` and `y` since they were not defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ModuleNotFoundError` occurs when the interpreter cannot find the library
    or module you are trying to import. This generally occurs when the module or library
    is installed in a bad directory or when it is not properly installed. Common fixes
    for this issue include:'
  prefs: []
  type: TYPE_NORMAL
- en: Verifying that the module’s name was written correctly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying that the module was correctly `pip` installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying that the module was installed in the correct location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another type of common error is the `TypeError`, and it occurs when you apply
    a certain operation on an incompatible element, such as summing an integer with
    a string. The following operation raises a `TypeError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In time series analysis, you will likely to encounter these four errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IndexError`'
  prefs: []
  type: TYPE_NORMAL
- en: This is raised when referring to an index that is out of range regarding the
    current array or dataframe. Imagine having an array of 300 values (rows). If you
    want to loop through them and, at each loop, input the number 1 in the next cell
    (time step + 1), the interpreter will raise an `IndexError` because in the last
    loop there is no next cell.
  prefs: []
  type: TYPE_NORMAL
- en: '`ValueError`'
  prefs: []
  type: TYPE_NORMAL
- en: This is raised when you try to call a function with an invalid argument. An
    example of this would be trying to pass an integer element as a string when calling
    a function.
  prefs: []
  type: TYPE_NORMAL
- en: '`KeyError`'
  prefs: []
  type: TYPE_NORMAL
- en: This occurs when trying to access an element in a dataframe that does not exist.
    For example, if you have three columns in the dataframe and you refer to one that
    does not exist (maybe due to a syntax issue), you are likely to run into a `KeyError`.
  prefs: []
  type: TYPE_NORMAL
- en: '`ZeroDivisionError`'
  prefs: []
  type: TYPE_NORMAL
- en: This error is intuitive and occurs when trying to divide a number by zero.
  prefs: []
  type: TYPE_NORMAL
- en: There are other types of errors that you may encounter. It is important to understand
    what they refer to so that you are able to fix them and get the code running again.
  prefs: []
  type: TYPE_NORMAL
- en: '*Exceptions* are errors that may not be fatal to the code in the sense that
    they only show a warning but don’t necessarily terminate the code. Therefore,
    exceptions occur during code execution (as opposed to errors, which occur because
    the interpreter is unable to execute the code). To ignore certain exceptions (and
    errors), the `try`  and `except` keywords are used. This is useful when you are
    certain that handling the exception will not alter the output of the code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take an example of creating a function that divides the first column
    of a time series by the next value of the second column. The first step is to
    define the time series as a dataframe or as an array (or any other data collection
    structure):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s write the division function that will take any value in the first
    column and divide it by the next value in the second column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the two previous code blocks will give an `IndexError` because in the
    last loop, the function cannot find the next value of the second column since
    it does not exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixing this through `try` and `except` will ignore the last calculation that
    is causing the problem and will return the expected results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Data Structures in numpy and pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You now understand what a library is and know that *numpy* and *pandas* are
    the go-to libraries to manipulate, handle, and import data in Python. This section
    discusses the differences between the two, along with key functions that are definitely
    a great addition to your data analysis toolbox. But first, let’s define these
    two libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '*numpy*'
  prefs: []
  type: TYPE_NORMAL
- en: Short for numerical Python, *numpy* is a Python library that allows working
    with multidimensional arrays and matrices. It provides a powerful  interface for
    performing various operations on arrays and matrices.
  prefs: []
  type: TYPE_NORMAL
- en: '*pandas*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Short for panel data, *pandas* is a Python library that allows working with
    dataframes (a type of tabular data). It provides two main data structures: series
    and dataframes. A *series* is a one-dimensional array-like object that can hold
    any data type. A *dataframe* is a two-dimensional table-like structure that consists
    of rows and columns (similar to a spreadsheet).'
  prefs: []
  type: TYPE_NORMAL
- en: Both libraries are very useful in analyzing time series data. Arrays hold only
    numerical type data and therefore do not really hold date type data. This may
    be one of the advantages of using *pandas* over *numpy*, but both have strengths
    and relative weaknesses. In the end, it is a matter of choice. This book will
    prioritize using *numpy* due to its simplicity and the fact that the machine learning
    models in the next chapter use the *sklearn* library, which is applied on arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Switching between *numpy* and *pandas* requires converting the time series type.
    This is a relatively easy task, but it can sometimes cause the loss of certain
    types of data (e.g., date data).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s import both libraries before discussing some of their potential:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code creates two time series with two columns and three rows.
    The first time series is called `my_data_frame` and is created using the *pandas*
    library function `pd.DataFrame`. The second time series is called `my_array` and
    is created using the *numpy* library function `np.array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As shown in [Figure 6-2](#figure-6-2), dataframes have real indices and can
    have column names. Arrays can only hold one type of data.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_0602.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2\. A *pandas* dataframe (left) and a *numpy* array (right)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To switch between the two types of data, you will be using the same two functions
    used in the previous code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now take a look at useful functions that will come in handy when dealing
    with models. Slicing and concatenation are among the processes you must master
    to smoothly navigate through data analysis. Consider the following arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '*Concatenation* is the act of fusing two datasets together either through rows
    (axis = 0) or through columns (axis = 1). Let’s do both of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s do the same thing for dataframes. Consider the following dataframes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Concatenation is useful when you want to combine data into one structure. This
    is how it can be done with dataframes (notice that it’s simply a change of syntax
    and function source):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that with time series, *rows* (horizontal cells) represent one time
    step (e.g., hourly) with all the data inside, while *columns* represent the different
    types of data (e.g., open price and close price of a financial instrument). Now
    let’s see slicing techniques for arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It is important to know that Python indexing starts at zero. This means that
    to refer to the first element in a data structure, you refer to its index as index
    = 0\. It is also worth noting that in ranges, the last element is excluded, which
    means that the first three elements in a data structure are referred to as `[0,
    3]`, which will give the elements indexed at 0, 1, and 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see the same thing for dataframes so that this section becomes a sort
    of mini reference whenever you want to manipulate data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Try going back to the earlier chapters to execute the code given there. You
    should have a more solid understanding by now.
  prefs: []
  type: TYPE_NORMAL
- en: Importing Financial Time Series in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section discusses a key aspect of deploying machine and deep learning algorithms.
    It deals with the historical OHLC data that is needed to run the models and evaluate
    their performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to prepare the environment and everything else necessary
    for the success of the algorithms. For this, you need two programs:'
  prefs: []
  type: TYPE_NORMAL
- en: A Python interpreter that you use to write and execute code. You already completed
    this step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Charting and financial software that you use as a database. This part is covered
    in this section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For charting benchmarks, I use MetaTrader 5, a program used by many traders
    around the globe. MetaTrader 5 works with Spyder, so you should start by downloading
    Spyder and familiarizing yourself with how it works.
  prefs: []
  type: TYPE_NORMAL
- en: From the [official website](https://oreil.ly/YlNWu), download and install MetaTrader
    5\. You need to create a demo account, which is simply a virtual account with
    imaginary money. The word *demo* does not refer to a limited duration of use but
    to the fact that it is not using real money.
  prefs: []
  type: TYPE_NORMAL
- en: To open an account, select File > Open an Account, choose MetaQuotes Software
    Corp, and then click Next. Then choose the first option to open a demo account;
    this will let you trade virtual money. Finally, enter some basic information such
    as your name, email, and account type. You will not receive a verification request
    or any type of confirmation as the demo should launch directly, allowing you to
    see the charts.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-3](#figure-6-3) shows the platform’s interface. By default, MetaTrader
    5 does not show all the markets it covers, so you need to make them accessible
    for import and visualization if necessary. Click View, click Market Watch, and
    then right-click any of the symbols shown in the new tab and choose Show All.
    This way, you can see the extended list with more markets.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can start coding, you need to install the MetaTrader 5 Python integration
    library so that you can use it later in Spyder. This is easy and requires one
    step. Open the Anaconda prompt and type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Installation is the bridge that allows you to use Python modules and functions
    designed for MetaTrader 5 in the interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_0603.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-3\. MetaTrader 5 interface
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following code block uses the `import` built-in statement, which calls
    for internal (self-created) or external (created by third parties) libraries.
    You’ll recall that a library is a store of functions, and thus, you need to import
    the libraries that are pertinent to what you want to do. For demonstration purposes,
    import the following modules, packages, and libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create the universe of the time frames that you will be
    able to import. Even though I will be showing you how to analyze and backtest
    hourly data, you can define a wider universe, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The full code is found in this book’s [GitHub repository](https://oreil.ly/5YGHI)
    under the name *master_function.py.*
  prefs: []
  type: TYPE_NORMAL
- en: A *time frame* is the frequency with which you record the prices. With hourly
    data, you will record the last price printed every hour. This means that in a
    day, you can have up to 24 hourly prices. This allows you to see the intraday
    evolution of the price. The aim is to record the totality of the OHLC data within
    a specific period.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code defines the current time, which is used so that the algorithm
    has a reference point when importing the data. Basically, you are creating a variable
    that stores the current time and date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now proceed to defining the universe of the financial instruments you
    want to backtest. In this book, the backtests will be done exclusively on the
    foreign exchange (FX) market. So let’s create a variable that stores some key
    currency pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have your time and asset variables ready, all you need to do is
    create the structure of the importing algorithm. The `get_quotes()` function does
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that in the `get_quotes()` function, you use the *pytz* and *pandas*
    libraries. The function starts by defining the Olson time zone,^([2](ch06.html#id594))
    which you can set yourself. Here is a brief, nonexhaustive list of what you can
    enter depending on your time zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Next define two variables called `time_from` and `time_to`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `time_from` variable contains the `datetime` referring to the beginning
    of the import date (e.g., 01-01-2020).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `time_to` variable contains the `datetime` referring to the end of the import
    date, which uses the `now` variable to represent the current time and date.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next step is to create a variable that imports the financial data using
    the time periods you have specified. This is done through the `rates` variable
    using the `mt5.copy_rates_range()` function. Finally, using *pandas*, transform
    the data into a dataframe. The final function required for the importing process
    is the `mass_import()` function. It lets you choose the time frame using the variable
    and then uses the `get_quotes()` function to import the data and format it to
    an array. The following code snippet defines the `mass_import()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `mass_import()` function automatically converts the dataframe into an array,
    so you do not have to worry about conversion when using the automatic import.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You may need to adjust the year argument higher to get the data in case you
    have an empty array. For instance, if you get an empty array using the `mass_import()` function,
    try putting a more recent year in the `get_quotes()` function (“2014” instead
    of “2013”).
  prefs: []
  type: TYPE_NORMAL
- en: 'To import the historical hourly EURUSD data from the beginning of 2014 to date,
    you may type the following (assuming `get_quotes()`, `now`, the frames, and the
    libraries are already defined):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice how the `return` statement is used in the `mass_import` function to store
    the historical data in chosen variables.
  prefs: []
  type: TYPE_NORMAL
- en: Even though there is a macOS version of MetaTrader 5, the Python library only
    works on Windows. It requires a Windows emulator on macOS. For macOS or Linux
    users, you may want to try the manual import method (or the alternative way proposed
    in [Chapter 7](ch07.html#ch07) that uses a library called *pandas-datareader*).
  prefs: []
  type: TYPE_NORMAL
- en: Automatic import is a huge time-saver, but even Windows users may run into frustrating
    errors. Therefore, I will show you the manual import method, which you can use
    as a fix. On the [Github page](https://oreil.ly/5YGHI) for this book, you will
    find a folder called *Historical Data*. Inside the folder there is a selection
    of historical financial time series in Excel format that you can download.
  prefs: []
  type: TYPE_NORMAL
- en: Manual import requires an Excel file with OHLC data that you have downloaded
    from a third party (such as the Excel files provided in this book’s GitHub repository).
    In this case, you can use the *pandas* library to import it and transform it into
    an array.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take an example of *Daily_GBPUSD_Historical_Data.xlsx**.* Download the
    file from the repository (found in *Historical Data*) and store it on your desktop.
    The Spyder directory must be in the same place as the file. In layperson’s terms,
    this means Spyder must search your desktop for the Excel file. To choose the right
    directory, click the folder button next to the arrow. The Directory tab should
    look like [Figure 6-4](#figure-6-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_0604.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-4\. The Directory tab after choosing the correct folder
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You should get a separate window where you can choose the desktop location and
    then validate the choice. Having done this, the tab should look like [Figure 6-5](#figure-6-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_0605.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-5\. The Directory tab after choosing the correct desktop location
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You use the `read_excel()` function (built into *pandas* and accessible after
    importing it) to get the values inside the Excel file. Follow this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: You should have a dataframe called *Daily_GBPUSD_Historical_Data.xlsx* with
    five different columns representing open, high, low, and close prices. You generally
    have to enter the library’s name before using a function that belongs to it; this
    is why `read_excel()` is preceded by `pd`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I recommend using automatic import for Windows users and manual import for macOS
    users due to compatibility issues.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python, a major star among coding languages, enjoys widespread adoption by the
    developer community. Mastering it is key to unlocking huge potential in the data
    science world.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter discusses machine learning and different prediction algorithms.
    The main aim is to be able to code the algorithms and run a backtest over financial
    data. You will see that once you start understanding the process, it becomes a
    matter of removing one algorithm and plugging another one in (in case they have
    the same assumptions). The warm-up chapters are over, and it’s time to start coding.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch06.html#id561-marker)) Imaginary numbers are a type of complex number
    that represents the square root of a negative number.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch06.html#id594-marker)) Named after its creator, Arthur David Olson,
    the Olson time zone addresses issues related to time zone data and daylight saving
    time rules. It has been an essential resource for developers and computer systems
    to accurately handle time-related functions and conversions.
  prefs: []
  type: TYPE_NORMAL
