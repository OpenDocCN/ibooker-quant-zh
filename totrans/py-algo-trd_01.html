<html><head></head><body><section class="pagenumrestart" data-pdf-bookmark="Chapter 1. Python and Algorithmic Trading" data-type="chapter" epub:type="chapter"><div class="chapter" id="algorithmic_trading">&#13;
<h1><span class="label">Chapter 1. </span>Python and Algorithmic Trading</h1>&#13;
&#13;
<blockquote data-type="epigraph" epub:type="epigraph">&#13;
    <p>At Goldman [Sachs] the number of people engaged in trading shares has fallen from a peak of 600 in 2000 to just two today.<sup><a data-type="noteref" href="ch01.html#idm45785394843768" id="idm45785394843768-marker">1</a></sup></p>&#13;
    <p data-type="attribution"><em>The Economist</em></p>&#13;
  </blockquote>&#13;
&#13;
<p><a data-primary="Goldman Sachs" data-type="indexterm" id="idm45785394771848"/><a data-primary="Python (generally)" data-secondary="basics" data-type="indexterm" id="ix_01_python_algorithmic_trading_-asciidoc0"/>This chapter provides background information for, and an overview of, the topics covered in this book. Although Python for algorithmic trading is a niche at the intersection of Python programming and finance, it is a fast-growing one that touches on such diverse topics as Python deployment, interactive financial analytics, machine and deep learning, object-oriented programming, socket communication, visualization of streaming data, and trading platforms.</p>&#13;
&#13;
<p>For a quick refresher on important Python topics, read the <a data-type="xref" href="app01.html#python_numpy_pandas">Appendix A</a> first.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Python for Finance" data-type="sect1"><div class="sect1" id="idm45785394798392">&#13;
<h1>Python for Finance</h1>&#13;
&#13;
<p><a data-primary="Python (generally)" data-secondary="origins" data-type="indexterm" id="idm45785394796952"/>The Python programming language originated in 1991 with the first release by Guido van Rossum of a version labeled 0.9.0. In 1994, version 1.0 followed. However, it took almost two decades for Python to establish itself as a major programming language and technology platform in the financial industry. Of course, there were early adopters, mainly hedge funds, but widespread adoption probably started only around 2011.</p>&#13;
&#13;
<p><a data-primary="Python (generally)" data-secondary="obstacles to adoption in financial industry" data-type="indexterm" id="idm45785394795160"/>One major obstacle to the adoption of Python in the financial industry has been the fact that the default Python version, called <a data-primary="CPython" data-type="indexterm" id="idm45785394793944"/>CPython, is an interpreted, high-level language. Numerical algorithms in general and financial algorithms in particular are quite often implemented based on (nested) loop structures. While compiled, low-level languages like C or C++ are really fast at executing such loops, Python, which relies on interpretation instead of compilation, is generally quite slow at doing so. As a consequence, pure Python proved too slow for many real-world financial applications, such as option pricing or risk management.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Python Versus Pseudo-Code" data-type="sect2"><div class="sect2" id="idm45785396036632">&#13;
<h2>Python Versus Pseudo-Code</h2>&#13;
&#13;
<p><a data-primary="pseudo-code, Python versus" data-type="indexterm" id="idm45785396035208"/><a data-primary="Python (generally)" data-secondary="pseudo-code versus" data-type="indexterm" id="idm45785396034440"/>Although Python was never specifically targeted towards the scientific and financial communities, many people from these fields nevertheless liked the beauty and conciseness of its syntax. Not too long ago, it was generally considered good tradition to explain a (financial) algorithm and at the same time present some pseudo-code as an intermediate step towards its proper technological implementation. Many felt that, with Python, the pseudo-code step would not be necessary anymore. And they were proven mostly correct.</p>&#13;
&#13;
<p><a data-primary="Euler discretization" data-type="indexterm" id="idm45785396058392"/>Consider, for instance, the Euler discretization of the geometric Brownian motion, as in <a data-type="xref" href="#euler_disc_intro">Equation 1-1</a>.</p>&#13;
<div data-type="equation" id="euler_disc_intro">&#13;
<h5><span class="label">Equation 1-1. </span>Euler discretization of geometric Brownian motion</h5>&#13;
<math alttext="upper S Subscript upper T Baseline equals upper S 0 exp left-parenthesis left-parenthesis r minus 0.5 sigma squared right-parenthesis upper T plus sigma z StartRoot upper T EndRoot right-parenthesis" display="block">&#13;
  <mrow>&#13;
    <msub><mi>S</mi> <mi>T</mi> </msub>&#13;
    <mo>=</mo>&#13;
    <msub><mi>S</mi> <mn>0</mn> </msub>&#13;
    <mo form="prefix">exp</mo>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mrow>&#13;
        <mo>(</mo>&#13;
        <mi>r</mi>&#13;
        <mo>-</mo>&#13;
        <mn>0</mn>&#13;
        <mo>.</mo>&#13;
        <mn>5</mn>&#13;
        <msup><mi>σ</mi> <mn>2</mn> </msup>&#13;
        <mo>)</mo>&#13;
      </mrow>&#13;
      <mi>T</mi>&#13;
      <mo>+</mo>&#13;
      <mi>σ</mi>&#13;
      <mi>z</mi>&#13;
      <msqrt>&#13;
        <mi>T</mi>&#13;
      </msqrt>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
  </mrow>&#13;
</math>&#13;
</div>&#13;
&#13;
<p><a data-primary="LaTeX" data-type="indexterm" id="idm45785393433496"/>For decades, the LaTeX markup language and compiler have been the gold standard for authoring scientific documents containing mathematical formulae. In many ways, Latex syntax is similar to or already like pseudo-code when, for example, laying out equations, as in <a data-type="xref" href="#euler_disc_intro">Equation 1-1</a>. In this particular case, the Latex version looks like this:</p>&#13;
&#13;
<pre data-type="programlisting">S_T = S_0 \exp((r - 0.5 \sigma^2) T + \sigma z \sqrt{T})</pre>&#13;
&#13;
<p>In Python, this translates to executable code, given respective variable definitions, that is also really close to the financial formula as well as to the Latex representation:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="n">S_T</code> <code class="o">=</code> <code class="n">S_0</code> <code class="o">*</code> <code class="n">exp</code><code class="p">((</code><code class="n">r</code> <code class="o">-</code> <code class="mf">0.5</code> <code class="o">*</code> <code class="n">sigma</code> <code class="o">**</code> <code class="mi">2</code><code class="p">)</code> <code class="o">*</code> <code class="n">T</code> <code class="o">+</code> <code class="n">sigma</code> <code class="o">*</code> <code class="n">z</code> <code class="o">*</code> <code class="n">sqrt</code><code class="p">(</code><code class="n">T</code><code class="p">))</code></pre>&#13;
&#13;
<p>However, the speed issue remains. Such a difference equation, as a numerical approximation of the respective stochastic differential equation, is generally used to price derivatives by Monte Carlo simulation or to do risk analysis and management based on simulation.<sup><a data-type="noteref" href="ch01.html#idm45785394872712" id="idm45785394872712-marker">2</a></sup> These tasks in turn can require millions of simulations that need to be finished in due time, often in almost real-time or at least near-time. Python, as an interpreted high-level programming language, was never designed to be fast enough to tackle such computationally demanding tasks.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="NumPy and Vectorization" data-type="sect2"><div class="sect2" id="idm45785394871768">&#13;
<h2>NumPy and Vectorization</h2>&#13;
&#13;
<p><a data-primary="NumPy" data-type="indexterm" id="ix_01_python_algorithmic_trading_-asciidoc1"/><a data-primary="Python (generally)" data-secondary="NumPy and vectorization" data-type="indexterm" id="ix_01_python_algorithmic_trading_-asciidoc2"/>In 2006, version 1.0 of the <a href="http://numpy.org"><code>NumPy</code> Python package</a> was released by Travis Oliphant. <code>NumPy</code> stands for <em>numerical Python</em>, suggesting that it targets scenarios that are numerically demanding. The base Python interpreter tries to be as general as possible in many areas, which often leads to quite a bit of overhead at run-time.<sup><a data-type="noteref" href="ch01.html#idm45785393485592" id="idm45785393485592-marker">3</a></sup> <code>NumPy</code>, on the other hand, uses specialization as its major approach &#13;
<span class="keep-together">to avoid</span> overhead and to be as good and as fast as possible in certain application &#13;
<span class="keep-together">scenarios.</span></p>&#13;
&#13;
<p><a data-primary="ndarray objects" data-type="indexterm" id="idm45785395565448"/>The major class of <code>NumPy</code> is the regular array object, called <code>ndarray</code> object for <em>n-dimensional array</em>. It is immutable, which means that it cannot be changed in size, and can only accommodate a single data type, called <code>dtype</code>. This specialization allows for the implementation of concise and fast code. <a data-primary="mean-reversion strategies" data-type="indexterm" id="idm45785401539608"/><a data-primary="trading strategies" data-secondary="mean-reversion" data-type="indexterm" id="idm45785401539048"/><a data-primary="vectorization" data-type="indexterm" id="idm45785401538104"/>One central approach in this context is <em>vectorization</em>. Basically, this approach avoids looping on the Python level and delegates the looping to specialized <code>NumPy</code> code, generally implemented in C and therefore rather fast.</p>&#13;
&#13;
<p>Consider the simulation of 1,000,000 end of period values <math alttext="upper S Subscript upper T">&#13;
  <msub><mi>S</mi> <mi>T</mi> </msub>&#13;
</math> according to <a data-type="xref" href="#euler_disc_intro">Equation 1-1</a> with pure Python. The major part of the following code is a <code>for</code> loop with 1,000,000 iterations:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="n">In</code><code> </code><code class="p">[</code><code class="mi">1</code><code class="p">]</code><code class="p">:</code><code> </code><code class="o">%</code><code class="o">%</code><code class="n">time</code><code>&#13;
</code><code>        </code><code class="kn">import</code><code> </code><code class="nn">random</code><code>&#13;
</code><code>        </code><code class="kn">from</code><code> </code><code class="nn">math</code><code> </code><code class="kn">import</code><code> </code><code class="n">exp</code><code class="p">,</code><code> </code><code class="n">sqrt</code><code>&#13;
</code><code>&#13;
</code><code>        </code><code class="n">S0</code><code> </code><code class="o">=</code><code> </code><code class="mi">100</code><code>  </code><a class="co" href="#callout_python_and_algorithmic_trading_CO1-1" id="co_python_and_algorithmic_trading_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>        </code><code class="n">r</code><code> </code><code class="o">=</code><code> </code><code class="mf">0.05</code><code>  </code><a class="co" href="#callout_python_and_algorithmic_trading_CO1-2" id="co_python_and_algorithmic_trading_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>        </code><code class="n">T</code><code> </code><code class="o">=</code><code> </code><code class="mf">1.0</code><code>  </code><a class="co" href="#callout_python_and_algorithmic_trading_CO1-3" id="co_python_and_algorithmic_trading_CO1-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code>        </code><code class="n">sigma</code><code> </code><code class="o">=</code><code> </code><code class="mf">0.2</code><code>  </code><a class="co" href="#callout_python_and_algorithmic_trading_CO1-4" id="co_python_and_algorithmic_trading_CO1-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
</code><code>&#13;
</code><code>        </code><code class="n">values</code><code> </code><code class="o">=</code><code> </code><code class="p">[</code><code class="p">]</code><code>  </code><a class="co" href="#callout_python_and_algorithmic_trading_CO1-5" id="co_python_and_algorithmic_trading_CO1-5"><img alt="5" src="assets/5.png"/></a><code>&#13;
</code><code>&#13;
</code><code>        </code><code class="k">for</code><code> </code><code class="n">_</code><code> </code><code class="ow">in</code><code> </code><code class="nb">range</code><code class="p">(</code><code class="mi">1000000</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" href="#callout_python_and_algorithmic_trading_CO1-6" id="co_python_and_algorithmic_trading_CO1-6"><img alt="6" src="assets/6.png"/></a><code>&#13;
</code><code>            </code><code class="n">ST</code><code> </code><code class="o">=</code><code> </code><code class="n">S0</code><code> </code><code class="o">*</code><code> </code><code class="n">exp</code><code class="p">(</code><code class="p">(</code><code class="n">r</code><code> </code><code class="o">-</code><code> </code><code class="mf">0.5</code><code> </code><code class="o">*</code><code> </code><code class="n">sigma</code><code> </code><code class="o">*</code><code class="o">*</code><code> </code><code class="mi">2</code><code class="p">)</code><code> </code><code class="o">*</code><code> </code><code class="n">T</code><code> </code><code class="o">+</code><code>&#13;
</code><code>                            </code><code class="n">sigma</code><code> </code><code class="o">*</code><code> </code><code class="n">random</code><code class="o">.</code><code class="n">gauss</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code> </code><code class="mi">1</code><code class="p">)</code><code> </code><code class="o">*</code><code> </code><code class="n">sqrt</code><code class="p">(</code><code class="n">T</code><code class="p">)</code><code class="p">)</code><code>  </code><a class="co" href="#callout_python_and_algorithmic_trading_CO1-7" id="co_python_and_algorithmic_trading_CO1-7"><img alt="7" src="assets/7.png"/></a><code>&#13;
</code><code>            </code><code class="n">values</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">ST</code><code class="p">)</code><code>  </code><a class="co" href="#callout_python_and_algorithmic_trading_CO1-8" id="co_python_and_algorithmic_trading_CO1-8"><img alt="8" src="assets/8.png"/></a><code>&#13;
</code><code>        </code><code class="n">CPU</code><code> </code><code class="n">times</code><code class="p">:</code><code> </code><code class="n">user</code><code> </code><code class="mf">1.13</code><code> </code><code class="n">s</code><code class="p">,</code><code> </code><code class="n">sys</code><code class="p">:</code><code> </code><code class="mf">21.7</code><code> </code><code class="n">ms</code><code class="p">,</code><code> </code><code class="n">total</code><code class="p">:</code><code> </code><code class="mf">1.15</code><code> </code><code class="n">s</code><code>&#13;
</code><code>        </code><code class="n">Wall</code><code> </code><code class="n">time</code><code class="p">:</code><code> </code><code class="mf">1.15</code><code> </code><code class="n">s</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_python_and_algorithmic_trading_CO1-1" id="callout_python_and_algorithmic_trading_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The initial index level.</p></dd>&#13;
<dt><a class="co" href="#co_python_and_algorithmic_trading_CO1-2" id="callout_python_and_algorithmic_trading_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The constant short rate.</p></dd>&#13;
<dt><a class="co" href="#co_python_and_algorithmic_trading_CO1-3" id="callout_python_and_algorithmic_trading_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The time horizon in year fractions.</p></dd>&#13;
<dt><a class="co" href="#co_python_and_algorithmic_trading_CO1-4" id="callout_python_and_algorithmic_trading_CO1-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>The constant volatility factor.</p></dd>&#13;
<dt><a class="co" href="#co_python_and_algorithmic_trading_CO1-5" id="callout_python_and_algorithmic_trading_CO1-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>An empty <code>list</code> object to collect simulated values.</p></dd>&#13;
<dt><a class="co" href="#co_python_and_algorithmic_trading_CO1-6" id="callout_python_and_algorithmic_trading_CO1-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>The main <code>for</code> loop.</p></dd>&#13;
<dt><a class="co" href="#co_python_and_algorithmic_trading_CO1-7" id="callout_python_and_algorithmic_trading_CO1-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>The simulation of a <em>single</em> end-of-period value.</p></dd>&#13;
<dt><a class="co" href="#co_python_and_algorithmic_trading_CO1-8" id="callout_python_and_algorithmic_trading_CO1-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>Appends the simulated value to the <code>list</code> object.</p></dd>&#13;
</dl>&#13;
&#13;
<p>With <code>NumPy</code>, you can avoid looping on the Python level completely by the use of vectorization. The code is much more concise, more readable, and faster by a factor of about eight:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="n">In</code><code> </code><code class="p">[</code><code class="mi">2</code><code class="p">]</code><code class="p">:</code><code> </code><code class="o">%</code><code class="o">%</code><code class="n">time</code><code>&#13;
</code><code>        </code><code class="kn">import</code><code> </code><code class="nn">numpy</code><code> </code><code class="kn">as</code><code> </code><code class="nn">np</code><code>&#13;
</code><code>&#13;
</code><code>        </code><code class="n">S0</code><code> </code><code class="o">=</code><code> </code><code class="mi">100</code><code>&#13;
</code><code>        </code><code class="n">r</code><code> </code><code class="o">=</code><code> </code><code class="mf">0.05</code><code>&#13;
</code><code>        </code><code class="n">T</code><code> </code><code class="o">=</code><code> </code><code class="mf">1.0</code><code>&#13;
</code><code>        </code><code class="n">sigma</code><code> </code><code class="o">=</code><code> </code><code class="mf">0.2</code><code>&#13;
</code><code>&#13;
</code><code>        </code><code class="n">ST</code><code> </code><code class="o">=</code><code> </code><code class="n">S0</code><code> </code><code class="o">*</code><code> </code><code class="n">np</code><code class="o">.</code><code class="n">exp</code><code class="p">(</code><code class="p">(</code><code class="n">r</code><code> </code><code class="o">-</code><code> </code><code class="mf">0.5</code><code> </code><code class="o">*</code><code> </code><code class="n">sigma</code><code> </code><code class="o">*</code><code class="o">*</code><code> </code><code class="mi">2</code><code class="p">)</code><code> </code><code class="o">*</code><code> </code><code class="n">T</code><code> </code><code class="o">+</code><code>&#13;
</code><code>                            </code><code class="n">sigma</code><code> </code><code class="o">*</code><code> </code><code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">standard_normal</code><code class="p">(</code><code class="mi">1000000</code><code class="p">)</code><code> </code><code class="o">*</code><code>&#13;
</code><code>                            </code><code class="n">np</code><code class="o">.</code><code class="n">sqrt</code><code class="p">(</code><code class="n">T</code><code class="p">)</code><code class="p">)</code><code>  </code><a class="co" href="#callout_python_and_algorithmic_trading_CO2-1" id="co_python_and_algorithmic_trading_CO2-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>        </code><code class="n">CPU</code><code> </code><code class="n">times</code><code class="p">:</code><code> </code><code class="n">user</code><code> </code><code class="mi">375</code><code> </code><code class="n">ms</code><code class="p">,</code><code> </code><code class="n">sys</code><code class="p">:</code><code> </code><code class="mf">82.6</code><code> </code><code class="n">ms</code><code class="p">,</code><code> </code><code class="n">total</code><code class="p">:</code><code> </code><code class="mi">458</code><code> </code><code class="n">ms</code><code>&#13;
</code><code>        </code><code class="n">Wall</code><code> </code><code class="n">time</code><code class="p">:</code><code> </code><code class="mi">160</code><code> </code><code class="n">ms</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_python_and_algorithmic_trading_CO2-1" id="callout_python_and_algorithmic_trading_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>This single line of <code>NumPy</code> code simulates all the values and stores them in an &#13;
<span class="keep-together"><code>ndarray</code></span> object.</p></dd>&#13;
</dl>&#13;
<div data-type="tip">&#13;
<p>Vectorization is a powerful concept for writing concise, easy-to-read, and easy-to-maintain code in finance and algorithmic trading. With <code>NumPy</code>, vectorized code does not only make code more concise, but it also can speed up code execution considerably (by a factor of about eight in the Monte Carlo simulation, for example).</p>&#13;
</div>&#13;
&#13;
<p>It’s safe to say that <code>NumPy</code> has significantly contributed to the success of Python in science and finance. <a data-primary="scientific stack" data-type="indexterm" id="idm45785400286600"/>Many other popular Python packages from the so-called <em>scientific Python stack</em> build on <code>NumPy</code> as an efficient, performing data structure to store and handle numerical data. <a data-primary="SciPy package project" data-type="indexterm" id="idm45785400284936"/>In fact, <code>NumPy</code> is an outgrowth of the <code>SciPy</code> package project, which provides a wealth of functionality frequently needed in science. The <code>SciPy</code> project recognized the need for a more powerful numerical data structure and &#13;
<span class="keep-together">consolidated</span> older projects like <code>Numeric</code> and <code>NumArray</code> in this area into a new, unifying one in the form of <code>NumPy</code>.</p>&#13;
&#13;
<p>In algorithmic trading, a Monte Carlo simulation might not be the most important use case for a programming language. However, if you enter the algorithmic trading space, the management of larger, or even big, financial time series data sets is a very important use case. Just think of the backtesting of (intraday) trading strategies or the processing of tick data streams during trading hours. This is where the <a href="http://pandas.pydata.org"><code>pandas</code> data analysis package</a> comes into play.<a data-startref="ix_01_python_algorithmic_trading_-asciidoc2" data-type="indexterm" id="idm45785400290344"/><a data-startref="ix_01_python_algorithmic_trading_-asciidoc1" data-type="indexterm" id="idm45785400296744"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="pandas and the DataFrame Class" data-type="sect2"><div class="sect2" id="idm45785394870840">&#13;
<h2>pandas and the DataFrame Class</h2>&#13;
&#13;
<p><a data-primary="DataFrame class" data-type="indexterm" id="ix_01_python_algorithmic_trading_-asciidoc3"/><a data-primary="pandas" data-type="indexterm" id="ix_01_python_algorithmic_trading_-asciidoc4"/><a data-primary="Python (generally)" data-secondary="pandas and DataFrame class" data-type="indexterm" id="ix_01_python_algorithmic_trading_-asciidoc5"/>Development of <code>pandas</code> began in 2008 by <a data-primary="AQR Capital Management" data-type="indexterm" id="idm45785396578664"/><a data-primary="McKinney, Wes" data-type="indexterm" id="idm45785396577640"/>Wes McKinney, who back then was working at AQR Capital Management, a big hedge fund operating out of Greenwich, Connecticut. As with for any other hedge fund, working with time series data is of paramount importance for AQR Capital Management, but back then Python did not provide any kind of appealing support for this type of data. Wes’s idea was to create a package that mimics the capabilities of the R statistical language (<a href="http://r-project.org"><em class="hyperlink">http://r-project.org</em></a>) in this area. This is reflected, for example, in naming the major class <code>DataFrame</code>, whose counterpart in R is called <code>data.frame</code>. Not being considered close enough to the core business of money management, AQR Capital Management open sourced the <code>pandas</code> project in 2009, which marks the beginning of a major success story in open source–based data and financial analytics.</p>&#13;
&#13;
<p>Partly due to <code>pandas</code>, Python has become a major force in data and financial analytics. Many people who adopt Python, coming from diverse other languages, cite &#13;
<span class="keep-together"><code>pandas</code></span> as a major reason for their decision. In combination with open data sources like <a href="http://quandl.com">Quandl</a>, <code>pandas</code> even allows students to do sophisticated financial analytics with the lowest barriers of entry ever: a regular notebook computer with an internet connection suffices.</p>&#13;
&#13;
<p><a data-primary="Bitcoin" data-type="indexterm" id="idm45785396590104"/>Assume an algorithmic trader is interested in trading Bitcoin, the cryptocurrency with the largest market capitalization. A first step might be to retrieve data about the historical exchange rate in USD. Using Quandl data and <code>pandas</code>, such a task is accomplished in less than a minute. <a data-type="xref" href="#bitcoin_xr">Figure 1-1</a> shows the plot that results from the following Python code, which is (omitting some plotting style related parameterizations) only four lines. Although <code>pandas</code> is not explicitly imported, the Quandl Python wrapper package by default returns a <code>DataFrame</code> object that is then used to add a <a data-primary="simple moving averages (SMAs)" data-type="indexterm" id="idm45785396593816"/>simple moving average (SMA) of 100 days, as well as to visualize the raw data alongside &#13;
<span class="keep-together">the SMA:</span></p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="n">In</code><code> </code><code class="p">[</code><code class="mi">3</code><code class="p">]</code><code class="p">:</code><code> </code><code class="o">%</code><code class="n">matplotlib</code><code> </code><code class="n">inline</code><code>&#13;
</code><code>        </code><code class="kn">from</code><code> </code><code class="nn">pylab</code><code> </code><code class="kn">import</code><code> </code><code class="n">mpl</code><code class="p">,</code><code> </code><code class="n">plt</code><code>  </code><a class="co" href="#callout_python_and_algorithmic_trading_CO3-1" id="co_python_and_algorithmic_trading_CO3-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>        </code><code class="n">plt</code><code class="o">.</code><code class="n">style</code><code class="o">.</code><code class="n">use</code><code class="p">(</code><code class="s1">'</code><code class="s1">seaborn</code><code class="s1">'</code><code class="p">)</code><code>  </code><a class="co" href="#callout_python_and_algorithmic_trading_CO3-1" id="co_python_and_algorithmic_trading_CO3-2"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>        </code><code class="n">mpl</code><code class="o">.</code><code class="n">rcParams</code><code class="p">[</code><code class="s1">'</code><code class="s1">savefig.dpi</code><code class="s1">'</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="mi">300</code><code>  </code><a class="co" href="#callout_python_and_algorithmic_trading_CO3-1" id="co_python_and_algorithmic_trading_CO3-3"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>        </code><code class="n">mpl</code><code class="o">.</code><code class="n">rcParams</code><code class="p">[</code><code class="s1">'</code><code class="s1">font.family</code><code class="s1">'</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="s1">'</code><code class="s1">serif</code><code class="s1">'</code><code>  </code><a class="co" href="#callout_python_and_algorithmic_trading_CO3-1" id="co_python_and_algorithmic_trading_CO3-4"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>&#13;
</code><code class="n">In</code><code> </code><code class="p">[</code><code class="mi">4</code><code class="p">]</code><code class="p">:</code><code> </code><code class="kn">import</code><code> </code><code class="nn">configparser</code><code>  </code><a class="co" href="#callout_python_and_algorithmic_trading_CO3-2" id="co_python_and_algorithmic_trading_CO3-5"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>        </code><code class="n">c</code><code> </code><code class="o">=</code><code> </code><code class="n">configparser</code><code class="o">.</code><code class="n">ConfigParser</code><code class="p">(</code><code class="p">)</code><code>  </code><a class="co" href="#callout_python_and_algorithmic_trading_CO3-2" id="co_python_and_algorithmic_trading_CO3-6"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>        </code><code class="n">c</code><code class="o">.</code><code class="n">read</code><code class="p">(</code><code class="s1">'</code><code class="s1">../pyalgo.cfg</code><code class="s1">'</code><code class="p">)</code><code>  </code><a class="co" href="#callout_python_and_algorithmic_trading_CO3-2" id="co_python_and_algorithmic_trading_CO3-7"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code class="n">Out</code><code class="p">[</code><code class="mi">4</code><code class="p">]</code><code class="p">:</code><code> </code><code class="p">[</code><code class="s1">'</code><code class="s1">../pyalgo.cfg</code><code class="s1">'</code><code class="p">]</code><code>&#13;
</code><code>&#13;
</code><code class="n">In</code><code> </code><code class="p">[</code><code class="mi">5</code><code class="p">]</code><code class="p">:</code><code> </code><code class="kn">import</code><code> </code><code class="nn">quandl</code><code> </code><code class="kn">as</code><code> </code><code class="nn">q</code><code>  </code><a class="co" href="#callout_python_and_algorithmic_trading_CO3-3" id="co_python_and_algorithmic_trading_CO3-8"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code>        </code><code class="n">q</code><code class="o">.</code><code class="n">ApiConfig</code><code class="o">.</code><code class="n">api_key</code><code> </code><code class="o">=</code><code> </code><code class="n">c</code><code class="p">[</code><code class="s1">'</code><code class="s1">quandl</code><code class="s1">'</code><code class="p">]</code><code class="p">[</code><code class="s1">'</code><code class="s1">api_key</code><code class="s1">'</code><code class="p">]</code><code>  </code><a class="co" href="#callout_python_and_algorithmic_trading_CO3-3" id="co_python_and_algorithmic_trading_CO3-9"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code>        </code><code class="n">d</code><code> </code><code class="o">=</code><code> </code><code class="n">q</code><code class="o">.</code><code class="n">get</code><code class="p">(</code><code class="s1">'</code><code class="s1">BCHAIN/MKPRU</code><code class="s1">'</code><code class="p">)</code><code>  </code><a class="co" href="#callout_python_and_algorithmic_trading_CO3-4" id="co_python_and_algorithmic_trading_CO3-10"><img alt="4" src="assets/4.png"/></a><code>&#13;
</code><code>        </code><code class="n">d</code><code class="p">[</code><code class="s1">'</code><code class="s1">SMA</code><code class="s1">'</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="n">d</code><code class="p">[</code><code class="s1">'</code><code class="s1">Value</code><code class="s1">'</code><code class="p">]</code><code class="o">.</code><code class="n">rolling</code><code class="p">(</code><code class="mi">100</code><code class="p">)</code><code class="o">.</code><code class="n">mean</code><code class="p">(</code><code class="p">)</code><code>  </code><a class="co" href="#callout_python_and_algorithmic_trading_CO3-5" id="co_python_and_algorithmic_trading_CO3-11"><img alt="5" src="assets/5.png"/></a><code>&#13;
</code><code>        </code><code class="n">d</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="s1">'</code><code class="s1">2013-1-1</code><code class="s1">'</code><code class="p">:</code><code class="p">]</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="n">title</code><code class="o">=</code><code class="s1">'</code><code class="s1">BTC/USD exchange rate</code><code class="s1">'</code><code class="p">,</code><code>&#13;
</code><code>                                </code><code class="n">figsize</code><code class="o">=</code><code class="p">(</code><code class="mi">10</code><code class="p">,</code><code> </code><code class="mi">6</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code>  </code><a class="co" href="#callout_python_and_algorithmic_trading_CO3-6" id="co_python_and_algorithmic_trading_CO3-12"><img alt="6" src="assets/6.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_python_and_algorithmic_trading_CO3-1" id="callout_python_and_algorithmic_trading_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Imports and configures the plotting package.</p></dd>&#13;
<dt><a class="co" href="#co_python_and_algorithmic_trading_CO3-5" id="callout_python_and_algorithmic_trading_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Imports the <code>configparser</code> module and reads credentials.</p></dd>&#13;
<dt><a class="co" href="#co_python_and_algorithmic_trading_CO3-8" id="callout_python_and_algorithmic_trading_CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Imports the Quandl Python wrapper package and provides the API key.</p></dd>&#13;
<dt><a class="co" href="#co_python_and_algorithmic_trading_CO3-10" id="callout_python_and_algorithmic_trading_CO3-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Retrieves daily data for the Bitcoin exchange rate and returns a <code>pandas</code> <code>DataFrame</code> object with a single column.</p></dd>&#13;
<dt><a class="co" href="#co_python_and_algorithmic_trading_CO3-11" id="callout_python_and_algorithmic_trading_CO3-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Calculates the SMA for 100 days in vectorized fashion.</p></dd>&#13;
<dt><a class="co" href="#co_python_and_algorithmic_trading_CO3-12" id="callout_python_and_algorithmic_trading_CO3-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Selects data from the 1st of January 2013 on and plots it.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Obviously, <code>NumPy</code> and <code>pandas</code> measurably contribute to the success of Python in finance. However, the Python ecosystem has much more to offer in the form of additional Python packages that solve rather fundamental problems and sometimes specialized ones. This book will make use of packages for data retrieval and storage (for example, <code>PyTables</code>, <code>TsTables</code>, <code>SQLite</code>) and for machine and deep learning (for example, <code>scikit-learn</code>, <code>TensorFlow</code>), to name just two categories. Along the way, we will also implement classes and modules that will make any algorithmic trading project more efficient. However, the main packages used throughout will be <code>NumPy</code> and &#13;
<span class="keep-together"><code>pandas</code>.</span></p>&#13;
&#13;
<figure><div class="figure" id="bitcoin_xr">&#13;
<img alt="pfat 0101" src="assets/pfat_0101.png"/>&#13;
<h6><span class="label">Figure 1-1. </span>Historical Bitcoin exchange rate in USD from the beginning of 2013 until mid-2020</h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note">&#13;
<p>While <code>NumPy</code> provides the basic data structure to store numerical data and work with it, <code>pandas</code> brings powerful time series management capabilities to the table. It also does a great job of wrapping functionality from other packages into an easy-to-use API. The Bitcoin example just described shows that a single method call on a <code>DataFrame</code> object is enough to generate a plot with two financial time series visualized. Like <code>NumPy</code>, <code>pandas</code> allows for rather concise, vectorized code that is also generally executed quite fast due to heavy use of compiled code under the hood.<a data-startref="ix_01_python_algorithmic_trading_-asciidoc5" data-type="indexterm" id="idm45785397484088"/><a data-startref="ix_01_python_algorithmic_trading_-asciidoc4" data-type="indexterm" id="idm45785397483352"/><a data-startref="ix_01_python_algorithmic_trading_-asciidoc3" data-type="indexterm" id="idm45785397482648"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Algorithmic Trading" data-type="sect1"><div class="sect1" id="idm45785397481816">&#13;
<h1>Algorithmic Trading</h1>&#13;
&#13;
<p><a data-primary="algorithmic trading (generally)" data-secondary="basics" data-type="indexterm" id="ix_01_python_algorithmic_trading_-asciidoc6"/>The term <em>algorithmic trading</em> is neither uniquely nor universally defined. On a rather basic level, it refers to the trading of financial instruments based on some formal algorithm. An <em>algorithm</em> is a set of operations (mathematical, technical) to be conducted in a certain sequence to achieve a certain goal. For example, there are mathematical algorithms to solve a Rubik’s Cube.<sup><a data-type="noteref" href="ch01.html#idm45785397477592" id="idm45785397477592-marker">4</a></sup> Such an algorithm can solve the problem at hand via a step-by-step procedure, often perfectly. Another example is algorithms for finding the root(s) of an equation if it (they) exist(s) at all. In that sense, the objective of a mathematical algorithm is often well specified and an optimal solution is often expected.</p>&#13;
&#13;
<p>But what about the objective of financial trading algorithms? This question is not that easy to answer in general. It might help to step back for a moment and consider general motives for trading. In Dorn et al. (2008) write:</p>&#13;
<blockquote>&#13;
<p>Trading in financial markets is an important economic activity. Trades are necessary to get into and out of the market, to put unneeded cash into the market, and to convert back into cash when the money is wanted. They are also needed to move money around within the market, to exchange one asset&#13;
for another, to manage risk, and to exploit information about&#13;
future price movements.</p></blockquote>&#13;
&#13;
<p>The view expressed here is more technical than economic in nature, focusing mainly on the process itself and only partly on why people initiate trades in the first place. <a data-primary="motives, for trading" data-type="indexterm" id="idm45785397472984"/><a data-primary="trading, motives for" data-type="indexterm" id="idm45785397472280"/>For our purposes, a nonexhaustive list of financial trading motives of people and financial institutions managing money of their own or for others includes the &#13;
<span class="keep-together">following:</span></p>&#13;
<dl>&#13;
<dt>Beta trading</dt>&#13;
<dd>&#13;
<p><a data-primary="S&amp;P 500" data-type="indexterm" id="ix_01_python_algorithmic_trading_-asciidoc7"/>Earning market risk premia by investing in, for instance, exchange traded funds (ETFs) that replicate the performance of the S&amp;P 500.</p>&#13;
</dd>&#13;
<dt>Alpha generation</dt>&#13;
<dd>&#13;
<p>Earning risk premia independent of the market by, for example, selling short stocks listed in the S&amp;P 500 or ETFs on the S&amp;P 500.</p>&#13;
</dd>&#13;
<dt>Static hedging</dt>&#13;
<dd>&#13;
<p>Hedging against market risks by buying, for example, out-of-the-money put options on the S&amp;P 500.</p>&#13;
</dd>&#13;
<dt>Dynamic hedging</dt>&#13;
<dd>&#13;
<p>Hedging against market risks affecting options on the S&amp;P 500 by, for example, dynamically trading futures on the S&amp;P 500 and appropriate cash, money market, or rate instruments.</p>&#13;
</dd>&#13;
<dt>Asset-liability management</dt>&#13;
<dd>&#13;
<p>Trading S&amp;P 500 stocks and ETFs to be able to cover liabilities resulting from, for example, writing life insurance policies.</p>&#13;
</dd>&#13;
<dt>Market making</dt>&#13;
<dd>&#13;
<p>Providing, for example, liquidity to options on the S&amp;P 500 by buying and selling options at different bid and ask prices.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>All these types of trades can be implemented by a discretionary approach, &#13;
<span class="keep-together">with human</span> traders making decisions mainly on their own, as well as based on algorithms supporting the human trader or even replacing them completely in the &#13;
<span class="keep-together">decision-making</span> process. In this context, computerization of financial trading of course plays an important role. While in the beginning of financial trading, floor trading with a large group of people shouting at each other (“open outcry”) was the only way of executing trades, computerization and the advent of the internet and web technologies have revolutionized trading in the financial industry. The quotation at the beginning of this chapter illustrates this impressively in terms of the number of people actively engaged in trading shares at <a data-primary="Goldman Sachs" data-type="indexterm" id="idm45785397458024"/>Goldman Sachs in 2000 and in 2016. It is a trend that was foreseen 25 years ago, as Solomon and Corso (1991) point out:</p>&#13;
<blockquote>&#13;
<p>Computers have revolutionized the trading of securities and the stock market is currently in the midst of a dynamic transformation. It is clear that the market of the future will not resemble the markets of the past.</p>&#13;
&#13;
<p>Technology has made it possible for information regarding stock prices to be sent all over the world in seconds. Presently, computers route orders and execute small trades directly from the brokerage firm’s terminal to the exchange. Computers now link together various stock exchanges, a practice which is helping to create a single global market for the trading of securities. The continuing improvements in technology will make it possible to execute trades globally by electronic trading systems.</p></blockquote>&#13;
&#13;
<p><a data-primary="dynamic hedging" data-type="indexterm" id="idm45785397454936"/>Interestingly, one of the oldest and most widely used algorithms is found in dynamic hedging of options. <a data-primary="delta hedging" data-type="indexterm" id="idm45785397453976"/>Already with the publication of the seminal papers about the pricing of European options by Black and Scholes (1973) and Merton (1973), the algorithm, called <em>delta hedging</em>, was made available long before computerized and electronic trading even started. Delta hedging as a trading algorithm shows how to hedge away all market risks in a simplified, perfect, continuous model world. In the real world, with transaction costs, discrete trading, imperfectly liquid markets, and other frictions (“imperfections”), the algorithm has proven, somewhat surprisingly maybe, its usefulness and robustness, as well. It might not allow one to perfectly hedge away market risks affecting options, but it is useful in getting close to the ideal and is therefore still used on a large scale in the financial industry.<sup><a data-type="noteref" href="ch01.html#idm45785397451960" id="idm45785397451960-marker">5</a></sup></p>&#13;
&#13;
<p><a data-primary="alpha, defined" data-type="indexterm" id="idm45785397451016"/>This book focuses on algorithmic trading in the context of <em>alpha generating strategies</em>. Although there are more sophisticated definitions for alpha, for the purposes of this book, alpha is seen as the difference between a trading strategy’s return over some period of time and the return of the benchmark (single stock, index, cryptocurrency, etc.). For example, if the S&amp;P 500 returns 10% in 2018 and an algorithmic strategy returns 12%, then alpha is +2% points. If the strategy returns 7%, then alpha is -3% points. In general, such numbers are not adjusted for risk, and other risk characteristics, such as maximal drawdown (period), are usually considered to be of second order importance, if at all.</p>&#13;
<div data-type="note" epub:type="note">&#13;
<p>This book focuses on alpha-generating strategies, or strategies that try to generate positive returns (above a benchmark) independent of the market’s performance. Alpha is defined in this book (in the simplest way) as the excess return of a strategy over the benchmark financial instrument’s performance.</p>&#13;
</div>&#13;
&#13;
<p><a data-primary="high frequency trading (HFQ)" data-type="indexterm" id="idm45785397447448"/>There are other areas where trading-related algorithms play an important role. One is the <em>high frequency trading</em> (HFT) space, where speed is typically the discipline in which players compete.<sup><a data-type="noteref" href="ch01.html#idm45785397446152" id="idm45785397446152-marker">6</a></sup> The motives for HFT are diverse, but market making and alpha generation probably play a prominent role. Another one is <em>trade execution</em>, where algorithms are deployed to optimally execute certain nonstandard trades. Motives in this area might include the execution (at best possible prices) of large orders or the execution of an order with as little market and price impact as possible. A more subtle motive might be to disguise an order by executing it on a number of different exchanges.</p>&#13;
&#13;
<p><a data-primary="algorithmic trading (generally)" data-secondary="advantages of" data-type="indexterm" id="idm45785397444280"/>An important question remains to be addressed: is there any advantage to using algorithms for trading instead of human research, experience, and discretion? This question can hardly be answered in any generality. For sure, there are human traders and portfolio managers who have earned, on average, more than their benchmark for investors over longer periods of time. The paramount example in this regard is Warren Buffett. On the other hand, statistical analyses show that the majority of active portfolio managers rarely beat relevant benchmarks consistently.&#13;
Referring to the year 2015, Adam Shell writes:</p>&#13;
<blockquote>&#13;
<p>Last year, for example, when the Standard &amp; Poor’s 500-stock index posted a paltry total return of 1.4% with dividends included, 66% of “actively managed” large-company stock funds posted smaller returns than the index…The longer-term outlook is just as gloomy, with 84% of large-cap funds generating lower returns than the S&amp;P 500 in the latest five year period and 82% falling shy in the past 10 years, the study found.<sup><a data-type="noteref" href="ch01.html#idm45785397441432" id="idm45785397441432-marker">7</a></sup></p></blockquote>&#13;
&#13;
<p>In an empirical study published in December 2016, Harvey et al. write:</p>&#13;
<blockquote>&#13;
<p>We analyze and contrast the performance of discretionary and systematic hedge funds. Systematic funds use strategies that are rules‐based, with little or no daily intervention by humans….We find that, for the period 1996‐2014, systematic equity managers underperform their discretionary counterparts in terms of unadjusted (raw) returns, but that after adjusting for exposures to well‐known risk factors, the risk‐adjusted performance is similar. In the case of macro, systematic funds outperform discretionary funds, both on an unadjusted and risk‐adjusted basis.</p></blockquote>&#13;
&#13;
<p><a data-type="xref" href="#hedge_fund_performance">Table 1-0</a> reproduces the major quantitative findings of the study by Harvey et al. (2016).<sup><a data-type="noteref" href="ch01.html#idm45785397437656" id="idm45785397437656-marker">8</a></sup> In the table, <em>factors</em> include traditional ones (equity, bonds, etc.), dynamic ones (value, momentum, etc.), and volatility (buying at-the-money puts and calls). <a data-primary="adjusted return appraisal ratio" data-type="indexterm" id="idm45785397436216"/>The <em>adjusted return appraisal ratio</em> divides alpha by the adjusted return volatility. For more details and background, see the original study.</p>&#13;
&#13;
<p><a data-primary="macro hedge funds, algorithmic trading and" data-type="indexterm" id="idm45785397434616"/><a data-primary="systematic macro hedge funds" data-type="indexterm" id="idm45785397433880"/>The study’s results illustrate that systematic (“algorithmic”) macro hedge funds perform best as a category, both in unadjusted and risk-adjusted terms. They generate an annualized alpha of 4.85% points over the period studied. These are hedge funds implementing strategies that are typically global, are cross-asset, and often involve political and macroeconomic elements. Systematic equity hedge funds only beat their discretionary counterparts on the basis of the adjusted return appraisal ratio (0.35 versus 0.25).</p>&#13;
<table class="border" id="hedge_fund_performance">&#13;
<thead>&#13;
<tr>&#13;
  <th><p> </p></th>&#13;
  <th><p>Systematic macro</p></th>&#13;
  <th><p>Discretionary macro</p></th>&#13;
  <th><p>Systematic equity</p></th>&#13;
  <th><p>Discretionary equity</p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
  <th><p>Return average</p></th>&#13;
  <td>5.01%</td><td>2.86%</td><td>2.88%</td><td>4.09%</td>&#13;
</tr>&#13;
<tr>&#13;
  <th><p>Return attributed to factors</p></th>&#13;
  <td>0.15%</td><td>1.28%</td><td>1.77%</td><td>2.86%</td>&#13;
</tr>&#13;
<tr>&#13;
  <th><p>Adj. return average (alpha) </p></th>&#13;
  <td>4.85%</td><td>1.57%</td><td>1.11%</td><td>1.22%</td>&#13;
</tr>&#13;
<tr>&#13;
  <th><p>Adj. return volatility</p></th>&#13;
  <td>0.93%</td><td>5.10%</td><td>3.18%</td><td>4.79%</td>&#13;
</tr>&#13;
<tr>&#13;
  <th><p>Adj. return appraisal ratio </p></th>&#13;
  <td>0.44 </td><td>0.31 </td><td>0.35 </td><td>0.25</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Compared to the S&amp;P 500, hedge fund performance overall was quite meager for the year 2017. While the S&amp;P 500 index returned 21.8%, hedge funds only returned 8.5% to investors (see this <a href="https://oreil.ly/N59Hf">article</a> in <em>Investopedia</em>). This illustrates how hard it is, even with multimillion dollar budgets for research and technology, to generate alpha<a data-startref="ix_01_python_algorithmic_trading_-asciidoc7" data-type="indexterm" id="idm45785397413704"/>.<a data-startref="ix_01_python_algorithmic_trading_-asciidoc6" data-type="indexterm" id="idm45785397412840"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Python for Algorithmic Trading" data-type="sect1"><div class="sect1" id="idm45785397480984">&#13;
<h1>Python for Algorithmic Trading</h1>&#13;
&#13;
<p><a data-primary="Python (generally)" data-secondary="advantages of" data-type="indexterm" id="idm45785397411368"/>Python is used in many corners of the financial industry but has become particularly popular in the algorithmic trading space. There are a few good reasons for this:</p>&#13;
<dl>&#13;
<dt>Data analytics capabilities</dt>&#13;
<dd>&#13;
<p>A major requirement for every algorithmic trading project is the ability to manage and process financial data efficiently. Python, in combination with packages like <code>NumPy</code> and <code>pandas</code>, makes life easier in this regard for every algorithmic trader than most other programming languages do.</p>&#13;
</dd>&#13;
<dt>Handling of modern APIs</dt>&#13;
<dd>&#13;
<p>Modern online trading platforms like the ones from <a href="http://fxcm.co.uk">FXCM</a> and <a href="http://oanda.com">Oanda</a> offer RESTful application programming interfaces (APIs) and socket (streaming) APIs to access historical and live data. Python is in general well suited to efficiently interact with such APIs.</p>&#13;
</dd>&#13;
<dt>Dedicated packages</dt>&#13;
<dd>&#13;
<p>In addition to the standard data analytics packages, there are multiple packages available that are dedicated to the algorithmic trading space, such as <a href="https://oreil.ly/IpIt1"><code>PyAlgoTrade</code></a> and <a href="https://oreil.ly/2cSKR"><code>Zipline</code></a> for the backtesting of trading strategies and <a href="https://oreil.ly/KT7V8"><code>Pyfolio</code></a> for performing portfolio and risk analysis.</p>&#13;
</dd>&#13;
<dt>Vendor sponsored packages</dt>&#13;
<dd>&#13;
<p>More and more vendors in the space release open source Python packages to facilitate access to their offerings. Among them are online trading platforms like Oanda, as well as the leading data providers like <a href="https://oreil.ly/oSxei">Bloomberg</a> and <a href="https://oreil.ly/1SNBN">Refinitiv</a>.</p>&#13;
</dd>&#13;
<dt>Dedicated platforms</dt>&#13;
<dd>&#13;
<p><a href="http://quantopian.com">Quantopian</a>, for example, offers a standardized backtesting environment as a Web-based platform where the language of choice is Python and where people can exchange ideas with like-minded others via different social network features. From its founding until 2020, Quantopian has attracted more than 300,000 users.</p>&#13;
</dd>&#13;
<dt>Buy- and sell-side adoption</dt>&#13;
<dd>&#13;
<p>More and more institutional players have adopted Python to streamline development efforts in their trading departments. This, in turn, requires more and more staff proficient in Python, which makes learning Python a worthwhile &#13;
<span class="keep-together">investment.</span></p>&#13;
</dd>&#13;
<dt>Education, training, and books</dt>&#13;
<dd>&#13;
<p>Prerequisites for the widespread adoption of a technology or programming language are academic and professional education and training programs in combination with specialized books and other resources. The Python ecosystem has seen a tremendous growth in such offerings recently, educating and training more and more people in the use of Python for finance. This can be expected to reinforce the trend of Python adoption in the algorithmic trading space.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>In summary, it is rather safe to say that Python plays an important role in algorithmic trading already and seems to have strong momentum to become even more important in the future. It is therefore a good choice for anyone trying to enter the space, be it as an ambitious “retail” trader or as a professional employed by a leading financial institution engaged in systematic trading.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Focus and Prerequisites" data-type="sect1"><div class="sect1" id="idm45785393697560">&#13;
<h1>Focus and Prerequisites</h1>&#13;
&#13;
<p>The focus of this book is on Python as a programming language for algorithmic trading. The book assumes that the reader already has some experience with Python and popular Python packages used for data analytics. Good introductory books are, for example, Hilpisch (2018), McKinney (2017), and VanderPlas (2016), which all can be consulted to build a solid foundation in Python for data analysis and finance. The reader is also expected to have some experience with typical tools used for interactive analytics with Python, such as <code>IPython</code>, to which VanderPlas (2016) also provides an introduction.</p>&#13;
&#13;
<p>This book presents and explains Python code that is applied to the topics at hand, like backtesting trading strategies or working with streaming data. It cannot provide a thorough introduction to all packages used in different places. It tries, however, to highlight those capabilities of the packages that are central to the exposition (such as vectorization with <code>NumPy</code>).</p>&#13;
&#13;
<p>The book also cannot provide a thorough introduction and overview of all financial and operational aspects relevant for algorithmic trading. The approach instead focuses on the use of Python to build the necessary infrastructure for automated algorithmic trading systems. Of course, the majority of examples used are taken from the algorithmic trading space. However, when dealing with, say, momentum or mean-reversion strategies, they are more or less simply used without providing (statistical) verification or an in-depth discussion of their intricacies. Whenever it seems appropriate, references are given that point the reader to sources that address issues left open during the exposition.</p>&#13;
&#13;
<p>All in all, this book is written for readers who have some experience with both Python and (algorithmic) trading. For such a reader, the book is a practical guide to the creation of automated trading systems using Python and additional packages.</p>&#13;
<div data-type="caution">&#13;
<p>This book uses a number of Python programming approaches (for example, object oriented programming) and packages (for example, <code>scikit-learn</code>) that cannot be explained in detail. The focus is on applying these approaches and packages to different steps in an algorithmic trading process. It is therefore recommended that those who do not yet have enough Python (for finance) experience additionally consult more introductory Python texts.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Trading Strategies" data-type="sect1"><div class="sect1" id="trading_strategies">&#13;
<h1>Trading Strategies</h1>&#13;
&#13;
<p><a data-primary="algorithmic trading (generally)" data-secondary="strategies" data-type="indexterm" id="ix_01_python_algorithmic_trading_-asciidoc8"/><a data-primary="trading strategies" data-seealso="specific strategies" data-type="indexterm" id="ix_01_python_algorithmic_trading_-asciidoc9"/>Throughout this book, four different algorithmic trading strategies are used as examples. They are introduced briefly in the following sections and in some more detail &#13;
<span class="keep-together">in <a data-type="xref" href="ch04.html#vectorized_backtesting">Chapter 4</a>.</span> All these trading strategies can be classified as mainly <a data-primary="alpha seeking strategies" data-type="indexterm" id="idm45785393683672"/><em>alpha seeking</em> &#13;
<span class="keep-together"><em>strategies</em>,</span> since their main objective is to generate positive, above-market returns independent of the market direction. Canonical examples throughout the book, when it comes to financial instruments traded, are a <em>stock index</em>, a <em>single stock</em>, or a <em>cryptocurrency</em> (denominated in a fiat currency). The book does not cover strategies involving multiple financial instruments at the same time (pair trading strategies, strategies based on baskets, etc.). It also covers only strategies whose trading signals are derived from structured, financial time series data and not, for instance, from unstructured data sources like news or social media feeds. This keeps the discussions and the Python implementations concise and easier to understand, in line with the approach (discussed earlier) of focusing on Python for algorithmic trading.<sup><a data-type="noteref" href="ch01.html#idm45785393679512" id="idm45785393679512-marker">9</a></sup></p>&#13;
&#13;
<p>The remainder of this chapter gives a quick overview of the four trading strategies used in this book.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Simple Moving Averages" data-type="sect2"><div class="sect2" id="idm45785393678168">&#13;
<h2>Simple Moving Averages</h2>&#13;
&#13;
<p><a data-primary="simple moving averages (SMAs)" data-type="indexterm" id="idm45785393676968"/><a data-primary="trading strategies" data-secondary="simple moving averages" data-type="indexterm" id="idm45785393676296"/>The first type of trading strategy relies on simple moving averages (SMAs) to generate trading signals and market positionings. These trading strategies have been popularized by so-called technical analysts or chartists. The basic idea is that a shorter-term SMA being higher in value than a longer term SMA signals a long market position and the opposite scenario signals a neutral or short market position.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Momentum" data-type="sect2"><div class="sect2" id="idm45785393674536">&#13;
<h2>Momentum</h2>&#13;
&#13;
<p><a data-primary="momentum strategies" data-type="indexterm" id="idm45785393673368"/><a data-primary="trading strategies" data-secondary="momentum" data-type="indexterm" id="idm45785393672664"/>The basic idea behind momentum strategies is that a financial instrument is assumed to perform in accordance with its recent performance for some additional time. For example, when a stock index has seen a negative return on average over the last five days, it is assumed that its performance will be negative tomorrow, as well.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Mean Reversion" data-type="sect2"><div class="sect2" id="idm45785393670984">&#13;
<h2>Mean Reversion</h2>&#13;
&#13;
<p>In mean-reversion strategies, a financial instrument is assumed to revert to some mean or trend level if it is currently far enough away from such a level. For example, assume that a stock trades 10 USD under its 200 days SMA level of 100. It is then expected that the stock price will return to its SMA level sometime soon.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before" data-pdf-bookmark="Machine and Deep Learning" data-type="sect2"><div class="sect2" id="idm45785393669096">&#13;
<h2>Machine and Deep Learning</h2>&#13;
&#13;
<p><a data-primary="deep learning" data-secondary="trading strategies and" data-type="indexterm" id="idm45785393667656"/><a data-primary="machine learning" data-secondary="trading strategies and" data-type="indexterm" id="idm45785393666680"/><a data-primary="trading strategies" data-secondary="machine learning/deep learning" data-type="indexterm" id="idm45785393665736"/>With machine and deep learning algorithms, one generally takes a more black box approach to predicting market movements. For simplicity and reproducibility, the examples in this book mainly rely on historical return observations as features to train machine and deep learning algorithms to predict stock market movements.</p>&#13;
<div data-type="caution">&#13;
<p>This book does not introduce algorithmic trading in a systematic fashion. Since the focus lies on applying Python in this fascinating field, readers not familiar with algorithmic trading should consult dedicated resources on the topic, some of which are cited in this chapter and the chapters that follow. But be aware of the fact that the algorithmic trading world in general is secretive and that almost everyone who is successful is naturally reluctant to share their secrets in order to protect their sources of success (that is, their alpha).</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Conclusions" data-type="sect1"><div class="sect1" id="idm45785393662440">&#13;
<h1>Conclusions</h1>&#13;
&#13;
<p>Python is already a force in finance in general and is on its way to becoming a major force in algorithmic trading. There are a number of good reasons to use Python for algorithmic trading, among them the powerful ecosystem of packages that allows for efficient data analysis or the handling of modern APIs. There are also a number of good reasons to learn Python for algorithmic trading, chief among them the fact that some of the biggest buy- and sell-side institutions make heavy use of Python in their trading operations and constantly look for seasoned Python professionals.</p>&#13;
&#13;
<p>This book focuses on applying Python to the different disciplines in algorithmic trading, like backtesting trading strategies or interacting with online trading platforms. It cannot replace a thorough introduction to Python itself nor to trading in general. However, it systematically combines these two fascinating worlds to provide a valuable source for the generation of alpha in today’s competitive financial and cryptocurrency markets.<a data-startref="ix_01_python_algorithmic_trading_-asciidoc9" data-type="indexterm" id="idm45785393659416"/><a data-startref="ix_01_python_algorithmic_trading_-asciidoc8" data-type="indexterm" id="idm45785393658680"/><a data-primary="backtesting" data-secondary="vectorized" data-see="vectorized backtesting" data-type="indexterm" id="idm45785393657976"/><a data-primary="bar plots" data-see="Plotly; streaming bar plot" data-type="indexterm" id="idm45785393656760"/><a data-primary="comma separated value (CSV) files" data-see="CSV files" data-type="indexterm" id="idm45785393655848"/><a data-primary="containers" data-see="Docker containers" data-type="indexterm" id="idm45785393654936"/><a data-primary="contracts for difference" data-see="CFD" data-type="indexterm" id="idm45785393653992"/><a data-primary="foreign exchange trading" data-see="FX trading; FXCM" data-type="indexterm" id="idm45785393653080"/><a data-primary="infrastructure" data-see="Python infrastructure" data-type="indexterm" id="idm45785393652168"/><a data-primary="storage" data-see="data storage" data-type="indexterm" id="idm45785393651224"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="References and Further Resources" data-type="sect1"><div class="sect1" id="idm45785393650152">&#13;
<h1>References and Further Resources</h1>&#13;
&#13;
<p>Books and papers cited in this chapter:</p>&#13;
&#13;
<ul class="author-date-bib">&#13;
<li>&#13;
<p>Black, Fischer, and Myron Scholes. 1973. “The Pricing of Options and Corporate Liabilities.” <em>Journal of Political Economy</em> 81 (3): 638-659.</p>&#13;
</li>&#13;
<li>&#13;
<p>Chan, Ernest. 2013. <em>Algorithmic Trading: Winning Strategies and Their Rationale</em>. Hoboken et al: John Wiley &amp; Sons.</p>&#13;
</li>&#13;
<li>&#13;
<p>Dorn, Anne, Daniel Dorn, and Paul Sengmueller. 2008. “Why Do People Trade?” <em>Journal of Applied Finance</em> (Fall/Winter): 37-50.</p>&#13;
</li>&#13;
<li>&#13;
<p>Harvey, Campbell, Sandy Rattray, Andrew Sinclair, and Otto Van Hemert. 2016. “Man vs. Machine: Comparing Discretionary and Systematic Hedge Fund Performance.” <em>The Journal of Portfolio Management</em> White Paper, Man Group.</p>&#13;
</li>&#13;
<li>&#13;
<p>Hilpisch, Yves. 2015. <em>Derivatives Analytics with Python: Data Analysis, Models, Simulation, Calibration and Hedging</em>. Wiley Finance. Resources under <a href="http://dawp.tpq.io"><em class="hyperlink">http://dawp.tpq.io</em></a>.</p>&#13;
</li>&#13;
<li>&#13;
<p>⸻. 2018. <em>Python for Finance: Mastering Data-Driven Finance</em>. 2nd ed. Sebastopol: O’Reilly. Resources under <a href="https://py4fi.pqp.io"><em class="hyperlink">https://py4fi.pqp.io</em></a>.</p>&#13;
</li>&#13;
<li>&#13;
<p>⸻. 2020. <em>Artificial Intelligence in Finance: A Python-Based Guide</em>. Sebastopol: O’Reilly. Resources under <a href="https://aiif.pqp.io"><em class="hyperlink">https://aiif.pqp.io</em></a>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Kissel, Robert. 2013. <em>The Science of Algorithmic Trading and Portfolio Management</em>. Amsterdam et al: Elsevier/Academic Press.</p>&#13;
</li>&#13;
<li>&#13;
<p>Lewis, Michael. 2015. <em>Flash Boys: Cracking the Money Code</em>. New York, London: W.W. Norton &amp; Company.</p>&#13;
</li>&#13;
<li>&#13;
<p>McKinney, Wes. 2017. <em>Python for Data Analysis: Data Wrangling with Pandas, NumPy, and IPython</em>. 2nd ed. Sebastopol: O’Reilly.</p>&#13;
</li>&#13;
<li>&#13;
<p>Merton, Robert. 1973. “Theory of Rational Option Pricing.” <em>Bell Journal of Economics and Management Science</em> 4: 141-183.</p>&#13;
</li>&#13;
<li>&#13;
<p>Narang, Rishi. 2013. <em>Inside the Black Box: A Simple Guide to Quantitative and High Frequency Trading</em>. Hoboken et al: John Wiley &amp; Sons.</p>&#13;
</li>&#13;
<li>&#13;
<p>Solomon, Lewis, and Louise Corso. 1991. “The Impact of Technology on the Trading of Securities: The Emerging Global Market and the Implications for Regulation.” <em>The John Marshall Law Review</em> 24 (2): 299-338.</p>&#13;
</li>&#13;
<li>&#13;
<p>VanderPlas, Jake. 2016. <em>Python Data Science Handbook: Essential Tools for Working with Data</em>. Sebastopol: O’Reilly.<a data-startref="ix_01_python_algorithmic_trading_-asciidoc0" data-type="indexterm" id="idm45785393625752"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45785394843768"><sup><a href="ch01.html#idm45785394843768-marker">1</a></sup> “Too Squid to Fail.” <em>The Economist</em>, 29. October 2016.</p><p data-type="footnote" id="idm45785394872712"><sup><a href="ch01.html#idm45785394872712-marker">2</a></sup> For details, see Hilpisch (2018, ch. 12).</p><p data-type="footnote" id="idm45785393485592"><sup><a href="ch01.html#idm45785393485592-marker">3</a></sup> For example, <code>list</code> objects are not only mutable, which means that they can be changed in size, but they can also contain almost any other kind of Python object, like <code>int</code>, <code>float</code>, <code>tuple</code> objects or <code>list</code> objects themselves.</p><p data-type="footnote" id="idm45785397477592"><sup><a href="ch01.html#idm45785397477592-marker">4</a></sup> See <a href="https://oreil.ly/16pIA">The Mathematics of the Rubik’s Cube</a> or <a href="https://oreil.ly/XM0ZP">Algorithms for Solving Rubik’s Cube.</a></p><p data-type="footnote" id="idm45785397451960"><sup><a href="ch01.html#idm45785397451960-marker">5</a></sup> See Hilpisch (2015) for a detailed analysis of delta hedging strategies for European and American options using Python.</p><p data-type="footnote" id="idm45785397446152"><sup><a href="ch01.html#idm45785397446152-marker">6</a></sup> See the book by Lewis (2015) for a non-technical introduction to HFT.</p><p data-type="footnote" id="idm45785397441432"><sup><a href="ch01.html#idm45785397441432-marker">7</a></sup> Source: “66% of Fund Managers Can’t Match S&amp;P Results.” <em>USA Today</em>, March 14, 2016.</p><p data-type="footnote" id="idm45785397437656"><sup><a href="ch01.html#idm45785397437656-marker">8</a></sup> Annualized performance (above the short-term interest rate) and risk measures for hedge fund categories comprising a total of 9,000 hedge funds over the period from June 1996 to December 2014.</p><p data-type="footnote" id="idm45785393679512"><sup><a href="ch01.html#idm45785393679512-marker">9</a></sup> See the book by Kissel (2013) for an overview of topics related to algorithmic trading, the book by Chan (2013) for an in-depth discussion of momentum and mean-reversion strategies, or the book by Narang (2013) for a coverage of quantitative and HFT trading in general.</p></div></div></section></body></html>