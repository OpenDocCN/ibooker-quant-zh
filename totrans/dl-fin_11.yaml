- en: Chapter 11\. Advanced Techniques and Strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you should have a solid understanding of deep learning algorithms and
    how to develop a model to predict time series data. Even though this is just a
    first step toward deploying a profitable algorithm, you should know that you have
    come a long way since the beginning of the book. This chapter is divided into
    independent sections that discuss interesting ways of applying a few advanced
    deep learning techniques and methods for time series prediction and to enhance
    the process.
  prefs: []
  type: TYPE_NORMAL
- en: Using COT Data to Predict Long-Term Trends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *Commitments of Traders* (COT) report is a [weekly publication](https://oreil.ly/PLtaP)
    released by the US Commodity Futures Trading Commission (CFTC). It provides information
    on the positions held by various market participants in futures markets. The report
    is based on data collected from futures exchanges, including the Chicago Mercantile
    Exchange (CME) and the Intercontinental Exchange (ICE). The COT report categorizes
    traders into three main groups:'
  prefs: []
  type: TYPE_NORMAL
- en: Commercial traders (also referred to as dealers or hedgers)
  prefs: []
  type: TYPE_NORMAL
- en: These are typically companies that use the futures market to hedge their main
    business activities. For example, a grain producer may use futures contracts to
    protect against price fluctuations in the agricultural market. Their positions
    are generally negatively correlated to the underlying market.
  prefs: []
  type: TYPE_NORMAL
- en: Noncommercial traders (also referred to as funds or leveraged money)
  prefs: []
  type: TYPE_NORMAL
- en: This group consists of large speculators, such as hedge funds and commodity
    trading advisors. Noncommercial traders often take positions based on their market
    outlook and profit-seeking strategies. Their positions are generally positively
    correlated to the underlying market as they have a trend-following nature.
  prefs: []
  type: TYPE_NORMAL
- en: Nonreportable traders
  prefs: []
  type: TYPE_NORMAL
- en: This category includes small speculators and traders whose positions do not
    meet the reporting requirements set by the CFTC. They do not have a clear correlation
    with the underlying market.
  prefs: []
  type: TYPE_NORMAL
- en: The report provides a breakdown of the positions held by each group, indicating
    whether they are *net long* (holding more long positions than short positions)
    or *net short* (holding more short positions than long positions) in a particular
    futures market.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traders and investors analyze the COT report to gain insights into the sentiment
    and behavior of different market participants. By monitoring changes in positions,
    they attempt to identify potential trends or reversals in the market. The report
    is especially popular in the commodity and currency markets, where it is used
    as a tool for fundamental analysis and to gauge market sentiment. This section
    covers how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an algorithm to download the COT data automatically and analyze it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chart and understand the correlations between the COT values and their respective
    underlying markets. Additionally, check for stationarity in the COT values to
    see if they can be used directly in the algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an LSTM algorithm to forecast the next COT value using lagged values
    and evaluate it. This will be referred to as the *indirect one-step COT model*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an LSTM algorithm to forecast a few weeks’ worth of COT observations
    using the direct method. This will be referred to as the *MPF COT direct model*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an LSTM algorithm to forecast a few weeks’ worth of COT observations
    using the recursive method. This will be referred to as the *MPF COT recursive
    model*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are mainly four columns of interest in the COT report: the long hedgers,
    the short hedgers, the long funds, and the short funds. They are the four basic
    pillars from which you calculate the net hedgers and the net funds. Some traders
    like to analyze every column before netting and seeing the bigger picture. It
    helps to understand the logic behind every column before proceeding to the netting
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: Long hedgers (the percentage long positions of commercial traders)
  prefs: []
  type: TYPE_NORMAL
- en: You can consider these hedgers *consumers* of the asset. A long hedger is an
    entity that buys futures on a certain asset (such as wheat) to hedge its main
    business. The primary goal is to protect itself from the risk of rising prices
    by securing a fixed price they need in the future. By doing so, they can plan
    their production costs more accurately and avoid potential losses if wheat prices
    increase. Therefore, long hedgers buy the asset in fear that it will go up. They
    usually buy it on its way down, which results in a negative correlation with the
    price of the asset.
  prefs: []
  type: TYPE_NORMAL
- en: Short hedgers (the percentage short positions of commercial traders)
  prefs: []
  type: TYPE_NORMAL
- en: You can consider these hedgers *producers* of the asset. A short hedger is an
    entity that sells short futures on a certain asset to hedge its main business.
    The primary goal is to protect itself from the risk of falling prices. Therefore,
    short hedgers sell in fear that it will go down. They usually sell it on its way
    up, which results in a positive correlation with the price of the asset (this
    means that the number of short hedgers rises as the price of the asset rises).
  prefs: []
  type: TYPE_NORMAL
- en: Long funds (the percentage long positions of noncommercial traders)
  prefs: []
  type: TYPE_NORMAL
- en: Speculative long fund positions are buyers of futures contracts in anticipation
    that the price will rise. They have a positive correlation with the price of the
    asset on account of their trend-following nature.
  prefs: []
  type: TYPE_NORMAL
- en: Short funds (the percentage short positions of noncommercial traders)
  prefs: []
  type: TYPE_NORMAL
- en: Speculative short fund positions are sellers of futures contracts in anticipation
    that the price will go down. They have a negative correlation with the price of
    the asset on account of their trend-following nature. An example of this would
    be the decreased number of short funds as the asset goes up.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Netting the COT report can be done in different ways depending on your needs.
    If you prefer to focus on commercial traders, then you can simply take the difference
    between commercial longs and commercial shorts (or as you may call them, consumers
    and producers). If you prefer to focus on noncommercial traders, then you can
    take the difference between noncommercial longs and noncommercial shorts. And
    if you prefer a global image, then you can take the difference between the netted
    commercial and noncommercial traders so that you’re left with only one time series
    that summarizes the global picture of the market positioning on a certain asset.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 11-1](#table-11-1) sheds some light on the calculation of net COT values.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 11-1\. COT netting representation
  prefs: []
  type: TYPE_NORMAL
- en: '| Hedger long | Hedger short | Fund long | Fund short | Net hedger | Net fund
    | Net COT |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| A | B | C | D | E = A – B | F = C – D | G = F – E |'
  prefs: []
  type: TYPE_TB
- en: 'The net COT value has the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: Net COT = Net funds – Net hedgers
  prefs: []
  type: TYPE_NORMAL
- en: It shares a positive correlation with the underlying price of the asset. [Figure 11-1](#figure-11-1)
    shows the net COT positioning on the Canadian dollar (CAD).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_1101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-1\. Net COT CAD since 2015; notice the mean-reverting nature of the
    values.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s see how to download COT values using Python. First, `pip install` the
    library that allows you to automatically download COT values from the CFTC website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Just in case the library has issues, you can use the predownloaded COT reports
    in Excel format found in the [GitHub repository](https://oreil.ly/5YGHI) (a code
    block at the end of this section is provided for this manual import).
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the required libraries to download the historical observations of the
    COT report. For simplicity, let’s choose CAD positioning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `import_cot_data()` function that allows you to fetch the COT values of
    a selected market is defined as follows (found in *master_function.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To import CAD COT values, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It is worth mentioning that other markets have the following code names that
    you can use to import them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In case you have a request error, try applying the following code before running
    the import section (remember to `pip install` the *proxy_requests* library):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 11-2](#figure-11-2) shows the net COT positioning on the CAD versus
    the CADUSD. Notice the strong positive correlation between the two. Calculating
    the Pearson correlation of the last 200 observations gives a whopping 0.66\. In
    other words, tops on the net COT data coincide with tops on the CADUSD. Similarly,
    troughs on the net COT data coincide with troughs on the CADUSD.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_1102.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-2\. The CADUSD (left scale) versus the CAD net COT positioning (right
    scale).
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Note that the chart shows the CADUSD and not the USDCAD, the commonly used
    pair. This is because you are trying to understand the CAD; therefore, it helps
    to use it as the base currency so that you can see the positive correlation with
    the CAD speculators and the negative correlation with the CAD hedgers. To obtain
    the CADUSD from the USDCAD observations, take its reciprocal:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper C upper A upper D upper U upper S upper D equals StartFraction
    1 Over upper U upper S upper D upper C upper A upper D EndFraction"><mrow><mi>C</mi>
    <mi>A</mi> <mi>D</mi> <mi>U</mi> <mi>S</mi> <mi>D</mi> <mo>=</mo> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><mn>1</mn> <mrow><mi>U</mi><mi>S</mi><mi>D</mi><mi>C</mi><mi>A</mi><mi>D</mi></mrow></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to check for stationarity on the COT values so as to know
    whether it requires transformation or not. Remember, transformation can be either
    differencing, taking the percentage returns, or even using fractional differentiation
    (as discussed in [Chapter 9](ch09.html#ch09)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The COT values seem to be stationary and ready to be used as inputs in the algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Algorithm 1: Indirect One-Step COT Model'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goodness of fit model will use long short-term memory (LSTM) to predict
    the next COT value at every time step. The assumption is that predicting a value
    that is directionally correlated to the underlying market may give a bias for
    the expected move during the coming week. For example, if the forecast is for
    a higher COT value in the coming week, then you may have a bullish CAD bias in
    preparation of your weekly trading.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the required libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the required data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the hyperparameters and create the arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To comply with the LSTM architecture, the independent variables must be transformed
    into three-dimensional arrays. This is done using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the architecture of the model and predict the values on the training
    set (only to understand the goodness of fit) and the test set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To plot the predictions along the real values, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 11-3](#figure-11-3) compares the predicted values with the real test
    values. At first glance, the model seems to capture the variations of the COT
    values well. Let’s have a look at the performance results.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_1103.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-3\. COT training data followed by COT test data (dashed line) and
    the predicted COT data (thin line); the vertical dashed line represents the start
    of the test period. The model used is the LSTM regression algorithm.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following are the results of the model used on the CADUSD from 2015 to
    2023:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An interesting task for you would be to apply the model to forecast the returns
    of the underlying market using COT values as inputs. You can use either the net
    COT value or any of the six other series you have available, such as long hedgers
    and net funds. However, make sure to always check for stationarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Algorithm 2: MPF COT Direct Model'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The MPF COT model will use LSTM to project a trajectory for the COT values
    to lead the way for the main market moves to come. The assumption is that by predicting
    the next COT values, which are less noisy than the market itself, you may have
    a guide for the expected trajectory of the market. As COT values are stationary
    and are highly correlated with the market (which is not stationary), you have
    a better chance of having a decent forecast than by using the MPF directly on
    the market. This algorithm uses the direct method (for more information, have
    another look at [Chapter 9](ch09.html#ch09)). First, import the required libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the hyperparameters and create the arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To comply with the LSTM architecture, the independent variables must be transformed
    into three-dimensional arrays. This is done using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the architecture of the model and predict the values using the
    recursive function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To plot the predictions along the real values, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 11-4](#figure-11-4) compares the predicted values with the real test
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_1104.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-4\. Predicted data versus test data.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following are the results of the model used on the CADUSD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Algorithm 3: MPF COT Recursive Model'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This algorithm uses the recursive method (for more information, have another
    look at [Chapter 9](ch09.html#ch09)). First, import the required libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the hyperparameters and create the arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To comply with the LSTM architecture, the independent variables must be transformed
    into three-dimensional arrays. This is done using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the architecture of the model and predict the values using the
    recursive function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To plot the predictions along the real values, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 11-5](#figure-11-5) compares the predicted values with the test values.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_1105.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-5\. Multiperiod forecasting of the COT data.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following are the results of the model used on the CADUSD from 2015 to
    2023:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember that while setting the `random_state` and ensuring reproducibility
    is useful for experimentation, it might also limit the model’s ability to generalize
    well if the data distribution is genuinely random. In many cases, it’s recommended
    to perform multiple runs with different random seeds to get a better sense of
    the model’s performance and robustness. This is why many of the models seen in
    this book do not have the `random_state` implementation in their code (except
    a few models in [Chapter 7](ch07.html#ch07)).
  prefs: []
  type: TYPE_NORMAL
- en: 'It does not hurt to remember the symptoms of overfitting. Unfortunately, overfitting
    is sometimes not that easily detectable, so consider these general rules:'
  prefs: []
  type: TYPE_NORMAL
- en: High training accuracy and low test accuracy
  prefs: []
  type: TYPE_NORMAL
- en: The model shows excellent performance on the training data but performs poorly
    on the test data. This is a clear indication that the model has memorized the
    training data rather than learning general patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Large gap between training and test performance
  prefs: []
  type: TYPE_NORMAL
- en: There is a significant difference between the training and test error rates.
    Ideally, the two measures should be close to each other, and a large gap suggests
    overfitting.
  prefs: []
  type: TYPE_NORMAL
- en: Unusually high model complexity
  prefs: []
  type: TYPE_NORMAL
- en: If the model is overly complex with a large number of parameters or features,
    it becomes more prone to overfitting. A simpler model may generalize better to
    new data.
  prefs: []
  type: TYPE_NORMAL
- en: Noisy predictions
  prefs: []
  type: TYPE_NORMAL
- en: Overfit models tend to make erratic and inconsistent predictions on new data.
    This is because they are highly sensitive to small variations in the input data,
    including noise.
  prefs: []
  type: TYPE_NORMAL
- en: Putting It All Together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The COT report, released every Friday by the CFTC, outlines the positioning
    of key market participants. It can be transformed into a time series forecasting
    task with the aim of improving market forecasts. The market participants of particular
    interest are the commercial participants (dealers or hedgers) and the noncommercial
    participants (leveraged money or funds).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Make sure to put *master_function.py* in the directory of the interpreter. Alternatively,
    you can simply open *master_function.py* in Python and execute the whole file.
    However, the latter method requires you to do it every time you restart the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Deep learning techniques can be applied on COT values to forecast market positioning
    through hidden patterns and seasonal configurations. This section discussed three
    algorithms to squeeze out value from the COT report. You can experiment with machine
    learning models, deep reinforcement learning, and even simple statistical techniques
    to better understand the COT data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To manually import COT values, refer to the historical data found in the [GitHub
    repository](https://oreil.ly/5YGHI) and use the following code (change the path
    of the interpreter to be the same as the location of the downloaded file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It’s important to remember that the COT report provides a snapshot of market
    participant positioning and should be used in conjunction with other tools and
    analysis methods. While it can offer valuable information, it’s not a standalone
    trading strategy, and careful consideration of other factors is essential for
    making well-informed trading decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Using Technical Indicators as Inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You learned about technical indicators in [Chapter 5](ch05.html#ch05). It’s
    time to use them as inputs to predict the underlying market’s returns. Using lagged
    values implies that there must be value in the past observations, which may translate
    into decent forecasts. This section will explore past that assumption and will
    search for value in other price transformations. You can have the following price-derived
    calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical transformation
  prefs: []
  type: TYPE_NORMAL
- en: This type of transformation is likely to be a direct manipulation of the raw
    data. An example of this is a basic differencing or a simple moving average. Normalization
    is also part of mathematical transformation.
  prefs: []
  type: TYPE_NORMAL
- en: Technical transformation
  prefs: []
  type: TYPE_NORMAL
- en: This type of transformation is less obvious, and the result may not look at
    all like the raw data. An example of this is the RSI, a technical indicator created
    out of recursive rules based on moving averages and normalization.
  prefs: []
  type: TYPE_NORMAL
- en: Categorical transformation
  prefs: []
  type: TYPE_NORMAL
- en: This type of transformation shifts the type of numerical data to categorical
    and vice versa. For example, an algorithm that is known as *OneHotEncoder* takes
    categorical data and transforms it into binary data so that machine learning algorithms
    are able to classify it.
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding, there is a data issue that is worth discussing. *Multicollinearity*
    is a statistical phenomenon that occurs in regression analysis when two or more
    independent variables (inputs) in a multiple regression model are highly correlated
    with each other. In other words, it is a situation where there is a strong linear
    relationship between two or more of the predictors. This correlation can make
    it difficult for the regression model to separate the individual effects of each
    predictor on the dependent variable (the outcome variable). Obviously, if you
    are using multiple RSIs with different time periods, then you are likely to run
    into multicollinearity. Make sure you look for weakly correlated indicators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two technical indicators (or transformations) are used in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: The five-week RSI, a stationary indicator that does not require any transformation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between the weekly close price and the 20-week moving average.
    This is also a stationary calculation that does not require any transformation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, the EURUSD’s weekly returns will be forecasted using the previous
    week’s RSI value and the distance between the previous week’s close price and
    the 20-week moving average.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the required libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, import the data using the `mass_import()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Define the multiple data preprocessing function, which takes the values of the
    two technical indicators and lags them so that they can be used as inputs to predict
    the EURUSD’s returns. [Table 11-2](#table-11-2) shows the training table `x_train`
    with six lagged values as independent variables to explain and predict the next
    EURUSD return.
  prefs: []
  type: TYPE_NORMAL
- en: Table 11-2\. A sample of the training array
  prefs: []
  type: TYPE_NORMAL
- en: '| RSI t–1 | (Close – MA)t–1 | RSI t–2 | (Close – MA)t–2 | RSI t–3 | (Close
    – MA)t–3 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 36.6190 | –0.003804 | 48.5188 | 0.001044 | 42.4396 | –0.001714 |'
  prefs: []
  type: TYPE_TB
- en: '| 46.7928 | 0.001674 | 36.6190 | –0.003804 | 48.5188 | 0.001044 |'
  prefs: []
  type: TYPE_TB
- en: '| 40.5430 | –0.002518 | 46.7928 | 0.001674 | 36.6190 | –0.003804 |'
  prefs: []
  type: TYPE_TB
- en: '| 65.9614 | 0.011340 | 40.5430 | –0.002518 | 46.7928 | 0.001674 |'
  prefs: []
  type: TYPE_TB
- en: '| 47.2585 | –0.000390 | 65.9614 | 0.011340 | 40.5430 | –0.002518 |'
  prefs: []
  type: TYPE_TB
- en: '| 63.9755 | 0.011302 | 47.2585 | –0.000390 | 65.9614 | 0.011340 |'
  prefs: []
  type: TYPE_TB
- en: 'The next function is already defined, but it doesn’t hurt to discuss what it
    does. The `multiple_data_preprocessing()` function simply creates the four needed
    arrays for the backtest, but it uses the two technical indicators as inputs. You
    can define the function for six lagged values (three for the RSI and three for
    the difference between the close and the moving average) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the hyperparameters and create the arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To comply with the LSTM architecture, the independent variables must be transformed
    into three-dimensional arrays. This is done using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the architecture of the model and predict the values on the training
    set (only to understand the goodness of fit) and the test set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To plot the predictions along the real values, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 11-6](#figure-11-6) compares the predicted values with the real test
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_1106.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-6\. Training data followed by test data (dashed line) and the predicted
    data (thin line); the vertical dashed line represents the start of the test period.
    The model used is the LSTM regression algorithm.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following are the results of the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It is very interesting to tweak the model and see how to improve it. As these
    are weekly predictions, good accuracy could be the first step in shaping your
    swing trading on the condition of optimizing the model and making sure it is not
    overfit.^([1](ch11.html#id806)) It is worth noting that since this algorithm is
    trying to predict the financial returns of an instrument, the `calculate_accuracy()`
    function is used as opposed to `ca⁠lc⁠ul⁠ate_​di⁠re⁠cti⁠on⁠al_accuracy()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Try running the algorithm seen in this section on MPF mode and see what you
    can extract from it. Remember the algorithm’s limitations while doing so.
  prefs: []
  type: TYPE_NORMAL
- en: Predicting Bitcoin’s Volatility Using Deep Learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Bitcoin* is a decentralized digital currency that was created in 2009 by an
    unknown person or entity using the pseudonym *Satoshi Nakamoto*. It was the first
    cryptocurrency to be introduced and remains the most well known and widely traded
    cryptocurrency to date. You probably do not need an introduction to Bitcoin considering
    the immense hype over it during these past years, but more knowledge never hurts.'
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin operates on a technology called *blockchain*, which is a distributed
    ledger system. Unlike traditional currencies that are issued and regulated by
    governments or central banks, Bitcoin is not controlled by any central authority.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, it relies on a peer-to-peer network of computers, known as nodes, to
    validate and record transactions. Nowadays, Bitcoin is heavily traded on cryptocurrency
    exchanges and is used for speculative but also hedging operations. The most commonly
    traded pair is BTCUSD, which is the value of 1 bitcoin relative to USD.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-7](#figure-11-7) shows the evolution of the BTCUSD (Bitcoin’s value
    priced in US dollars).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_1107.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-7\. Historical evolution of BTCUSD since 2014 in a linear scale.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can generate [Figure 11-7](#figure-11-7) using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you download the historical BTCUSD values from the [GitHub repository](https://oreil.ly/5YGHI)
    and that you set the directory of the interpreter in the same folder as the downloaded
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-7](#figure-11-7) is charted using a linear scale, which means that
    data is represented on a straight and evenly spaced axis (the space between 10
    and 20 is the same as the space between 1230 and 1240). It is also possible to
    use what is known as a logarithmic scale to chart time series that experience
    big jumps.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-8](#figure-11-8) shows the evolution of BTCUSD (Bitcoin’s value
    priced in US dollars) in logarithmic scale.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_1108.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-8\. Historical evolution of BTCUSD since 2014 in a semilog scale.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Use the following code to generate [Figure 11-8](#figure-11-8) using the `plt.semilogy()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The word *semilog* refers to transforming one of the two axes into a logarithmic
    scale, while the word *log* refers to transforming both axes into a logarithmic
    scale.
  prefs: []
  type: TYPE_NORMAL
- en: Since time is linear, you only need to transform the *y*-axis (which means the
    values), and therefore, you are technically using semilog charts. This is why
    the `matplotlib()` function is called `pl⁠t.​se⁠mi⁠log⁠y()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer to import BTCUSD values using a Python script, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see if deep learning helps forecast BTCUSD’s volatility using its lagged
    values. But first, two questions are begging an answer:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the use of predicting Bitcoin’s volatility?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you calculate Bitcoin’s volatility?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To answer the first question, by predicting Bitcoin’s volatility, traders can
    potentially identify periods of increased price swings and capitalize on them.
    Similarly, volatility predictions can also provide insights into market sentiment.
    When investors expect uncertain or turbulent market conditions, it may indicate
    a lack of confidence, leading to potential changes in market dynamics.
  prefs: []
  type: TYPE_NORMAL
- en: To answer the second question, you can use a rolling standard deviation measure
    on the close prices. This allows you to create a new time series that reflects
    the historical volatility of Bitcoin.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Typically, an increase in volatility is a sign of market stress and fear, which
    translates to a bearish tone. In contrast, a decrease in volatility is a sign
    of a healthy and stable market, which translates to a bullish market. This relationship
    is not perfect, and other variables may impact it. For example, if you calculate
    the correlation coefficient of Bitcoin’s daily close prices and the 10-day rolling
    volatility, you will find that it’s positive (at some periods, it’s extremely
    positive). Bitcoin is known for being a euphoric asset where rises are accompanied
    by a phenomenon called FOMO, an abbreviation of *fear of missing out*. This psychological
    bias is one of the building blocks of a market bubble where everyone keeps buying
    in the hopes of profiting from the move.
  prefs: []
  type: TYPE_NORMAL
- en: The first step of predictive analytics is to understand the data you’re dealing
    with. As a reminder, volatility refers to the degree of variation or fluctuation
    in the price of a financial instrument, such as a stock, bond, commodity, or currency,
    over a specific period of time. It is a statistical measure of the dispersion
    for that particular asset.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-9](#figure-11-9) shows the latest values of Bitcoin’s 10-day volatility
    as measured by the rolling standard deviation calculation. The latest values say
    that recently, the price variations hovered around $500 from the 10-day mean most
    of the time (refer to [Chapter 3](ch03.html#ch03) for more in-depth comprehension
    on standard deviation).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_1109.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-9\. Bitcoin’s rolling 10-day standard deviation as a proxy for volatility.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s get started. For this task, let’s manually import BTCUSD into the interpreter.
    First, start by importing the required libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, import the data using *pandas*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to calculate volatility. Its function is defined in `master_function`,
    and as you have imported it already, it should work directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You have to check for stationarity. If the data is stationary, then it’s ready
    to be deployed for training. Otherwise, you may have to transform it. The following
    code applies the ADF test on the 10-day volatility of Bitcoin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'It seems that the volatility values are nonstationary. Let’s try differencing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can also apply fractional differentiation to preserve a hint of memory.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-10](#figure-11-10) shows the latest values of Bitcoin’s 10-day differenced
    volatility.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_1110.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-10\. Bitcoin’s rolling 10-day standard deviation (differenced).
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The next step is to set the hyperparameters and prepare the arrays as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To comply with the LSTM architecture, the independent variables must be transformed
    into three-dimensional arrays. This is done using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the deep neural network architecture with a few extra layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, fit and predict the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 11-11](#figure-11-11) compares the predicted values with the test values.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_1111.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-11\. Forecasting Bitcoin’s volatility; the model used is the LSTM
    regression algorithm.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following are the results of the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that the backtesting results may differ significantly due to the
    backtested period, time granularity, transaction costs, different quotations from
    different brokers, different hyperparameters, and different randomization. Optimization
    is a key component, and validation of the results must be done before forming
    an opinion on the algorithm. Your task is therefore to improve the results and
    get a better prediction on volatility.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also wonder if you can predict Bitcoin’s returns directly with an accuracy
    better than random. The answer is yes, and if you need a few ideas of inputs that
    may help predict Bitcoin’s returns, check out the following nonexhaustive list:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Historical price data and its derivatives*: Using historical price data is
    a fundamental aspect of predicting returns. You can include features such as daily,
    weekly, or monthly price changes, moving averages, and price volatility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Trading volume*: The trading volume of Bitcoin provides valuable information
    about the level of market activity and liquidity. Higher trading volumes often
    accompany significant price movements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Market sentiment indicators*: Sentiment analysis from social media platforms,
    news articles, or forums can help gauge the overall market sentiment toward Bitcoin.
    Bitcoin’s Fear & Greed index is a good candidate as it’s published on a daily
    basis and uses many fundamental variables to calculate its values.^([2](ch11.html#id815))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Network metrics*: Bitcoin’s blockchain data provides useful metrics, such
    as the number of transactions, hash rate, and difficulty level. These metrics
    reflect the activity and health of the Bitcoin network, which can influence prices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Market indicators*: Consider using general market indicators like the S&P
    500 or the VIX as external variables. Cryptocurrencies, including Bitcoin, can
    sometimes exhibit correlations with traditional financial markets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cryptocurrency-specific indicators*: Other indicators specific to the cryptocurrency
    space, such as the total market capitalization of all cryptocurrencies and dominance
    ratio of Bitcoin, may provide insights into broader market conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Technical indicators*: Various technical analysis indicators, such as the
    RSI and volatility, can offer insights into potential price trends and reversals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Google trends*: Monitoring the popularity of search terms related to Bitcoin
    on Google Trends can provide insights into public interest and potential price
    movements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cryptocurrency exchange data*: Data from cryptocurrency exchanges, such as
    open interest, funding rates, and liquidation data, can offer insights into market
    dynamics and potential price shifts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-Time Visualization of Training
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What happens during training? Sure, you can see that the training process is
    on-going when you look at the progress bar of every epoch:'
  prefs: []
  type: TYPE_NORMAL
- en: Epoch 1/100
  prefs: []
  type: TYPE_NORMAL
- en: '9/9 [=============================] – 3s 77ms/step - loss: 0.0052'
  prefs: []
  type: TYPE_NORMAL
- en: Epoch 2/100
  prefs: []
  type: TYPE_NORMAL
- en: '9/9 [=============================] – 1s 78ms/step - loss: 0.0026'
  prefs: []
  type: TYPE_NORMAL
- en: Epoch 3/100
  prefs: []
  type: TYPE_NORMAL
- en: '9/9 [=============================] – 1s 68ms/step - loss: 0.0015'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you can also code a dynamic plot that shows you the in-sample predictions
    getting updated through epochs as they approach the in-sample real values. This
    will be the first aim of this section. Before proceeding, refresh your knowledge
    of the terminologies:'
  prefs: []
  type: TYPE_NORMAL
- en: In-sample real values
  prefs: []
  type: TYPE_NORMAL
- en: These are the values contained in `y_train`. They are the real values the model
    uses to calibrate its training. They belong to the training set.
  prefs: []
  type: TYPE_NORMAL
- en: In-sample predictions
  prefs: []
  type: TYPE_NORMAL
- en: These are the values contained in `y_predicted_train`. They are the predictions
    the model outputs during its training. They belong to the training set and suffer
    from *look-ahead bias*, which happens when future information is used to make
    decisions or predictions that should have been made in the past based only on
    historical data available at that time.
  prefs: []
  type: TYPE_NORMAL
- en: Out-of-sample real values
  prefs: []
  type: TYPE_NORMAL
- en: These are the test values used to test the model’s ability to predict values
    on data that has never been seen before. They belong to the test set.
  prefs: []
  type: TYPE_NORMAL
- en: Out-of-sample predictions
  prefs: []
  type: TYPE_NORMAL
- en: These are the predictions that follow the training phase. They belong to the
    test set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take an example that you are familiar with from [Chapter 9](ch09.html#ch09),
    the ISM PMI data. The aim is to create a one-step forecast LSTM model of the differenced
    ISM PMI values while creating a dynamic plot during training that shows predictions
    being calibrated to the training set. First, import the required libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'From the [GitHub repository](https://oreil.ly/5YGHI), import and difference
    the ISM PMI data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to set the hyperparameters and prepare the arrays as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To comply with the LSTM architecture, the independent variables must be transformed
    into three-dimensional arrays. This is done using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the deep neural network architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code fits the `x_train` data to the `y_train` data while plotting
    the predictions at every epoch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 11-12](#figure-11-12) shows the training at epoch 1\. Notice how the
    algorithm is just starting out and is not quite capturing the relationship between
    the independent and dependent variables yet.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_1112.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-12\. ISM PMI data training in progress at epoch 1.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 11-13](#figure-11-13) shows the training at epoch 21\. It looks like
    the algorithm is still calibrating itself to the features.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_1113.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-13\. ISM PMI data training in progress at epoch 21.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 11-14](#figure-11-14) shows the training at epoch 29\. The model is
    starting to properly fit the data.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_1114.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-14\. ISM PMI data training in progress at epoch 29.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 11-15](#figure-11-15) shows the training at epoch 62\. The model seems
    to fit the data well, although with some errors, but this is not the main aim
    of this section.'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic training plots can be an interesting tool to see how the model is learning—and
    whether it’s actually learning something. This helps with the problem of *constant
    predictions*, which occur when the model fails to capture any relationship between
    the dependent and independent variables.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_1115.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-15\. ISM PMI data training in progress at epoch 62.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Several factors can lead to the problem of constant predictions in deep learning:'
  prefs: []
  type: TYPE_NORMAL
- en: Poor model architecture
  prefs: []
  type: TYPE_NORMAL
- en: If the model is not expressive enough, it may struggle to learn meaningful patterns,
    resorting to a simple, constant prediction instead.
  prefs: []
  type: TYPE_NORMAL
- en: Limited or noisy data
  prefs: []
  type: TYPE_NORMAL
- en: Insufficient or noisy data can hinder the model’s ability to learn meaningful
    patterns. If the data lacks diversity or contains significant errors, the model
    may converge to a constant forecast as the simplest way to minimize the loss.
  prefs: []
  type: TYPE_NORMAL
- en: Improper loss function
  prefs: []
  type: TYPE_NORMAL
- en: The choice of the loss function plays a vital role in guiding the model during
    training. If the loss function is not appropriate for the task or the model architecture,
    it may not encourage the model to make varied predictions, leading to constant
    forecasts.
  prefs: []
  type: TYPE_NORMAL
- en: Poor hyperparameter tuning
  prefs: []
  type: TYPE_NORMAL
- en: Hyperparameters, such as the batch size and the number of neurons, can significantly
    impact the training process. If these hyperparameters are not appropriately tuned,
    the model might not converge effectively, leading to constant predictions.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you must have wondered what the architecture you built using
    the `Sequential()` and `Dense()` functions looks like. Naturally, it should look
    like the neural network graphs you have seen previously. To see this, you must
    `pip install` the required libraries from the prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Then download the *graphviz* binaries folder from the [official website](https://oreil.ly/SV5FO),
    extract the contents of the file, then set the *bin* folder as one of the paths
    of the Python interpreter (e.g., Spyder). Restart the kernel, and proceed to compile
    your model as usual. Finally, use the following code to print the architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 11-16](#figure-11-16) shows the output of the code.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_1116.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-16\. Model architecture example.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The code outputs the current architecture of the compiled LSTM model.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This information-heavy chapter showed you a few ideas for using a selection
    of trading algorithms to forecast returns. It is mostly a way to stimulate critical
    and innovative thinking and to find new and innovative ideas from where trading
    signals may be derived. For example, you can try applying filters with the signals
    you get from the algorithms. *Filters* are like on/off switches that allow the
    signal based on whether a final condition is met or not. An example of a hypothetical
    trading strategy with a filter is to take the bullish signals only if the market
    is above its 200-day moving average and to take the bearish signals only if the
    market is below its 200-day moving average.
  prefs: []
  type: TYPE_NORMAL
- en: Your main takeaway should be how things must be structured so that you can understand
    the backtesting process. Compared to this chapter, [Chapter 12](ch12.html#ch12)
    will be a gentle breeze as it explores risk management and fundamental tools aimed
    at enhancing the research process.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch11.html#id806-marker)) Swing trading involves holding positions for
    a short- to medium-term period, typically a few days to a few weeks, to profit
    from price swings or price movements within a larger trend.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch11.html#id815-marker)) The index is used to gauge the emotions and sentiments
    of investors in the cryptocurrency market. It provides a numerical value on a
    scale from 0 to 100, where lower values indicate extreme fear and higher values
    indicate extreme greed. The index is designed to help traders and investors identify
    potential market turning points based on prevailing emotions.
  prefs: []
  type: TYPE_NORMAL
