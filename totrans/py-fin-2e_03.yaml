- en: Chapter 3\. Data Types and Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 数据类型和结构
- en: Bad programmers worry about the code. Good programmers worry about data structures
    and their relationships.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 糟糕的程序员担心代码。优秀的程序员担心数据结构及其关系。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Linus Torvalds
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Linus Torvalds
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: This chapter introduces basic data types and data structures of `Python`. Although
    the `Python` interpreter itself already brings a rich variety of data structures
    with it, `NumPy` and other libraries add to these in a valuable fashion.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了`Python`的基本数据类型和数据结构。尽管`Python`解释器本身已经带来了丰富多样的数据结构，但`NumPy`和其他库在其中增添了宝贵的内容。
- en: 'The chapter is organized as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章组织如下：
- en: '[“Basic Data Types”](#data_types)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[“基本数据类型”](#data_types)'
- en: The first section introduces basic data types such as `int`, `float`, and `string`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 第一节介绍了基本数据类型，如`int`、`float`和`string`。
- en: '[“Basic Data Structures”](#data_structures)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[“基本数据结构”](#data_structures)'
- en: The next section introduces the fundamental data structures of Python (e.g.,
    `list` objects) and illustrates control structures, functional programming paradigms,
    and anonymous functions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节介绍了`Python`的基本数据结构（例如`list`对象）并说明了控制结构、函数式编程范式和匿名函数。
- en: The spirit of this chapter is to provide a general introduction to `Python`
    specifics when it comes to data types and structures. If you are equipped with
    a background from another programing language, say `C` or `Matlab`, you should
    be able to easily grasp the differences that `Python` usage might bring along.
    The topics introduced here are all important and fundamental for the chapters
    to come.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的精神是在涉及数据类型和结构时提供对`Python`特定内容的一般介绍。如果您具备来自其他编程语言（例如`C`或`Matlab`）的背景，那么您应该能够轻松掌握`Python`用法可能带来的差异。此处介绍的主题对于接下来的章节都是重要且基础的。
- en: 'The chapter covers the following data types and structures:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下数据类型和结构：
- en: '| object type | meaning | usage/model for |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 对象类型 | 含义 | 用法/模型 |'
- en: '| --- | --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `int` | integer value | natural number |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 整数值 | 自然数 |'
- en: '| `float` | floating point number | real number |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `float` | 浮点数 | 实数 |'
- en: '| `bool` | boolean value | something true or false |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | 布尔值 | 某种真或假 |'
- en: '| `str` | string object | character, word, text |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `str` | 字符串对象 | 字符、单词、文本 |'
- en: '| `tuple` | immutable container | fixed set of objects, record |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `tuple` | 不可变容器 | 固定的对象集合、记录 |'
- en: '| `list` | mutable container | changing set of objects |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `list` | 可变容器 | 变化的对象集合 |'
- en: '| `dict` | mutable container | key-value store |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `dict` | 可变容器 | 键-值存储 |'
- en: '| `set` | mutable container | collection of unique objects |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `set` | 可变容器 | 唯一对象的集合 |'
- en: Basic Data Types
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本数据类型
- en: '`Python` is a *dynamically typed* language, which means that the `Python` interpreter
    infers the type of an object at runtime. In comparison, compiled languages like
    `C` are generally *statically typed*. In these cases, the type of an object has
    to be attached to the object before compile time.^([1](ch03.html#idm140277701762352))'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Python` 是一种*动态类型*语言，这意味着`Python`解释器在运行时推断对象的类型。相比之下，像`C`这样的编译语言通常是*静态类型*的。在这些情况下，对象的类型必须在编译时与对象关联。^([1](ch03.html#idm140277701762352))'
- en: Integers
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数
- en: 'One of the most fundamental data types is the integer, or ``int``:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的数据类型之一是整数，或者``int``：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The built-in function `type` provides type information for all objects with
    standard and built-in types as well as for newly created classes and objects.
    In the latter case, the information provided depends on the description the programmer
    has stored with the class. There is a saying that “everything in `Python` is an
    object.” This means, for example, that even simple objects like the `int` object
    we just defined have built-in methods. For example, you can get the number of
    bits needed to represent the `int` object in-memory by calling the method `bit_length`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 内置函数`type`提供了标准和内置类型的所有对象的类型信息，以及新创建的类和对象。在后一种情况下，提供的信息取决于程序员与类存储的描述。有一句话说“`Python`中的一切都是对象。”这意味着，例如，即使是我们刚刚定义的`int`对象这样的简单对象也有内置方法。例如，您可以通过调用方法`bit_length`来获取表示内存中的`int`对象所需的位数：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will see that the number of bits needed increases the higher the integer
    value is that we assign to the object:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现，所需的位数随我们分配给对象的整数值的增加而增加：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In general, there are so many different methods that it is hard to memorize
    all methods of all classes and objects. Advanced `Python` environments, like `IPython`,
    provide tab completion capabilities that show all methods attached to an object.
    You simply type the object name followed by a dot (e.g., `a.`) and then press
    the Tab key, e.g., `a.*tab*`. This then provides a collection of methods you can
    call on the object. Alternatively, the `Python` built-in function `dir` gives
    a complete list of attributes and methods of any object.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，有很多不同的方法，很难记住所有类和对象的所有方法。高级`Python`环境，如`IPython`，提供了可以显示附加到对象的所有方法的制表符完成功能。您只需键入对象名称，然后跟一个点（例如，`a.`），然后按Tab键，例如，`a.*tab*`。然后，这将提供您可以调用的对象的方法集合。或者，`Python`内置函数`dir`提供了任何对象的完整属性和方法列表。
- en: 'A specialty of `Python` is that integers can be arbitrarily large. Consider,
    for example, the googol number 10^(100). `Python` has no problem with such large
    numbers, which are technically `long` objects:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Python`的一个特殊之处在于整数可以是任意大的。例如，考虑谷歌数10^(100)。`Python`对于这样的大数没有问题，这些大数在技术上是`long`对象：'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Large Integers
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大整数
- en: '`Python` integers can be arbitrarily large. The interpreter simply uses as
    many bits/bytes as needed to represent the numbers.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Python` 整数可以是任意大的。解释器会根据需要使用尽可能多的位/字节来表示数字。'
- en: 'Arithmetical operations on integers are easy to implement:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 整数的算术运算易于实现：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Floats
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮点数
- en: The last expression return the generally *desired* result of 0.25 (this is different
    in basic Python 2.7). This brings us to the next basic data type, the `float`
    object. Adding a dot to an integer value, like in `1.` or `1.0`, causes `Python`
    to interpret the object as a `float`. Expressions involving a `float` also return
    a `float` object in general:^([2](ch03.html#idm140277701533120))
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个表达式返回通常*期望*的结果0.25（在基本的Python 2.7中不同）。这使我们进入了下一个基本数据类型，即`float`对象。在整数值后添加一个点，如`1.`或`1.0`，会导致`Python`将对象解释为`float`。涉及`float`的表达式通常也返回一个`float`对象：^（[2](ch03.html#idm140277701533120)）
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A `float` is a bit more involved in that the computerized representation of
    rational or real numbers is in general not exact and depends on the specific technical
    approach taken. To illustrate what this implies, let us define another `float`
    object `b`. `float` objects like this one are always represented internally up
    to a certain degree of accuracy only. This becomes evident when adding 0.1 to
    `b`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`float`稍微复杂一些，因为有理数或实数的计算机化表示通常不是精确的，而是取决于所采取的具体技术方法。为了说明这意味着什么，让我们定义另一个`float`对象`b`。像这样的`float`对象总是内部表示为仅具有一定精度的。当向`b`添加0.1时，这变得明显：'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The reason for this is that +`float`+s are internally represented in binary
    format; that is, a decimal number <math alttext="0 less-than n less-than 1"><mrow><mn>0</mn>
    <mo><</mo> <mi>n</mi> <mo><</mo> <mn>1</mn></mrow></math> is represented by a
    series of the form <math alttext="n equals StartFraction x Over 2 EndFraction
    plus StartFraction y Over 4 EndFraction plus StartFraction z Over 8 EndFraction
    plus period period period"><mrow><mi>n</mi> <mo>=</mo> <mfrac><mi>x</mi> <mn>2</mn></mfrac>
    <mo>+</mo> <mfrac><mi>y</mi> <mn>4</mn></mfrac> <mo>+</mo> <mfrac><mi>z</mi> <mn>8</mn></mfrac>
    <mo>+</mo> <mo>.</mo> <mo>.</mo> <mo>.</mo></mrow></math> . For certain floating-point
    numbers the binary representation might involve a large number of elements or
    might even be an infinite series. However, given a fixed number of bits used to
    represent such a number — i.e., a fixed number of terms in the representation
    series—inaccuracies are the consequence. Other numbers can be represented *perfectly*
    and are therefore stored exactly even with a finite number of bits available.
    Consider the following example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为+`float`+s在内部以二进制格式表示；也就是说，十进制数<math alttext="0 less-than n less-than 1"><mrow><mn>0</mn>
    <mo><</mo> <mi>n</mi> <mo><</mo> <mn>1</mn></mrow></math>通过形式为<math alttext="n
    equals StartFraction x Over 2 EndFraction plus StartFraction y Over 4 EndFraction
    plus StartFraction z Over 8 EndFraction plus period period period"><mrow><mi>n</mi>
    <mo>=</mo> <mfrac><mi>x</mi> <mn>2</mn></mfrac> <mo>+</mo> <mfrac><mi>y</mi> <mn>4</mn></mfrac>
    <mo>+</mo> <mfrac><mi>z</mi> <mn>8</mn></mfrac> <mo>+</mo> <mo>.</mo> <mo>.</mo>
    <mo>.</mo></mrow></math>的系列表示。对于某些浮点数，二进制表示可能涉及大量元素，甚至可能是一个无限级数。然而，给定用于表示此类数字的固定位数-即表示系列中的固定项数-不准确是其结果。其他数字可以*完美*表示，因此即使只有有限数量的位可用，它们也会被精确地存储。考虑以下示例：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'One half, i.e., 0.5, is stored exactly because it has an exact (finite) binary
    representation as <math alttext="normal dollar-sign 0.5 equals one-half normal
    dollar-sign"><mrow><mi>$</mi> <mn>0</mn> <mo>.</mo> <mn>5</mn> <mo>=</mo> <mfrac><mn>1</mn>
    <mn>2</mn></mfrac> <mi>$</mi></mrow></math> . However, for `b = 0.35` we get something
    different than the expected rational number <math alttext="normal dollar-sign
    0.35 equals seven-twenty-ths normal dollar-sign"><mrow><mi>$</mi> <mn>0</mn> <mo>.</mo>
    <mn>35</mn> <mo>=</mo> <mfrac><mn>7</mn> <mn>20</mn></mfrac> <mi>$</mi></mrow></math>
    :'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一半，即0.5，被准确地存储，因为它有一个精确（有限）的二进制表示：<math alttext="normal dollar-sign 0.5 equals
    one-half normal dollar-sign"><mrow><mi>$</mi> <mn>0</mn> <mo>.</mo> <mn>5</mn>
    <mo>=</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mi>$</mi></mrow></math> 。然而，对于`b
    = 0.35`，我们得到的结果与期望的有理数<math alttext="normal dollar-sign 0.35 equals seven-twenty-ths
    normal dollar-sign"><mrow><mi>$</mi> <mn>0</mn> <mo>.</mo> <mn>35</mn> <mo>=</mo>
    <mfrac><mn>7</mn> <mn>20</mn></mfrac> <mi>$</mi></mrow></math> 不同：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The precision is dependent on the number of bits used to represent the number.
    In general, all platforms that `Python` runs on use the IEEE 754 double-precision
    standard (i.e., 64 bits), for internal representation.^([3](ch03.html#idm140277701447424))
    This translates into a 15-digit relative accuracy.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 精度取决于用于表示数字的位数。一般来说，所有`Python`运行的平台都使用IEEE 754双精度标准（即64位）来进行内部表示。[^3](ch03.html#idm140277701447424)
    这意味着相对精度为15位数字。
- en: Since this topic is of high importance for several application areas in finance,
    it is sometimes necessary to ensure the exact, or at least best possible, representation
    of numbers. For example, the issue can be of importance when summing over a large
    set of numbers. In such a situation, a certain kind and/or magnitude of representation
    error might, in aggregate, lead to significant deviations from a benchmark value.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个主题在金融等几个应用领域非常重要，有时需要确保数字的确切或至少是最佳可能的表示。例如，在对一大堆数字求和时，这个问题可能很重要。在这种情况下，某种类型和/或数量级别的表示误差可能导致与基准值的显著偏差。
- en: 'The module `decimal` provides an arbitrary-precision object for floating-point
    numbers and several options to address precision issues when working with such
    numbers:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 模块`decimal`提供了一个用于浮点数的任意精度对象，以及几个选项来解决使用这些数字时的精度问题：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can change the precision of the representation by changing the respective
    attribute value of the `Context` object:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过改变`Context`对象的相应属性值来改变表示的精度：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](images/1.png)](#co_mastering_the_basics_CO1-1)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](images/1.png)](#co_mastering_the_basics_CO1-1)'
- en: Lower precision than default.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 低于默认精度。
- en: '[![2](images/2.png)](#co_mastering_the_basics_CO1-2)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](images/2.png)](#co_mastering_the_basics_CO1-2)'
- en: Higher precision than default.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 高于默认精度。
- en: 'If needed, the precision can in this way be adjusted to the exact problem at
    hand and one can operate with floating-point objects that exhibit different degrees
    of accuracy:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如有需要，可以通过这种方式调整精度以适应手头的确切问题，并且可以处理具有不同精度的浮点对象：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Arbitrary-Precision Floats
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任意精度浮点数
- en: The module `decimal` provides an arbitrary-precision floating-point number object.
    In finance, it might sometimes be necessary to ensure high precision and to go
    beyond the 64-bit double-precision standard.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 模块`decimal`提供了一个任意精度浮点数对象。在金融中，有时需要确保高精度并超越64位双精度标准。
- en: Boolean
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: In programming, evaluating a comparison or logical expression, such as `4 >
    3`, `4.5 <= 3.25` or `(4 > 3) and (3 > 2)` , yields one of `True` or `False` as
    output, two important Python keywords. Others are, for example, `def`, `for` or
    `if`. A complete list of Python keywords is available in the `keyword` module.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，评估比较或逻辑表达式，例如`4 > 3`，`4.5 <= 3.25`或`(4 > 3) and (3 > 2)`，会产生`True`或`False`之一作为输出，这是两个重要的Python关键字。其他例如`def`，`for`或`if`。Python关键字的完整列表可在`keyword`模块中找到。
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`True` and `False` are of data type `bool`, standing for a Boolean value. The
    following code shows Python’s *comparison* operators applied to the same operands
    with the resulting `bool` objects.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`True`和`False`是`bool`数据类型，代表布尔值。以下代码展示了Python对相同操作数应用*比较*操作符后生成的`bool`对象。'
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](images/1.png)](#co_mastering_the_basics_CO2-1)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](images/1.png)](#co_mastering_the_basics_CO2-1)'
- en: Is greater.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 更大。
- en: '[![2](images/2.png)](#co_mastering_the_basics_CO2-2)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](images/2.png)](#co_mastering_the_basics_CO2-2)'
- en: Is greater or equal.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 大于或等于。
- en: '[![3](images/3.png)](#co_mastering_the_basics_CO2-3)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](images/3.png)](#co_mastering_the_basics_CO2-3)'
- en: Is smaller.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 更小。
- en: '[![4](images/4.png)](#co_mastering_the_basics_CO2-4)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](images/4.png)](#co_mastering_the_basics_CO2-4)'
- en: Is smaller or equal.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 小于或等于。
- en: '[![5](images/5.png)](#co_mastering_the_basics_CO2-5)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](images/5.png)](#co_mastering_the_basics_CO2-5)'
- en: Is equal.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 相等。
- en: '[![6](images/6.png)](#co_mastering_the_basics_CO2-6)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](images/6.png)](#co_mastering_the_basics_CO2-6)'
- en: Is not equal.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 不相等。
- en: Often, *logical* operators are applied on `bool` objects, which in turn yields
    another `bool` object.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 经常，*逻辑*运算符被应用于`bool`对象，从而产生另一个`bool`对象。
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Of course, both types of operators are often combined.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这两种类型的运算符经常结合使用。
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: One major application are is to control the code flow via other Python keywords,
    such as `if` or `while` (more examples later in the chapter).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 其一主要应用是通过其他Python关键字（例如`if`或`while`）来控制代码流程（本章后面将有更多示例）。
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](images/1.png)](#co_mastering_the_basics_CO3-1)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](images/1.png)](#co_mastering_the_basics_CO3-1)'
- en: If condition holds true, execute code to follow.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件成立，则执行要跟随的代码。
- en: '[![2](images/2.png)](#co_mastering_the_basics_CO3-2)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](images/2.png)](#co_mastering_the_basics_CO3-2)'
- en: The code to be executed if condition holds true.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件成立，则执行要跟随的代码。
- en: '[![3](images/3.png)](#co_mastering_the_basics_CO3-3)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](images/3.png)](#co_mastering_the_basics_CO3-3)'
- en: Initializes the parameter `i` with 0.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用0初始化参数`i`。
- en: '[![4](images/4.png)](#co_mastering_the_basics_CO3-4)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](images/4.png)](#co_mastering_the_basics_CO3-4)'
- en: As long as the condition holds true, execute and repeat the code to follow.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 只要条件成立，就执行并重复执行后续代码。
- en: '[![5](images/5.png)](#co_mastering_the_basics_CO3-5)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](images/5.png)](#co_mastering_the_basics_CO3-5)'
- en: Prints a text and the value of parameter `i`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 打印文本和参数`i`的值。
- en: '[![6](images/6.png)](#co_mastering_the_basics_CO3-6)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](images/6.png)](#co_mastering_the_basics_CO3-6)'
- en: Increases the parameter value by 1; `i += 1` is the same as `i = i + 1`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将参数值增加1；`i += 1`等同于`i = i + 1`。
- en: Numerically, Python attaches a value of 0 to `False` and a value of 1 to `True`.
    When transforming number to `bool` objects via the `bool()` function, a 0 gives
    `False` while all other numbers give `True`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在数值上，Python将`False`赋值为0，将`True`赋值为1。通过`bool()`函数将数字转换为`bool`对象时，0给出`False`，而所有其他数字给出`True`。
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Strings
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Now that we can represent natural and floating-point numbers, we turn to text.
    The basic data type to represent text in `Python` is the `string`. The ``string``
    object has a number of really helpful built-in methods. In fact, `Python` is generally
    considered to be a good choice when it comes to working with text files of any
    kind and any size. A `string` object is generally defined by single or double
    quotation marks or by converting another object using the `str` function (i.e.,
    using the object’s standard or user-defined `string` representation):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以表示自然数和浮点数，我们转向文本。在`Python`中表示文本的基本数据类型是`string`。``string``对象具有许多非常有用的内置方法。事实上，当涉及到处理任何类型和任何大小的文本文件时，`Python`通常被认为是一个很好的选择。`string`对象通常由单引号或双引号定义，或者通过使用`str`函数转换另一个对象（即使用对象的标准或用户定义的`string`表示）来定义：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With regard to the built-in methods, you can, for example, capitalize the first
    word in this object:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 关于内置方法，例如，您可以将对象中的第一个单词大写：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Or you can split it into its single-word components to get a `list` object
    of all the words (more on `list` objects later):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以将其拆分为其单词组件以获得所有单词的`list`对象（稍后会有关于`list`对象的更多内容）：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can also search for a word and get the position (i.e., index value) of
    the first letter of the word back in a successful case:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以搜索单词并在成功情况下获得单词的第一个字母的位置（即，索引值）：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the word is not in the `string` object, the method returns -1:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单词不在`string`对象中，则该方法返回-1：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Replacing characters in a string is a typical task that is easily accomplished
    with the `replace` method:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 用`replace`方法轻松替换字符串中的字符是一个典型的任务：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The stripping of strings—i.e., deletion of certain leading/lagging characters—is
    also often necessary:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的剥离—即删除某些前导/后置字符—也经常是必要的：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[Table 3-1](#string_methods) lists a number of helpful methods of the `string`
    object.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 3-1](#string_methods) 列出了`string`对象的许多有用方法。'
- en: Table 3-1\. Selected string methods
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 3-1\. 选择的字符串方法
- en: '| Method | Arguments | Returns/result |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 参数 | 返回/结果 |'
- en: '| --- | --- | --- |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `capitalize` | `()` | Copy of the string with first letter capitalized |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `capitalize` | `()` | 第一个字母大写的字符串副本 |'
- en: '| `count` | `(sub[, start[, end]])` | Count of the number of occurrences of
    substring |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `count` | `(子串[, 开始[, 结束]])` | 子串出现次数的计数 |'
- en: '| `decode` | `([encoding[, errors]])` | Decoded version of the string, using
    `encoding` (e.g., UTF-8) |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `decode` | `([编码[, 错误]])` | 使用`编码`（例如，UTF-8）的字符串的解码版本 |'
- en: '| `encode` | `([encoding+[, errors]])` | Encoded version of the string |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `encode` | `([编码+[, 错误]])` | 字符串的编码版本 |'
- en: '| `find` | `(sub[, start[, end]])` | (Lowest) index where substring is found
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `find` | `(sub[, start[, end]])` | 找到子字符串的（最低）索引 |'
- en: '| `join` | `(seq)` | Concatenation of strings in sequence `seq` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `join` | `(seq)` | 将序列`seq`中的字符串连接起来 |'
- en: '| `replace` | `(old, new[, count])` | Replaces `old` by `new` the first `count`
    times |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `replace` | `(old, new[, count])` | 将`old`替换为`new`的第一个`count`次 |'
- en: '| `split` | `([sep[, maxsplit]])` | List of words in string with `sep` as separator
    |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `split` | `([sep[, maxsplit]])` | 以`sep`为分隔符的字符串中的单词列表 |'
- en: '| `splitlines` | `([keepends])` | Separated lines with line ends/breaks if
    `keepends` is `True` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `splitlines` | `([keepends])` | 如果`keepends`为`True`，则带有行结束符/断行的分隔行 |'
- en: '| `strip` | `(chars)` | Copy of string with leading/lagging characters in `chars`
    removed |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `strip` | `(chars)` | 删除`chars`中的前导/尾随字符的字符串的副本 |'
- en: '| `upper` | `()` | Copy with all letters capitalized |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `upper` | `()` | 复制并将所有字母大写 |'
- en: Caution
  id: totrans-129
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A fundamental change from Python 2.7 (first edition of the book) to Python 3.6
    (now used for the second edition) is the encoding and decoding of string objects
    and the introduction of Unicode (see [*https://docs.python.org/3/howto/unicode.html*](https://docs.python.org/3/howto/unicode.html)).
    This chapter does not allow to go into the many details important in this context.
    For the purposes of this book, which mainly deals with numerical data and standard
    strings containing English words, this omission seems justified.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 2.7（本书的第一版）到Python 3.6（本书的第二版使用的版本）的基本变化是字符串对象的编码和解码以及Unicode的引入（参见[*https://docs.python.org/3/howto/unicode.html*](https://docs.python.org/3/howto/unicode.html)）。本章不允许详细讨论此上下文中重要的许多细节。对于本书的目的，主要涉及包含英文单词的数字数据和标准字符串，这种省略似乎是合理的。
- en: 'Excursion: Printing and String Replacements'
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录：打印和字符串替换
- en: Printing `str` objects or string representations of other Python objects is
    usually accomplished by the `print()` function (used to be a statement in Python
    2.7).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 打印`str`对象或其他Python对象的字符串表示通常是通过`print()`函数完成的（在Python 2.7中是一个语句）。
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](images/1.png)](#co_mastering_the_basics_CO4-1)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](images/1.png)](#co_mastering_the_basics_CO4-1)'
- en: Prints a `str` object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 打印一个`str`对象。
- en: '[![2](images/2.png)](#co_mastering_the_basics_CO4-2)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](images/2.png)](#co_mastering_the_basics_CO4-2)'
- en: Prints a `str` object referenced by a variable name.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 打印由变量名引用的`str`对象。
- en: '[![3](images/3.png)](#co_mastering_the_basics_CO4-3)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](images/3.png)](#co_mastering_the_basics_CO4-3)'
- en: Prints the string representation of an `int` object.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 打印`int`对象的字符串表示。
- en: '[![4](images/4.png)](#co_mastering_the_basics_CO4-4)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](images/4.png)](#co_mastering_the_basics_CO4-4)'
- en: Specifies the final character(s) when printing; default is a line break `\n`
    as seen before.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 指定打印的最后一个字符（默认为前面看到的换行符`\n`）。
- en: Python offers powerful string replacement operations. There is the old way via
    the `%` character and the new way via curley brackets `{}` and `format()`. Both
    are still applied in practice. This section cannot provide an exhaustive illustration
    of all options, but the following code snippets show some important ones. First,
    the *old* way of doing it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了强大的字符串替换操作。有通过`%`字符进行的旧方法和通过花括号`{}`和`format()`进行的新方法。两者在实践中仍然适用。本节不能提供所有选项的详尽说明，但以下代码片段显示了一些重要的内容。首先，*旧*的方法。
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[![1](images/1.png)](#co_mastering_the_basics_CO5-1)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](images/1.png)](#co_mastering_the_basics_CO5-1)'
- en: '`int` object replacement.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`int`对象替换。'
- en: '[![2](images/2.png)](#co_mastering_the_basics_CO5-2)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](images/2.png)](#co_mastering_the_basics_CO5-2)'
- en: With fixed number of characters.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 带有固定数量的字符。
- en: '[![3](images/3.png)](#co_mastering_the_basics_CO5-3)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](images/3.png)](#co_mastering_the_basics_CO5-3)'
- en: With leading zeros if necessary.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必要，带有前导零。
- en: '[![4](images/4.png)](#co_mastering_the_basics_CO5-4)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](images/4.png)](#co_mastering_the_basics_CO5-4)'
- en: '`float` object replacement.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`float`对象替换。'
- en: '[![5](images/5.png)](#co_mastering_the_basics_CO5-5)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](images/5.png)](#co_mastering_the_basics_CO5-5)'
- en: With fixed number of decimals.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 带有固定数量的小数位数。
- en: '[![6](images/6.png)](#co_mastering_the_basics_CO5-6)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](images/6.png)](#co_mastering_the_basics_CO5-6)'
- en: With fixed number of characters (and filled up decimals).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 带有固定数量的字符（并填充小数）。
- en: '[![7](images/7.png)](#co_mastering_the_basics_CO5-7)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](images/7.png)](#co_mastering_the_basics_CO5-7)'
- en: With fixed number of characters and decimals …
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 带有固定数量的字符和小数位数…
- en: '[![8](images/8.png)](#co_mastering_the_basics_CO5-8)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](images/8.png)](#co_mastering_the_basics_CO5-8)'
- en: … and leading zeros if necessary.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: … 以及必要时的前导零。
- en: '[![9](images/9.png)](#co_mastering_the_basics_CO5-9)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](images/9.png)](#co_mastering_the_basics_CO5-9)'
- en: '`str` object replacement.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`str`对象替换。'
- en: '[![10](images/10.png)](#co_mastering_the_basics_CO5-10)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](images/10.png)](#co_mastering_the_basics_CO5-10)'
- en: With fixed number of characters.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 带有固定数量的字符。
- en: The same examples now implemented in the *new* way. Notice the slight differences
    in the output in some places.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在以*新*方式实现相同的示例。请注意，输出在某些地方略有不同。
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: String replacements are particularly useful in the context of multiple printing
    operations where the printed data is updated, for instance, during a `while` loop.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串替换在多次打印操作的上下文中特别有用，其中打印的数据会更新，例如，在`while`循环期间。
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Excursion: Regular Expressions'
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旅行：正则表达式
- en: 'A powerful tool when working with `string` objects is *regular expressions*.
    `Python` provides such functionality in the module `re`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理`string`对象时，使用*正则表达式*是一种强大的工具。`Python`在模块`re`中提供了这样的功能：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Suppose you are faced with a large text file, such as a comma-separated value
    (`CSV`) file, which contains certain time series and respective date-time information.
    More often than not, the date-time information is delivered in a format that `Python`
    cannot interpret directly. However, the date-time information can generally be
    described by a regular expression. Consider the following `string` object, containing
    three date-time elements, three integers, and three strings. Note that triple
    quotation marks allow the definition of strings over multiple rows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你面对一个大文本文件，例如一个逗号分隔值（`CSV`）文件，其中包含某些时间序列和相应的日期时间信息。往往情况下，日期时间信息以`Python`无法直接解释的格式提供。然而，日期时间信息通常可以通过正则表达式描述。考虑以下`string`对象，其中包含三个日期时间元素，三个整数和三个字符串。请注意，三重引号允许在多行上定义字符串：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The following regular expression describes the format of the date-time information
    provided in the `string` object:^([4](ch03.html#idm140277697069680))
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下正则表达式描述了提供在`string`对象中的日期时间信息的格式：^([4](ch03.html#idm140277697069680))
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Equipped with this regular expression, we can go on and find all the date-time
    elements. In general, applying regular expressions to `string` objects also leads
    to performance improvements for typical parsing tasks:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个正则表达式，我们可以继续找到所有日期时间元素。通常，将正则表达式应用于`string`对象还会导致典型解析任务的性能改进：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Regular Expressions
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: When parsing `string` objects, consider using regular expressions, which can
    bring both convenience and performance to such operations.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析`string`对象时，考虑使用正则表达式，这可以为此类操作带来便利性和性能。
- en: 'The resulting `string` objects can then be parsed to generate `Python datetime`
    objects (cf. [Link to Come] for an overview of handling date and time data with
    `Python`). To parse the `string` objects containing the date-time information,
    we need to provide information of how to parse—again as a `string` object:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以解析生成`Python datetime`对象的结果`string`对象（参见[Link to Come]，了解如何使用`Python`处理日期和时间数据的概述）。要解析包含日期时间信息的`string`对象，我们需要提供如何解析的信息
    —— 再次作为`string`对象：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Later chapters provide more information on date-time data, the handling of such
    data, and `datetime` objects and their methods. This is just meant to be a teaser
    for this important topic in finance.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 后续章节将提供有关日期时间数据的更多信息，以及处理此类数据和`datetime`对象及其方法。这只是对金融中这一重要主题的一个引子。
- en: Basic Data Structures
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本数据结构
- en: 'As a general rule, data structures are objects that contain a possibly large
    number of other objects. Among those that `Python` provides as built-in structures
    are:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个通用规则，数据结构是包含可能大量其他对象的对象。在`Python`提供的内置结构中包括：
- en: '`tuple`'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`tuple`'
- en: An immutable collection of arbitrary objects; only a few methods available
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不可变的任意对象的集合；只有少量方法可用
- en: '`list`'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`'
- en: A mutable collection of arbitrary objects; many methods available
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可变的任意对象的集合；有许多方法可用
- en: '`dict`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`dict`'
- en: A key-value store object
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 键-值存储对象
- en: '`set`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`'
- en: An unordered collection object for other *unique* objects
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 用于其他*唯一*对象的无序集合对象
- en: Tuples
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组
- en: 'A `tuple` is an advanced data structure, yet it’s still quite simple and limited
    in its applications. It is defined by providing objects in parentheses:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`tuple`是一种高级数据结构，但在其应用中仍然相当简单且有限。通过在括号中提供对象来定义它：'
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can even drop the parentheses and provide multiple objects, just separated
    by commas:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以放弃括号，提供多个对象，只需用逗号分隔：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Like almost all data structures in `Python` the ``tuple`` has a built-in index,
    with the help of which you can retrieve single or multiple elements of the `tuple`.
    It is important to remember that `Python` uses *zero-based numbering*, such that
    the third element of a `tuple` is at index position 2:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 像几乎所有的`Python`数据结构一样，``tuple``具有内置索引，借助它可以检索单个或多个`tuple`元素。重要的是要记住，`Python`使用*零基编号*，因此`tuple`的第三个元素位于索引位置2：
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Zero-Based Numbering
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 零基编号
- en: In contrast to some other programming languages like `Matlab`, `Python` uses
    zero-based numbering schemes. For example, the first element of a `tuple` object
    has index value 0.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他一些编程语言（如`Matlab`）相比，`Python`使用零基编号方案。例如，`tuple`对象的第一个元素的索引值为0。
- en: 'There are only two special methods that this object type provides: `count`
    and `index`. The first counts the number of occurrences of a certain object and
    the second gives the index value of the first appearance of it:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对象类型提供的特殊方法仅有两个：`count`和`index`。第一个方法统计某个对象的出现次数，第二个方法给出其第一次出现的索引值：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`tuple` objects are *immutable* objects. This means that they, once defined,
    cannot be changed easily.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`tuple`对象是*不可变*对象。这意味着一旦定义，它们就不容易更改。'
- en: Lists
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: 'Objects of type `list` are much more flexible and powerful in comparison to
    `tuple` objects. From a finance point of view, you can achieve a lot working only
    with `list` objects, such as storing stock price quotes and appending new data.
    A `list` object is defined through brackets and the basic capabilities and behavior
    are similar to those of `tuple` objects:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为`list`的对象比`tuple`对象更加灵活和强大。从财务角度来看，你可以仅使用`list`对象就能实现很多，比如存储股价报价和添加新数据。`list`对象通过括号定义，其基本功能和行为与`tuple`对象相似：
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`list` objects can also be defined or converted by using the function `list`.
    The following code generates a new `list` object by converting the `tuple` object
    from the previous example:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过使用函数`list`来定义或转换`list`对象。以下代码通过转换前面示例中的`tuple`对象生成一个新的`list`对象：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In addition to the characteristics of `tuple` objects, ``list`` objects are
    also expandable and reducible via different methods. In other words, whereas `string`
    and `tuple` objects are *immutable* sequence objects (with indexes) that cannot
    be changed once created, `list` objects are *mutable* and can be changed via different
    operations. You can append `list` objects to an existing `list` object, and more:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`tuple`对象的特性外，``list``对象还可以通过不同的方法进行扩展和缩减。换句话说，虽然`string`和`tuple`对象是*不可变*序列对象（具有索引），一旦创建就无法更改，但`list`对象是*可变*的，并且可以通过不同的操作进行更改。你可以将`list`对象附加到现有的`list`对象上，等等：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[![1](images/1.png)](#co_mastering_the_basics_CO6-1)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](images/1.png)](#co_mastering_the_basics_CO6-1)'
- en: Append `list` object at the end.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在末尾附加`list`对象。
- en: '[![2](images/2.png)](#co_mastering_the_basics_CO6-2)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](images/2.png)](#co_mastering_the_basics_CO6-2)'
- en: Append elements of the `list` object.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`list`对象的元素。
- en: '[![3](images/3.png)](#co_mastering_the_basics_CO6-3)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](images/3.png)](#co_mastering_the_basics_CO6-3)'
- en: Insert object before index position.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在索引位置之前插入对象。
- en: '[![4](images/4.png)](#co_mastering_the_basics_CO6-4)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](images/4.png)](#co_mastering_the_basics_CO6-4)'
- en: Remove first occurence of object.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 删除对象的第一次出现。
- en: '[![5](images/5.png)](#co_mastering_the_basics_CO6-5)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](images/5.png)](#co_mastering_the_basics_CO6-5)'
- en: Removes and returns object at index position.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 删除并返回索引位置的对象。
- en: 'Slicing is also easily accomplished. Here, *slicing* refers to an operation
    that breaks down a data set into smaller parts (of interest):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 切片也很容易实现。在这里，*切片*指的是将数据集分解为较小部分（感兴趣的部分）的操作：
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[![1](images/1.png)](#co_mastering_the_basics_CO7-1)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](images/1.png)](#co_mastering_the_basics_CO7-1)'
- en: 3rd to 5th element.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第三到第五个元素。
- en: '[Table 3-2](#list_methods) provides a summary of selected operations and methods
    of the `list` object.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[Table 3-2](#list_methods)提供了`list`对象的选定操作和方法的摘要。'
- en: Table 3-2\. Selected operations and methods of list objects
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 表3-2\. `list`对象的选定操作和方法
- en: '| Method | Arguments | Returns/result |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 参数 | 返回/结果 |'
- en: '| --- | --- | --- |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `l[i] = x` | `[i]` | Replaces `i`-th element by `x` |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `l[i] = x` | `[i]` | 将第`i`个元素替换为`x` |'
- en: '| `l[i:j:k] = s` | `[i:j:k]` | Replaces every `k`-th element from `i` to `j
    - 1` by `s` |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `l[i:j:k] = s` | `[i:j:k]` | 用`s`替换从`i`到`j-1`的每个第`k`个元素 |'
- en: '| `append` | `(x)` | Appends `x` to object |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `append` | `(x)` | 将`x`附加到对象 |'
- en: '| `count` | `(x)` | Number of occurrences of object `x` |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `count` | `(x)` | 对象`x`的出现次数 |'
- en: '| `del l[i:j:k]` | `[i:j:k]` | Deletes elements with index values `i` to `j
    – 1` |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `del l[i:j:k]` | `[i:j:k]` | 删除索引值为`i`到`j-1`的元素 |'
- en: '| `extend` | `(s)` | Appends all elements of `s` to object |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `extend` | `(s)` | 将`s`的所有元素附加到对象 |'
- en: '| `index` | `(x[, i[, j]])` | First index of `x` between elements `i` and `j
    – 1` |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `index` | `(x[, i[, j]])` | 元素`i`和`j-1`之间`x`的第一个索引 |'
- en: '| `insert` | `(i, x)` | Inserts `x` at/before index `i` |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `insert` | `(i, x)` | 在索引`i`之前/后插入`x` |'
- en: '| `remove` | `(i)` | Removes element with index `i` |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `remove` | `(i)` | 删除索引为`i`的元素 |'
- en: '| `pop` | `(i)` | Removes element with index `i` and return it |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `pop` | `(i)` | 删除索引为`i`的元素并返回它 |'
- en: '| `reverse` | `()` | Reverses all items in place |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `reverse` | `()` | 将所有项目原地颠倒 |'
- en: '| `sort` | `([cmp[, key[, reverse]]])` | Sorts all items in place |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `sort` | `([cmp[, key[, reverse]]])` | 原地对所有项目排序 |'
- en: 'Excursion: Control Structures'
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专题：控制结构
- en: 'Although a topic in itself, *control structures* like `for` loops are maybe
    best introduced in `Python` based on `list` objects. This is due to the fact that
    looping in general takes place over `list` objects, which is quite different to
    what is often the standard in other languages. Take the following example. The
    `for` loop loops over the elements of the `list` object `l` with index values
    2 to 4 and prints the square of the respective elements. Note the importance of
    the indentation (whitespace) in the second line:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然控制结构本身是一个专题，像`for`循环这样的*控制结构*可能最好是基于`Python`中的`list`对象介绍的。这是因为一般情况下循环是在`list`对象上进行的，这与其他语言中通常的标准相当不同。看下面的例子。`for`循环遍历`list`对象`l`的元素，索引值为2到4，并打印出相应元素的平方。注意第二行缩进（空格）的重要性：
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This provides a really high degree of flexibility in comparison to the typical
    counter-based looping. Counter-based looping is also an option with `Python`,
    but is accomplished based on the (standard) `list` object `range`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这相比于典型的基于计数器的循环提供了非常高的灵活性。基于（标准的）`list`对象`range`也可以使用计数器进行循环：
- en: '[PRE43]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[![1](images/1.png)](#co_mastering_the_basics_CO8-1)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](images/1.png)](#co_mastering_the_basics_CO8-1)'
- en: Parameters are `start`, `end`, `step size`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是`start`、`end`、`step size`。
- en: 'For comparison, the same loop is implemented using `range` as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较，相同的循环使用`range`实现如下：
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Looping over Lists
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历列表
- en: In `Python` you can loop over arbitrary `list` objects, no matter what the content
    of the object is. This often avoids the introduction of a counter.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Python`中，你可以遍历任意的`list`对象，不管对象的内容是什么。这通常避免了引入计数器。
- en: '`Python` also provides the typical (conditional) control elements `if`, `elif`,
    and `else`. Their use is comparable in other languages:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`Python`还提供了典型的（条件）控制元素`if`、`elif`和`else`。它们在其他语言中的使用方式类似：'
- en: '[PRE45]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[![1](images/1.png)](#co_mastering_the_basics_CO9-1)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](images/1.png)](#co_mastering_the_basics_CO9-1)'
- en: '`%` stands for modulo.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`%`代表取模。'
- en: 'Similarly, `while` provides another means to control the flow:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`while`提供了另一种控制流的手段：
- en: '[PRE46]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'A specialty of `Python` is so-called `list` *comprehensions*. Instead of looping
    over existing `list` objects, this approach generates `list` objects via loops
    in a rather compact fashion:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`Python`的一个特点是所谓的`list` *推导式*。与遍历现有`list`对象不同，这种方法以一种相当紧凑的方式通过循环生成`list`对象：'
- en: '[PRE47]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In a certain sense, this already provides a first means to generate “something
    like” vectorized code in that loops are rather more implicit than explicit (vectorization
    of code is discussed in more detail later in this chapter).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，这已经提供了一种生成“类似”的向量化代码的第一手段，因为循环相对来说更加隐式而不是显式的（代码的向量化将在本章后面更详细地讨论）。
- en: 'Excursion: Functional Programming'
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专题：功能编程
- en: '`Python` provides a number of tools for functional programming support as well—i.e.,
    the application of a function to a whole set of inputs (in our case `list` objects).
    Among these tools are `filter`, `map`, and `reduce`. However, we need a function
    definition first. To start with something really simple, consider a function `f`
    that returns the square of the input `x`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`Python`还提供了一些功能编程支持工具，即将函数应用于整套输入（在我们的情况下是`list`对象）。其中包括`filter`、`map`和`reduce`。然而，我们首先需要一个函数定义。首先从一个非常简单的函数开始，考虑一个返回输入`x`的平方的函数`f`：'
- en: '[PRE48]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Of course, functions can be arbitrarily complex, with multiple input/parameter
    objects and even multiple outputs, (return objects). However, consider the following
    function:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，函数可以是任意复杂的，具有多个输入/参数对象，甚至多个输出（返回对象）。但是，考虑以下函数：
- en: '[PRE49]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The return object is a Boolean. Such a function can be applied to a whole `list`
    object by using `map`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 返回对象是一个布尔值。这样的函数可以通过使用 `map` 应用于整个 `list` 对象：
- en: '[PRE50]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To this end, we can also provide a function definition directly as an argument
    to `map`, by using `lambda` or *anonymous* functions:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们还可以直接将函数定义作为 `map` 的参数提供，通过使用 `lambda` 或*匿名*函数：
- en: '[PRE51]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Functions can also be used to filter a `list` object. In the following example,
    the filter returns elements of a `list` object that match the Boolean condition
    as defined by the `even` function:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以用于过滤 `list` 对象。在下面的示例中，过滤器返回符合由 `even` 函数定义的布尔条件的 `list` 对象元素：
- en: '[PRE52]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: List Comprehensions, Functional Programming, Anonymous Functions
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表推导、函数式编程、匿名函数
- en: It can be considered *good practice* to avoid loops on the `Python` level as
    far as possible. `list` comprehensions and functional programming tools like `map`,
    `filter`, and `reduce` provide means to write code without (explicit) loops that
    is both compact and in general more readable. `lambda` or anonymous functions
    are also powerful tools in this context.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Python` 级别尽可能避免使用循环被认为是*良好的实践*。`list` 推导和函数式编程工具如 `map`、`filter` 和 `reduce`
    提供了编写没有（显式）循环的代码的方法，这种代码既紧凑又通常更可读。在这种情况下，`lambda` 或匿名函数也是强大的工具。
- en: Dicts
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典
- en: '`dict` objects are dictionaries, and also mutable sequences, that allow data
    retrieval by keys that can, for example, be `string` objects. They are so-called
    *key-value stores*. While `list` objects are ordered and sortable, `dict` objects
    are unordered and unsortable. An example best illustrates further differences
    to `list` objects. Curly brackets are what define `dict` objects:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`dict` 对象是字典，也是可变序列，允许通过可以是 `string` 对象的键来检索数据。它们被称为*键值存储*。虽然 `list` 对象是有序且可排序的，但
    `dict` 对象是无序且不可排序的。通过示例可以更好地说明与 `list` 对象的进一步差异。花括号是定义 `dict` 对象的标志：'
- en: '[PRE53]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Again, this class of objects has a number of built-in methods:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这类对象具有许多内置方法：
- en: '[PRE54]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'There are several methods to get `iterator` objects from the `dict` object.
    The objects behave like `list` objects when iterated over:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从 `dict` 对象获取 `iterator` 对象。当进行迭代时，这些对象的行为类似于 `list` 对象：
- en: '[PRE55]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[Table 3-3](#dict_methods) provides a summary of selected operations and methods
    of the `dict` object.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-3](#dict_methods) 提供了 `dict` 对象的选定操作和方法的摘要。'
- en: Table 3-3\. Selected operations and methods of dict objects
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-3\. `dict` 对象的选定操作和方法
- en: '| Method | Arguments | Returns/result |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 参数 | 返回/结果 |'
- en: '| --- | --- | --- |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `d[k]` | `[k]` | Item of `d` with key `k` |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `d[k]` | `[k]` | `d` 中具有键 `k` 的项目 |'
- en: '| `d[k] = x` | `[k]` | Sets item key `k` to `x` |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `d[k] = x` | `[k]` | 将项目键 `k` 设置为 `x` |'
- en: '| `del d[k]` | `[k]` | Deletes item with key `k` |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `del d[k]` | `[k]` | 删除具有键 `k` 的项目 |'
- en: '| `clear` | `()` | Removes all items |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `clear` | `()` | 删除所有项目 |'
- en: '| `copy` | `()` | Makes a copy |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `copy` | `()` | 复制一个副本 |'
- en: '| `has_key` | `(k)` | `True` if `k` is a key |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `has_key` | `(k)` | 如果 `k` 是键，则为 `True` |'
- en: '| `items` | `()` | Iterator over all items |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `items` | `()` | 迭代器遍历所有项目 |'
- en: '| `keys` | `()` | Iterator over all keys |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `keys` | `()` | 迭代器遍历所有键 |'
- en: '| `values` | `()` | Iterator over all values |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `values` | `()` | 迭代器遍历所有值 |'
- en: '| `popitem` | `(k)` | Returns and removes item with key `k` |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `popitem` | `(k)` | 返回并删除具有键 `k` 的项目 |'
- en: '| `update` | `([e])` | Updates items with items from `e` |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `update` | `([e])` | 用 `e` 中的项目更新项目 |'
- en: Sets
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: 'The last data structure we will consider is the `set` object. Although set
    theory is a cornerstone of mathematics and also finance theory, there are not
    too many practical applications for `set` objects. The objects are unordered collections
    of other objects, containing every element only once:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑的最后一个数据结构是 `set` 对象。尽管集合论是数学和金融理论的基石，但对于 `set` 对象的实际应用并不太多。这些对象是其他对象的无序集合，每个元素只包含一次：
- en: '[PRE56]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'With `set` objects, you can implement operations as you are used to in mathematical
    set theory. For example, you can generate unions, intersections, and differences:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `set` 对象，您可以像在数学集合论中一样实现操作。例如，您可以生成并集、交集和差异：
- en: '[PRE57]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[![1](images/1.png)](#co_mastering_the_basics_CO10-1)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](images/1.png)](#co_mastering_the_basics_CO10-1)'
- en: All of `s` and `t`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`s` 和 `t` 的全部。'
- en: '[![2](images/2.png)](#co_mastering_the_basics_CO10-2)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](images/2.png)](#co_mastering_the_basics_CO10-2)'
- en: Both in `s` and `t`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `s` 和 `t` 中都有。
- en: '[![3](images/3.png)](#co_mastering_the_basics_CO10-3)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](images/3.png)](#co_mastering_the_basics_CO10-3)'
- en: In `s` but not in `t`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `s` 中但不在 `t` 中。
- en: '[![4](images/4.png)](#co_mastering_the_basics_CO10-4)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](images/4.png)](#co_mastering_the_basics_CO10-4)'
- en: In `t` but not in `s`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `t` 中但不在 `s` 中。
- en: '[![5](images/5.png)](#co_mastering_the_basics_CO10-5)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](images/5.png)](#co_mastering_the_basics_CO10-5)'
- en: In either one but not both.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中一个但不是两者都。
- en: 'One application of `set` objects is to get rid of duplicates in a `list` object.
    For example:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`对象的一个应用是从`list`对象中消除重复项。例如：'
- en: '[PRE58]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[![1](images/1.png)](#co_mastering_the_basics_CO11-1)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](images/1.png)](#co_mastering_the_basics_CO11-1)'
- en: 1,000 random integers between 0 and 10.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 1,000个0到10之间的随机整数。
- en: '[![2](images/2.png)](#co_mastering_the_basics_CO11-2)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](images/2.png)](#co_mastering_the_basics_CO11-2)'
- en: Number of elements in `l`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`l` 中的元素数量。'
- en: Conclusions
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'The basic `Python` interpreter provides already a rich set of flexible data
    structures. From a finance point of view, the following can be considered the
    most important ones:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的`Python`解释器已经提供了丰富灵活的数据结构。从金融的角度来看，以下可以被认为是最重要的：
- en: Basic data types
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 基本数据类型
- en: In finance, the classes `int`, `float`, and `string` provide the atomic data
    types.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在金融中，`int`、`float`和`string`类提供了原子数据类型。
- en: Standard data structures
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 标准数据结构
- en: The classes `tuple`, `list`, `dict`, and `set` have many application areas in
    finance, with `list` being the most flexible workhorse in general.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`tuple`、`list`、`dict`和`set`类在金融领域有许多应用领域，其中`list`通常是最灵活的通用工作马。'
- en: Further Resources
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步资源
- en: This chapter focuses on those issues that might be of particular importance
    for finance algorithms and applications. However, it can only represent a starting
    point for the exploration of data structures and data modeling in `Python`. There
    are a number of valuable resources available to go deeper from here.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点讨论可能对金融算法和应用特别重要的问题。但是，它只能代表探索`Python`中数据结构和数据建模的起点。有许多宝贵的资源可供进一步深入了解。
- en: 'Good references in book form are:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍形式的良好参考资料包括：
- en: 'Goodrich, Michael et al. (2013): *Data Structures and Algorithms in Python.*
    John Wiley & Sons, Hoboken, NJ.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Goodrich, Michael 等（2013）：*Python 数据结构与算法.* John Wiley & Sons, Hoboken, NJ.
- en: 'Harrison, Matt (2017): *Illustrated Guide to Python 3.* Treading on Python
    Series.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Harrison, Matt (2017): *Python 3图解指南*. Treading on Python Series.'
- en: 'Ramalho, Luciano (2016): *Fluent Python*. O’Reilly, Beijing et al.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ramalho, Luciano (2016): *流畅的Python*. O’Reilly, Beijing et al.'
- en: ^([1](ch03.html#idm140277701762352-marker)) The [`Cython` library](http://www.cython.org)
    brings static typing and compiling features to `Python` that are comparable to
    those in `C`. In fact, `Cython` is a hybrid language of `Python` and `C`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.html#idm140277701762352-marker)) [`Cython`库](http://www.cython.org)将静态类型和编译功能引入`Python`，与`C`中的相似。实际上，`Cython`是`Python`和`C`的混合语言。
- en: ^([2](ch03.html#idm140277701533120-marker)) Here and in the following discussion,
    terms like *float*, *float object*, etc. are used interchangeably, acknowledging
    that every *float* is also an *object*. The same holds true for other object types.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch03.html#idm140277701533120-marker)) 在这里和后续讨论中，诸如*float*、*float 对象*等术语可互换使用，承认每个*float*也是一个*对象*。对于其他对象类型也是如此。
- en: ^([3](ch03.html#idm140277701447424-marker)) Cf. [*http://en.wikipedia.org/wiki/Double-precision_floating-point_format*](http://en.wikipedia.org/wiki/Double-precision_floating-point_format).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch03.html#idm140277701447424-marker)) 参考[*http://en.wikipedia.org/wiki/Double-precision_floating-point_format*](http://en.wikipedia.org/wiki/Double-precision_floating-point_format)。
- en: '^([4](ch03.html#idm140277697069680-marker)) It is not possible to go into details
    here, but there is a wealth of information available on the Internet about regular
    expressions in general and for `Python` in particular. For an introduction to
    this topic, refer to Fitzgerald, Michael (2012): *Introducing Regular Expressions*.
    O’Reilly, Sebastopol, CA.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '^([4](ch03.html#idm140277697069680-marker)) 在这里不可能详细介绍，但互联网上有大量关于正则表达式的信息，特别是针对`Python`。关于这个主题的介绍，请参阅Fitzgerald,
    Michael (2012): *正则表达式入门*. O’Reilly, Sebastopol, CA.'
