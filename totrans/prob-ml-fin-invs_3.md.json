["```py\n# Import modules\nimport numpy as np\nfrom numpy import random as npr\nimport matplotlib.pyplot as plt\n\n# Number of iterations in the simulation\nn = 100000\n\n# Draw random points from a uniform distribution in the X-Y plane to fill \n#the area of a square that has a side of 2 units\nx = npr.uniform(low=-1, high=1, size=n)\ny = npr.uniform(low=-1, high=1, size=n)\n\n# Points with a distance less than or equal to one unit from the origin will \n# be inside the area of the unit circle. \n# Using Pythagoras's theorem c^2 = a^2 + b^2\ninside = np.sqrt(x**2 + y**2) <=1\n\n# We generate N random points within our square and count the number of points \n# that fall within the circle. Summing the points inside the circle is equivalent \n# to integrating over the area of the circle. \n\n# Note that the ratio of the area of the circle to the area of the square is \n# pi*r^2/(2*r)^2 = pi/4\\. So if we can calculate the areas of the circle \n# and the square, we can solve for pi\npi = 4.0*sum(inside)/n \n\n# Estimate percentage error using the theoretical value of Pi\nerror = abs((pi-np.pi)/np.pi)*100\n\nprint(\"After {0} simulations, our estimate of Pi is {1} with an error of {2}%\"\n.format(n, pi, round(error,2)))\n\n# Points outside the circle are the negation of the boolean array inside\noutside = np.invert(inside)\n\n# Plot the graph\nplt.plot(x[inside], y[inside], 'b.')\nplt.plot(x[outside], y[outside], 'r.')\nplt.axis('square');\n```", "```py\n# Import Python libraries\nimport pandas as pd\nfrom datetime import datetime\nimport numpy as np\n\nimport matplotlib.pyplot as plt\nplt.style.use('seaborn')\n\n# Install web scraper for Yahoo Finance\n!pip install yfinance\nimport yfinance as yf\n\n# Import over 30 years of S&P 500 ('SPY') price data into a dataframe \n# called equity\nstart = datetime(1993, 2, 1)\nend = datetime(2022, 10, 15)\nequity = yf.Ticker('SPY').history(start=start, end=end)\n\n# Use SPY's closing prices to compute its daily returns. \n# Remove NaNs from your dataframe.\nequity['Returns'] = equity['Close'].pct_change(1)*100\nequity = equity.dropna()\n\n# Visualize and summarize SPY's daily price returns. \n# Compute its skewness and kurtosis.\nplt.hist(equity['Returns']), plt.title('Distribution of S&P 500 Daily Percentage \nReturns Over the Past 30 Years'), plt.xlabel('Daily Percentage Returns'), \nplt.ylabel('Frequency'), plt.show();\nprint(\"Descriptive statistics of S&P 500 percentage returns:\\n{}\"\n.format(equity['Returns'].describe().round(2)))\nprint('The skewness of S&P 500 returns is: {0:.2f} and the kurtosis is: {1:.2f}.'\n.format(equity['Returns'].skew(), equity['Returns'].kurtosis()))\n```", "```py\n# Estimate the mean and standard deviation from SPY's 30 year historical data\nmean = equity['Returns'].mean()\nvol = equity['Returns'].std()\nsample = equity['Returns'].count()\n\n# Use NumPy's random number generator to sample from a normal distribution\n# with the above estimates of its mean and standard deviation\n# Create a new column called 'Simulated' and generate the same number of \n# random samples from NumPy's normal distribution as the actual data sample\n# you've imported above for SPY\nequity['Simulated'] = np.random.normal(mean, vol, sample)\n\n# Visualize and summarize SPY's simulated daily price returns.\nplt.hist(equity['Simulated']), plt.title('Distribution of S&P 500 Simulated \nDaily Returns'), plt.xlabel('Simulated Daily Percentage Returns'), \nplt.ylabel('Frequency'), plt.show();\nprint(\"Descriptive statistics of S&P 500 stock's simulated percentage \nreturns:\\n{}\".\nformat(equity['Simulated'].describe()))\n\n# Compute the skewness and kurtosis of the simulated daily price returns.\nprint('The skewness of S&P 500 simulated returns is: {0} \nand the kurtosis is: \n{1}.'.format(equity['Simulated'].skew().round(2), equity['Simulated']\n.kurtosis().round(2)))\n```", "```py\n# Import key Python libraries and packages that we need to process and analyze \n# our data\nimport pandas as pd\nfrom datetime import datetime\nimport numpy as np\nfrom numpy import random as npr\nimport matplotlib.pyplot as plt \nplt.style.use('seaborn')\n\n# Specify model constants per full-time equivalent (fte)\ndaily_rate = 400\ntechnology_charges = 500\noverhead_charges = 200\n\n# Specify other constants\ntax_rate = 0.15\n\n# Specify model risk factors that have little or no correlation among them.\n# Number of trials/simulations\nn = 10000\n# Number of full-time equivalent persons on the team\nfte = npr.uniform(low=1, high=5, size=n)\n# In person days and driven independently by the scope of the project\neffort = npr.uniform(low=240, high=480, size=n)\n# Based on market research or expert judgment or both\nprice = npr.uniform(low=100, high=200, size=n)\n# Independent of price in the price range considered\nunits = npr.normal(loc=1000, scale=500, size=n)\n# Discount rate for the project period based on risk of similar efforts \ndiscount_rate = npr.uniform(low=0.06, high=0.10, size=n)\n\n# Specify how risk factors affect the project model\nlabor_costs = effort * daily_rate\ntechnology_costs = fte * technology_charges\noverhead_costs = fte * overhead_charges\nrevenues = price * units\n# Duration determines the number of days the project will take to complete\n# assuming no interruption. Different from the elapsed time of the project.\nduration = effort/fte\n\n# Specify target_value\nfree_cash_flow = (revenues - labor_costs - technology_costs - overhead_costs) \n                 * (1 - tax_rate)\n\n# Simulate project NPV assuming initial FCF=0\nnpv = free_cash_flow/(1 + discount_rate)\n\n# Convert numpy array to pandas DataFrame for easier analysis\nNPV = pd.DataFrame(npv, columns=['NPV'])\n# Estimate project duration in days\nDuration = pd.DataFrame(duration, columns=['Days'])\n\n# Plot histogram of NPV distribution\nplt.hist(NPV['NPV'], bins=50), plt.title ('Distribution of Project NPV'), \nplt.xlabel('Project NPV'), \nplt.ylabel('Frequency'), plt.show();\nprint(NPV.describe().round())\nsuccess_probability = sum(NPV['NPV'] > 0)/n *100\nprint('There is a {0}% probability that the project will have a positive NPV.'\n.format(round(success_probability)))\n# Plot histogram of project duration distribution\nplt.hist(Duration['Days'], bins=50), \nplt.title ('Distribution of Project Duration'), plt.xlabel('Days'), \nplt.ylabel('Frequency'), plt.show();\nprint(Duration.describe().round())\n```"]