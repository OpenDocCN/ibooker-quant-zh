- en: Chapter 4\. Linear Algebra and Calculus for Deep Learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Algebra and calculus are integral parts of data science. Machine learning and
    deep learning algorithms are mostly based on algebra and calculus techniques.
    This chapter introduces some key topics in a way that everyone can understand.
  prefs: []
  type: TYPE_NORMAL
- en: '*Algebra *is the study of operations and relational rules, as well as the constructions
    and ideas that result from them. Algebra covers topics such as linear equations
    and matrices. You can consider algebra as the first step toward calculus.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Calculus *is the study of curve slopes and rates of change. Calculus covers
    topics such as derivatives and integrals. It is heavily used in many fields such
    as economics and engineering. Many learning algorithms rely on the concepts of
    calculus to perform their complex operations.'
  prefs: []
  type: TYPE_NORMAL
- en: The distinction between the two is that while calculus works with ideas of change,
    motion, and accumulation, algebra deals with mathematical symbols and the rules
    for manipulating those symbols. Calculus focuses on the characteristics and behavior
    of changing functions, while algebra offers the foundation for solving equations
    and comprehending functions.
  prefs: []
  type: TYPE_NORMAL
- en: Linear Algebra
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Algebra encompasses various mathematical structures, including numbers, variables,
    and operations like addition, subtraction, multiplication, and division. *Linear
    algebra* is a fundamental branch of algebra that deals with vector spaces and
    linear transformations. It is heavily used in machine learning and deep learning
    for tasks such as data preprocessing, dimensionality reduction, and solving systems
    of linear equations. Matrices and vectors are central data structures in linear
    algebra, and operations like matrix multiplication are common in various algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Vectors and Matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *vector* is an object that has a magnitude (length) and a direction (arrowhead).
    The basic representation of a vector is an arrow with coordinates on the axis.
    But first, let’s see what an axis is.
  prefs: []
  type: TYPE_NORMAL
- en: The *x*-axis and *y*-axis are perpendicular lines that specify a plane’s boundaries
    and the locations of different points within them in a two-dimensional Cartesian
    coordinate system. The *x*-axis is horizontal and the *y*-axis is vertical.
  prefs: []
  type: TYPE_NORMAL
- en: These axes may represent vectors, with the *x*-axis representing the vector’s
    horizontal component and the *y*-axis representing its vertical component.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In time series analysis, the *x*-axis is typically the time step (hours, days,
    etc.), and the *y*-axis is the value at the respective time step (price, return,
    etc.).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-1](#figure-4-1) shows a simple two-dimensional Cartesian coordinate
    system with both axes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The two-dimensional Cartesian coordinate system uses simple parentheses to
    show the location of different points following this order:'
  prefs: []
  type: TYPE_NORMAL
- en: Point coordinates = (`x`, `y`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable `x` represents the horizontal location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable `y` represents the horizontal location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/dlff_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. A two-dimensional Cartesian coordinate system
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Therefore, if you want to draw point A, which has (2, 3) as coordinates, you
    are likely to look at a graph from point zero, move two points to the right, and
    from there, move three points upward. The result of the point should look like
    [Figure 4-2](#figure-4-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. The location of A on the coordinate system
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s now add another point and draw a vector between them. Suppose you have
    point B with (4, 5) as coordinates. Naturally, as the coordinates of B are higher
    than the coordinates of A, you would expect vector AB to be upward sloping. [Figure 4-3](#figure-4-3)
    shows the new point B and vector AB.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_0403.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3\. Vector AB joining points A and B together in magnitude and direction
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'However, having drawn the vector using the coordinates of both points, how
    would you refer to the vector? Simply put, vector AB has its own coordinates that
    represent it. Remember that the vector is a representation of the movement from
    point A to point B. This means the two-point movement along the *x*-axis and the
    *y*-axis is the vector. Mathematically, to find the vector, you should subtract
    the two coordinate points from each other while respecting the direction. Here’s
    how to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Vector AB* means that you are going from A to B; therefore, you need to subtract
    the coordinates of point B from the coordinates of point A:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row  ModifyingAbove upper A upper B With right-arrow
    equals mathematical left-angle 4 minus 2 comma 5 minus 3 mathematical right-angle
    2nd Row  ModifyingAbove upper A upper B With right-arrow equals mathematical left-angle
    2 comma 2 mathematical right-angle EndLayout"><mtable><mtr><mtd columnalign="left"><mrow><mover
    accent="true"><mrow><mi>A</mi><mi>B</mi></mrow> <mo>→</mo></mover> <mo>=</mo>
    <mrow><mo>〈</mo> <mn>4</mn> <mo>-</mo> <mn>2</mn> <mo>,</mo> <mn>5</mn> <mo>-</mo>
    <mn>3</mn> <mo>〉</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mover
    accent="true"><mrow><mi>A</mi><mi>B</mi></mrow> <mo>→</mo></mover> <mo>=</mo>
    <mrow><mo>〈</mo> <mn>2</mn> <mo>,</mo> <mn>2</mn> <mo>〉</mo></mrow></mrow></mtd></mtr></mtable></math>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Vector BA* means that you are going from B to A; therefore, you need to subtract
    the coordinates of point A from the coordinates of point B:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row  ModifyingAbove upper B upper A With right-arrow
    equals mathematical left-angle 2 minus 4 comma 3 minus 5 mathematical right-angle
    2nd Row  ModifyingAbove upper B upper A With right-arrow equals mathematical left-angle
    negative 2 comma negative 2 mathematical right-angle EndLayout"><mtable><mtr><mtd
    columnalign="left"><mrow><mover accent="true"><mrow><mi>B</mi><mi>A</mi></mrow>
    <mo>→</mo></mover> <mo>=</mo> <mrow><mo>〈</mo> <mn>2</mn> <mo>-</mo> <mn>4</mn>
    <mo>,</mo> <mn>3</mn> <mo>-</mo> <mn>5</mn> <mo>〉</mo></mrow></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mover accent="true"><mrow><mi>B</mi><mi>A</mi></mrow>
    <mo>→</mo></mover> <mo>=</mo> <mrow><mo>〈</mo> <mo>-</mo> <mn>2</mn> <mo>,</mo>
    <mo>-</mo> <mn>2</mn> <mo>〉</mo></mrow></mrow></mtd></mtr></mtable></math>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To interpret the AB and BA vectors, you need to think in terms of movement.
    Vector AB represents going from point A to point B, two positive points horizontally
    and vertically (to the right and upward, respectively). Vector BA represents going
    from point B to point A, two negative points horizontally and vertically (to the
    left and downward, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Vectors AB and BA are not the same thing even though they share the same slope.
    But what is a slope anyway?
  prefs: []
  type: TYPE_NORMAL
- en: 'The *slope* is the ratio of the vertical change between two points on the line
    to the horizontal change between the same two points. You calculate the slope
    using this mathematical formula:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row  upper S l o p e equals StartFraction left-parenthesis
    normal upper Delta upper Y right-parenthesis Over left-parenthesis normal upper
    Delta upper X right-parenthesis EndFraction 2nd Row  upper S l o p e o f ModifyingAbove
    upper A upper B With right-arrow equals two-halves equals 1 3rd Row  upper S l
    o p e o f ModifyingAbove upper B upper A With right-arrow equals StartFraction
    negative 2 Over negative 2 EndFraction equals 1 EndLayout"><mtable><mtr><mtd columnalign="left"><mrow><mi>S</mi>
    <mi>l</mi> <mi>o</mi> <mi>p</mi> <mi>e</mi> <mo>=</mo> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><mrow><mo>(</mo><mi>Δ</mi><mi>Y</mi><mo>)</mo></mrow> <mrow><mo>(</mo><mi>Δ</mi><mi>X</mi><mo>)</mo></mrow></mfrac></mstyle></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>S</mi> <mi>l</mi> <mi>o</mi> <mi>p</mi>
    <mi>e</mi> <mi>o</mi> <mi>f</mi> <mover accent="true"><mrow><mi>A</mi><mi>B</mi></mrow>
    <mo>→</mo></mover> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mn>2</mn>
    <mn>2</mn></mfrac></mstyle> <mo>=</mo> <mn>1</mn></mrow></mtd></mtr> <mtr><mtd
    columnalign="left"><mrow><mi>S</mi> <mi>l</mi> <mi>o</mi> <mi>p</mi> <mi>e</mi>
    <mi>o</mi> <mi>f</mi> <mover accent="true"><mrow><mi>B</mi><mi>A</mi></mrow> <mo>→</mo></mover>
    <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mo>-</mo><mn>2</mn></mrow>
    <mrow><mo>-</mo><mn>2</mn></mrow></mfrac></mstyle> <mo>=</mo> <mn>1</mn></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: If the two vectors were simply lines (with no direction), then they would be
    the same object. However, adding the directional component makes them two distinguishable
    mathematical objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-4](#figure-4-4) sheds more light on the concept of the slope, as
    *x* has shifted two points to the right and *y* has shifted two points to the
    left.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_0404.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-4\. The change in *x* and the change in *y* for vector AB
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A vector that has a magnitude of 1 is referred to as a *unit vector*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-5](#figure-4-5) shows the change in *x* and the change in *y* in
    the case of vector BA.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_0405.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-5\. The change in *x* and the change in *y* for vector BA
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Researchers typically use vectors as representations of speed, especially in
    engineering. Navigation is one field that heavily relies on vectors. It allows
    navigators to determine their positions and plan their destinations. Naturally,
    magnitude represents speed and the direction represents the destination.
  prefs: []
  type: TYPE_NORMAL
- en: You can add and subtract vectors from each other and from scalars. This allows
    for a shift in direction and magnitude. What you should retain from the previous
    discussion is that vectors indicate directions between different points on the
    axis.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A *scalar *is a value with magnitude but no direction. Scalars, as opposed to
    vectors, are used to represent elements, like temperature and prices. Basically,
    scalars are numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *matrix* is a rectangular array containing numbers and organized in rows
    and columns.^([1](ch04.html#id453)) Matrices are useful in computer graphics and
    other domains as well as to define and manipulate linear systems of equations.
    What differentiates a matrix from a vector? The simplest answer is that a vector
    is a matrix with a single column or a single row. Here’s a basic example of a
    3 × 3 matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 5 2nd Column 2 3rd Column
    9 2nd Row 1st Column negative 8 2nd Column 10 3rd Column 13 3rd Row 1st Column
    1 2nd Column 5 3rd Column 12 EndMatrix"><mfenced close="]" open="["><mtable><mtr><mtd><mn>5</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>9</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>8</mn></mrow></mtd>
    <mtd><mn>10</mn></mtd> <mtd><mn>13</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>5</mn></mtd> <mtd><mn>12</mn></mtd></mtr></mtable></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The size of a matrix is the number of rows and columns it contains. A row is
    a horizontal line, and a column is a vertical line. The following representation
    is a 2 × 4 matrix (i.e., two rows by four columns):'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="Start 2 By 4 Matrix 1st Row 1st Column 5 2nd Column 2 3rd Column
    1 4th Column 3 2nd Row 1st Column negative 8 2nd Column 10 3rd Column 9 4th Column
    4 EndMatrix"><mfenced close="]" open="["><mtable><mtr><mtd><mn>5</mn></mtd> <mtd><mn>2</mn></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>8</mn></mrow></mtd>
    <mtd><mn>10</mn></mtd> <mtd><mn>9</mn></mtd> <mtd><mn>4</mn></mtd></mtr></mtable></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The following representation is a 4 × 2 matrix (i.e., four rows by two columns):'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="Start 4 By 2 Matrix 1st Row 1st Column 5 2nd Column 2 2nd Row
    1st Column negative 8 2nd Column 10 3rd Row 1st Column 8 2nd Column 22 4th Row
    1st Column 7 2nd Column 3 EndMatrix"><mfenced close="]" open="["><mtable><mtr><mtd><mn>5</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>8</mn></mrow></mtd>
    <mtd><mn>10</mn></mtd></mtr> <mtr><mtd><mn>8</mn></mtd> <mtd><mn>22</mn></mtd></mtr>
    <mtr><mtd><mn>7</mn></mtd> <mtd><mn>3</mn></mtd></mtr></mtable></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Matrices are heavily used in machine learning. Rows generally represent time
    and columns represent features.
  prefs: []
  type: TYPE_NORMAL
- en: 'The summation of different matrices is straightforward but must be used only
    when the matrices match in size (which means they have the same number of columns
    and rows). For instance, let’s add the following two matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 2 2nd Row
    1st Column 5 2nd Column 8 EndMatrix plus Start 2 By 2 Matrix 1st Row 1st Column
    3 2nd Column 9 2nd Row 1st Column 1 2nd Column 5 EndMatrix equals Start 2 By 2
    Matrix 1st Row 1st Column 4 2nd Column 11 2nd Row 1st Column 6 2nd Column 13 EndMatrix"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>5</mn></mtd> <mtd><mn>8</mn></mtd></mtr></mtable></mfenced> <mo>+</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>9</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd> <mtd><mn>11</mn></mtd></mtr>
    <mtr><mtd><mn>6</mn></mtd> <mtd><mn>13</mn></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that to add two matrices, you simply have to add the numbers in
    the same positions. Now, if you try to add the next pair of matrices, you won’t
    be able to do it as there is a mismatch in what to add:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 8 2nd Column 3 2nd Row
    1st Column 3 2nd Column 2 EndMatrix plus Start 3 By 2 Matrix 1st Row 1st Column
    3 2nd Column 9 2nd Row 1st Column 1 2nd Column 5 3rd Row 1st Column 5 2nd Column
    4 EndMatrix"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>8</mn></mtd>
    <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mo>+</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>9</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>5</mn></mtd></mtr> <mtr><mtd><mn>5</mn></mtd>
    <mtd><mn>4</mn></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The subtraction of matrices is also straightforward and follows the same rules
    as the summation of matrices. Let’s take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 5 2nd Column 2 2nd Row
    1st Column negative 8 2nd Column 10 EndMatrix minus Start 2 By 2 Matrix 1st Row
    1st Column 3 2nd Column 9 2nd Row 1st Column negative 1 2nd Column negative 5
    EndMatrix equals Start 2 By 2 Matrix 1st Row 1st Column 2 2nd Column negative
    7 2nd Row 1st Column negative 9 2nd Column 15 EndMatrix"><mrow><mfenced close="]"
    open="["><mtable><mtr><mtd><mn>5</mn></mtd> <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>8</mn></mrow></mtd> <mtd><mn>10</mn></mtd></mtr></mtable></mfenced> <mo>-</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>9</mn></mtd></mtr>
    <mtr><mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd> <mtd><mrow><mo>-</mo> <mn>5</mn></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>7</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>9</mn></mrow></mtd>
    <mtd><mn>15</mn></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Evidently, subtraction of matrices is also a summation of matrices with a change
    of signs in one of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Matrix multiplication by a scalar is quite simple. Let’s take the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="3 times Start 2 By 2 Matrix 1st Row 1st Column 5 2nd Column 2
    2nd Row 1st Column 8 2nd Column 22 EndMatrix equals Start 2 By 2 Matrix 1st Row
    1st Column 15 2nd Column 6 2nd Row 1st Column 24 2nd Column 66 EndMatrix"><mrow><mn>3</mn>
    <mo>×</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>5</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>8</mn></mtd> <mtd><mn>22</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>15</mn></mtd> <mtd><mn>6</mn></mtd></mtr>
    <mtr><mtd><mn>24</mn></mtd> <mtd><mn>66</mn></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'So basically, you are multiplying every cell in the matrix by the scalar. Multiplying
    one matrix by another matrix is a bit more complicated as it uses the *dot product*
    method. First of all, to multiply two matrices together, they must satisfy this
    condition:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="Matrix Subscript x y Baseline times Matrix Subscript y z Baseline
    equals Matrix Subscript x z"><mrow><msub><mtext>Matrix</mtext> <mrow><mi>x</mi><mi>y</mi></mrow></msub>
    <mo>×</mo> <msub><mtext>Matrix</mtext> <mrow><mi>y</mi><mi>z</mi></mrow></msub>
    <mo>=</mo> <msub><mtext>Matrix</mtext> <mrow><mi>x</mi><mi>z</mi></mrow></msub></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the first matrix must have a number of columns equal to the
    number of rows in the second matrix, and the resulting matrix from the dot product
    is a matrix that has the number of rows of the first matrix and the number of
    columns of the second matrix. The dot product is explained in the following example
    representation of a 1 × 3 and 3 × 1 matrix multiplication (notice the equal number
    of columns and rows):'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="Start 1 By 3 Matrix 1st Row 1st Column 1 2nd Column 2 3rd Column
    3 EndMatrix times Start 3 By 1 Matrix 1st Row  3 2nd Row  2 3rd Row  1 EndMatrix
    equals Start 1 By 1 Matrix 1st Row  left-parenthesis 1 times 3 right-parenthesis
    plus left-parenthesis 2 times 2 right-parenthesis plus left-parenthesis 3 times
    1 right-parenthesis EndMatrix equals Start 1 By 1 Matrix 1st Row  10 EndMatrix"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>3</mn></mtd></mtr></mtable></mfenced>
    <mo>×</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mo>(</mo> <mn>1</mn>
    <mo>×</mo> <mn>3</mn> <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>2</mn> <mo>×</mo> <mn>2</mn>
    <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>3</mn> <mo>×</mo> <mn>1</mn> <mo>)</mo></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>10</mn></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s take an example of a 2 × 2 matrix multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 2 2nd Row
    1st Column 0 2nd Column 1 EndMatrix times Start 2 By 2 Matrix 1st Row 1st Column
    3 2nd Column 0 2nd Row 1st Column 2 2nd Column 1 EndMatrix equals Start 2 By 2
    Matrix 1st Row 1st Column 7 2nd Column 2 2nd Row 1st Column 2 2nd Column 1 EndMatrix"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced> <mo>×</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>7</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a special type of matrix called the *identity matrix*, which is basically
    the number 1 for matrices. It is defined as follows for a 2 × 2 dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper I equals Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column
    0 2nd Row 1st Column 0 2nd Column 1 EndMatrix"><mrow><mi>I</mi> <mo>=</mo> <mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'and as follows for a 3 × 3 dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper I equals Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column
    0 3rd Column 0 2nd Row 1st Column 0 2nd Column 1 3rd Column 0 3rd Row 1st Column
    0 2nd Column 0 3rd Column 1 EndMatrix"><mrow><mi>I</mi> <mo>=</mo> <mfenced close="]"
    open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiplying any matrix by the identity matrix yields the same original matrix.
    This is why it can be referred to as the 1 of matrices (multiplying any number
    by 1 yields the same number). It is worth noting that matrix multiplication is
    not commutative, which means that the order of multiplication changes the result:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper A upper B not-equals upper B upper A"><mrow><mi>A</mi>
    <mi>B</mi> <mo>≠</mo> <mi>B</mi> <mi>A</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: '*Matrix transposing* is a process that involves changing the rows into columns
    and vice versa. The transpose of a matrix is obtained by reflecting the matrix
    along its main diagonal:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 4 2nd Column 6 3rd Column
    1 2nd Row 1st Column 1 2nd Column 4 3rd Column 2 EndMatrix Superscript upper T
    Baseline equals Start 3 By 2 Matrix 1st Row 1st Column 4 2nd Column 1 2nd Row
    1st Column 6 2nd Column 4 3rd Row 1st Column 1 2nd Column 2 EndMatrix"><mrow><msup><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd><mtd><mn>6</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><mn>4</mn></mtd><mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mi>T</mi></msup> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>6</mn></mtd> <mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Transposing is used in some machine learning algorithms and is not an uncommon
    operation when dealing with such models. If you are wondering about the role of
    matrices in data science and machine learning, you can refer to this nonexhaustive
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: Representation of data
  prefs: []
  type: TYPE_NORMAL
- en: Matrices often represent data with rows representing samples and columns representing
    features. For example, a row in a matrix can present OHLC data in one time step.
  prefs: []
  type: TYPE_NORMAL
- en: Linear algebra
  prefs: []
  type: TYPE_NORMAL
- en: Matrices and linear algebra are intertwined, and many learning algorithms use
    the concepts of matrices in their operations. Having a basic understanding of
    these mathematical concepts helps smooth the learning curve when dealing with
    machine learning algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Data relationship matrices
  prefs: []
  type: TYPE_NORMAL
- en: Covariance and correlation measures are often represented as matrices. These
    relationship calculations are important concepts in time series analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The key takeaways from this section are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A vector is an object that has a magnitude (length) and a direction (arrowhead).
    Multiple vectors grouped together form a matrix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A matrix can be used to store data. It has its special ways of performing operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matrix multiplication uses the dot product method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transposing a matrix means to swap its rows and its columns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Linear Equations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You saw an example of a linear equation in [“Regression Analysis and Statistical
    Inference”](ch03.html#regression_analysis). *Linear equations* are basically formulas
    that present an equality relationship between different variables and constants.
    In the case of machine learning, it is often a relationship between a dependent
    variable (the output) and an independent variable (the input). The best way to
    understand linear equations is through examples.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The aim of linear equations is to find an unknown variable, usually denoted
    by the letter *x*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start with a very basic example that you can consider as a first building
    block toward the more advanced concepts you will see later on. The following example
    requires finding the value of *x* that satisfies the equation:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="10 x equals 20"><mrow><mn>10</mn> <mi>x</mi> <mo>=</mo> <mn>20</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: You should understand the equation as “*10 times which number equals 20?*” When
    a constant is directly attached to a variable such as *x*, it refers to a multiplication
    operation. Now, to solve for *x* (i.e., finding the value of *x* that equalizes
    the equation), you have an obvious solution, which is to get rid of 10 so that
    you have *x* on one side of the equation and the rest on the other side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, to get rid of 10, you divide by 10 so that what remains is 1, which
    if multiplied by the variable *x* does nothing. However, keep in mind two important
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: If you do a mathematical operation on one side of an equation, you must do it
    on the other side as well. This is why they are called equations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For simplicity, instead of dividing by the constant to get rid of it, you should
    multiply it by its reciprocal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *reciprocal* of a number is 1 divided by that number. Here’s the mathematical
    representation of it:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper R e c i p r o c a l left-parenthesis x right-parenthesis
    equals StartFraction 1 Over x EndFraction"><mrow><mi>R</mi> <mi>e</mi> <mi>c</mi>
    <mi>i</mi> <mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>c</mi> <mi>a</mi> <mi>l</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <mi>x</mi></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, back to the example, to find *x* you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="left-parenthesis one-tenth right-parenthesis 10 x equals 20 left-parenthesis
    one-tenth right-parenthesis"><mrow><mrow><mo>(</mo> <mfrac><mn>1</mn> <mn>10</mn></mfrac>
    <mo>)</mo></mrow> <mn>10</mn> <mi>x</mi> <mo>=</mo> <mn>20</mn> <mrow><mo>(</mo>
    <mfrac><mn>1</mn> <mn>10</mn></mfrac> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Performing the multiplication and simplifying gives the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x equals 2"><mrow><mi>x</mi> <mo>=</mo> <mn>2</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the solution of the equation is 2\. To verify this, you just
    need to plug 2 into the original equation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="10 times 2 equals 20"><mrow><mn>10</mn> <mo>×</mo> <mn>2</mn>
    <mo>=</mo> <mn>20</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it takes two 10s to get 20.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Dividing the number by itself is the same thing as multiplying it by its reciprocal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take another example of how to solve *x* through linear techniques. Consider
    the following problem:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="eight-sixths x equals 24"><mrow><mfrac><mn>8</mn> <mn>6</mn></mfrac>
    <mi>x</mi> <mo>=</mo> <mn>24</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Performing the multiplication and simplifying gives the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="left-parenthesis six-eighths right-parenthesis eight-sixths x
    equals 24 left-parenthesis six-eighths right-parenthesis"><mrow><mrow><mo>(</mo>
    <mfrac><mn>6</mn> <mn>8</mn></mfrac> <mo>)</mo></mrow> <mfrac><mn>8</mn> <mn>6</mn></mfrac>
    <mi>x</mi> <mo>=</mo> <mn>24</mn> <mrow><mo>(</mo> <mfrac><mn>6</mn> <mn>8</mn></mfrac>
    <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x equals 18"><mrow><mi>x</mi> <mo>=</mo> <mn>18</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the solution of the equation is 18\. To verify this, you just
    need to plug 18 into the original equation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="eight-sixths times 18 equals 24"><mrow><mfrac><mn>8</mn> <mn>6</mn></mfrac>
    <mo>×</mo> <mn>18</mn> <mo>=</mo> <mn>24</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, linear equations are not this simple. Sometimes they contain more
    variables and more constants, which need more detailed solutions, but let’s keep
    taking it step by step. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="3 x minus 6 equals 12"><mrow><mn>3</mn> <mi>x</mi> <mo>-</mo>
    <mn>6</mn> <mo>=</mo> <mn>12</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Solving for *x* requires rearranging the equation a little bit. Remember, the
    aim is to leave *x* on one side and the rest on the other. Here, you have to get
    rid of the constant 6 before taking care of 3\. The first part of the solution
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="3 x minus 6 left-parenthesis plus 6 right-parenthesis equals
    12 left-parenthesis plus 6 right-parenthesis"><mrow><mn>3</mn> <mi>x</mi> <mo>-</mo>
    <mn>6</mn> <mo>(</mo> <mo>+</mo> <mn>6</mn> <mo>)</mo> <mo>=</mo> <mn>12</mn>
    <mo>(</mo> <mo>+</mo> <mn>6</mn> <mo>)</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how you have to add 6 to both parts of the equation. The part on the
    left will cancel itself out, while the part on the right will add up to 18:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="3 x equals 18"><mrow><mn>3</mn> <mi>x</mi> <mo>=</mo> <mn>18</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you’re all set to multiply by the reciprocal of the constant attached
    to the variable *x*:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="left-parenthesis one-third right-parenthesis 3 x equals 18 left-parenthesis
    one-third right-parenthesis"><mrow><mrow><mo>(</mo> <mfrac><mn>1</mn> <mn>3</mn></mfrac>
    <mo>)</mo></mrow> <mn>3</mn> <mi>x</mi> <mo>=</mo> <mn>18</mn> <mrow><mo>(</mo>
    <mfrac><mn>1</mn> <mn>3</mn></mfrac> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Simplifying and solving for *x* leaves the following solution:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x equals 6"><mrow><mi>x</mi> <mo>=</mo> <mn>6</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the solution of the equation is 6\. To verify this, just plug
    6 into the original equation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="left-parenthesis 3 times 6 right-parenthesis minus 6 equals 12"><mrow><mo>(</mo>
    <mn>3</mn> <mo>×</mo> <mn>6</mn> <mo>)</mo> <mo>-</mo> <mn>6</mn> <mo>=</mo> <mn>12</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'By now, you should have noticed that linear algebra is all about using shortcuts
    and quick techniques to simplify equations and find unknown variables. The next
    example shows how sometimes the variable *x* can occur in multiple places:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="6 x plus x equals 27 minus 2 x"><mrow><mn>6</mn> <mi>x</mi> <mo>+</mo>
    <mi>x</mi> <mo>=</mo> <mn>27</mn> <mo>-</mo> <mn>2</mn> <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, the main focus is to have *x* on one side of the equation and the
    rest on the other side:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="6 x plus x plus 2 x equals 27"><mrow><mn>6</mn> <mi>x</mi> <mo>+</mo>
    <mi>x</mi> <mo>+</mo> <mn>2</mn> <mi>x</mi> <mo>=</mo> <mn>27</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the constants of *x* gives you the following:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="9 x equals 27"><mrow><mn>9</mn> <mi>x</mi> <mo>=</mo> <mn>27</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is dividing by 9 so that you only have *x* remaining:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x equals 3"><mrow><mi>x</mi> <mo>=</mo> <mn>3</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: You may now verify this by plugging 3 in the place of *x* in the original equation.
    You will notice that both sides of the equation will be equal.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Even though this section is quite simple, it contains the basic foundations
    you need to start advancing in algebra and calculus. The key takeaways from this
    section are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A linear equation is a representation in which the highest exponent on any variable
    is one. This means that there are no variables that are raised to the power of
    two and above.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A linear equation line is straight when plotted on a chart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application of linear equations in modeling a wide range of real-world occurrences
    makes them crucial in many branches of mathematics and research. They are also
    widely utilized in machine learning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving for *x* is the process of finding for it a value that equalizes both
    sides of the equation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When performing an operation (such as adding a constant or multiplying by a
    constant) on one side of the equation, you have to do it on the other side as
    well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Systems of Equations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *system of equations* is when there are two or more equations working together
    to solve one or more variables. Therefore, instead of the usual single equation:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x plus 10 equals 20"><mrow><mi>x</mi> <mo>+</mo> <mn>10</mn>
    <mo>=</mo> <mn>20</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'systems of equations resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x plus 10 equals 20"><mrow><mi>x</mi> <mo>+</mo> <mn>10</mn>
    <mo>=</mo> <mn>20</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="y plus 2 x equals 10"><mrow><mi>y</mi> <mo>+</mo> <mn>2</mn>
    <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Systems of equations are useful in machine learning and are used in many of
    its aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the previous system of equations from the beginning of this section
    and solve it graphically. Plotting the two functions can actually give the solution
    directly. The point of intersection is the solution. Therefore, the coordinates
    of the intersection (*x, y*) refer to the solutions of *x* and *y*, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'From [Figure 4-6](#figure-4-6), it seems that *x* = 10 and *y* = –10\. Plugging
    these values into their respective variables gives the correct answer:'
  prefs: []
  type: TYPE_NORMAL
- en: 10 + 10 = 20
  prefs: []
  type: TYPE_NORMAL
- en: (–10) + (2 × 10) = 10
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_0406.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-6\. A graph showing the two functions and their intersection (solution)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As the functions are linear, solving them can result in one of three outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: There is only one solution for each variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no solution. This occurs when the functions are *parallel* (this means
    that they never intersect).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are an infinite number of solutions. This occurs when, through simplification,
    both functions are the same (since all points fall on the straight line).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before moving on to solving systems of equations using algebra, let’s visually
    see how there can be no solution and how there can be an infinite number of solutions.
    Consider the following system:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="2 x equals 10"><mrow><mn>2</mn> <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="4 x equals 20"><mrow><mn>4</mn> <mi>x</mi> <mo>=</mo> <mn>20</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-7](#figure-4-7) charts the two together. Since they are exactly the
    same equation, they fall on the same line. In reality, there are two lines in
    [Figure 4-7](#figure-4-7), but since they are the same, they are indistinguishable.
    For every *x* on the line, there is a corresponding *y*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_0407.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-7\. A graph showing the two functions and their infinite intersections
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now consider the following system:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="3 x equals 10"><mrow><mn>3</mn> <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="6 x equals 10"><mrow><mn>6</mn> <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-8](#figure-4-8) shows how they never intersect, which is intuitive
    as you cannot multiply the same number (represented by the variable *x*) with
    different numbers and expect to get the same result.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_0408.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-8\. A graph showing the two functions and their impossible intersection
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Algebraic methods are used when there are more than two variables since they
    cannot be solved through graphs. This mainly entails two methods: substitution
    and elimination.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Substitution* is used when you can replace the value of a variable in one
    equation and plug it into the second equation. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x plus y equals 2"><mrow><mi>x</mi> <mo>+</mo> <mi>y</mi> <mo>=</mo>
    <mn>2</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="10 x plus y equals 10"><mrow><mn>10</mn> <mi>x</mi> <mo>+</mo>
    <mi>y</mi> <mo>=</mo> <mn>10</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest method is to rearrange the first equation so that you have *y*
    in terms of *x*:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="y equals 2 minus x"><mrow><mi>y</mi> <mo>=</mo> <mn>2</mn> <mo>-</mo>
    <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="10 x plus left-parenthesis 2 minus x right-parenthesis equals
    10"><mrow><mn>10</mn> <mi>x</mi> <mo>+</mo> <mo>(</mo> <mn>2</mn> <mo>-</mo> <mi>x</mi>
    <mo>)</mo> <mo>=</mo> <mn>10</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Solving for *x* in the second equation becomes simple:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row  10 x plus left-parenthesis 2 minus x right-parenthesis
    equals 10 2nd Row  10 x plus 2 minus x equals 10 3rd Row  10 x minus x equals
    10 minus 2 4th Row  9 x equals 8 5th Row  x equals eight-ninths 6th Row  x equals
    0.8889 EndLayout"><mtable><mtr><mtd columnalign="left"><mrow><mn>10</mn> <mi>x</mi>
    <mo>+</mo> <mo>(</mo> <mn>2</mn> <mo>-</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mn>10</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mn>10</mn> <mi>x</mi> <mo>+</mo> <mn>2</mn>
    <mo>-</mo> <mi>x</mi> <mo>=</mo> <mn>10</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mn>10</mn>
    <mi>x</mi> <mo>-</mo> <mi>x</mi> <mo>=</mo> <mn>10</mn> <mo>-</mo> <mn>2</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mn>9</mn> <mi>x</mi> <mo>=</mo> <mn>8</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>x</mi> <mo>=</mo> <mfrac><mn>8</mn> <mn>9</mn></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>x</mi> <mo>=</mo> <mn>0</mn> <mo lspace="0%"
    rspace="0%">.</mo> <mn>8889</mn></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have found the value of *x*, you can easily find *y* by plugging
    the value of *x* into the first equation:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row  0.8889 plus y equals 2 2nd Row  y equals
    2 minus 0.8889 3rd Row  y equals 1.111 EndLayout"><mtable><mtr><mtd columnalign="left"><mrow><mn>0</mn>
    <mo lspace="0%" rspace="0%">.</mo> <mn>8889</mn> <mo>+</mo> <mi>y</mi> <mo>=</mo>
    <mn>2</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mi>y</mi> <mo>=</mo>
    <mn>2</mn> <mo>-</mo> <mn>0</mn> <mo lspace="0%" rspace="0%">.</mo> <mn>8889</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>y</mi> <mo>=</mo> <mn>1</mn> <mo lspace="0%"
    rspace="0%">.</mo> <mn>111</mn></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'To check if your solution is correct, you can plug in the values of *x* and
    *y* in both formulas:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row  0.8889 plus 1.111 equals 2 2nd Row  left-parenthesis
    10 times 0.8889 right-parenthesis plus 1.111 equals 10 EndLayout"><mtable><mtr><mtd
    columnalign="left"><mrow><mn>0</mn> <mo lspace="0%" rspace="0%">.</mo> <mn>8889</mn>
    <mo>+</mo> <mn>1</mn> <mo lspace="0%" rspace="0%">.</mo> <mn>111</mn> <mo>=</mo>
    <mn>2</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mo>(</mo> <mn>10</mn>
    <mo>×</mo> <mn>0</mn> <mo lspace="0%" rspace="0%">.</mo> <mn>8889</mn> <mo>)</mo>
    <mo>+</mo> <mn>1</mn> <mo lspace="0%" rspace="0%">.</mo> <mn>111</mn> <mo>=</mo>
    <mn>10</mn></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: Graphically, this means that the two equations intersect at (0.8889, 1.111).
    This technique can be used with more than two variables. Follow the same process
    until the equations are simplified enough to give you the answers. The issue with
    substitution is that it may take some time when you’re dealing with more than
    two variables.
  prefs: []
  type: TYPE_NORMAL
- en: '*Elimination* is a faster alternative. It is about eliminating variables until
    there is only one left. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row  2 x plus 4 y equals 20 2nd Row  3 x plus
    2 y equals 10 EndLayout"><mtable><mtr><mtd columnalign="left"><mrow><mn>2</mn>
    <mi>x</mi> <mo>+</mo> <mn>4</mn> <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mn>3</mn> <mi>x</mi> <mo>+</mo> <mn>2</mn>
    <mi>y</mi> <mo>=</mo> <mn>10</mn></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Noticing that there is 4*y* and 2*y*, it is possible to multiply the second
    equation by 2 so that you can subtract the equations from each other (which will
    remove the *y* variable):'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row  2 x plus 4 y equals 20 2nd Row  6 x plus
    4 y equals 20 EndLayout"><mtable><mtr><mtd columnalign="left"><mrow><mn>2</mn>
    <mi>x</mi> <mo>+</mo> <mn>4</mn> <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mn>6</mn> <mi>x</mi> <mo>+</mo> <mn>4</mn>
    <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Subtracting the two equations from each other gives the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row  minus 4 x equals 0 2nd Row  x equals 0 EndLayout"><mtable><mtr><mtd
    columnalign="left"><mrow><mo>-</mo> <mn>4</mn> <mi>x</mi> <mo>=</mo> <mn>0</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>x</mi> <mo>=</mo> <mn>0</mn></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, *x* = 0\. Graphically, this means that they intersect whenever *x*
    = 0 (exactly at the vertical *y* line). Plugging the value of *x* into the first
    formula gives *y*  = 5:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row  left-parenthesis 2 times 0 right-parenthesis
    plus 4 y equals 20 2nd Row  4 y equals 20 3rd Row  y equals 5 EndLayout"><mtable><mtr><mtd
    columnalign="left"><mrow><mo>(</mo> <mn>2</mn> <mo>×</mo> <mn>0</mn> <mo>)</mo>
    <mo>+</mo> <mn>4</mn> <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></mtd></mtr> <mtr><mtd
    columnalign="left"><mrow><mn>4</mn> <mi>y</mi> <mo>=</mo> <mn>20</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>y</mi> <mo>=</mo> <mn>5</mn></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, elimination can also solve equations with three variables. The choice
    between substitution and elimination depends on the type of equation being solved.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The key takeaways from this section are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Systems of equations solve variables together. They are very useful in machine
    learning and are used in some algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphical solutions are preferred for simple systems of equations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving systems of equations through algebra entails the use of substitution
    and elimination methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Substitution is preferred when the system is simple, but elimination is the
    way to go when the system is a bit more complex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trigonometry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Trigonometry e*xplores the behavior of what is known as *trigonometric functions*
    that relate the angles of a triangle to the lengths of its sides. The most-used
    triangle is the right-angled triangle, which has one angle at 90**°**. [Figure 4-9](#figure-4-9)
    shows an example of a right-angled triangle.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_0409.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-9\. A right-angled triangle
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s define the main characteristics of a right-angled triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: The longest side of the triangle is called the *hypotenuse.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The angle in front of the hypotenuse is the right angle (the one at 90**°**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the other angle (θ) you choose (from the two that remain), the
    line between this angle and the hypotenuse is called the *adjacent* and the other
    line is called the *opposite*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Trigonometric functions are mathematical functions used to relate the angles
    of a right triangle to the ratios of its sides. They have various applications
    in fields like geometry, physics, engineering, and more. They help analyze and
    solve problems related to angles, distances, oscillations, and waveforms, among
    other things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Trigonometric functions are simply the division of one line by another line.
    Remember that you have three lines in a triangle (hypotenuse, opposite, and adjacent).
    The trigonometric functions are found as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="s i n left-parenthesis theta right-parenthesis equals StartFraction
    Opposite Over Hypotenuse EndFraction"><mrow><mi>s</mi> <mi>i</mi> <mi>n</mi> <mrow><mo>(</mo>
    <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mtext>Opposite</mtext>
    <mtext>Hypotenuse</mtext></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="c o s left-parenthesis theta right-parenthesis equals StartFraction
    Adjacent Over Hypotenuse EndFraction"><mrow><mi>c</mi> <mi>o</mi> <mi>s</mi> <mrow><mo>(</mo>
    <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mtext>Adjacent</mtext>
    <mtext>Hypotenuse</mtext></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="t a n left-parenthesis theta right-parenthesis equals StartFraction
    Opposite Over Adjacent EndFraction"><mrow><mi>t</mi> <mi>a</mi> <mi>n</mi> <mrow><mo>(</mo>
    <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mtext>Opposite</mtext>
    <mtext>Adjacent</mtext></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'From the previous three trigonometric functions, it is possible to extract
    a trigonometric identity that reaches *tan* from *sin* and *cos* using basic linear
    algebra:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="t a n left-parenthesis theta right-parenthesis equals StartFraction
    s i n left-parenthesis theta right-parenthesis Over c o s left-parenthesis theta
    right-parenthesis EndFraction"><mrow><mi>t</mi> <mi>a</mi> <mi>n</mi> <mrow><mo>(</mo>
    <mi>θ</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>θ</mi><mo>)</mo></mrow>
    <mrow><mi>c</mi><mi>o</mi><mi>s</mi><mo>(</mo><mi>θ</mi><mo>)</mo></mrow></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: '*Hyperbolic functions *are similar to trigonometric functions but are defined
    using exponential functions. Before understanding hyperbolic functions, one must
    understand Euler’s number.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This part on hyperbolic functions is interesting as it forms the basis of what
    is known as *activation functions*, a key concept in neural networks, the protagonists
    of deep learning models. You will see them in detail in [Chapter 8](ch08.html#ch08).
  prefs: []
  type: TYPE_NORMAL
- en: '*Euler’s number* (denoted as *e*) is one of the most important numbers in mathematics.
    It is an *irrational number*, which is a real number that cannot be expressed
    as a fraction. The word *irrational* comes from the fact that there is no *ratio*
    to express it; it has nothing to do with its personality. Euler’s numberis also
    the base of the natural logarithm *ln*, and the first digits of it are 2.71828\.
    One of the best approximations to get *e* is the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="e equals left-parenthesis 1 plus StartFraction 1 Over n EndFraction
    right-parenthesis Superscript n"><mrow><mi>e</mi> <mo>=</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mi>n</mi></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'By increasing *n* in the previous formula, you will approach the value of *e*.
    Euler’s number has many interesting properties, most notably the fact that its
    slope is its own value. Consider the following function (also called the *natural
    exponent function*):'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals e Superscript x"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi> <mi>x</mi></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: At any point, the slope of the function is the same value. Take a look at [Figure 4-10](#figure-4-10).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_0410.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-10\. A graph of the natural exponent function
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You may be wondering why I am explaining exponents and logarithms in this book.
    There are mainly two reasons for this:'
  prefs: []
  type: TYPE_NORMAL
- en: Exponents and, more importantly, Euler’s number are used in hyperbolic functions
    where *tanh(x)* is one of the main activation functions for neural networks, a
    type of machine and deep learning model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logarithms are useful in *loss functions*, a concept that you will see in later
    chapters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hyperbolic functions use the natural exponent function and are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="s i n h left-parenthesis x right-parenthesis equals StartFraction
    e Superscript x Baseline minus e Superscript negative x Baseline Over 2 EndFraction"><mrow><mi>s</mi>
    <mi>i</mi> <mi>n</mi> <mi>h</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><msup><mi>e</mi>
    <mi>x</mi></msup> <mo>-</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow>
    <mn>2</mn></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="c o s h left-parenthesis x right-parenthesis equals StartFraction
    e Superscript x Baseline plus e Superscript negative x Baseline Over 2 EndFraction"><mrow><mi>c</mi>
    <mi>o</mi> <mi>s</mi> <mi>h</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><msup><mi>e</mi>
    <mi>x</mi></msup> <mo>+</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow>
    <mn>2</mn></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="t a n h left-parenthesis x right-parenthesis equals StartFraction
    e Superscript x Baseline minus e Superscript negative x Baseline Over e Superscript
    x Baseline plus e Superscript negative x Baseline EndFraction"><mrow><mi>t</mi>
    <mi>a</mi> <mi>n</mi> <mi>h</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><msup><mi>e</mi>
    <mi>x</mi></msup> <mo>-</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow>
    <mrow><msup><mi>e</mi> <mi>x</mi></msup> <mo>+</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Among the key characteristics of *tanh(x)* are nonlinearity, the limitation
    between [–1, 1], and the fact that it is centered at zero. [Figure 4-11](#figure-4-11)
    shows the graph of *tanh(x)*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_0411.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-11\. A graph of tanh(x) showing how it’s limited between –1 and 1
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The key takeaways from this section are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Trigonometry is a field that explores the behavior of trigonometric functions
    that relate the angles of a triangle to the lengths of its sides.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A trigonometric identity is a shortcut that relates the trigonometric functions
    with each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Euler’s number *e* is irrational and is the base of the natural logarithm. It
    has many applications in exponential growth and in hyperbolic functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hyperbolic tangent function is used in neural networks, a deep learning
    algorithm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As previously mentioned, calculus is a branch of mathematics that focuses on
    the study of rates of change and accumulation of quantities. It consists of two
    primary branches: *differential calculus* (which deals with derivatives) and *integral
    calculus* (which deals with integration). This section briefly introduces both
    types of calculus while also discussing topics such as limits and optimization.'
  prefs: []
  type: TYPE_NORMAL
- en: Limits and Continuity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Calculus works by making visible the infinitesimally small.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Keith Devlin
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Limits don’t have to be nightmarish. I have always found them to be misunderstood.
    They are actually quite easy to get. But first, you need motivation, and this
    comes from knowing the added value of learning limits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding limits is important in machine learning models for many reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimization
  prefs: []
  type: TYPE_NORMAL
- en: In optimization methods like gradient descent, limits can be used to regulate
    the step size and guarantee convergence to a local minimum.
  prefs: []
  type: TYPE_NORMAL
- en: Feature selection
  prefs: []
  type: TYPE_NORMAL
- en: Limits can be used to rank the significance of various model features and perform
    feature selection, which can make the model simpler and perform better.
  prefs: []
  type: TYPE_NORMAL
- en: Sensitivity analysis
  prefs: []
  type: TYPE_NORMAL
- en: A machine learning model’s sensitivity to changes in input data and its capacity
    to generalize to new data can be used to examine a model’s behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Also, limits are used in more advanced calculus concepts that you will learn
    about shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The main aim of limits is to know the value of a function when it’s undefined.
    But what is an *undefined function*? When you have a function that gives a solution
    that is not possible (such as dividing by zero), limits help you bypass this issue
    in order to know the value of the function at that point. So the aim of limits
    is to solve functions even when they are undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that the solution to a function that takes *x* as an input is a value
    in the *y*-axis. [Figure 4-12](#figure-4-12) shows a linear graph of the following
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals x plus 2"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mi>x</mi> <mo>+</mo> <mn>2</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_0412.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-12\. A graph of the function f(x) = x + 2
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The solution of the function in the graph is the one that lies on the linear
    line taking into account the value of *x* every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'What would be the solution of the function (the value of *y*) when *x* = 4?
    Clearly, the answer is 6, as substituting the value of *x* with 4 gives 6:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis 4 right-parenthesis equals 4 plus 2 equals
    6"><mrow><mi>f</mi> <mo>(</mo> <mn>4</mn> <mo>)</mo> <mo>=</mo> <mn>4</mn> <mo>+</mo>
    <mn>2</mn> <mo>=</mo> <mn>6</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Thinking of this solution in terms of limits would be like asking for the solution
    of the function as *x* approaches 4 from both sides (the negative/decreasing side
    and the positive/increasing side). [Table 4-1](#table-4-1) simplifies this dilemma.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1\. Finding x as it approaches 4
  prefs: []
  type: TYPE_NORMAL
- en: '| *f(x)* | *x* |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 5.998 | 3.998 |'
  prefs: []
  type: TYPE_TB
- en: '| 5.999 | 3.999 |'
  prefs: []
  type: TYPE_TB
- en: '| 6.000 | 4.000 |'
  prefs: []
  type: TYPE_TB
- en: '| 6.001 | 4.001 |'
  prefs: []
  type: TYPE_TB
- en: '| 6.002 | 4.002 |'
  prefs: []
  type: TYPE_TB
- en: Approaching from the negative side is the equivalent of adding a fraction of
    a number while below 4 and analyzing the result every time. Similarly, approaching
    from the positive side is the equivalent of removing a fraction of a number while
    above 4 and analyzing the result every time. The solution seems to converge to
    6 as *x* approaches 4\. This is the solution to the limit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Limits in the general form are written following this convention:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow a Endscripts f left-parenthesis
    x right-parenthesis equals upper L"><mrow><msub><mo form="prefix" movablelimits="true">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mi>a</mi></mrow></msub> <mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>L</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The general form of the limit is read as follows: as you approach *a* along
    the *x*-axis (whether from the positive or the negative side), the function *f(x)*
    gets closer to the value of *L*.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The idea of the limit states that as you lock in and approach a number from
    either side (negative or positive), the solution of the equation approaches a
    certain number, and the solution to the limit is that number.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, limits are useful when the exact point of the solution
    is undefined using the conventional way of substitution.
  prefs: []
  type: TYPE_NORMAL
- en: 'A one-sided limit is different from the general limit. With a lefthand limit,
    you search for the limit going from the negative side to the positive side, and
    with a righthand limit, you search for the limit going from the positive side
    to the negative side. The general limit exists when the two one-sided limits exist
    and are equal. Therefore, the previous statements are summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The lefthand limit exists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The righthand limit exists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lefthand limit is equal to the righthand limit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The lefthand limit is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow a Superscript minus Baseline
    Endscripts f left-parenthesis x right-parenthesis equals upper L"><mrow><msub><mo
    form="prefix" movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><msup><mi>a</mi>
    <mo>-</mo></msup></mrow></msub> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>L</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The righthand limit is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow a Superscript plus Baseline Endscripts
    f left-parenthesis x right-parenthesis equals upper L"><mrow><msub><mo form="prefix"
    movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><msup><mi>a</mi> <mo>+</mo></msup></mrow></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>L</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals StartFraction x
    cubed minus 27 Over x minus 3 EndFraction"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><msup><mi>x</mi>
    <mn>3</mn></msup> <mo>-</mo><mn>27</mn></mrow> <mrow><mi>x</mi><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'What is the solution of the function when *x* = 3? Substitution leads to the
    following issue:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis 3 right-parenthesis equals StartFraction 3
    cubed minus 27 Over 3 minus 3 EndFraction equals StartFraction 27 minus 27 Over
    3 minus 3 EndFraction equals StartFraction 0 Over 0 EndFraction equals Undefined"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mn>3</mn> <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><mrow><msup><mn>3</mn> <mn>3</mn></msup> <mo>-</mo><mn>27</mn></mrow>
    <mrow><mn>3</mn><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle> <mo>=</mo> <mstyle
    displaystyle="false" scriptlevel="0"><mfrac><mrow><mn>27</mn><mo>-</mo><mn>27</mn></mrow>
    <mrow><mn>3</mn><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle> <mo>=</mo> <mstyle
    displaystyle="false" scriptlevel="0"><mfrac><mn>0</mn> <mn>0</mn></mfrac></mstyle>
    <mo>=</mo> <mtext>Undefined</mtext></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: However, thinking about this in terms of limits as shown in [Table 4-2](#table-4-2),
    it seems that as you approach *x* = 3, either from the left or right side, the
    solution tends to approach 27.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-2\. Finding x as it approaches 3
  prefs: []
  type: TYPE_NORMAL
- en: '| f(x) | x |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 2.9998 | 26.9982 |'
  prefs: []
  type: TYPE_TB
- en: '| 2.9999 | 26.9991 |'
  prefs: []
  type: TYPE_TB
- en: '| 3.0000 | Undefined |'
  prefs: []
  type: TYPE_TB
- en: '| 3.0001 | 27.0009 |'
  prefs: []
  type: TYPE_TB
- en: '| 3.0002 | 27.0018 |'
  prefs: []
  type: TYPE_TB
- en: Graphically, this can be seen as a discontinuity in the chart along both axes.
    The discontinuity exists on the line around the coordinate (3, 27). Some functions
    do not have limits. For example, what is the limit of the following function as
    *x* approaches 5?
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow 5 Endscripts StartFraction 1
    Over x minus 5 EndFraction"><mrow><msub><mo form="prefix" movablelimits="true">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mn>5</mn></mrow></msub> <mfrac><mn>1</mn> <mrow><mi>x</mi><mo>-</mo><mn>5</mn></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Looking at [Table 4-3](#table-4-3), it seems that as *x* approaches 5, the results
    highly diverge when approaching from both sides. For instance, approaching from
    the negative side, the limit of 4.9999 is –10,000, and from the positive side,
    the limit of 5.0001 is 10,000.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-3\. Finding x as it approaches 5
  prefs: []
  type: TYPE_NORMAL
- en: '| f(x) | x |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 4.9998 | –5000 |'
  prefs: []
  type: TYPE_TB
- en: '| 4.9999 | –10000 |'
  prefs: []
  type: TYPE_TB
- en: '| 5.0000 | Undefined |'
  prefs: []
  type: TYPE_TB
- en: '| 5.0001 | 10000 |'
  prefs: []
  type: TYPE_TB
- en: '| 5.0002 | 5000 |'
  prefs: []
  type: TYPE_TB
- en: Remember that for the general limit to exist, both one-sided limits must exist
    and must be equal, which is not the case here. Graphing this gives [Figure 4-13](#figure-4-13),
    which may help you understand why the limit does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_0413.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-13\. A graph of the function proving that the limit does not exist
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'But what if the function that you want to analyze looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow 5 Endscripts StartFraction 1
    Over StartAbsoluteValue x minus 5 EndAbsoluteValue EndFraction"><mrow><msub><mo
    form="prefix" movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>5</mn></mrow></msub>
    <mfrac><mn>1</mn> <mrow><mo>|</mo><mi>x</mi><mo>-</mo><mn>5</mn><mo>|</mo></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at [Table 4-3](#table-4-3), it seems that as *x* approaches 5, the
    results rapidly accelerate as they diverge to a very big number referred to as
    infinity (∞):'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals StartFraction 1
    Over StartAbsoluteValue x minus 5 EndAbsoluteValue EndFraction"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><mn>1</mn> <mrow><mo>|</mo><mi>x</mi><mo>-</mo><mn>5</mn><mo>|</mo></mrow></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at [Table 4-4](#table-4-4):'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-4\. Another attempt at finding x as it approaches 5
  prefs: []
  type: TYPE_NORMAL
- en: '| f(x) | x |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 4.99997 | 334333.33 |'
  prefs: []
  type: TYPE_TB
- en: '| 4.99998 | 50000 |'
  prefs: []
  type: TYPE_TB
- en: '| 4.99999 | 100000 |'
  prefs: []
  type: TYPE_TB
- en: '| 4.9999999 | 10000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 5.00000 | Undefined |'
  prefs: []
  type: TYPE_TB
- en: '| 5.0000001 | 10000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 5.00001 | 100000 |'
  prefs: []
  type: TYPE_TB
- en: '| 5.00002 | 50000 |'
  prefs: []
  type: TYPE_TB
- en: '| 5.00003 | 334333.33 |'
  prefs: []
  type: TYPE_TB
- en: At every tiny step, *x* approaches 5, and *y* approaches positive infinity.
    The answer to the limit question is therefore positive infinity (+∞). [Figure 4-14](#figure-4-14)
    shows the graph of the function. Notice how both sides rise in value as *x* approaches
    5.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_0414.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-14\. A graph of the function proving that the limit exists as x approaches
    5
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '*Continuous* functions are ones that are drawn without gaps or holes in the
    graph, while *discontinuous* functions contain such gaps and holes. This usually
    means that the latter contain points where the solution of the functions is undefined
    and may need to be approximated by limits. Therefore, continuity and limits are
    two related concepts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s proceed to solving limits; after all, you are not going to create a table
    every time and analyze the results subjectively to find the limits. There are
    three ways to solve limits:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Substitution*: This is the simplest rule and is generally used first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Factoring*: This comes after substitution does not work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Conjugate methods*: This solution comes after the first two do not work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Substitution* involves simply plugging in the value that *x* approaches. Basically,
    these are functions that have solutions where the limits are used. Take the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow 5 Endscripts x plus 10 minus
    2 x"><mrow><msub><mo form="prefix" movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>5</mn></mrow></msub>
    <mi>x</mi> <mo>+</mo> <mn>10</mn> <mo>-</mo> <mn>2</mn> <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Using substitution, the limit of the function is found as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row  limit Underscript x right-arrow 5 Endscripts
    x plus 10 minus 2 x equals 5 plus 10 minus left-parenthesis 2 times 5 right-parenthesis
    equals 5 EndLayout"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><munder><mo
    form="prefix" movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>5</mn></mrow></munder>
    <mi>x</mi> <mo>+</mo> <mn>10</mn> <mo>-</mo> <mn>2</mn> <mi>x</mi> <mo>=</mo>
    <mn>5</mn> <mo>+</mo> <mn>10</mn> <mo>-</mo> <mrow><mo>(</mo> <mn>2</mn> <mo>×</mo>
    <mn>5</mn> <mo>)</mo></mrow> <mo>=</mo> <mn>5</mn></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the answer to the limit is 5.
  prefs: []
  type: TYPE_NORMAL
- en: '*Factoring* is the next option when substitution does not work (e.g., the limit
    is undefined after plugging the value of *x* into the function). *Factoring* is
    all about changing the form of the equation using factors in such a way that the
    equation is not undefined anymore when using substitution. Take the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow negative 6 Endscripts StartFraction
    left-parenthesis x plus 6 right-parenthesis left-parenthesis x squared minus x
    plus 1 right-parenthesis Over x plus 6 EndFraction"><mrow><msub><mo form="prefix"
    movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></msub>
    <mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mn>6</mn><mo>)</mo></mrow><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mrow>
    <mrow><mi>x</mi><mo>+</mo><mn>6</mn></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try substitution, you will get an undefined value as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row  limit Underscript x right-arrow negative
    6 Endscripts StartFraction left-parenthesis x plus 6 right-parenthesis left-parenthesis
    x squared minus x plus 1 right-parenthesis Over x plus 6 EndFraction equals StartFraction
    left-parenthesis negative 6 plus 6 right-parenthesis left-parenthesis left-parenthesis
    negative 6 right-parenthesis squared minus left-parenthesis negative 6 right-parenthesis
    plus 1 right-parenthesis Over negative 6 plus 6 EndFraction equals StartFraction
    0 Over 0 EndFraction equals Undefined EndLayout"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><munder><mo form="prefix" movablelimits="true">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></munder> <mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mn>6</mn><mo>)</mo></mrow><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mrow>
    <mrow><mi>x</mi><mo>+</mo><mn>6</mn></mrow></mfrac> <mo>=</mo> <mfrac><mrow><mrow><mo>(</mo><mo>-</mo><mn>6</mn><mo>+</mo><mn>6</mn><mo>)</mo></mrow><mo>(</mo><msup><mrow><mo>(</mo><mo>-</mo><mn>6</mn><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>-</mo><mrow><mo>(</mo><mo>-</mo><mn>6</mn><mo>)</mo></mrow><mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>6</mn><mo>+</mo><mn>6</mn></mrow></mfrac> <mo>=</mo> <mfrac><mn>0</mn>
    <mn>0</mn></mfrac> <mo>=</mo> <mtext>Undefined</mtext></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Factoring may help in this case. For example, the nominator is multiplied by
    (*x *+ 6) and then divided by (*x* + 6). Simplifying this by canceling the two
    terms could give a solution:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow negative 6 Endscripts StartFraction
    left-parenthesis x plus 6 right-parenthesis left-parenthesis x squared minus x
    plus 1 right-parenthesis Over x plus 6 EndFraction equals limit Underscript x
    right-arrow negative 6 Endscripts x squared minus x plus 1"><mrow><msub><mo form="prefix"
    movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></msub>
    <mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mn>6</mn><mo>)</mo></mrow><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mrow>
    <mrow><mi>x</mi><mo>+</mo><mn>6</mn></mrow></mfrac> <mo>=</mo> <msub><mo form="prefix"
    movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></msub>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo> <mi>x</mi> <mo>+</mo> <mn>1</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that factoring is done, you can try substitution once again:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow negative 6 Endscripts x squared
    minus x plus 1 equals left-parenthesis negative 6 right-parenthesis squared minus
    left-parenthesis negative 6 right-parenthesis plus 1 equals 43"><mrow><msub><mo
    form="prefix" movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mo>-</mo><mn>6</mn></mrow></msub>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo> <mi>x</mi> <mo>+</mo> <mn>1</mn>
    <mo>=</mo> <msup><mrow><mo>(</mo><mo>-</mo><mn>6</mn><mo>)</mo></mrow> <mn>2</mn></msup>
    <mo>-</mo> <mrow><mo>(</mo> <mo>-</mo> <mn>6</mn> <mo>)</mo></mrow> <mo>+</mo>
    <mn>1</mn> <mo>=</mo> <mn>43</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: The limit of the function as *x* tends toward –6 is therefore 43.
  prefs: []
  type: TYPE_NORMAL
- en: 'Forming a conjugate is the next option when substitution and factoring do not
    work. A *conjugate* is formed by simply changing signs between two variables.
    For example, the conjugate of *x* + *y* is  *x* – *y*. The way to do this in the
    case of a fraction is to multiply the nominator and the denominator by the conjugate
    of one of them (with a preference to use the conjugate of the term that has a
    square root since it will get canceled out). Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow 9 Endscripts StartFraction x
    minus 9 Over StartRoot x EndRoot minus 3 EndFraction"><mrow><msub><mo form="prefix"
    movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub>
    <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mi>x</mi><mo>-</mo><mn>9</mn></mrow>
    <mrow><msqrt><mi>x</mi></msqrt><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'By multiplying both terms by the conjugate of the denominator, you will have
    started to use the conjugate method to solve the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow 9 Endscripts StartFraction x
    minus 9 Over StartRoot x EndRoot minus 3 EndFraction left-parenthesis StartFraction
    StartRoot x EndRoot plus 3 Over StartRoot x EndRoot plus 3 EndFraction right-parenthesis"><mrow><msub><mo
    form="prefix" movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub>
    <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mi>x</mi><mo>-</mo><mn>9</mn></mrow>
    <mrow><msqrt><mi>x</mi></msqrt><mo>-</mo><mn>3</mn></mrow></mfrac></mstyle> <mrow><mo>(</mo>
    <mfrac><mrow><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn></mrow> <mrow><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn></mrow></mfrac>
    <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking into account the multiplication and then simplifying gives the following:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow 9 Endscripts StartFraction left-parenthesis
    x minus 9 right-parenthesis left-parenthesis StartRoot x EndRoot plus 3 right-parenthesis
    Over left-parenthesis StartRoot x EndRoot minus 3 right-parenthesis left-parenthesis
    StartRoot x EndRoot plus 3 right-parenthesis EndFraction"><mrow><msub><mo form="prefix"
    movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub>
    <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>-</mo><mn>9</mn><mo>)</mo></mrow><mrow><mo>(</mo><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn><mo>)</mo></mrow></mrow>
    <mrow><mrow><mo>(</mo><msqrt><mi>x</mi></msqrt><mo>-</mo><mn>3</mn><mo>)</mo></mrow><mrow><mo>(</mo><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn><mo>)</mo></mrow></mrow></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be left with the following familiar situation:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow 9 Endscripts StartFraction left-parenthesis
    x minus 9 right-parenthesis left-parenthesis StartRoot x EndRoot plus 3 right-parenthesis
    Over x minus 9 EndFraction"><mrow><msub><mo form="prefix" movablelimits="true">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub> <mfrac><mrow><mrow><mo>(</mo><mi>x</mi><mo>-</mo><mn>9</mn><mo>)</mo></mrow><mrow><mo>(</mo><msqrt><mi>x</mi></msqrt><mo>+</mo><mn>3</mn><mo>)</mo></mrow></mrow>
    <mrow><mi>x</mi><mo>-</mo><mn>9</mn></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow 9 Endscripts StartRoot x EndRoot
    plus 3"><mrow><msub><mo form="prefix" movablelimits="true">lim</mo> <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub>
    <msqrt><mi>x</mi></msqrt> <mo>+</mo> <mn>3</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the function is ready for substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow 9 Endscripts StartRoot 9 EndRoot
    plus 3 equals 3 plus 3 equals 6"><mrow><msub><mo form="prefix" movablelimits="true">lim</mo>
    <mrow><mi>x</mi><mo>→</mo><mn>9</mn></mrow></msub> <msqrt><mn>9</mn></msqrt> <mo>+</mo>
    <mn>3</mn> <mo>=</mo> <mn>3</mn> <mo>+</mo> <mn>3</mn> <mo>=</mo> <mn>6</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: The solution to the function is therefore 6\. As you can see, sometimes work
    needs to be done on the equations before they are ready for substitution.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The key takeaways from this section are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Limits help find solutions for functions that may be undefined in certain points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the general limit to exist, the two one-sided limits must exist and must
    be equal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are ways to find the limit of a function, notably substitution, factoring,
    and forming the conjugate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Derivatives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *derivative* measures the change in a function given a change of one or more
    of its inputs. In other words, it is the rate of change of a function at a given
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a solid understanding of derivatives is important in building machine
    learning models, for multiple reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimization
  prefs: []
  type: TYPE_NORMAL
- en: To minimize the loss function, optimization methods employ derivatives to ascertain
    the direction of the steepest descent and modify the model’s parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Backpropagation
  prefs: []
  type: TYPE_NORMAL
- en: To execute gradient descent in deep learning, the backpropagation technique
    uses derivatives to calculate the gradients of the loss function with respect
    to the model’s parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperparameter tuning
  prefs: []
  type: TYPE_NORMAL
- en: To improve the performance of the model, derivatives are used for sensitivity
    analysis and tuning of hyperparameters.
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget what you learned from the previous section on limits, as you will
    need this knowledge for this section as well. Calculus mainly deals with derivatives
    and integrals. This section discusses derivatives and their uses.
  prefs: []
  type: TYPE_NORMAL
- en: You can consider derivatives to be functions that represent (or model) the slope
    of another function at some point. A *slope* is a measure of a line’s position
    relative to a horizontal line. A positive slope indicates a line moving up, while
    a negative slope indicates a line moving down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Derivatives and slopes are related concepts, but they are not the same thing.
    Here’s the main difference between the two:'
  prefs: []
  type: TYPE_NORMAL
- en: Slope
  prefs: []
  type: TYPE_NORMAL
- en: The slope measures the steepness of a line. It is the ratio of the change in
    the *y*-axis to the change in the *x*-axis.
  prefs: []
  type: TYPE_NORMAL
- en: Derivative
  prefs: []
  type: TYPE_NORMAL
- en: The derivative describes the rate of change of a given function. As the distance
    between two points on a function approaches zero, the derivative of that function
    at that point is the limit of the slope of the tangent line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before explaining derivatives in layperson’s terms and showing some examples,
    let’s see their formal definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts StartFraction f left-parenthesis x plus h right-parenthesis
    minus f left-parenthesis x right-parenthesis Over h EndFraction"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo
    form="prefix" movablelimits="true">lim</mo> <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub>
    <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo>)</mo><mo>-</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mi>h</mi></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The equation forms the basis of solving derivatives, although there are many
    shortcuts that you will learn about. Let’s try finding the derivative of a function
    using the formal definition. Consider the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals x squared plus
    4 x minus 2"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>4</mn> <mi>x</mi> <mo>-</mo>
    <mn>2</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the derivative, plug *f(x)* into the formal definition and then solve
    the limit:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts StartFraction f left-parenthesis x plus h right-parenthesis
    minus f left-parenthesis x right-parenthesis Over h EndFraction"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo
    form="prefix" movablelimits="true">lim</mo> <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub>
    <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo>)</mo><mo>-</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mi>h</mi></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify things, let’s find *f(x + h)* so that plugging it into the formal
    definition becomes easier:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x plus h right-parenthesis equals left-parenthesis
    x plus h right-parenthesis squared plus 4 left-parenthesis x plus h right-parenthesis
    minus 2"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>+</mo> <mi>h</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msup><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>+</mo> <mn>4</mn> <mrow><mo>(</mo> <mi>x</mi> <mo>+</mo>
    <mi>h</mi> <mo>)</mo></mrow> <mo>-</mo> <mn>2</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x plus h right-parenthesis equals x squared
    plus 2 x h plus h squared plus 4 x plus 4 h minus 2"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>+</mo> <mi>h</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>2</mn> <mi>x</mi> <mi>h</mi> <mo>+</mo> <msup><mi>h</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>4</mn> <mi>x</mi> <mo>+</mo> <mn>4</mn> <mi>h</mi>
    <mo>-</mo> <mn>2</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s plug *f(x + h)* into the definition:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts StartFraction x squared plus 2 x h plus h squared plus
    4 x plus 4 h minus 2 minus x squared minus 4 x plus 2 Over h EndFraction"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo
    form="prefix" movablelimits="true">lim</mo> <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub>
    <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo><mn>2</mn><mi>x</mi><mi>h</mi><mo>+</mo><msup><mi>h</mi> <mn>2</mn></msup>
    <mo>+</mo><mn>4</mn><mi>x</mi><mo>+</mo><mn>4</mn><mi>h</mi><mo>-</mo><mn>2</mn><mo>-</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mn>4</mn><mi>x</mi><mo>+</mo><mn>2</mn></mrow> <mi>h</mi></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how there are many terms that can be simplified so that the formula
    becomes clearer. Remember, you are trying to find the limit for the moment, and
    the derivative is found after solving the limit:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts StartFraction 2 x h plus h squared plus 4 h Over h
    EndFraction"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msub><mo form="prefix" movablelimits="true">lim</mo>
    <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><mrow><mn>2</mn><mi>x</mi><mi>h</mi><mo>+</mo><msup><mi>h</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>4</mn><mi>h</mi></mrow> <mi>h</mi></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The division by *h* gives further potential for simplification since you can
    divide all the terms in the numerator by the denominator *h*:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals limit Underscript
    h right-arrow 0 Endscripts 2 x plus h plus 4"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo form="prefix"
    movablelimits="true">lim</mo> <mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></msub>
    <mn>2</mn> <mi>x</mi> <mo>+</mo> <mi>h</mi> <mo>+</mo> <mn>4</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s now time to solve the limit. Because the equation is simple, the first
    attempt is by substitution, which, as you have guessed, is possible. By substituting
    the variable *h* and making it zero (according to the limit), you are left with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x plus
    4"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>4</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'That is the derivative of the original function *f(x)*. If you want to find
    the derivative of the function when *x* = 2, you simply have to plug 2 into the
    derivative function:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis 2 right-parenthesis equals 2 left-parenthesis
    2 right-parenthesis plus 4 equals 8"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mn>2</mn> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <mrow><mo>(</mo>
    <mn>2</mn> <mo>)</mo></mrow> <mo>+</mo> <mn>4</mn> <mo>=</mo> <mn>8</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-15](#figure-4-15) shows the original function’s graph with the derivative
    (the straight line). Notice how *f''(2)* lies exactly at 8\. The slope of *f(x)*
    when *x* = 2 is 8.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_0415.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-15\. The original f(x) with its derivative f'(x)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that when *f(x)* hits the bottom and starts rising, *f'(x)* crosses the
    zero line.
  prefs: []
  type: TYPE_NORMAL
- en: You are unlikely to use the formal definition every time you want to find a
    derivative. There are derivative rules that allow you to save a lot of time through
    shortcuts. The first rule is referred to as the *power rule,* which is a way to
    find the derivative of functions with exponents.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is common to also refer to derivatives using this notation (which is the
    same thing as *f''(x)*):'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction"><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The power rule for finding derivatives is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction left-parenthesis a x Superscript
    n Baseline right-parenthesis equals left-parenthesis a period n right-parenthesis
    x Superscript n minus 1"><mrow><mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></mstyle> <mrow><mo>(</mo> <mi>a</mi>
    <msup><mi>x</mi> <mi>n</mi></msup> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo>
    <mi>a</mi> <mo lspace="0%" rspace="0%">.</mo> <mi>n</mi> <mo>)</mo></mrow> <msup><mi>x</mi>
    <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, this means that the derivative is found by multiplying the constant
    by the exponent and then subtracting 1 from the exponent. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals x Superscript 4"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>4</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals left-parenthesis
    1 times 4 right-parenthesis x Superscript left-parenthesis 4 minus 1 right-parenthesis
    Baseline equals 4 x cubed"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <mn>1</mn> <mo>×</mo>
    <mn>4</mn> <mo>)</mo></mrow> <msup><mi>x</mi> <mrow><mo>(</mo><mn>4</mn><mo>-</mo><mn>1</mn><mo>)</mo></mrow></msup>
    <mo>=</mo> <mn>4</mn> <msup><mi>x</mi> <mn>3</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that if there is no constant attached to the variable, it means that
    the constant is equal to 1\. Here’s a more complex example with the same principle:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals 2 x squared plus
    3 x Superscript 7 Baseline minus 2 x cubed"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>3</mn> <msup><mi>x</mi> <mn>7</mn></msup> <mo>-</mo> <mn>2</mn>
    <msup><mi>x</mi> <mn>3</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 4 x plus
    21 x Superscript 6 Baseline minus 6 x squared"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>4</mn> <mi>x</mi>
    <mo>+</mo> <mn>21</mn> <msup><mi>x</mi> <mn>6</mn></msup> <mo>-</mo> <mn>6</mn>
    <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth noting that the rule also applies to constants even though they
    do not satisfy the general form of the power rule. The derivative of a constant
    is zero. While it helps to know why, first you must be aware of the following
    mathematical concept:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x Superscript 0 Baseline equals 1"><mrow><msup><mi>x</mi> <mn>0</mn></msup>
    <mo>=</mo> <mn>1</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, you can imagine constants as always being multiplied by *x*
    to the power of zero (since doing so does not change their value). Now, if you
    want to find the derivative of 17, here’s how it would go:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="17 equals 17 x Superscript 0 Baseline equals left-parenthesis
    0 times 17 right-parenthesis x Superscript 0 minus 1 Baseline equals 0 x Superscript
    negative 1 Baseline equals 0"><mrow><mn>17</mn> <mo>=</mo> <mn>17</mn> <msup><mi>x</mi>
    <mn>0</mn></msup> <mo>=</mo> <mrow><mo>(</mo> <mn>0</mn> <mo>×</mo> <mn>17</mn>
    <mo>)</mo></mrow> <msup><mi>x</mi> <mrow><mn>0</mn><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <mn>0</mn> <msup><mi>x</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <mn>0</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'As you know, anything multiplied by zero returns zero as a result. This gives
    the constants rule for derivatives as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction left-parenthesis a right-parenthesis
    equals 0"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <mrow><mo>(</mo> <mi>a</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>0</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: You follow the same logic when encountering fractions or negative numbers in
    the exponents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *product rule* of derivatives is useful when there are two functions multiplied
    by each other. The product rule is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction left-bracket f left-parenthesis
    x right-parenthesis g left-parenthesis x right-parenthesis right-bracket equals
    f prime left-parenthesis x right-parenthesis g left-parenthesis x right-parenthesis
    plus f left-parenthesis x right-parenthesis g prime left-parenthesis x right-parenthesis"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mrow><mo>[</mo> <mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mi>g</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>]</mo></mrow> <mo>=</mo> <msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mi>g</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>+</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <msup><mi>g</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take an example and find the derivative using the product rule:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="h left-parenthesis x right-parenthesis equals left-parenthesis
    x squared plus 2 right-parenthesis left-parenthesis x cubed plus 1 right-parenthesis"><mrow><mi>h</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>2</mn> <mo>)</mo></mrow> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mn>3</mn></msup> <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The equation can clearly be segmented into two terms, *f(x)* and *g(x),* like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals left-parenthesis
    x squared plus 2 right-parenthesis"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>2</mn> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="g left-parenthesis x right-parenthesis equals left-parenthesis
    x cubed plus 1 right-parenthesis"><mrow><mi>g</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <msup><mi>x</mi> <mn>3</mn></msup>
    <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s find the derivatives of the two terms before applying the product rule.
    Notice that finding the derivative of *f(x)* and *g(x)* is easy once you understand
    the power rule:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn>
    <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="g prime left-parenthesis x right-parenthesis equals 3 x squared"><mrow><msup><mi>g</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>3</mn>
    <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'When applying the product rule, you should get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="h prime left-parenthesis x right-parenthesis equals left-parenthesis
    x squared plus 2 right-parenthesis left-parenthesis 3 x squared right-parenthesis
    plus left-parenthesis 2 x right-parenthesis left-parenthesis x cubed plus 1 right-parenthesis"><mrow><msup><mi>h</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>2</mn> <mo>)</mo></mrow> <mrow><mo>(</mo>
    <mn>3</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>)</mo></mrow> <mo>+</mo> <mrow><mo>(</mo>
    <mn>2</mn> <mi>x</mi> <mo>)</mo></mrow> <mrow><mo>(</mo> <msup><mi>x</mi> <mn>3</mn></msup>
    <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="h prime left-parenthesis x right-parenthesis equals 3 x Superscript
    4 Baseline plus 6 x squared plus 2 x Superscript 4 Baseline plus 2 x"><mrow><msup><mi>h</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>3</mn>
    <msup><mi>x</mi> <mn>4</mn></msup> <mo>+</mo> <mn>6</mn> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>2</mn> <msup><mi>x</mi> <mn>4</mn></msup> <mo>+</mo> <mn>2</mn>
    <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="h prime left-parenthesis x right-parenthesis equals 5 x Superscript
    4 Baseline plus 6 x squared plus 2 x"><mrow><msup><mi>h</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>5</mn> <msup><mi>x</mi>
    <mn>4</mn></msup> <mo>+</mo> <mn>6</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo>
    <mn>2</mn> <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-16](#figure-4-16) shows the graph of *h(x)* and *h''(x)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_0416.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-16\. The original h(x) with its derivative h'(x)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now let’s turn our attention to the *quotient rule,* which deals with the division
    of two functions. The formal definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction left-bracket StartFraction
    f left-parenthesis x right-parenthesis Over g left-parenthesis x right-parenthesis
    EndFraction right-bracket equals StartFraction f prime left-parenthesis x right-parenthesis
    g left-parenthesis x right-parenthesis minus f left-parenthesis x right-parenthesis
    g prime left-parenthesis x right-parenthesis Over left-bracket g left-parenthesis
    x right-parenthesis right-bracket squared EndFraction"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mrow><mo>[</mo> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow> <mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac></mstyle>
    <mo>]</mo></mrow> <mo>=</mo> <mfrac><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mi>g</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>-</mo><mi>f</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><msup><mi>g</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow> <msup><mrow><mo>[</mo><mi>g</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>]</mo></mrow>
    <mn>2</mn></msup></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s apply it to the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals StartFraction x
    squared minus x plus 1 Over x squared plus 1 EndFraction"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow> <mrow><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn></mrow></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, it’s better to start by finding the derivatives of *f(x)* and *g(x)*,
    which in this case are clearly separated, with *f(x)* being the nominator and
    *g(x)* being the denominator. When applying the quotient rule, you should get
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals StartFraction
    left-parenthesis 2 x minus 1 right-parenthesis left-parenthesis x squared plus
    1 right-parenthesis minus left-parenthesis x squared minus x plus 1 right-parenthesis
    left-parenthesis 2 x right-parenthesis Over left-parenthesis x squared plus 1
    right-parenthesis squared EndFraction"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><mrow><mrow><mo>(</mo><mn>2</mn><mi>x</mi><mo>-</mo><mn>1</mn><mo>)</mo></mrow><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow><mo>-</mo><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mrow><mo>(</mo><mn>2</mn><mi>x</mi><mo>)</mo></mrow></mrow>
    <msup><mrow><mo>(</mo><msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mn>2</mn></msup></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals StartFraction
    2 x cubed plus 2 x minus x squared minus 1 minus 2 x cubed plus 2 x squared minus
    2 x Over left-parenthesis x squared plus 1 right-parenthesis squared EndFraction"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mstyle
    displaystyle="false" scriptlevel="0"><mfrac><mrow><mn>2</mn><msup><mi>x</mi> <mn>3</mn></msup>
    <mo>+</mo><mn>2</mn><mi>x</mi><mo>-</mo><msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo><mn>1</mn><mo>-</mo><mn>2</mn><msup><mi>x</mi>
    <mn>3</mn></msup> <mo>+</mo><mn>2</mn><msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo><mn>2</mn><mi>x</mi></mrow>
    <msup><mrow><mo>(</mo><msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mn>2</mn></msup></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals StartFraction
    x squared minus 1 Over left-parenthesis x squared plus 1 right-parenthesis squared
    EndFraction"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo><mn>1</mn></mrow> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow> <mn>2</mn></msup></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: '*Exponential derivatives* deal with the power rule applied to constants. Take
    a look at the following equation. How would you find its derivative?'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals a Superscript x"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>a</mi> <mi>x</mi></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of the usual variable-base-constant-exponent, it is constant-base-variable-exponent.
    This is treated differently when trying to calculate the derivative. The formal
    definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction a Superscript x Baseline
    equals a Superscript x Baseline left-parenthesis ln a right-parenthesis"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <msup><mi>a</mi> <mi>x</mi></msup> <mo>=</mo>
    <msup><mi>a</mi> <mi>x</mi></msup> <mrow><mo>(</mo> <mo form="prefix">ln</mo>
    <mi>a</mi> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction 4 Superscript x Baseline
    equals 4 Superscript x Baseline left-parenthesis ln 4 right-parenthesis"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <msup><mn>4</mn> <mi>x</mi></msup> <mo>=</mo>
    <msup><mn>4</mn> <mi>x</mi></msup> <mrow><mo>(</mo> <mo form="prefix">ln</mo>
    <mn>4</mn> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Euler’s number, mentioned earlier, has a special derivative. When it comes
    to finding the derivative of *e*, the answer is interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction e Superscript x Baseline
    equals e Superscript x Baseline left-parenthesis ln e right-parenthesis equals
    e Superscript x"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <msup><mi>e</mi> <mi>x</mi></msup> <mo>=</mo> <msup><mi>e</mi> <mi>x</mi></msup>
    <mrow><mo>(</mo> <mo form="prefix">ln</mo> <mi>e</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>e</mi> <mi>x</mi></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: This is because the natural log function and the exponential function are inverses
    of each other, so the term *ln e* equals 1\. Therefore, the derivative of the
    exponential function *e* is itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In parallel, let’s discuss logarithmic derivatives. By now, you should know
    what exponents and logarithms are. The general definition for both types of logarithms
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction log Subscript a Baseline
    x equals StartFraction 1 Over x ln a EndFraction"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <msub><mo form="prefix">log</mo> <mi>a</mi></msub>
    <mi>x</mi> <mo>=</mo> <mfrac><mn>1</mn> <mrow><mi>x</mi><mo form="prefix">ln</mo><mi>a</mi></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction ln x equals log Subscript
    e Baseline x equals StartFraction 1 Over x ln e EndFraction equals StartFraction
    1 Over x EndFraction"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <mo form="prefix">ln</mo> <mi>x</mi> <mo>=</mo> <msub><mo form="prefix">log</mo>
    <mi>e</mi></msub> <mi>x</mi> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mn>1</mn>
    <mrow><mi>x</mi><mo form="prefix">ln</mo><mi>e</mi></mrow></mfrac></mstyle> <mo>=</mo>
    <mfrac><mn>1</mn> <mi>x</mi></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Notice how in the second derivative function of the natural logarithm, the term
    *ln e* is once again encountered, thus making simplification quite easy since
    it is equal to 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals 7 l o g 2 left-parenthesis
    x right-parenthesis"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>7</mn> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the formal definition, the derivative of this logarithmic function is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 7 left-parenthesis
    StartFraction 1 Over x ln 2 EndFraction right-parenthesis equals StartFraction
    7 Over x ln 2 EndFraction"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>7</mn> <mrow><mo>(</mo> <mfrac><mn>1</mn>
    <mrow><mi>x</mi><mo form="prefix">ln</mo><mn>2</mn></mrow></mfrac> <mo>)</mo></mrow>
    <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mn>7</mn> <mrow><mi>x</mi><mo
    form="prefix">ln</mo><mn>2</mn></mrow></mfrac></mstyle></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The logarithm *log* has a base of 10, but the natural logarithm *ln* has a base
    of *e* (~2.7182).
  prefs: []
  type: TYPE_NORMAL
- en: The natural logarithm and the log function are actually linearly related through
    simple multiplication. If you know the log of the constant *a*, you can find its
    natural logarithm *ln* by multiplying the log of *a* by 2.4303.
  prefs: []
  type: TYPE_NORMAL
- en: 'One major concept in derivatives is the *chain rule*. Let’s back up to the
    power rule, which deals with exponents on variables. Remember the following formula
    to find the derivative:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction left-parenthesis a x Superscript
    n Baseline right-parenthesis equals left-parenthesis a period n right-parenthesis
    x Superscript n minus 1"><mrow><mstyle displaystyle="false" scriptlevel="0"><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></mstyle> <mrow><mo>(</mo> <mi>a</mi>
    <msup><mi>x</mi> <mi>n</mi></msup> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo>
    <mi>a</mi> <mo lspace="0%" rspace="0%">.</mo> <mi>n</mi> <mo>)</mo></mrow> <msup><mi>x</mi>
    <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simplified version because there is only *x*, but the reality is
    that you must multiply by the derivative of the term under the exponent. Until
    now, you have seen only *x* as the variable under the exponent. The derivative
    of *x* is 1, which is why it is simplified and rendered invisible. However, with
    more complex functions such as this one:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals left-parenthesis
    4 x plus 1 right-parenthesis squared"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msup><mrow><mo>(</mo><mn>4</mn><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mn>2</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The derivative of the function is found by following these two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the derivative of the outside function without touching the inside function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the derivative of the inside function and multiply it by the rest of the
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The solution is therefore as follows (knowing that the derivative of *4x* +
    1 is just 4):'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 left-parenthesis
    4 x plus 1 right-parenthesis .4"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <mrow><mo>(</mo> <mn>4</mn>
    <mi>x</mi> <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow> <mo lspace="0%" rspace="0%">.</mo>
    <mn>4</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 8 left-parenthesis
    4 x plus 1 right-parenthesis"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>8</mn> <mrow><mo>(</mo> <mn>4</mn>
    <mi>x</mi> <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 32 x plus
    8"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>32</mn> <mi>x</mi> <mo>+</mo> <mn>8</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The same applies with the exponential functions. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals e Superscript x"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi> <mi>x</mi></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals e Superscript
    x Baseline left-parenthesis 1 right-parenthesis equals e Superscript x"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi>
    <mi>x</mi></msup> <mrow><mo>(</mo> <mn>1</mn> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi>
    <mi>x</mi></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: The chain rule can actually be considered a master rule as it applies anywhere,
    even in the product rule and the quotient rule.
  prefs: []
  type: TYPE_NORMAL
- en: There are more concepts to master in derivatives, but as this book is not meant
    to be a full calculus master class, you should at least know the meaning of a
    derivative, how it is found, what it represents, and how it can be used in machine
    and deep learning.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The key takeaways from this section are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A derivative measures the change in a function given a change of one or more
    of its inputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The power rule is used to find the derivative of a function raised to a power.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The product rule is used to find the derivative of two functions that are multiplied
    together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The quotient rule is used to find the derivative of two functions that are divided
    by each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chain rule is the main rule used in differentiating (which means the process
    of finding the derivative). Due to simplicity, it is often overlooked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Derivatives play a crucial role in machine learning, such as enabling optimization
    techniques, aiding model training, and enhancing the interpretability of the models.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrals and the Fundamental Theorem of Calculus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *integral* is an operation that represents the area under a curve of a function
    given an interval. It is the inverse of a derivative, which is why it is also
    called an *antiderivative*.
  prefs: []
  type: TYPE_NORMAL
- en: The process of finding integrals is called *integration*. Integrals can be used
    to find areas below a curve, and they are heavily used in the world of finance
    in such areas as risk management, portfolio management, probabilistic methods,
    and even option pricing.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to understand an integral is to think of calculating an area
    below the curve of a function. This can be done by manually calculating the different
    changes in the *x*-axis, but adding these slices to find the area is a tedious
    process. This is where integrals come to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that an integral is the inverse of a derivative. This is important
    because it implies a direct relationship between the two. The basic definition
    of an integral is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral f left-parenthesis x right-parenthesis d x equals upper
    F left-parenthesis upper X right-parenthesis plus upper C"><mrow><mo>∫</mo> <mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mi>F</mi> <mo>(</mo>
    <mi>X</mi> <mo>)</mo> <mo>+</mo> <mi>C</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="The integral symbol represents the integration process"><mrow><mtext>The</mtext>
    <mo>∫</mo> <mtext>symbol</mtext> <mtext>represents</mtext> <mtext>the</mtext>
    <mtext>integration</mtext> <mtext>process</mtext></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis is the derivative of the
    general function upper F left-parenthesis x right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mtext>is</mtext> <mtext>the</mtext> <mtext>derivative</mtext>
    <mtext>of</mtext> <mtext>the</mtext> <mtext>general</mtext> <mtext>function</mtext>
    <mi>F</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper C represents the lost constant in the differentiation process"><mrow><mi>C</mi>
    <mtext>represents</mtext> <mtext>the</mtext> <mtext>lost</mtext> <mtext>constant</mtext>
    <mtext>in</mtext> <mtext>the</mtext> <mtext>differentiation</mtext> <mtext>process</mtext></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="d x represents slicing along x as it approaches zero"><mrow><mi>d</mi>
    <mi>x</mi> <mtext>represents</mtext> <mtext>slicing</mtext> <mtext>along</mtext>
    <mi>x</mi> <mtext>as</mtext> <mtext>it</mtext> <mtext>approaches</mtext> <mtext>zero</mtext></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: The preceding equation means that the integral of *f(x)* is the general function
    *F(x)* plus a constant *C*, which was lost in the initial differentiation process.
    Here’s an example to better explain the need to put in the constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals x squared plus
    5"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>5</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculating its derivative, you get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn>
    <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Now, what if you wanted to integrate it so that you go back to the original
    function (which in this case is represented by the capital letter *F(x)* instead
    of *f(x)*)?
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral 2 x d x"><mrow><mo>∫</mo> <mn>2</mn> <mi>x</mi> <mi>d</mi>
    <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, having seen the differentiation process (which means taking the derivative),
    you would return 2 as the exponent, which gives you the following answer:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral 2 x d x equals x squared"><mrow><mo>∫</mo> <mn>2</mn>
    <mi>x</mi> <mi>d</mi> <mi>x</mi> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'This does not look like the original function. It’s missing the constant 5\.
    But you have no way of knowing that, and even if you knew there was a constant,
    you would have no way of knowing what it is: 1? 2? 677? This is why a constant
    *C* is added in the integration process to represent the lost constant. Therefore,
    the answer to the integration problem is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral 2 x d x equals x squared plus upper C"><mrow><mo>∫</mo>
    <mn>2</mn> <mi>x</mi> <mi>d</mi> <mi>x</mi> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mi>C</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Up until now, the discussion has been limited to *indefinite integrals* where
    the integration symbol is *naked* (which means there are no boundaries to it).
    You will see what this means right after we define the necessary rules to complete
    the integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the power function (just like the previous function), the general rule
    for integration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral x Superscript a Baseline d x equals StartFraction x
    Superscript a plus 1 Baseline Over a plus 1 EndFraction plus upper C"><mrow><mo>∫</mo>
    <msup><mi>x</mi> <mi>a</mi></msup> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><msup><mi>x</mi> <mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow></msup>
    <mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mstyle> <mo>+</mo> <mi>C</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'This is much simpler than it looks. You are just reversing the power rule you
    saw earlier. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral 2 x Superscript 6 d x"><mrow><mo>∫</mo> <mn>2</mn> <msup><mi>x</mi>
    <mn>6</mn></msup> <mi>d</mi> <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral 2 x Superscript 6 Baseline d x equals StartFraction
    2 x Superscript 7 Baseline Over 7 EndFraction plus upper C"><mrow><mo>∫</mo> <mn>2</mn>
    <msup><mi>x</mi> <mn>6</mn></msup> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><mrow><mn>2</mn><msup><mi>x</mi> <mn>7</mn></msup></mrow>
    <mn>7</mn></mfrac></mstyle> <mo>+</mo> <mi>C</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral 2 x Superscript 6 Baseline d x equals two-sevenths x
    Superscript 7 Baseline plus upper C"><mrow><mo>∫</mo> <mn>2</mn> <msup><mi>x</mi>
    <mn>6</mn></msup> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mstyle displaystyle="false"
    scriptlevel="0"><mfrac><mn>2</mn> <mn>7</mn></mfrac></mstyle> <msup><mi>x</mi>
    <mn>7</mn></msup> <mo>+</mo> <mi>C</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify your answer, you can find the derivative of the result (using the
    power rule):'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals two-sevenths
    x Superscript 7 Baseline plus upper C"><mrow><mi>F</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mn>2</mn>
    <mn>7</mn></mfrac></mstyle> <msup><mi>x</mi> <mn>7</mn></msup> <mo>+</mo> <mi>C</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals left-parenthesis
    7 right-parenthesis two-sevenths x Superscript 7 minus 1 Baseline plus 0"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo>
    <mn>7</mn> <mo>)</mo></mrow> <mstyle displaystyle="false" scriptlevel="0"><mfrac><mn>2</mn>
    <mn>7</mn></mfrac></mstyle> <msup><mi>x</mi> <mrow><mn>7</mn><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>+</mo> <mn>0</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x Superscript
    6"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>2</mn> <msup><mi>x</mi> <mn>6</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take another example. Consider the following integration problem:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral 2 d x"><mrow><mo>∫</mo> <mn>2</mn> <mi>d</mi> <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, using the rule, you should find the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral 2 d x equals 2 x plus upper C"><mrow><mo>∫</mo> <mn>2</mn>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mi>C</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move on to *definite integrals,* which are integrals with numbers on
    the top and bottom that represent intervals below a curve of a function. Hence,
    *indefinite* integrals find the area under the curve everywhere, and definite
    integrals are bounded within an interval given by point *a* and point *b*. The
    general definition of indefinite integrals is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral Subscript a Superscript b Baseline f left-parenthesis
    x right-parenthesis d x equals upper F left-parenthesis upper B right-parenthesis
    minus upper F left-parenthesis upper A right-parenthesis"><mrow><msubsup><mo>∫</mo>
    <mi>a</mi> <mi>b</mi></msubsup> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo> <mi>B</mi> <mo>)</mo></mrow>
    <mo>-</mo> <mi>F</mi> <mrow><mo>(</mo> <mi>A</mi> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'This is as simple as it gets. You will solve the integral, then plug in the
    two numbers and subtract the two functions from each other. Consider the following
    evaluation of an integral (integral solving is commonly referred to as *evaluating*
    the integral):'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="integral Subscript 0 Superscript 6 Baseline 3 x squared minus
    10 x plus 4 d x"><mrow><msubsup><mo>∫</mo> <mn>0</mn> <mn>6</mn></msubsup> <mn>3</mn>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo> <mn>10</mn> <mi>x</mi> <mo>+</mo>
    <mn>4</mn> <mi>d</mi> <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to understand what is being asked. From the definition of
    integrals, it seems that the area between [0, 2] on the *x*-axis is to be calculated
    using the given function:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    left-bracket x cubed minus 5 x squared plus 4 x plus upper C right-bracket right-parenthesis
    vertical-bar Subscript 0 Baseline Superscript 6 Baseline"><mrow><mi>F</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <mrow><mo>[</mo> <msup><mi>x</mi>
    <mn>3</mn></msup> <mo>-</mo> <mn>5</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo>
    <mn>4</mn> <mi>x</mi> <mo>+</mo> <mi>C</mi> <mo>]</mo></mrow> <mo>)</mo></mrow>
    <msubsup><mrow><mo>|</mo></mrow> <mn>0</mn> <mn>6</mn></msubsup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'To evaluate the integral at the given points, simply plug in the values as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    left-bracket 6 cubed minus 5 left-parenthesis 6 right-parenthesis squared plus
    4 left-parenthesis 6 right-parenthesis plus upper C right-bracket right-parenthesis
    minus left-parenthesis left-bracket 0 cubed minus 5 left-parenthesis 0 right-parenthesis
    squared plus 4 left-parenthesis 0 right-parenthesis plus upper C right-bracket
    right-parenthesis"><mrow><mi>F</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mrow><mo>(</mo> <mrow><mo>[</mo> <msup><mn>6</mn> <mn>3</mn></msup>
    <mo>-</mo> <mn>5</mn> <msup><mrow><mo>(</mo><mn>6</mn><mo>)</mo></mrow> <mn>2</mn></msup>
    <mo>+</mo> <mn>4</mn> <mrow><mo>(</mo> <mn>6</mn> <mo>)</mo></mrow> <mo>+</mo>
    <mi>C</mi> <mo>]</mo></mrow> <mo>)</mo></mrow> <mo>-</mo> <mrow><mo>(</mo> <mrow><mo>[</mo>
    <msup><mn>0</mn> <mn>3</mn></msup> <mo>-</mo> <mn>5</mn> <msup><mrow><mo>(</mo><mn>0</mn><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>+</mo> <mn>4</mn> <mrow><mo>(</mo> <mn>0</mn> <mo>)</mo></mrow>
    <mo>+</mo> <mi>C</mi> <mo>]</mo></mrow> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    left-bracket 216 minus 180 plus 24 plus upper C right-bracket right-parenthesis
    minus left-parenthesis left-bracket 0 minus 0 plus 0 plus upper C right-bracket
    right-parenthesis"><mrow><mi>F</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo>
    <mo>(</mo> <mo>[</mo> <mn>216</mn> <mo>-</mo> <mn>180</mn> <mo>+</mo> <mn>24</mn>
    <mo>+</mo> <mi>C</mi> <mo>]</mo> <mo>)</mo> <mo>-</mo> <mo>(</mo> <mo>[</mo> <mn>0</mn>
    <mo>-</mo> <mn>0</mn> <mo>+</mo> <mn>0</mn> <mo>+</mo> <mi>C</mi> <mo>]</mo> <mo>)</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    left-bracket 60 plus upper C right-bracket right-parenthesis minus left-parenthesis
    left-bracket 0 plus upper C right-bracket right-parenthesis"><mrow><mi>F</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mo>(</mo> <mo>[</mo> <mn>60</mn>
    <mo>+</mo> <mi>C</mi> <mo>]</mo> <mo>)</mo> <mo>-</mo> <mo>(</mo> <mo>[</mo> <mn>0</mn>
    <mo>+</mo> <mi>C</mi> <mo>]</mo> <mo>)</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals left-parenthesis
    60 minus 0 right-parenthesis"><mrow><mi>F</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo>
    <mo>=</mo> <mo>(</mo> <mn>60</mn> <mo>-</mo> <mn>0</mn> <mo>)</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper F left-parenthesis x right-parenthesis equals 60"><mrow><mi>F</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mn>60</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The constant *C* will always cancel out indefinite integrals, so you can leave
    it out in this kind of problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the area below the graph of *f(x)* and above the *x*-axis, as well
    as between [0, 6] on the *x*-axis, is equal to 60 square units. The following
    shows a few rules of thumb on integrals (after all, this chapter is supposed to
    refresh your knowledge or give you a basic understanding of a few key mathematical
    concepts):'
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the integral of a constant:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="integral a d x equals a x plus upper C"><mrow><mo>∫</mo> <mi>a</mi>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mi>a</mi> <mi>x</mi> <mo>+</mo> <mi>C</mi></mrow></math>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To find the integral of a variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="integral x d x equals one-half x squared plus upper C"><mrow><mo>∫</mo>
    <mi>x</mi> <mi>d</mi> <mi>x</mi> <mo>=</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mi>C</mi></mrow></math>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To find the integral of a reciprocal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="integral StartFraction 1 Over x EndFraction d x equals ln StartAbsoluteValue
    x EndAbsoluteValue plus upper C"><mrow><mo>∫</mo> <mfrac><mn>1</mn> <mi>x</mi></mfrac>
    <mi>d</mi> <mi>x</mi> <mo>=</mo> <mo form="prefix">ln</mo> <mrow><mo>|</mo> <mi>x</mi>
    <mo>|</mo></mrow> <mo>+</mo> <mi>C</mi></mrow></math>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To find the integral of an exponential:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="integral a Superscript x Baseline d x equals StartFraction a
    Superscript x Baseline Over ln left-parenthesis a right-parenthesis EndFraction
    plus upper C"><mrow><mo>∫</mo> <msup><mi>a</mi> <mi>x</mi></msup> <mi>d</mi> <mi>x</mi>
    <mo>=</mo> <mfrac><msup><mi>a</mi> <mi>x</mi></msup> <mrow><mo form="prefix">ln</mo><mo>(</mo><mi>a</mi><mo>)</mo></mrow></mfrac>
    <mo>+</mo> <mi>C</mi></mrow></math>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <math alttext="integral e Superscript x Baseline d x equals e Superscript x
    Baseline plus upper C"><mrow><mo>∫</mo> <msup><mi>e</mi> <mi>x</mi></msup> <mi>d</mi>
    <mi>x</mi> <mo>=</mo> <msup><mi>e</mi> <mi>x</mi></msup> <mo>+</mo> <mi>C</mi></mrow></math>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The *fundamental theorem of calculus* links derivatives with integrals. This
    means that it defines derivatives in terms of integrals and vice versa. The fundamental
    theorem of calculus is actually made up of two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Part I
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the fundamental theorem of calculus states that if you have
    a continuous function *f(x)*, then the original function *F(x)* defined as the
    antiderivative of *f(x)* from a fixed starting point *a* up to *x* is a function
    that is differentiable everywhere from *a* to *x*, and its derivative is simply
    *f(x)* evaluated at *x*.
  prefs: []
  type: TYPE_NORMAL
- en: Part II
  prefs: []
  type: TYPE_NORMAL
- en: The second part of the fundamental theorem of calculus states that if you have
    a function *f(x)* that is continuous over a certain interval [*a, b*], and you
    define a new function *F(x)* as the integral of *f(x)* from *a* to *x*, then the
    definite integral of *f(x)* over that same interval [*a, b*] can be calculated
    as *F(b) – F(a)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The theorem is useful in many fields, including physics and engineering, but
    optimization and other mathematical models also benefit from it. Some examples
    of using integrals in the different learning algorithms can be summed up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Density estimation
  prefs: []
  type: TYPE_NORMAL
- en: Integrals are used in density estimation, a part of many machine learning algorithms,
    to calculate the probability density function.
  prefs: []
  type: TYPE_NORMAL
- en: Reinforcement learning
  prefs: []
  type: TYPE_NORMAL
- en: Integrals are used in reinforcement learning to calculate expected values of
    reward functions. Reinforcement learning is covered in [Chapter 10](ch10.html#ch10).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The key takeaways from this section are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrals are also known as antiderivatives and they are the opposite of derivatives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indefinite integrals find the area under the curve everywhere, while definite
    integrals are bounded within an interval given by point *a* and point *b*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fundamental theorem of calculus is the bridge between derivatives and integrals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In machine learning integrals are used for modeling uncertainty, making predictions,
    and estimating expected values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several machine and deep learning algorithms depend on optimization techniques
    to decrease error functions.
  prefs: []
  type: TYPE_NORMAL
- en: '*Optimization* is the process of finding the best solution among all possible
    solutions. Optimization is all about finding the highest and lowest points of
    a function. [Figure 4-17](#figure-4-17) shows the graph for the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals x Superscript 4
    Baseline minus 2 x squared plus x"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>4</mn></msup> <mo>-</mo> <mn>2</mn>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_0417.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-17\. A graph of the function <math alttext="f left-parenthesis x right-parenthesis
    equals x Superscript 4 Baseline minus 2 x squared plus x"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>4</mn></msup> <mo>-</mo>
    <mn>2</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mi>x</mi></mrow></math>
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A *local minimum* exists when values on the right of the *x*-axis are decreasing
    until reaching a point where they start increasing. The point does not have to
    necessarily be the lowest point in the function, hence the name *local*. In [Figure 4-17](#figure-4-17),
    the function has a local minimum at point A.
  prefs: []
  type: TYPE_NORMAL
- en: A *local maximum* exists when values on the right of the *x*-axis are increasing
    until reaching a point where they start decreasing. The point does not have to
    necessarily be the highest point in the function. In [Figure 4-17](#figure-4-17),
    the function has a local maximum at point B.
  prefs: []
  type: TYPE_NORMAL
- en: A *global minimum* exists when values on the right of the *x*-axis are decreasing
    until reaching a point where they start increasing. The point must be the lowest
    point in the function, hence the name global. In [Figure 4-17](#figure-4-17),
    the function has a global minimum at point C.
  prefs: []
  type: TYPE_NORMAL
- en: A *global maximum* exists when values on the right of the *x*-axis are increasing
    until reaching a point where they start decreasing. The point must be the highest
    point in the function. In [Figure 4-17](#figure-4-17), there is no global maximum,
    as the function will continue infinitely without creating a top. You can clearly
    see how the function accelerates upward.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with machine and deep learning models, the aim is to find model
    parameters (or inputs) that minimize what is known as a *loss function* (a function
    that gives the error of forecasts). If the loss function is convex, optimization
    techniques should find the parameters that tend toward the global minimum where
    the loss function is minimized.
  prefs: []
  type: TYPE_NORMAL
- en: If the loss function is nonconvex, the convergence is not guaranteed, and the
    optimization may only lead toward approaching a local minimum, which is a part
    of the aim, but this leaves the global minimum, which is the final aim.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how are these minima and maxima found? Let’s look at it step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to perform the first derivative test (which is calculating
    the derivative of the function). Then, setting the function equal to zero and
    solving for *x* will give what are known as critical points. *Critical points*
    are the points where the function changes direction (the values stop going in
    one direction and start going in another direction). Therefore, these points are
    maxima and minima.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second step is to perform the second derivative test (which is simply calculating
    the derivative of the derivative). Then, setting the function equal to zero and
    solving for *x* will give what are known as inflection points. *Inflection points*
    show where the function is concave up and where it is concave down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In other words, critical points are where the function changes direction, and
    inflection points are where the function changes concavity. [Figure 4-18](#figure-4-18)
    shows the difference between a concave up function and a concave down function.
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="Concave up function equals x squared"><mrow><mtext>Concave</mtext>
    <mtext>up</mtext> <mtext>function</mtext> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="Concave down function equals minus x squared"><mrow><mtext>Concave</mtext>
    <mtext>down</mtext> <mtext>function</mtext> <mo>=</mo> <mo>-</mo> <msup><mi>x</mi>
    <mn>2</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dlff_0418.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-18\. A concave up function and a concave down function
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The steps to find the extrema are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the first derivative and set it to zero.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solve the first derivative to find *x*. The values are called critical points,
    and they represent the points where the function changes direction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plug values into the formula that are either below or above the critical points.
    If the result of the first derivative is positive, it means that it’s increasing
    around that point, and if it’s negative, it means that it’s decreasing around
    that point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the second derivative and set it to zero.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solve the second derivative to find *x*. The values, called inflection points,
    represent the points where concavity changes from up to down and vice versa.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plug values into the formula that are either below or above the inflection points.
    If the result of the second derivative is positive, it means there is a minimum
    at that point, and if it’s negative, it means there is a maximum at that point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is important to understand that the first derivative test relates to critical
    points and the second derivative test relates to inflection points. The following
    example finds the extrema of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals x squared plus
    x plus 4"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mi>x</mi> <mo>+</mo> <mn>4</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to take the first derivative, set it to zero, and solve for
    *x*:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f prime left-parenthesis x right-parenthesis equals 2 x plus
    1"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>1</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="2 x plus 1 equals 0"><mrow><mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>1</mn>
    <mo>=</mo> <mn>0</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x equals negative one-half"><mrow><mi>x</mi> <mo>=</mo> <mo>-</mo>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The result shows there is a critical point at that value. Now find the second
    derivative:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f double-prime left-parenthesis x right-parenthesis equals 2"><mrow><msup><mi>f</mi>
    <mrow><mo>'</mo><mo>'</mo></mrow></msup> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>2</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the critical point must be plugged into the second derivative formula:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f double-prime left-parenthesis negative one-half right-parenthesis
    equals 2"><mrow><msup><mi>f</mi> <mrow><mo>'</mo><mo>'</mo></mrow></msup> <mrow><mo>(</mo>
    <mo>-</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: The second derivative is positive at the critical point. This means that there
    is a local minimum at that point.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming chapters, you will see more complex optimization techniques such
    as the gradient descent and the stochastic gradient descent, which are fairly
    common in machine learning algorithms. Note that you do not have to fully understand
    the details of optimization and solving for the unknown variables as the algorithms
    will do that on their own.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The key takeaways from this section are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimization is the process of finding the function’s extrema.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Critical points are the points where the function changes direction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inflection points give where the function is concave up and where it is concave
    down.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A loss function is a function that measures the error of forecasts in predictive
    machine learning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapters [2](ch02.html#ch02), [3](ch03.html#ch03), and [4](#ch04) presented
    the main numerical concepts to help you start understanding basic machine and
    deep learning models. I made all reasonable efforts to simplify the technical
    details as much as possible. However, I encourage you to read these three chapters
    at least twice so that everything you have learned becomes second nature. I also
    encourage you to research these concepts in more depth in other material.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, deep learning requires more in-depth knowledge in mathematics, but
    I believe that with the concepts in this chapter, you may start dipping your toes
    into creating algorithms. After all, they come prebuilt from packages and libraries,
    and the aim of this chapter was to help you understand what you are working with.
    It is unlikely that you will build the models from scratch using archaic tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'By now, you should have gained a certain understanding of data science and
    the mathematical requirements that will get you started comfortably. We have two
    more topics to cover before you can start building your first machine learning
    model: technical analysis and Python for data science.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch04.html#id453-marker)) Matrices can also contain symbols and expressions,
    but for the sake of simplicity, let’s stick to numbers.
  prefs: []
  type: TYPE_NORMAL
