<html><head></head><body><section data-pdf-bookmark="Chapter 11. Advanced Techniques and Strategies" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch11">&#13;
<h1><span class="label">Chapter 11. </span>Advanced Techniques and Strategies</h1>&#13;
&#13;
<p>By now, you should have a solid understanding of deep learning algorithms and how to develop a model to predict time series data. Even though this is just a first step toward deploying a profitable algorithm, you should know that you have come a long way since the beginning of the book. This chapter is divided into independent sections that discuss interesting ways of applying a few advanced deep learning techniques and methods for time series prediction and to enhance the process.</p>&#13;
&#13;
<section data-pdf-bookmark="Using COT Data to Predict Long-Term Trends" data-type="sect1"><div class="sect1" id="id82">&#13;
<h1>Using COT Data to Predict Long-Term Trends</h1>&#13;
&#13;
<p><a contenteditable="false" data-primary="Commitments of Traders (COT) report" data-secondary="using COT data to predict long-term trends" data-type="indexterm" id="Chapter_11.html0"/>The <em>Commitments of Traders</em> (COT) report is a <a href="https://oreil.ly/PLtaP">weekly publication</a> released by the US Commodity Futures Trading Commission (CFTC). It provides information on the positions held by various market participants in futures markets. The report is based on data collected from futures exchanges, including the Chicago Mercantile Exchange (CME) and the Intercontinental Exchange (ICE). The COT report <span class="keep-together">categorizes</span> traders into three main groups:</p>&#13;
&#13;
<dl>&#13;
 <dt>Commercial traders (also referred to as dealers or hedgers)</dt>&#13;
 <dd><p><a contenteditable="false" data-primary="commercial traders" data-type="indexterm" id="id791"/><a contenteditable="false" data-primary="dealers (commercial traders)" data-type="indexterm" id="id792"/><a contenteditable="false" data-primary="hedgers (commercial traders)" data-type="indexterm" id="id793"/>These are typically companies that use the futures market to hedge their main business activities. For example, a grain producer may use futures contracts to protect against price fluctuations in the agricultural market. Their positions are generally negatively correlated to the underlying market.</p></dd>&#13;
 &#13;
 <dt>Noncommercial traders (also referred to as funds or leveraged money)</dt>&#13;
 <dd><p><a contenteditable="false" data-primary="funds (noncommercial traders)" data-type="indexterm" id="id794"/><a contenteditable="false" data-primary="leveraged money (noncommercial traders)" data-type="indexterm" id="id795"/><a contenteditable="false" data-primary="noncommercial traders" data-type="indexterm" id="id796"/>This group consists of large speculators, such as hedge funds and commodity trading advisors. Noncommercial traders often take positions based on their market outlook and profit-seeking strategies. Their positions are generally positively correlated to the underlying market as they have a trend-following nature.</p></dd>&#13;
 &#13;
 <dt>Nonreportable traders</dt>&#13;
 <dd><p><a contenteditable="false" data-primary="nonreportable traders" data-type="indexterm" id="id797"/>This category includes small speculators and traders whose positions do not meet the reporting requirements set by the CFTC. They do not have a clear correlation with the underlying market.</p></dd>&#13;
</dl>&#13;
&#13;
<p>The report provides a breakdown of the positions held by each group, indicating whether they are <em>net long</em> (holding more long positions than short positions) or <em>net short </em>(holding more short positions than long positions) in a particular futures <span class="keep-together">market.</span></p>&#13;
&#13;
<p>Traders and investors analyze the COT report to gain insights into the sentiment and behavior of different market participants. By monitoring changes in positions, they attempt to identify potential trends or reversals in the market. The report is especially popular in the commodity and currency markets, where it is used as a tool for fundamental analysis and to gauge market sentiment. This section covers how to do the <span class="keep-together">following:</span></p>&#13;
&#13;
<ul>&#13;
	<li>Create an algorithm to download the COT data automatically and analyze it.</li>&#13;
	<li>Chart and understand the correlations between the COT values and their respective underlying markets. Additionally, check for stationarity in the COT values to see if they can be used directly in the algorithms.</li>&#13;
	<li>Create an LSTM algorithm to forecast the next COT value using lagged values and evaluate it. This will be referred to as the <em>indirect one-step COT model</em>.</li>&#13;
	<li>Create an LSTM algorithm to forecast a few weeks’ worth of COT observations using the direct method. This will be referred to as the <em>MPF COT direct model</em>.</li>&#13;
	<li>Create an LSTM algorithm to forecast a few weeks’ worth of COT observations using the recursive method. This will be referred to as the <em>MPF COT recursive model</em>.</li>&#13;
</ul>&#13;
&#13;
<p>There are mainly four columns of interest in the COT report: the long hedgers, the short hedgers, the long funds, and the short funds. They are the four basic pillars from which you calculate the net hedgers and the net funds. Some traders like to analyze every column before netting and seeing the bigger picture. It helps to understand the logic behind every column before proceeding to the netting process:</p>&#13;
&#13;
<dl>&#13;
	<dt>Long hedgers (the percentage long positions of commercial traders)</dt>&#13;
	<dd><p>You can consider these hedgers <em>consumers </em>of the asset. A long hedger is an entity that buys futures on a certain asset (such as wheat) to hedge its main business. The primary goal is to protect itself from the risk of rising prices by securing a fixed price they need in the future. By doing so, they can plan their production costs more accurately and avoid potential losses if wheat prices increase. Therefore, long hedgers buy the asset in fear that it will go up. They usually buy it on its way down, which results in a negative correlation with the price of the asset.</p></dd>&#13;
	<dt>Short hedgers (the percentage short positions of commercial traders)</dt>&#13;
	<dd><p>You can consider these hedgers <em>producers </em>of the asset. A short hedger is an entity that sells short futures on a certain asset to hedge its main business. The primary goal is to protect itself from the risk of falling prices. Therefore, short hedgers sell in fear that it will go down. They usually sell it on its way up, which results in a positive correlation with the price of the asset (this means that the number of short hedgers rises as the price of the asset rises).</p></dd>&#13;
	<dt>Long funds (the percentage long positions of noncommercial traders)</dt>&#13;
	<dd><p>Speculative long fund positions are buyers of futures contracts in anticipation that the price will rise. They have a positive correlation with the price of the asset on account of their trend-following nature.</p></dd>&#13;
	<dt>Short funds (the percentage short positions of noncommercial traders)</dt>&#13;
	<dd><p>Speculative short fund positions are sellers of futures contracts in anticipation that the price will go down. They have a negative correlation with the price of the asset on account of their trend-following nature. An example of this would be the decreased number of short funds as the asset goes up.</p></dd>&#13;
</dl>&#13;
&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Netting the COT report can be done in different ways depending on your needs. If you prefer to focus on commercial traders, then you can simply take the difference between commercial longs and commercial shorts (or as you may call them, consumers and producers). If you prefer to focus on noncommercial traders, then you can take the difference between noncommercial longs and noncommercial shorts. And if you prefer a global image, then you can take the difference between the netted commercial and noncommercial traders so that you’re left with only one time series that summarizes the global picture of the market positioning on a <span class="keep-together">certain asset.</span></p>&#13;
</div>&#13;
&#13;
<p><a data-type="xref" href="#table-11-1">Table 11-1</a> sheds some light on the calculation of net COT values.</p>&#13;
&#13;
<table id="table-11-1">&#13;
	<caption><span class="label">Table 11-1. </span>COT netting representation</caption>&#13;
	&#13;
	<thead>&#13;
		<tr>&#13;
			<th>Hedger long</th>&#13;
			<th>Hedger short</th>&#13;
			<th>Fund long</th>&#13;
			<th>Fund short</th>&#13;
			<th>Net hedger</th>&#13;
			<th>Net fund</th>&#13;
			<th>Net COT</th>&#13;
		</tr>&#13;
		</thead><tbody>&#13;
		<tr>&#13;
			<td>A</td>&#13;
			<td>B</td>&#13;
			<td>C</td>&#13;
			<td>D</td>&#13;
			<td>E = A – B</td>&#13;
			<td>F = C – D</td>&#13;
			<td>G = F – E</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<p>The net COT value has the following formula:</p>&#13;
&#13;
<div data-type="equation"><p>Net COT = Net funds – Net hedgers</p></div>&#13;
&#13;
<p class="pagebreak-before">It shares a positive correlation with the underlying price of the asset. <a data-type="xref" href="#figure-11-1">Figure 11-1</a> shows the net COT positioning on the Canadian dollar (CAD).</p>&#13;
&#13;
<figure><div class="figure" id="figure-11-1"><img alt="" class="iimagescad_cotpng" src="assets/dlff_1101.png"/>&#13;
<h6><span class="label">Figure 11-1. </span>Net COT CAD since 2015; notice the mean-reverting nature of the values.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Let’s see how to download COT values using Python. First, <code>pip install</code> the library that allows you to automatically download COT values from the CFTC website:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">pip</code> <code class="n">install</code> <code class="n">cot_reports</code></pre>&#13;
&#13;
<p>Just in case the library has issues, you can use the predownloaded COT reports in Excel format found in the <a href="https://oreil.ly/5YGHI">GitHub repository</a> (a code block at the end of this section is provided for this manual import).</p>&#13;
&#13;
<p>Import the required libraries to download the historical observations of the COT report. For simplicity, let’s choose CAD positioning:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>&#13;
<code class="kn">import</code> <code class="nn">matplotlib.pyplot</code> <code class="k">as</code> <code class="nn">plt</code>&#13;
<code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code>&#13;
<code class="kn">from</code> <code class="nn">master_function</code> <code class="kn">import</code> <code class="n">import_cot_data</code></pre>&#13;
&#13;
<p>The <code>import_cot_data()</code> function that allows you to fetch the COT values of a selected market is defined as follows (found in <em>master_function.py</em>):</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="k">def</code> <code class="nf">import_cot_data</code><code class="p">(</code><code class="n">start_year</code><code class="p">,</code> <code class="n">end_year</code><code class="p">,</code> <code class="n">market</code><code class="p">):</code>&#13;
    <code class="n">df</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">()</code>&#13;
    <code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="n">start_year</code><code class="p">,</code> <code class="n">end_year</code> <code class="o">+</code> <code class="mi">1</code><code class="p">):</code>&#13;
        <code class="n">single_year</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">(</code><code class="n">cot</code><code class="o">.</code><code class="n">cot_year</code><code class="p">(</code><code class="n">i</code><code class="p">,</code> &#13;
                      <code class="n">cot_report_type</code><code class="o">=</code><code class="s1">'traders_in_financial_futures_fut'</code><code class="p">))</code>&#13;
        <code class="n">df</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">concat</code><code class="p">([</code><code class="n">single_year</code><code class="p">,</code> <code class="n">df</code><code class="p">],</code> <code class="n">ignore_index</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code>&#13;
    <code class="n">new_df</code> <code class="o">=</code> <code class="n">df</code><code class="o">.</code><code class="n">loc</code><code class="p">[:,</code> <code class="p">[</code><code class="s1">'Market_and_Exchange_Names'</code><code class="p">,</code>&#13;
                        <code class="s1">'Report_Date_as_YYYY-MM-DD'</code><code class="p">,</code>&#13;
                        <code class="s1">'Pct_of_OI_Dealer_Long_All'</code><code class="p">,</code>&#13;
                        <code class="s1">'Pct_of_OI_Dealer_Short_All'</code><code class="p">,</code>&#13;
                        <code class="s1">'Pct_of_OI_Lev_Money_Long_All'</code><code class="p">,</code>                    &#13;
                        <code class="s1">'Pct_of_OI_Lev_Money_Short_All'</code><code class="p">]]</code>&#13;
    <code class="n">new_df</code><code class="p">[</code><code class="s1">'Report_Date_as_YYYY-MM-DD'</code><code class="p">]</code> <code class="o">=</code> &#13;
                       <code class="n">pd</code><code class="o">.</code><code class="n">to_datetime</code><code class="p">(</code><code class="n">new_df</code><code class="p">[</code><code class="s1">'Report_Date_as_YYYY-MM-DD'</code><code class="p">])</code>&#13;
    <code class="n">new_df</code> <code class="o">=</code> <code class="n">new_df</code><code class="o">.</code><code class="n">sort_values</code><code class="p">(</code><code class="n">by</code><code class="o">=</code><code class="s1">'Report_Date_as_YYYY-MM-DD'</code><code class="p">)</code>&#13;
    <code class="n">data</code> <code class="o">=</code> <code class="n">new_df</code><code class="p">[</code><code class="n">new_df</code><code class="p">[</code><code class="s1">'Market_and_Exchange_Names'</code><code class="p">]</code> <code class="o">==</code> <code class="n">market</code><code class="p">]</code>&#13;
    <code class="n">data</code><code class="p">[</code><code class="s1">'Net_COT'</code><code class="p">]</code> <code class="o">=</code> <code class="p">(</code><code class="n">data</code><code class="p">[</code><code class="s1">'Pct_of_OI_Lev_Money_Long_All'</code><code class="p">]</code> <code class="err">–</code> \&#13;
                       <code class="n">data</code><code class="p">[</code><code class="s1">'Pct_of_OI_Lev_Money_Short_All'</code><code class="p">])</code> <code class="err">–</code> \&#13;
                      <code class="p">(</code><code class="n">data</code><code class="p">[</code><code class="s1">'Pct_of_OI_Dealer_Long_All'</code><code class="p">]</code> <code class="err">–</code>\&#13;
                       <code class="n">data</code><code class="p">[</code><code class="s1">'Pct_of_OI_Dealer_Short_All'</code><code class="p">])</code>                &#13;
    <code class="k">return</code> <code class="n">data</code>&#13;
</pre>&#13;
&#13;
<p>To import CAD COT values, use the following syntax:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">CAD</code> <code class="o">=</code> <code class="s1">'CANADIAN DOLLAR - CHICAGO MERCANTILE EXCHANGE'</code>&#13;
<code class="n">data</code> <code class="o">=</code> <code class="n">import_cot_data</code><code class="p">(</code><code class="mi">2015</code><code class="p">,</code> <code class="mi">2023</code><code class="p">,</code> <code class="n">CAD</code><code class="p">)</code>&#13;
<code class="n">data</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">(</code><code class="n">data</code><code class="o">.</code><code class="n">iloc</code><code class="p">[:,</code> <code class="err">–</code><code class="mi">1</code><code class="p">],</code> <code class="n">dtype</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">float64</code><code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p>It is worth mentioning that other markets have the following code names that you can use to import them:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">EUR</code> <code class="o">=</code> <code class="s1">'EURO FX - CHICAGO MERCANTILE EXCHANGE'</code>&#13;
<code class="n">GBP</code> <code class="o">=</code> <code class="s1">'BRITISH POUND STERLING - CHICAGO MERCANTILE EXCHANGE'</code>&#13;
<code class="n">JPY</code> <code class="o">=</code> <code class="s1">'JAPANESE YEN - CHICAGO MERCANTILE EXCHANGE'</code>&#13;
<code class="n">CHF</code> <code class="o">=</code> <code class="s1">'SWISS FRANC - CHICAGO MERCANTILE EXCHANGE'</code>&#13;
<code class="n">AUD</code> <code class="o">=</code> <code class="s1">'AUSTRALIAN DOLLAR - CHICAGO MERCANTILE EXCHANGE'</code>&#13;
<code class="n">MXN</code> <code class="o">=</code> <code class="s1">'MEXICAN PESO - CHICAGO MERCANTILE EXCHANGE'</code>&#13;
<code class="n">BRL</code> <code class="o">=</code> <code class="s1">'BRAZILIAN REAL - CHICAGO MERCANTILE EXCHANGE'</code>&#13;
<code class="n">BTC</code> <code class="o">=</code> <code class="s1">'BITCOIN - CHICAGO MERCANTILE EXCHANGE'</code>&#13;
<code class="n">SPX</code> <code class="o">=</code> <code class="s1">'E-MINI S&amp;P 500 - CHICAGO MERCANTILE EXCHANGE'</code>&#13;
</pre>&#13;
&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In case you have a request error, try applying the following code before running the import section (remember to <code>pip install</code> the <em>proxy_requests</em> library):</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="kn">from</code> <code class="nn">proxy_requests.proxy_requests</code> <code class="kn">import</code> <code class="n">ProxyRequests</code>&#13;
<code class="n">req</code> <code class="o">=</code> <code class="n">ProxyRequests</code><code class="p">(</code><code class="s2">"https://api.ipify.org"</code><code class="p">)</code>&#13;
<code class="n">req</code><code class="o">.</code><code class="n">get</code><code class="p">()</code></pre>&#13;
</div>&#13;
&#13;
<p><a data-type="xref" href="#figure-11-2">Figure 11-2</a> shows the net COT positioning on the CAD versus the CADUSD. Notice the strong positive correlation between the two. Calculating the Pearson correlation of the last 200 observations gives a whopping 0.66. In other words, tops on the net COT data coincide with tops on the CADUSD. Similarly, troughs on the net COT data coincide with troughs on the CADUSD.</p>&#13;
&#13;
<figure><div class="figure" id="figure-11-2"><img alt="" class="iimagescadusd_cotpng" src="assets/dlff_1102.png"/>&#13;
<h6><span class="label">Figure 11-2. </span>The CADUSD (left scale) versus the CAD net COT positioning (right scale).</h6>&#13;
</div></figure>&#13;
&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Note that the chart shows the CADUSD and not the USDCAD, the commonly used pair. This is because you are trying to understand the CAD; therefore, it helps to use it as the base currency so that you can see the positive correlation with the CAD speculators and the negative correlation with the CAD hedgers. To obtain the CADUSD from the USDCAD observations, take its reciprocal:</p>&#13;
&#13;
<div data-type="equation"><p><math alttext="upper C upper A upper D upper U upper S upper D equals StartFraction 1 Over upper U upper S upper D upper C upper A upper D EndFraction">&#13;
  <mrow>&#13;
    <mi>C</mi>&#13;
    <mi>A</mi>&#13;
    <mi>D</mi>&#13;
    <mi>U</mi>&#13;
    <mi>S</mi>&#13;
    <mi>D</mi>&#13;
    <mo>=</mo>&#13;
    <mstyle displaystyle="false" scriptlevel="0">&#13;
      <mfrac><mn>1</mn> <mrow><mi>U</mi><mi>S</mi><mi>D</mi><mi>C</mi><mi>A</mi><mi>D</mi></mrow></mfrac>&#13;
    </mstyle>&#13;
  </mrow>&#13;
</math></p></div>&#13;
</div>&#13;
&#13;
<p>The next step is to check for stationarity on the COT values so as to know whether it requires transformation or not. Remember, transformation can be either differencing, taking the percentage returns, or even using fractional differentiation (as discussed in <a data-type="xref" href="ch09.html#ch09">Chapter 9</a>):</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="kn">from</code> <code class="nn">statsmodels.tsa.stattools</code> <code class="kn">import</code> <code class="n">adfuller</code>&#13;
<code class="nb">print</code><code class="p">(</code><code class="s1">'p-value: </code><code class="si">%f</code><code class="s1">'</code> <code class="o">%</code> <code class="n">adfuller</code><code class="p">(</code><code class="n">raw_data</code><code class="p">)[</code><code class="mi">1</code><code class="p">])</code></pre>&#13;
&#13;
<p>The output is as follows:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">p</code><code class="o">-</code><code class="n">value</code><code class="p">:</code> <code class="mf">0.000717</code></pre>&#13;
&#13;
<p>The COT values seem to be stationary and ready to be used as inputs in <span class="keep-together">the algorithms.</span></p>&#13;
&#13;
<section data-pdf-bookmark="Algorithm 1: Indirect One-Step COT Model" data-type="sect2"><div class="sect2" id="id83">&#13;
<h2>Algorithm 1: Indirect One-Step COT Model</h2>&#13;
&#13;
<p><a contenteditable="false" data-primary="Commitments of Traders (COT) report" data-secondary="algorithm 1: indirect one-step COT model" data-type="indexterm" id="Chapter_11.html1"/><a contenteditable="false" data-primary="long short-term memory (LSTM)" data-secondary="for indirect one-step COT model" data-type="indexterm" id="Chapter_11.html2"/>The goodness of fit model will use long short-term memory (LSTM) to predict the next COT value at every time step. The assumption is that predicting a value that is directionally correlated to the underlying market may give a bias for the expected move during the coming week. For example, if the forecast is for a higher COT value in the coming week, then you may have a bullish CAD bias in preparation of your weekly trading.</p>&#13;
&#13;
<p>First, import the required libraries:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>&#13;
<code class="kn">import</code> <code class="nn">matplotlib.pyplot</code> <code class="k">as</code> <code class="nn">plt</code>&#13;
<code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code>&#13;
<code class="kn">from</code> <code class="nn">keras.models</code> <code class="kn">import</code> <code class="n">Sequential</code>&#13;
<code class="kn">from</code> <code class="nn">keras.layers</code> <code class="kn">import</code> <code class="n">Dense</code><code class="p">,</code> <code class="n">LSTM</code>&#13;
<code class="kn">from</code> <code class="nn">master_function</code> <code class="kn">import</code> <code class="n">import_cot_data</code><code class="p">,</code> <code class="n">data_preprocessing</code>&#13;
<code class="kn">from</code> <code class="nn">master_function</code> <code class="kn">import</code> <code class="n">plot_train_test_values</code><code class="p">,</code> &#13;
<code class="kn">from</code> <code class="nn">master_function</code> <code class="kn">import</code> <code class="n">calculate_directional_accuracy</code>&#13;
<code class="kn">from</code> <code class="nn">sklearn.metrics</code> <code class="kn">import</code> <code class="n">mean_squared_error</code></pre>&#13;
&#13;
<p>Import the required data:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
CAD = 'CANADIAN DOLLAR - CHICAGO MERCANTILE EXCHANGE'&#13;
data = import_cot_data(2015, 2023, CAD)&#13;
data = np.array(data.iloc[:, –1], dtype = np.float64)</pre>&#13;
&#13;
<p>Set the hyperparameters and create the arrays:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">num_lags</code> <code class="o">=</code> <code class="mi">100</code>&#13;
<code class="n">train_test_split</code> <code class="o">=</code> <code class="mf">0.80</code>&#13;
<code class="n">num_neurons_in_hidden_layers</code> <code class="o">=</code> <code class="mi">200</code>&#13;
<code class="n">num_epochs</code> <code class="o">=</code> <code class="mi">200</code>&#13;
<code class="n">batch_size</code> <code class="o">=</code> <code class="mi">4</code>&#13;
<code class="c1"># Creating the training and test sets</code>&#13;
<code class="n">x_train</code><code class="p">,</code> <code class="n">y_train</code><code class="p">,</code> <code class="n">x_test</code><code class="p">,</code> <code class="n">y_test</code> <code class="o">=</code> <code class="n">data_preprocessing</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> &#13;
                                                      <code class="n">num_lags</code><code class="p">,</code> &#13;
                                                      <code class="n">train_test_split</code><code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p>To comply with the LSTM architecture, the independent variables must be transformed into three-dimensional arrays. This is done using the following code:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">x_train</code> <code class="o">=</code> <code class="n">x_train</code><code class="o">.</code><code class="n">reshape</code><code class="p">((</code><code class="err">–</code><code class="mi">1</code><code class="p">,</code> <code class="n">num_lags</code><code class="p">,</code> <code class="mi">1</code><code class="p">))</code>&#13;
<code class="n">x_test</code> <code class="o">=</code> <code class="n">x_test</code><code class="o">.</code><code class="n">reshape</code><code class="p">((</code><code class="err">–</code><code class="mi">1</code><code class="p">,</code> <code class="n">num_lags</code><code class="p">,</code> <code class="mi">1</code><code class="p">))</code></pre>&#13;
&#13;
<p>Next, create the architecture of the model and predict the values on the training set (only to understand the goodness of fit) and the test set:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="c1"># Create the LSTM model</code>&#13;
<code class="n">model</code> <code class="o">=</code> <code class="n">Sequential</code><code class="p">()</code>&#13;
<code class="c1"># Adding a first layer</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">LSTM</code><code class="p">(</code><code class="n">units</code> <code class="o">=</code> <code class="n">neurons</code><code class="p">,</code> <code class="n">input_shape</code> <code class="o">=</code> <code class="p">(</code><code class="n">num_lags</code><code class="p">,</code> <code class="mi">1</code><code class="p">)))</code>&#13;
<code class="c1"># Adding a second layer</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">Dense</code><code class="p">(</code><code class="n">neurons</code><code class="p">,</code> <code class="n">activation</code> <code class="o">=</code> <code class="s1">'relu'</code><code class="p">))</code> &#13;
<code class="c1"># Adding the output layer</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">Dense</code><code class="p">(</code><code class="n">units</code> <code class="o">=</code> <code class="mi">1</code><code class="p">))</code>&#13;
<code class="c1"># Compiling the model</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="n">loss</code> <code class="o">=</code> <code class="s1">'mean_squared_error'</code><code class="p">,</code> <code class="n">optimizer</code> <code class="o">=</code> <code class="s1">'adam'</code><code class="p">)</code>&#13;
<code class="c1"># Fitting the model</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">fit</code><code class="p">(</code><code class="n">x_train</code><code class="p">,</code> <code class="n">y_train</code><code class="p">,</code> <code class="n">epochs</code> <code class="o">=</code> <code class="n">num_epochs</code><code class="p">,</code> <code class="n">batch_size</code> <code class="o">=</code> <code class="n">batch_size</code><code class="p">)</code>&#13;
<code class="c1"># Predicting in the training set for illustrative purposes</code>&#13;
<code class="n">y_predicted_train</code> <code class="o">=</code> <code class="n">model</code><code class="o">.</code><code class="n">predict</code><code class="p">(</code><code class="n">x_train</code><code class="p">)</code>&#13;
<code class="c1"># Predicting in the test set</code>&#13;
<code class="n">y_predicted</code> <code class="o">=</code> <code class="n">model</code><code class="o">.</code><code class="n">predict</code><code class="p">(</code><code class="n">x_test</code><code class="p">)</code></pre>&#13;
&#13;
<p>To plot the predictions along the real values, use the following syntax:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">plot_train_test_values</code><code class="p">(</code><code class="mi">100</code><code class="p">,</code> <code class="mi">50</code><code class="p">,</code> <code class="n">y_train</code><code class="p">,</code> <code class="n">y_test</code><code class="p">,</code> <code class="n">y_predicted</code><code class="p">)</code></pre>&#13;
&#13;
<p><a data-type="xref" href="#figure-11-3">Figure 11-3</a> compares the predicted values with the real test values. At first glance, the model seems to capture the variations of the COT values well. Let’s have a look at the performance results.</p>&#13;
&#13;
<figure><div class="figure" id="figure-11-3"><img alt="" class="iimageschap_11_indir_model_1png" src="assets/dlff_1103.png"/>&#13;
<h6><span class="label">Figure 11-3. </span>COT training data followed by COT test data (dashed line) and the predicted COT data (thin line); the vertical dashed line represents the start of the test period. The model used is the LSTM regression algorithm.</h6>&#13;
</div></figure>&#13;
&#13;
<p>The following are the results of the model used on the CADUSD from 2015 to 2023:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">Directional</code> <code class="n">Accuracy</code> <code class="n">Train</code> <code class="o">=</code>  <code class="mf">86.18</code> <code class="o">%</code>&#13;
<code class="n">Directional</code> <code class="n">Accuracy</code> <code class="n">Test</code> <code class="o">=</code>  <code class="mf">60.87</code> <code class="o">%</code>&#13;
<code class="n">RMSE</code> <code class="n">Train</code> <code class="o">=</code>  <code class="mf">5.3655332132</code>&#13;
<code class="n">RMSE</code> <code class="n">Test</code> <code class="o">=</code>  <code class="mf">14.7772701349</code>&#13;
<code class="n">Correlation</code> <code class="n">In</code><code class="o">-</code><code class="n">Sample</code> <code class="n">Predicted</code><code class="o">/</code><code class="n">Train</code> <code class="o">=</code>  <code class="mf">0.995</code>&#13;
<code class="n">Correlation</code> <code class="n">Out</code><code class="o">-</code><code class="n">of</code><code class="o">-</code><code class="n">Sample</code> <code class="n">Predicted</code><code class="o">/</code><code class="n">Test</code> <code class="o">=</code>  <code class="mf">0.88</code>&#13;
</pre>&#13;
&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>An interesting task for you would be to apply the model to forecast the returns of the underlying market using COT values as inputs. You can use either the net COT value or any of the six other series you have available, such as long hedgers and net funds. However, make sure to always check for stationarity.<a contenteditable="false" data-primary="" data-startref="Chapter_11.html2" data-type="indexterm" id="id798"/><a contenteditable="false" data-primary="" data-startref="Chapter_11.html1" data-type="indexterm" id="id799"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Algorithm 2: MPF COT Direct Model" data-type="sect2"><div class="sect2" id="id84">&#13;
<h2>Algorithm 2: MPF COT Direct Model</h2>&#13;
&#13;
<p><a contenteditable="false" data-primary="Commitments of Traders (COT) report" data-secondary="algorithm 2: MPF COT direct model" data-type="indexterm" id="Chapter_11.html3"/><a contenteditable="false" data-primary="long short-term memory (LSTM)" data-secondary="for MPF COT direct model" data-type="indexterm" id="Chapter_11.html4"/>The MPF COT model will use LSTM to project a trajectory for the COT values to lead the way for the main market moves to come. The assumption is that by predicting the next COT values, which are less noisy than the market itself, you may have a guide for the expected trajectory of the market. As COT values are stationary and are highly correlated with the market (which is not stationary), you have a better chance of having a decent forecast than by using the MPF directly on the market. This algorithm uses the direct method (for more information, have another look at <a data-type="xref" href="ch09.html#ch09">Chapter 9</a>). First, import the required libraries:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>&#13;
<code class="kn">import</code> <code class="nn">matplotlib.pyplot</code> <code class="k">as</code> <code class="nn">plt</code>&#13;
<code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code>&#13;
<code class="kn">from</code> <code class="nn">keras.models</code> <code class="kn">import</code> <code class="n">Sequential</code>&#13;
<code class="kn">from</code> <code class="nn">keras.layers</code> <code class="kn">import</code> <code class="n">Dense</code><code class="p">,</code> <code class="n">LSTM</code>&#13;
<code class="kn">from</code> <code class="nn">master_function</code> <code class="kn">import</code> <code class="n">import_cot_data</code><code class="p">,</code> <code class="n">direct_mpf</code>&#13;
<code class="kn">from</code> <code class="nn">master_function</code> <code class="kn">import</code> <code class="n">calculate_directional_accuracy</code>&#13;
<code class="kn">from</code> <code class="nn">sklearn.metrics</code> <code class="kn">import</code> <code class="n">mean_squared_error</code>&#13;
</pre>&#13;
&#13;
<p>Set the hyperparameters and create the arrays:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="c1"># Setting the hyperparameters</code>&#13;
<code class="n">num_lags</code> <code class="o">=</code> <code class="mi">100</code>&#13;
<code class="n">train_test_split</code> <code class="o">=</code> <code class="mf">0.80</code>&#13;
<code class="n">neurons</code> <code class="o">=</code> <code class="mi">400</code>&#13;
<code class="n">num_epochs</code> <code class="o">=</code> <code class="mi">200</code>&#13;
<code class="n">batch_size</code> <code class="o">=</code> <code class="mi">10</code>&#13;
<code class="n">forecast_horizon</code> <code class="o">=</code> <code class="mi">50</code>&#13;
<code class="c1"># Creating the training and test sets</code>&#13;
<code class="n">x_train</code><code class="p">,</code> <code class="n">y_train</code><code class="p">,</code> <code class="n">x_test</code><code class="p">,</code> <code class="n">y_test</code> <code class="o">=</code> <code class="n">direct_mpf</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> &#13;
                                              <code class="n">num_lags</code><code class="p">,</code> &#13;
                                              <code class="n">train_test_split</code><code class="p">,</code> &#13;
                                              <code class="n">forecast_horizon</code><code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p>To comply with the LSTM architecture, the independent variables must be transformed into three-dimensional arrays. This is done using the following code:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">x_train</code> <code class="o">=</code> <code class="n">x_train</code><code class="o">.</code><code class="n">reshape</code><code class="p">((</code><code class="err">–</code><code class="mi">1</code><code class="p">,</code> <code class="n">num_lags</code><code class="p">,</code> <code class="mi">1</code><code class="p">))</code>&#13;
<code class="n">x_test</code> <code class="o">=</code> <code class="n">x_test</code><code class="o">.</code><code class="n">reshape</code><code class="p">((</code><code class="err">–</code><code class="mi">1</code><code class="p">,</code> <code class="n">num_lags</code><code class="p">,</code> <code class="mi">1</code><code class="p">))</code>&#13;
</pre>&#13;
&#13;
<p>Next, create the architecture of the model and predict the values using the <span class="keep-together">recursive function:</span></p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="c1"># Create the LSTM model</code>&#13;
<code class="n">model</code> <code class="o">=</code> <code class="n">Sequential</code><code class="p">()</code>&#13;
<code class="c1"># Adding a first layer</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">LSTM</code><code class="p">(</code><code class="n">units</code> <code class="o">=</code> <code class="n">neurons</code><code class="p">,</code> <code class="n">input_shape</code> <code class="o">=</code> <code class="p">(</code><code class="n">num_lags</code><code class="p">,</code> <code class="mi">1</code><code class="p">)))</code>&#13;
<code class="c1"># Adding a second layer</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">Dense</code><code class="p">(</code><code class="n">neurons</code><code class="p">,</code> <code class="n">activation</code> <code class="o">=</code> <code class="s1">'relu'</code><code class="p">))</code> &#13;
<code class="c1"># Adding the output layer </code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">Dense</code><code class="p">(</code><code class="n">units</code> <code class="o">=</code> <code class="n">forecast_horizon</code><code class="p">))</code>&#13;
<code class="c1"># Compiling the model</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="n">loss</code> <code class="o">=</code> <code class="s1">'mean_squared_error'</code><code class="p">,</code> <code class="n">optimizer</code> <code class="o">=</code> <code class="s1">'adam'</code><code class="p">)</code>&#13;
<code class="c1"># Fitting the model</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">fit</code><code class="p">(</code><code class="n">x_train</code><code class="p">,</code> <code class="n">y_train</code><code class="p">,</code> <code class="n">epochs</code> <code class="o">=</code> <code class="n">num_epochs</code><code class="p">,</code> <code class="n">batch_size</code> <code class="o">=</code> <code class="n">batch_size</code><code class="p">)</code>&#13;
<code class="c1"># Predicting in the test set</code>&#13;
<code class="n">y_predicted</code> <code class="o">=</code> <code class="n">model</code><code class="o">.</code><code class="n">predict</code><code class="p">(</code><code class="n">x_test</code><code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p>To plot the predictions along the real values, use the following syntax:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">plt</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="n">y_predicted</code><code class="p">[</code><code class="err">–</code><code class="mi">1</code><code class="p">],</code> <code class="n">label</code> <code class="o">=</code> <code class="s1">'Predicted data'</code><code class="p">,</code> <code class="n">color</code> <code class="o">=</code> <code class="s1">'red'</code><code class="p">,</code> &#13;
         <code class="n">linewidth</code> <code class="o">=</code> <code class="mi">1</code><code class="p">)</code>&#13;
<code class="n">plt</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="n">y_test</code><code class="p">[</code><code class="err">–</code><code class="mi">1</code><code class="p">],</code> <code class="n">label</code> <code class="o">=</code> <code class="s1">'Test data'</code><code class="p">,</code> <code class="n">color</code> <code class="o">=</code> <code class="s1">'black'</code><code class="p">,</code> &#13;
         <code class="n">linestyle</code> <code class="o">=</code> <code class="s1">'dashed'</code><code class="p">,</code> <code class="n">linewidth</code> <code class="o">=</code> <code class="mi">2</code><code class="p">)</code>&#13;
<code class="n">plt</code><code class="o">.</code><code class="n">grid</code><code class="p">()</code>&#13;
<code class="n">plt</code><code class="o">.</code><code class="n">legend</code><code class="p">()</code>&#13;
</pre>&#13;
&#13;
<p><a data-type="xref" href="#figure-11-4">Figure 11-4</a> compares the predicted values with the real test values.</p>&#13;
&#13;
<figure><div class="figure" id="figure-11-4"><img alt="" class="iimagesnew_mpf_directpng" src="assets/dlff_1104.png"/>&#13;
<h6><span class="label">Figure 11-4. </span>Predicted data versus test data.</h6>&#13;
</div></figure>&#13;
&#13;
<p>The following are the results of the model used on the CADUSD:<a contenteditable="false" data-primary="" data-startref="Chapter_11.html4" data-type="indexterm" id="id800"/><a contenteditable="false" data-primary="" data-startref="Chapter_11.html3" data-type="indexterm" id="id801"/></p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">Directional</code> <code class="n">Accuracy</code> <code class="n">Test</code> <code class="o">=</code>  <code class="mf">57.14</code> <code class="o">%</code>&#13;
<code class="n">RMSE</code> <code class="n">Test</code> <code class="o">=</code>  <code class="mf">26.4021245739</code>&#13;
<code class="n">Correlation</code> <code class="n">Out</code><code class="o">-</code><code class="n">of</code><code class="o">-</code><code class="n">Sample</code> <code class="n">Predicted</code><code class="o">/</code><code class="n">Test</code> <code class="o">=</code>  <code class="mf">0.426</code>&#13;
</pre>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Algorithm 3: MPF COT Recursive Model" data-type="sect2"><div class="sect2" id="id85">&#13;
<h2>Algorithm 3: MPF COT Recursive Model</h2>&#13;
&#13;
<p><a contenteditable="false" data-primary="Commitments of Traders (COT) report" data-secondary="algorithm 3: MPF COT recursive model" data-type="indexterm" id="Chapter_11.html5"/><a contenteditable="false" data-primary="recursive model" data-secondary="MPF COT recursive model" data-type="indexterm" id="Chapter_11.html6"/>This algorithm uses the recursive method (for more information, have another look at <a data-type="xref" href="ch09.html#ch09">Chapter 9</a>). First, import the required libraries:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>&#13;
<code class="kn">import</code> <code class="nn">matplotlib.pyplot</code> <code class="k">as</code> <code class="nn">plt</code>&#13;
<code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code>&#13;
<code class="kn">from</code> <code class="nn">keras.models</code> <code class="kn">import</code> <code class="n">Sequential</code>&#13;
<code class="kn">from</code> <code class="nn">keras.layers</code> <code class="kn">import</code> <code class="n">Dense</code><code class="p">,</code> <code class="n">LSTM</code>&#13;
<code class="kn">from</code> <code class="nn">master_function</code> <code class="kn">import</code> <code class="n">data_preprocessing</code><code class="p">,</code> <code class="n">import_cot_data</code>&#13;
<code class="kn">from</code> <code class="nn">master_function</code> <code class="kn">import</code> <code class="n">plot_train_test_values</code><code class="p">,</code> <code class="n">recursive_mpf</code>&#13;
<code class="kn">from</code> <code class="nn">master_function</code> <code class="kn">import</code> <code class="n">calculate_directional_accuracy</code>&#13;
</pre>&#13;
&#13;
<p>Set the hyperparameters and create the arrays:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">num_lags</code> <code class="o">=</code> <code class="mi">100</code>&#13;
<code class="n">train_test_split</code> <code class="o">=</code> <code class="mf">0.80</code>&#13;
<code class="n">neurons</code> <code class="o">=</code> <code class="mi">100</code>&#13;
<code class="n">num_epochs</code> <code class="o">=</code> <code class="mi">200</code>&#13;
<code class="n">batch_size</code> <code class="o">=</code> <code class="mi">2</code>&#13;
<code class="c1"># Creating the training and test sets</code>&#13;
<code class="n">x_train</code><code class="p">,</code> <code class="n">y_train</code><code class="p">,</code> <code class="n">x_test</code><code class="p">,</code> <code class="n">y_test</code> <code class="o">=</code> <code class="n">data_preprocessing</code><code class="p">(</code><code class="n">data</code><code class="p">,</code>&#13;
                                                      <code class="n">num_lags</code><code class="p">,</code>&#13;
                                                      <code class="n">train_test_split</code><code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p>To comply with the LSTM architecture, the independent variables must be transformed into three-dimensional arrays. This is done using the following code:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">x_train</code> <code class="o">=</code> <code class="n">x_train</code><code class="o">.</code><code class="n">reshape</code><code class="p">((</code><code class="err">–</code><code class="mi">1</code><code class="p">,</code> <code class="n">num_lags</code><code class="p">,</code> <code class="mi">1</code><code class="p">))</code>&#13;
<code class="n">x_test</code> <code class="o">=</code> <code class="n">x_test</code><code class="o">.</code><code class="n">reshape</code><code class="p">((</code><code class="err">–</code><code class="mi">1</code><code class="p">,</code> <code class="n">num_lags</code><code class="p">,</code> <code class="mi">1</code><code class="p">))</code></pre>&#13;
&#13;
<p>Next, create the architecture of the model and predict the values using the recursive function:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="c1"># Create the LSTM model</code>&#13;
<code class="n">model</code> <code class="o">=</code> <code class="n">Sequential</code><code class="p">()</code>&#13;
<code class="c1"># Adding a first layer</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">LSTM</code><code class="p">(</code><code class="n">units</code> <code class="o">=</code> <code class="n">neurons</code><code class="p">,</code> <code class="n">input_shape</code> <code class="o">=</code> <code class="p">(</code><code class="n">num_lags</code><code class="p">,</code> <code class="mi">1</code><code class="p">)))</code>&#13;
<code class="c1"># Adding a second layer</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">Dense</code><code class="p">(</code><code class="n">neurons</code><code class="p">,</code> <code class="n">activation</code> <code class="o">=</code> <code class="s1">'relu'</code><code class="p">))</code> &#13;
<code class="c1"># Adding the output layer </code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">Dense</code><code class="p">(</code><code class="n">units</code> <code class="o">=</code> <code class="mi">1</code><code class="p">))</code>&#13;
<code class="c1"># Compiling the model</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="n">loss</code> <code class="o">=</code> <code class="s1">'mean_squared_error'</code><code class="p">,</code> <code class="n">optimizer</code> <code class="o">=</code> <code class="s1">'adam'</code><code class="p">)</code>&#13;
<code class="c1"># Fitting the model</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">fit</code><code class="p">(</code><code class="n">x_train</code><code class="p">,</code> <code class="n">y_train</code><code class="p">,</code> <code class="n">epochs</code> <code class="o">=</code> <code class="n">num_epochs</code><code class="p">,</code> <code class="n">batch_size</code> <code class="o">=</code> <code class="n">batch_size</code><code class="p">)</code>&#13;
<code class="c1"># Predicting in the test set on a recursive basis</code>&#13;
<code class="n">x_test</code><code class="p">,</code> <code class="n">y_predicted</code> <code class="o">=</code> <code class="n">recursive_mpf</code><code class="p">(</code><code class="n">x_test</code><code class="p">,</code> <code class="n">y_test</code><code class="p">,</code> <code class="n">num_lags</code><code class="p">,</code> <code class="n">model</code><code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p>To plot the predictions along the real values, use the following syntax:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">plot_train_test_values</code><code class="p">(</code><code class="mi">100</code><code class="p">,</code> <code class="mi">50</code><code class="p">,</code> <code class="n">y_train</code><code class="p">,</code> <code class="n">y_test</code><code class="p">,</code> <code class="n">y_predicted</code><code class="p">)</code></pre>&#13;
&#13;
<p><a data-type="xref" href="#figure-11-5">Figure 11-5</a> compares the predicted values with the test values.</p>&#13;
&#13;
<figure><div class="figure" id="figure-11-5"><img alt="" class="iimageschap_11_indir_model_3png" src="assets/dlff_1105.png"/>&#13;
<h6><span class="label">Figure 11-5. </span>Multiperiod forecasting of the COT data.</h6>&#13;
</div></figure>&#13;
&#13;
<p>The following are the results of the model used on the CADUSD from 2015 to 2023:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">Directional</code> <code class="n">Accuracy</code> <code class="n">Test</code> <code class="o">=</code>  <code class="mf">52.17</code> <code class="o">%</code>&#13;
<code class="n">RMSE</code> <code class="n">Test</code> <code class="o">=</code>  <code class="mf">40.3120541504</code>&#13;
<code class="n">Correlation</code> <code class="n">Out</code><code class="o">-</code><code class="n">of</code><code class="o">-</code><code class="n">Sample</code> <code class="n">Predicted</code><code class="o">/</code><code class="n">Test</code> <code class="o">=</code>  <code class="mf">0.737</code>&#13;
</pre>&#13;
&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Remember that while setting the <code>random_state</code> and ensuring reproducibility is useful for experimentation, it might also limit the model’s ability to generalize well if the data distribution is genuinely random. In many cases, it’s recommended to perform multiple runs with different random seeds to get a better sense of the model’s performance and robustness. This is why many of the models seen in this book do not have the <code>random_state</code> implementation in their code (except a few models in <a data-type="xref" href="ch07.html#ch07">Chapter 7</a>).</p>&#13;
</div>&#13;
&#13;
<p>It does not hurt to remember the symptoms of overfitting. Unfortunately, overfitting is sometimes not that easily detectable, so consider these general rules:</p>&#13;
&#13;
<dl>&#13;
	<dt>High training accuracy and low test accuracy</dt>&#13;
	<dd><p>The model shows excellent performance on the training data but performs poorly on the test data. This is a clear indication that the model has memorized the training data rather than learning general patterns.</p></dd>&#13;
	<dt>Large gap between training and test performance</dt>&#13;
	<dd><p class="fix_tracking">There is a significant difference between the training and test error rates. Ideally, the two measures should be close to each other, and a large gap suggests overfitting.</p></dd>&#13;
	<dt>Unusually high model complexity</dt>&#13;
	<dd><p>If the model is overly complex with a large number of parameters or features, it becomes more prone to overfitting. A simpler model may generalize better to new data.</p></dd>&#13;
	<dt>Noisy predictions</dt>&#13;
	<dd><p>Overfit models tend to make erratic and inconsistent predictions on new data. This is because they are highly sensitive to small variations in the input data, including noise.<a contenteditable="false" data-primary="" data-startref="Chapter_11.html6" data-type="indexterm" id="id802"/><a contenteditable="false" data-primary="" data-startref="Chapter_11.html5" data-type="indexterm" id="id803"/></p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Putting It All Together" data-type="sect2"><div class="sect2" id="id86">&#13;
<h2>Putting It All Together</h2>&#13;
&#13;
<p>The COT report, released every Friday by the CFTC, outlines the positioning of key market participants. It can be transformed into a time series forecasting task with the aim of improving market forecasts. The market participants of particular interest are the commercial participants (dealers or hedgers) and the noncommercial participants (leveraged money or funds).</p>&#13;
&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Make sure to put <em>master_function.py</em> in the directory of the interpreter. Alternatively, you can simply open <em>master_function.py </em>in Python and execute the whole file. However, the latter method requires you to do it every time you restart the kernel.</p>&#13;
</div>&#13;
&#13;
<p>Deep learning techniques can be applied on COT values to forecast market positioning through hidden patterns and seasonal configurations. This section discussed three algorithms to squeeze out value from the COT report. You can experiment with machine learning models, deep reinforcement learning, and even simple statistical techniques to better understand the COT data.</p>&#13;
&#13;
<p>To manually import COT values, refer to the historical data found in the <a href="https://oreil.ly/5YGHI">GitHub repository</a> and use the following code (change the path of the interpreter to be the same as the location of the downloaded file):</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>&#13;
<code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code>&#13;
<code class="c1"># Import the data using pandas</code>&#13;
<code class="n">data</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">read_excel</code><code class="p">(</code><code class="s1">'name_of_file.xlsx'</code><code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p class="pagebreak-before">It’s important to remember that the COT report provides a snapshot of market participant positioning and should be used in conjunction with other tools and analysis methods. While it can offer valuable information, it’s not a standalone trading strategy, and careful consideration of other factors is essential for making well-informed trading decisions.<a contenteditable="false" data-primary="" data-startref="Chapter_11.html0" data-type="indexterm" id="id804"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Using Technical Indicators as Inputs" data-type="sect1"><div class="sect1" id="id87">&#13;
<h1>Using Technical Indicators as Inputs</h1>&#13;
&#13;
<p><a contenteditable="false" data-primary="technical indicators, as inputs" data-type="indexterm" id="Chapter_11.html7"/><a contenteditable="false" data-primary="transformations (technical indicators)" data-type="indexterm" id="Chapter_11.html8"/>You learned about technical indicators in <a data-type="xref" href="ch05.html#ch05">Chapter 5</a>. It’s time to use them as inputs to predict the underlying market’s returns. Using lagged values implies that there must be value in the past observations, which may translate into decent forecasts. This section will explore past that assumption and will search for value in other price transformations. You can have the following price-derived calculations:</p>&#13;
&#13;
<dl>&#13;
 <dt>Mathematical transformation</dt>&#13;
 <dd><p>This type of transformation is likely to be a direct manipulation of the raw data. An example of this is a basic differencing or a simple moving average. Normalization is also part of mathematical transformation.</p></dd>&#13;
 &#13;
 <dt>Technical transformation</dt>&#13;
 <dd><p>This type of transformation is less obvious, and the result may not look at all like the raw data. An example of this is the RSI, a technical indicator created out of recursive rules based on moving averages and <span class="keep-together">normalization.</span></p></dd>&#13;
 &#13;
 <dt>Categorical transformation</dt>&#13;
 <dd><p>This type of transformation shifts the type of numerical data to categorical and vice versa. For example, an algorithm that is known as <em>OneHotEncoder</em> takes categorical data and transforms it into binary data so that machine learning <span class="keep-together">algorithms</span> are able to classify it.</p></dd>&#13;
 &#13;
</dl>&#13;
&#13;
&#13;
<p><a contenteditable="false" data-primary="multicollinearity" data-type="indexterm" id="id805"/>Before proceeding, there is a data issue that is worth discussing. <em>Multicollinearity </em>is a statistical phenomenon that occurs in regression analysis when two or more independent variables (inputs) in a multiple regression model are highly correlated with each other. In other words, it is a situation where there is a strong linear relationship between two or more of the predictors. This correlation can make it difficult for the regression model to separate the individual effects of each predictor on the dependent variable (the outcome variable). Obviously, if you are using multiple RSIs with different time periods, then you are likely to run into multicollinearity. Make sure you look for weakly correlated indicators.</p>&#13;
&#13;
<p class="pagebreak-before">Two technical indicators (or transformations) are used in this example:</p>&#13;
&#13;
<ul>&#13;
	<li class="fix_tracking">The five-week RSI, a stationary indicator that does not require any transformation.</li>&#13;
	<li>The difference between the weekly close price and the 20-week moving average. This is also a stationary calculation that does not require any transformation.</li>&#13;
</ul>&#13;
&#13;
<p>Therefore, the EURUSD’s weekly returns will be forecasted using the previous week’s RSI value and the distance between the previous week’s close price and the 20-week moving average.</p>&#13;
&#13;
<p>First, import the required libraries:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>&#13;
<code class="kn">import</code> <code class="nn">matplotlib.pyplot</code> <code class="k">as</code> <code class="nn">plt</code>&#13;
<code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code>&#13;
<code class="kn">from</code> <code class="nn">keras.models</code> <code class="kn">import</code> <code class="n">Sequential</code>&#13;
<code class="kn">from</code> <code class="nn">keras.layers</code> <code class="kn">import</code> <code class="n">Dense</code><code class="p">,</code> <code class="n">LSTM</code>&#13;
<code class="kn">from</code> <code class="nn">master_function</code> <code class="kn">import</code> <code class="n">mass_import</code><code class="p">,</code> <code class="n">rsi</code><code class="p">,</code> <code class="n">ma</code><code class="p">,</code> <code class="n">calculate_accuracy</code>&#13;
<code class="kn">from</code> <code class="nn">master_function</code> <code class="kn">import</code> <code class="n">plot_train_test_values</code><code class="p">,</code> &#13;
<code class="kn">from</code> <code class="nn">master_function</code> <code class="kn">import</code> <code class="n">multiple_data_preprocessing</code>&#13;
<code class="kn">from</code> <code class="nn">sklearn.metrics</code> <code class="kn">import</code> <code class="n">mean_squared_error</code>&#13;
<code class="kn">from</code> <code class="nn">master_function</code> <code class="kn">import</code> <code class="n">add_column</code><code class="p">,</code> <code class="n">delete_column</code>&#13;
</pre>&#13;
&#13;
<p>Next, import the data using the <code>mass_import()</code> function:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">data</code> <code class="o">=</code> <code class="n">mass_import</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="s1">'W1'</code><code class="p">)[:,</code> <code class="err">–</code><code class="mi">1</code><code class="p">]</code>&#13;
<code class="n">data</code> <code class="o">=</code> <code class="n">rsi</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">reshape</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> <code class="p">(</code><code class="err">–</code><code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">)),</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code>&#13;
<code class="n">data</code> <code class="o">=</code> <code class="n">ma</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">2</code><code class="p">)</code>&#13;
<code class="n">data</code><code class="p">[:,</code> <code class="mi">2</code><code class="p">]</code> <code class="o">=</code> <code class="n">data</code><code class="p">[:,</code> <code class="mi">0</code><code class="p">]</code> <code class="err">–</code> <code class="n">data</code><code class="p">[:,</code> <code class="mi">2</code><code class="p">]</code>&#13;
<code class="n">data</code> <code class="o">=</code> <code class="n">add_column</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code>&#13;
<code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="n">data</code><code class="p">)):</code>&#13;
    <code class="n">data</code><code class="p">[</code><code class="n">i</code><code class="p">,</code> <code class="mi">3</code><code class="p">]</code> <code class="o">=</code> <code class="n">data</code><code class="p">[</code><code class="n">i</code><code class="p">,</code> <code class="mi">0</code><code class="p">]</code> <code class="err">–</code> <code class="n">data</code><code class="p">[</code><code class="n">i</code> <code class="err">–</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">]</code>&#13;
<code class="n">data</code><code class="p">[:,</code> <code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="n">data</code><code class="p">[:,</code> <code class="err">–</code><code class="mi">1</code><code class="p">]</code>&#13;
<code class="n">data</code> <code class="o">=</code> <code class="n">delete_column</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code></pre>&#13;
&#13;
<p>Define the multiple data preprocessing function, which takes the values of the two technical indicators and lags them so that they can be used as inputs to predict the EURUSD’s returns. <a data-type="xref" href="#table-11-2">Table 11-2</a> shows the training table <code>x_train</code> with six lagged values as independent variables to explain and predict the next EURUSD return.</p>&#13;
&#13;
<table id="table-11-2">&#13;
	<caption><span class="label">Table 11-2. </span>A sample of the training array</caption>&#13;
&#13;
<thead>&#13;
		<tr>&#13;
			<th>RSI t–1</th>&#13;
			<th>(Close – MA)t–1</th>&#13;
			<th>RSI t–2</th>&#13;
			<th>(Close – MA)t–2</th>&#13;
			<th>RSI t–3</th>&#13;
			<th>(Close – MA)t–3</th>&#13;
		</tr></thead>&#13;
			<tbody>&#13;
		<tr>&#13;
			<td class="right">36.6190</td>&#13;
			<td class="right">–0.003804</td>&#13;
			<td class="right">48.5188</td>&#13;
			<td class="right">0.001044</td>&#13;
			<td class="right">42.4396</td>&#13;
			<td class="right">–0.001714</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td class="right">46.7928</td>&#13;
			<td class="right">0.001674</td>&#13;
			<td class="right">36.6190</td>&#13;
			<td class="right">–0.003804</td>&#13;
			<td class="right">48.5188</td>&#13;
			<td class="right">0.001044</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td class="right">40.5430</td>&#13;
			<td class="right">–0.002518</td>&#13;
			<td class="right">46.7928</td>&#13;
			<td class="right">0.001674</td>&#13;
			<td class="right">36.6190</td>&#13;
			<td class="right">–0.003804</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td class="right">65.9614</td>&#13;
			<td class="right">0.011340</td>&#13;
			<td class="right">40.5430</td>&#13;
			<td class="right">–0.002518</td>&#13;
			<td class="right">46.7928</td>&#13;
			<td class="right">0.001674</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td class="right">47.2585</td>&#13;
			<td class="right">–0.000390</td>&#13;
			<td class="right">65.9614</td>&#13;
			<td class="right">0.011340</td>&#13;
			<td class="right">40.5430</td>&#13;
			<td class="right">–0.002518</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td class="right">63.9755</td>&#13;
			<td class="right">0.011302</td>&#13;
			<td class="right">47.2585</td>&#13;
			<td class="right">–0.000390</td>&#13;
			<td class="right">65.9614</td>&#13;
			<td class="right">0.011340</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<p>The next function is already defined, but it doesn’t hurt to discuss what it does. The <code>multiple_data_preprocessing()</code> function simply creates the four needed arrays for the backtest, but it uses the two technical indicators as inputs. You can define the function for six lagged values (three for the RSI and three for the difference between the close and the moving average) as follows:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="k">def</code> <code class="nf">multiple_data_preprocessing</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> <code class="n">train_test_split</code><code class="p">):</code>&#13;
    <code class="n">data</code> <code class="o">=</code> <code class="n">add_column</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> <code class="mi">4</code><code class="p">)</code>&#13;
    <code class="n">data</code><code class="p">[:,</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">roll</code><code class="p">(</code><code class="n">data</code><code class="p">[:,</code> <code class="mi">1</code><code class="p">],</code> <code class="mi">1</code><code class="p">,</code> <code class="n">axis</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code>&#13;
    <code class="n">data</code><code class="p">[:,</code> <code class="mi">2</code><code class="p">]</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">roll</code><code class="p">(</code><code class="n">data</code><code class="p">[:,</code> <code class="mi">2</code><code class="p">],</code> <code class="mi">1</code><code class="p">,</code> <code class="n">axis</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code>&#13;
    <code class="n">data</code><code class="p">[:,</code> <code class="mi">3</code><code class="p">]</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">roll</code><code class="p">(</code><code class="n">data</code><code class="p">[:,</code> <code class="mi">1</code><code class="p">],</code> <code class="mi">1</code><code class="p">,</code> <code class="n">axis</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code>&#13;
    <code class="n">data</code><code class="p">[:,</code> <code class="mi">4</code><code class="p">]</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">roll</code><code class="p">(</code><code class="n">data</code><code class="p">[:,</code> <code class="mi">2</code><code class="p">],</code> <code class="mi">1</code><code class="p">,</code> <code class="n">axis</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code>&#13;
    <code class="n">data</code><code class="p">[:,</code> <code class="mi">5</code><code class="p">]</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">roll</code><code class="p">(</code><code class="n">data</code><code class="p">[:,</code> <code class="mi">3</code><code class="p">],</code> <code class="mi">1</code><code class="p">,</code> <code class="n">axis</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code>&#13;
    <code class="n">data</code><code class="p">[:,</code> <code class="mi">6</code><code class="p">]</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">roll</code><code class="p">(</code><code class="n">data</code><code class="p">[:,</code> <code class="mi">4</code><code class="p">],</code> <code class="mi">1</code><code class="p">,</code> <code class="n">axis</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code>&#13;
    <code class="n">data</code> <code class="o">=</code> <code class="n">data</code><code class="p">[</code><code class="mi">1</code><code class="p">:,</code> <code class="p">]</code>&#13;
    <code class="n">x</code> <code class="o">=</code> <code class="n">data</code><code class="p">[:,</code> <code class="mi">1</code><code class="p">:]</code>&#13;
    <code class="n">y</code> <code class="o">=</code> <code class="n">data</code><code class="p">[:,</code> <code class="mi">0</code><code class="p">]</code>&#13;
    <code class="n">split_index</code> <code class="o">=</code> <code class="nb">int</code><code class="p">(</code><code class="n">train_test_split</code> <code class="o">*</code> <code class="nb">len</code><code class="p">(</code><code class="n">x</code><code class="p">))</code>&#13;
    <code class="n">x_train</code> <code class="o">=</code> <code class="n">x</code><code class="p">[:</code><code class="n">split_index</code><code class="p">]</code>&#13;
    <code class="n">y_train</code> <code class="o">=</code> <code class="n">y</code><code class="p">[:</code><code class="n">split_index</code><code class="p">]</code>&#13;
    <code class="n">x_test</code> <code class="o">=</code> <code class="n">x</code><code class="p">[</code><code class="n">split_index</code><code class="p">:]</code>&#13;
    <code class="n">y_test</code> <code class="o">=</code> <code class="n">y</code><code class="p">[</code><code class="n">split_index</code><code class="p">:]</code>&#13;
    <code class="k">return</code> <code class="n">x_train</code><code class="p">,</code> <code class="n">y_train</code><code class="p">,</code> <code class="n">x_test</code><code class="p">,</code> <code class="n">y_test</code></pre>&#13;
&#13;
<p>Set the hyperparameters and create the arrays:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">num_lags</code> <code class="o">=</code> <code class="mi">6</code> <code class="c1"># Must equal the number of the lagged values you create</code>&#13;
<code class="n">train_test_split</code> <code class="o">=</code> <code class="mf">0.80</code>&#13;
<code class="n">neurons</code> <code class="o">=</code> <code class="mi">500</code>&#13;
<code class="n">num_epochs</code> <code class="o">=</code> <code class="mi">500</code>&#13;
<code class="n">batch_size</code> <code class="o">=</code> <code class="mi">200</code>&#13;
<code class="c1"># Creating the training and test sets</code>&#13;
<code class="n">x_train</code><code class="p">,</code> <code class="n">y_train</code><code class="p">,</code> <code class="n">x_test</code><code class="p">,</code> <code class="n">y_test</code> <code class="o">=</code> <code class="n">multiple_data_preprocessing</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> &#13;
                                                   <code class="n">train_test_split</code><code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p>To comply with the LSTM architecture, the independent variables must be transformed into three-dimensional arrays. This is done using the following code:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">x_train</code> <code class="o">=</code> <code class="n">x_train</code><code class="o">.</code><code class="n">reshape</code><code class="p">((</code><code class="err">–</code><code class="mi">1</code><code class="p">,</code> <code class="n">num_lags</code><code class="p">,</code> <code class="mi">1</code><code class="p">))</code>&#13;
<code class="n">x_test</code> <code class="o">=</code> <code class="n">x_test</code><code class="o">.</code><code class="n">reshape</code><code class="p">((</code><code class="err">–</code><code class="mi">1</code><code class="p">,</code> <code class="n">num_lags</code><code class="p">,</code> <code class="mi">1</code><code class="p">))</code></pre>&#13;
&#13;
<p>Next, create the architecture of the model and predict the values on the training set (only to understand the goodness of fit) and the test set:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="c1"># Create the LSTM model</code>&#13;
<code class="n">model</code> <code class="o">=</code> <code class="n">Sequential</code><code class="p">()</code>&#13;
<code class="c1"># Adding a first layer</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">LSTM</code><code class="p">(</code><code class="n">units</code> <code class="o">=</code> <code class="n">neurons</code><code class="p">,</code> <code class="n">input_shape</code> <code class="o">=</code> <code class="p">(</code><code class="n">num_lags</code><code class="p">,</code> <code class="mi">1</code><code class="p">)))</code>&#13;
<code class="c1"># Adding a second layer</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">Dense</code><code class="p">(</code><code class="n">neurons</code><code class="p">,</code> <code class="n">activation</code> <code class="o">=</code> <code class="s1">'relu'</code><code class="p">))</code> &#13;
<code class="c1"># Adding a third layer</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">Dense</code><code class="p">(</code><code class="n">neurons</code><code class="p">,</code> <code class="n">activation</code> <code class="o">=</code> <code class="s1">'relu'</code><code class="p">))</code> &#13;
<code class="c1"># Adding a fourth layer</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">Dense</code><code class="p">(</code><code class="n">neurons</code><code class="p">,</code> <code class="n">activation</code> <code class="o">=</code> <code class="s1">'relu'</code><code class="p">))</code> &#13;
<code class="c1"># Adding a fifth layer</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">Dense</code><code class="p">(</code><code class="n">neurons</code><code class="p">,</code> <code class="n">activation</code> <code class="o">=</code> <code class="s1">'relu'</code><code class="p">))</code> &#13;
<code class="c1"># Adding the output layer </code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">Dense</code><code class="p">(</code><code class="n">units</code> <code class="o">=</code> <code class="mi">1</code><code class="p">))</code>&#13;
<code class="c1"># Compiling the model</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="n">loss</code> <code class="o">=</code> <code class="s1">'mean_squared_error'</code><code class="p">,</code> <code class="n">optimizer</code> <code class="o">=</code> <code class="s1">'ada</code><code class="w"/>&#13;
<code class="c1"># Fitting the model</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">fit</code><code class="p">(</code><code class="n">x_train</code><code class="p">,</code> <code class="n">y_train</code><code class="p">,</code> <code class="n">epochs</code> <code class="o">=</code> <code class="n">num_epochs</code><code class="p">,</code> <code class="n">batch_size</code> <code class="o">=</code> <code class="n">batch_size</code><code class="p">)</code>&#13;
<code class="c1"># Predicting in the training set for illustrative purposes</code>&#13;
<code class="n">y_predicted_train</code> <code class="o">=</code> <code class="n">model</code><code class="o">.</code><code class="n">predict</code><code class="p">(</code><code class="n">x_train</code><code class="p">)</code>&#13;
<code class="c1"># Predicting in the test set</code>&#13;
<code class="n">y_predicted</code> <code class="o">=</code> <code class="n">model</code><code class="o">.</code><code class="n">predict</code><code class="p">(</code><code class="n">x_test</code><code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p>To plot the predictions along the real values, use the following syntax:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<code class="n">plot_train_test_values</code><code class="p">(</code><code class="mi">100</code><code class="p">,</code> <code class="mi">50</code><code class="p">,</code> <code class="n">y_train</code><code class="p">,</code> <code class="n">y_test</code><code class="p">,</code> <code class="n">y_predicted</code><code class="p">)</code></pre>&#13;
&#13;
<p><a data-type="xref" href="#figure-11-6">Figure 11-6</a> compares the predicted values with the real test values.</p>&#13;
&#13;
<figure><div class="figure" id="figure-11-6"><img alt="" class="iimagesmultiple_inputspng" src="assets/dlff_1106.png"/>&#13;
<h6><span class="label">Figure 11-6. </span>Training data followed by test data (dashed line) and the predicted data (thin line); the vertical dashed line represents the start of the test period. The model used is the LSTM regression algorithm.</h6>&#13;
</div></figure>&#13;
&#13;
<p>The following are the results of the model:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">Accuracy</code> <code class="n">Train</code> <code class="o">=</code>  <code class="mf">59.39</code> <code class="o">%</code>&#13;
<code class="n">Accuracy</code> <code class="n">Test</code> <code class="o">=</code>  <code class="mf">51.82</code> <code class="o">%</code>&#13;
<code class="n">RMSE</code> <code class="n">Train</code> <code class="o">=</code>  <code class="mf">0.0163232045</code>&#13;
<code class="n">RMSE</code> <code class="n">Test</code> <code class="o">=</code>  <code class="mf">0.0122093494</code>&#13;
<code class="n">Correlation</code> <code class="n">In</code><code class="o">-</code><code class="n">Sample</code> <code class="n">Predicted</code><code class="o">/</code><code class="n">Train</code> <code class="o">=</code>  <code class="mf">0.255</code>&#13;
<code class="n">Correlation</code> <code class="n">Out</code><code class="o">-</code><code class="n">of</code><code class="o">-</code><code class="n">Sample</code> <code class="n">Predicted</code><code class="o">/</code><code class="n">Test</code> <code class="o">=</code>  <code class="mf">0.015</code></pre>&#13;
&#13;
<p>It is very interesting to tweak the model and see how to improve it. As these are weekly predictions, good accuracy could be the first step in shaping your swing trading on the condition of optimizing the model and making sure it is not overfit.<sup><a data-type="noteref" href="ch11.html#id806" id="id806-marker">1</a></sup> It is worth noting that since this algorithm is trying to predict the financial returns of an instrument, the <code>calculate_accuracy()</code> function is used as opposed to <code>ca⁠lc⁠ul⁠ate_​di⁠re⁠cti⁠on⁠al_accuracy()</code>.</p>&#13;
&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Try running the algorithm seen in this section on MPF mode and see what you can extract from it. Remember the algorithm’s limitations while doing so.<a contenteditable="false" data-primary="" data-startref="Chapter_11.html8" data-type="indexterm" id="id807"/><a contenteditable="false" data-primary="" data-startref="Chapter_11.html7" data-type="indexterm" id="id808"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Predicting Bitcoin’s Volatility Using Deep Learning" data-type="sect1"><div class="sect1" id="id88">&#13;
<h1>Predicting Bitcoin’s Volatility Using Deep Learning</h1>&#13;
&#13;
<p><a contenteditable="false" data-primary="Bitcoin, predicting volatility using deep learning" data-type="indexterm" id="Chapter_11.html9"/><a contenteditable="false" data-primary="cryptocurrency" data-type="indexterm" id="Chapter_11.html10"/><a contenteditable="false" data-primary="digital currency" data-type="indexterm" id="Chapter_11.html11"/><em>Bitcoin</em> is a decentralized digital currency that was created in 2009 by an unknown person or entity using the pseudonym <em>Satoshi Nakamoto</em>. It was the first cryptocurrency to be introduced and remains the most well known and widely traded cryptocurrency to date. You probably do not need an introduction to Bitcoin considering the immense hype over it during these past years, but more knowledge never hurts.</p>&#13;
&#13;
<p><a contenteditable="false" data-primary="blockchain" data-type="indexterm" id="id809"/>Bitcoin operates on a technology called <em>blockchain</em>, which is a distributed ledger system. Unlike traditional currencies that are issued and regulated by governments or central banks, Bitcoin is not controlled by any central authority.</p>&#13;
&#13;
<p>Instead, it relies on a peer-to-peer network of computers, known as nodes, to validate and record transactions. Nowadays, Bitcoin is heavily traded on cryptocurrency exchanges and is used for speculative but also hedging operations. The most commonly traded pair is BTCUSD, which is the value of 1 bitcoin relative to USD.</p>&#13;
&#13;
<p><a data-type="xref" href="#figure-11-7">Figure 11-7</a> shows the evolution of the BTCUSD (Bitcoin’s value priced in <span class="keep-together">US dollars)</span>.</p>&#13;
&#13;
<figure><div class="figure" id="figure-11-7"><img alt="" class="iimagesdlf_1105png" src="assets/dlff_1107.png"/>&#13;
<h6><span class="label">Figure 11-7. </span>Historical evolution of BTCUSD since 2014 in a linear scale.</h6>&#13;
</div></figure>&#13;
&#13;
<p>You can generate <a data-type="xref" href="#figure-11-7">Figure 11-7</a> using the following code:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>&#13;
<code class="c1"># Manually importing BTCUSD values</code>&#13;
<code class="n">my_data</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">read_excel</code><code class="p">(</code><code class="s1">'Bitcoin_Daily_Historical_Data.xlsx'</code><code class="p">)</code>&#13;
<code class="c1"># Renaming the columns</code>&#13;
<code class="n">my_data</code><code class="o">.</code><code class="n">columns</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'Date'</code><code class="p">,</code> <code class="s1">'Open'</code><code class="p">,</code> <code class="s1">'High'</code><code class="p">,</code> <code class="s1">'Low'</code><code class="p">,</code> <code class="s1">'Close'</code><code class="p">]</code>&#13;
<code class="c1"># Setting the date column</code>&#13;
<code class="n">my_data</code><code class="p">[</code><code class="s1">'Date'</code><code class="p">]</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">to_datetime</code><code class="p">(</code><code class="n">my_data</code><code class="p">[</code><code class="s1">'Date'</code><code class="p">])</code>&#13;
<code class="c1"># Charting</code>&#13;
<code class="n">plt</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="n">my_data</code><code class="p">[</code><code class="s1">'Date'</code><code class="p">],</code> <code class="n">my_data</code><code class="p">[</code><code class="s1">'Close'</code><code class="p">],</code> <code class="n">label</code> <code class="o">=</code> <code class="s1">'BTCUSD'</code><code class="p">,</code> &#13;
         <code class="n">color</code> <code class="o">=</code> <code class="s1">'black'</code><code class="p">)</code>&#13;
<code class="n">plt</code><code class="o">.</code><code class="n">legend</code><code class="p">()</code>&#13;
<code class="n">plt</code><code class="o">.</code><code class="n">grid</code><code class="p">()</code>&#13;
</pre>&#13;
&#13;
<p>Make sure you download the historical BTCUSD values from the <a href="https://oreil.ly/5YGHI">GitHub repository</a> and that you set the directory of the interpreter in the same folder as the downloaded file.</p>&#13;
&#13;
<p><a data-type="xref" href="#figure-11-7">Figure 11-7</a> is charted using a linear scale, which means that data is represented on a straight and evenly spaced axis (the space between 10 and 20 is the same as the space between 1230 and 1240). It is also possible to use what is known as a logarithmic scale to chart time series that experience big jumps.</p>&#13;
&#13;
<aside class="pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id810">&#13;
<h1 class="less_space">To Log or to Lin</h1>&#13;
&#13;
<p><a contenteditable="false" data-primary="linear scale, logarithmic scale versus" data-type="indexterm" id="id811"/><a contenteditable="false" data-primary="logarithmic scale, linear scale versus" data-type="indexterm" id="id812"/>The <em>logarithmic scale</em> is a scale used in charting that represents the data using logarithmic transformations. In a logarithmic scale, the spacing between values is based on the logarithm of the actual values rather than their linear scale. This means that the distance between, for example, 1 and 10 on a logarithmic scale is the same as the distance between 10 and 100, rather than being 10 times larger as in a linear scale.</p>&#13;
&#13;
<p>The importance of using a logarithmic scale in charting financial time series stems from the nature of financial data and its tendency to exhibit exponential growth or decay (as is the case on BTCUSD).</p>&#13;
&#13;
<p>Financial markets often experience large variations in prices or returns, and using a logarithmic scale can help to better visualize and understand these changes. In trading jargon, linear scale charts are typically referred to as <em>lin charts</em>, and logarithmic scale charts are referred to as <em>log charts</em>.</p>&#13;
&#13;
<p>Using a logarithmic scale in charting financial time series helps provide a more accurate representation of the data, facilitates the analysis of growth rates, and enhances the ability to identify trends and patterns in financial markets.</p>&#13;
</div></aside>&#13;
&#13;
<p><a data-type="xref" href="#figure-11-8">Figure 11-8</a> shows the evolution of BTCUSD (Bitcoin’s value priced in US dollars) in logarithmic scale.</p>&#13;
&#13;
<figure><div class="figure" id="figure-11-8"><img alt="" class="iimagesdlf_1106png" src="assets/dlff_1108.png"/>&#13;
<h6><span class="label">Figure 11-8. </span>Historical evolution of BTCUSD since 2014 in a semilog scale.</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">Use the following code to generate <a data-type="xref" href="#figure-11-8">Figure 11-8</a> using the <code>plt.semilogy()</code> function:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">plt</code><code class="o">.</code><code class="n">semilogy</code><code class="p">(</code><code class="n">my_data</code><code class="p">[</code><code class="s1">'Date'</code><code class="p">],</code> <code class="n">my_data</code><code class="p">[</code><code class="s1">'Close'</code><code class="p">],</code> <code class="n">label</code> <code class="o">=</code> <code class="s1">'BTCUSD'</code><code class="p">,</code> &#13;
             <code class="n">color</code> <code class="o">=</code> <code class="s1">'black'</code><code class="p">)</code>&#13;
<code class="n">plt</code><code class="o">.</code><code class="n">legend</code><code class="p">()</code>&#13;
<code class="n">plt</code><code class="o">.</code><code class="n">grid</code><code class="p">()</code>&#13;
</pre>&#13;
&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The word <em>semilog </em>refers to transforming one of the two axes into a logarithmic scale, while the word <em>log </em>refers to transforming both axes into a logarithmic scale.</p>&#13;
&#13;
<p>Since time is linear, you only need to transform the <em>y</em>-axis (which means the values), and therefore, you are technically using semilog charts. This is why the <code>matplotlib()</code> function is called <code>pl⁠t.​se⁠mi⁠log⁠y()</code>.</p>&#13;
</div>&#13;
&#13;
<p>If you prefer to import BTCUSD values using a Python script, use the following:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="kn">import</code> <code class="nn">requests</code>&#13;
<code class="kn">import</code> <code class="nn">json</code>&#13;
<code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>&#13;
<code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code>  &#13;
<code class="kn">import</code> <code class="nn">datetime</code> <code class="k">as</code> <code class="nn">dt</code>&#13;
&#13;
<code class="c1"># Selecting the time frame</code>&#13;
<code class="n">frequency</code> <code class="o">=</code> <code class="s1">'1h'</code>&#13;
<code class="c1"># Defining the import function</code>&#13;
<code class="k">def</code> <code class="nf">import_crypto</code><code class="p">(</code><code class="n">symbol</code><code class="p">,</code> <code class="n">interval</code> <code class="o">=</code> <code class="n">frequency</code><code class="p">):</code>&#13;
    <code class="c1"># Getting the original link from Binance</code>&#13;
    <code class="n">url</code> <code class="o">=</code> <code class="s1">'https://api.binance.com/api/v1/klines'</code>&#13;
    <code class="c1"># Linking the link with the cryptocurrency and the time frame</code>&#13;
    <code class="n">link</code> <code class="o">=</code> <code class="n">url</code> <code class="o">+</code> <code class="s1">'?symbol='</code> <code class="o">+</code> <code class="n">symbol</code> <code class="o">+</code> <code class="s1">'&amp;interval='</code> <code class="o">+</code> <code class="n">interval</code>&#13;
    <code class="c1"># Requesting the data in the form of text</code>&#13;
    <code class="n">data</code> <code class="o">=</code> <code class="n">json</code><code class="o">.</code><code class="n">loads</code><code class="p">(</code><code class="n">requests</code><code class="o">.</code><code class="n">get</code><code class="p">(</code><code class="n">link</code><code class="p">)</code><code class="o">.</code><code class="n">text</code><code class="p">)</code>&#13;
    <code class="c1"># Converting the text data to a dataframe</code>&#13;
    <code class="n">data</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">(</code><code class="n">data</code><code class="p">)</code>&#13;
    <code class="n">data</code> <code class="o">=</code> <code class="n">data</code><code class="o">.</code><code class="n">astype</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">float</code><code class="p">)</code>&#13;
    <code class="n">data</code> <code class="o">=</code> <code class="n">data</code><code class="p">[:,</code> <code class="mi">1</code><code class="p">:</code><code class="mi">5</code><code class="p">]</code>&#13;
    <code class="k">return</code> <code class="n">data</code>&#13;
<code class="c1"># Importing hourly BTCUSD data</code>&#13;
<code class="n">data</code> <code class="o">=</code> <code class="n">import_crypto</code><code class="p">(</code><code class="s1">'BTCUSDT'</code><code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p>Let’s see if deep learning helps forecast BTCUSD’s volatility using its lagged values. But first, two questions are begging an answer:</p>&#13;
&#13;
<ul>&#13;
	<li>What is the use of predicting Bitcoin’s volatility?</li>&#13;
	<li>How do you calculate Bitcoin’s volatility?</li>&#13;
</ul>&#13;
&#13;
<p class="pagebreak-before">To answer the first question, by predicting Bitcoin’s volatility, traders can potentially identify periods of increased price swings and capitalize on them. Similarly, volatility predictions can also provide insights into market sentiment. When investors expect uncertain or turbulent market conditions, it may indicate a lack of confidence, leading to potential changes in market dynamics.</p>&#13;
&#13;
<p>To answer the second question, you can use a rolling standard deviation measure on the close prices. This allows you to create a new time series that reflects the historical volatility of Bitcoin.</p>&#13;
&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Typically, an increase in volatility is a sign of market stress and fear, which translates to a bearish tone. In contrast, a decrease in volatility is a sign of a healthy and stable market, which translates to a bullish market. This relationship is not perfect, and other variables may impact it. For example, if you calculate the correlation coefficient of Bitcoin’s daily close prices and the 10-day rolling volatility, you will find that it’s positive (at some periods, it’s extremely positive). <a contenteditable="false" data-primary="fear of missing out (FOMO)" data-type="indexterm" id="id813"/><a contenteditable="false" data-primary="FOMO (fear of missing out)" data-type="indexterm" id="id814"/>Bitcoin is known for being a euphoric asset where rises are accompanied by a phenomenon called FOMO, an abbreviation of <em>fear of missing out</em>. This psychological bias is one of the building blocks of a market bubble where everyone keeps buying in the hopes of profiting from the move.</p>&#13;
</div>&#13;
&#13;
<p>The first step of predictive analytics is to understand the data you’re dealing with. As a reminder, volatility refers to the degree of variation or fluctuation in the price of a financial instrument, such as a stock, bond, commodity, or currency, over a specific period of time. It is a statistical measure of the dispersion for that particular asset.</p>&#13;
&#13;
<p><a data-type="xref" href="#figure-11-9">Figure 11-9</a> shows the latest values of Bitcoin’s 10-day volatility as measured by the rolling standard deviation calculation. The latest values say that recently, the price variations hovered around $500 from the 10-day mean most of the time (refer to <a data-type="xref" href="ch03.html#ch03">Chapter 3</a> for more in-depth comprehension on standard deviation).</p>&#13;
&#13;
<figure><div class="figure" id="figure-11-9"><img alt="" class="iimagesbtc_volpng" src="assets/dlff_1109.png"/>&#13;
<h6><span class="label">Figure 11-9. </span>Bitcoin’s rolling 10-day standard deviation as a proxy for volatility.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Let’s get started. For this task, let’s manually import BTCUSD into the interpreter. First, start by importing the required libraries:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>&#13;
<code class="kn">import</code> <code class="nn">matplotlib.pyplot</code> <code class="k">as</code> <code class="nn">plt</code>&#13;
<code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code>&#13;
<code class="kn">from</code> <code class="nn">keras.models</code> <code class="kn">import</code> <code class="n">Sequential</code>&#13;
<code class="kn">from</code> <code class="nn">keras.layers</code> <code class="kn">import</code> <code class="n">Dense</code><code class="p">,</code> <code class="n">LSTM</code>&#13;
<code class="kn">from</code> <code class="nn">master_function</code> <code class="kn">import</code> <code class="n">add_column</code><code class="p">,</code> <code class="n">delete_row</code><code class="p">,</code> <code class="n">volatility</code>&#13;
<code class="kn">from</code> <code class="nn">master_function</code> <code class="kn">import</code> <code class="n">data_preprocessing</code><code class="p">,</code> <code class="n">plot_train_test_values</code>&#13;
<code class="kn">from</code> <code class="nn">master_function</code> <code class="kn">import</code> <code class="n">calculate_directional_accuracy</code>&#13;
<code class="kn">from</code> <code class="nn">sklearn.metrics</code> <code class="kn">import</code> <code class="n">mean_squared_error</code>&#13;
<code class="kn">from</code> <code class="nn">statsmodels.tsa.stattools</code> <code class="kn">import</code> <code class="n">adfuller</code>&#13;
</pre>&#13;
&#13;
<p>Next, import the data using <em>pandas</em>:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">data</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">read_excel</code><code class="p">(</code><code class="s1">'Bitcoin_Daily_Historical_Data.xlsx'</code><code class="p">)</code><code class="o">.</code><code class="n">values</code>&#13;
</pre>&#13;
&#13;
<p>The next step is to calculate volatility. Its function is defined in <code>master_function</code>, and as you have imported it already, it should work directly:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">data</code> <code class="o">=</code> <code class="n">volatility</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code>&#13;
<code class="n">data</code> <code class="o">=</code> <code class="n">data</code><code class="p">[:,</code> <code class="err">–</code><code class="mi">1</code><code class="p">]</code></pre>&#13;
&#13;
<p>You have to check for stationarity. If the data is stationary, then it’s ready to be deployed for training. Otherwise, you may have to transform it. The following code applies the ADF test on the 10-day volatility of Bitcoin:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="nb">print</code><code class="p">(</code><code class="s1">'p-value: </code><code class="si">%f</code><code class="s1">'</code> <code class="o">%</code> <code class="n">adfuller</code><code class="p">(</code><code class="n">data</code><code class="p">)[</code><code class="mi">1</code><code class="p">])</code></pre>&#13;
&#13;
<p class="pagebreak-before">Here is the output:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">p</code><code class="o">-</code><code class="n">value</code><code class="p">:</code> <code class="mf">0.120516</code></pre>&#13;
&#13;
<p>It seems that the volatility values are nonstationary. Let’s try differencing:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">data</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">diff</code><code class="p">(</code><code class="n">data</code><code class="p">)</code></pre>&#13;
&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>You can also apply fractional differentiation to preserve a hint of memory.</p>&#13;
</div>&#13;
&#13;
<p><a data-type="xref" href="#figure-11-10">Figure 11-10</a> shows the latest values of Bitcoin’s 10-day differenced volatility.</p>&#13;
&#13;
<figure><div class="figure" id="figure-11-10"><img alt="" class="iimagesstationary_btc_volpng" src="assets/dlff_1110.png"/>&#13;
<h6><span class="label">Figure 11-10. </span>Bitcoin’s rolling 10-day standard deviation (differenced).</h6>&#13;
</div></figure>&#13;
&#13;
<p>The next step is to set the hyperparameters and prepare the arrays as usual:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">num_lags</code> <code class="o">=</code> <code class="mi">300</code>&#13;
<code class="n">train_test_split</code> <code class="o">=</code> <code class="mf">0.80</code>&#13;
<code class="n">neurons</code> <code class="o">=</code> <code class="mi">80</code>&#13;
<code class="n">num_epochs</code> <code class="o">=</code> <code class="mi">100</code>&#13;
<code class="n">batch_size</code> <code class="o">=</code> <code class="mi">500</code>&#13;
<code class="c1"># Prepare the arrays</code>&#13;
<code class="n">x_train</code><code class="p">,</code> <code class="n">y_train</code><code class="p">,</code> <code class="n">x_test</code><code class="p">,</code> <code class="n">y_test</code> <code class="o">=</code> <code class="n">direct_mpf</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> &#13;
                                              <code class="n">num_lags</code><code class="p">,</code> &#13;
                                              <code class="n">train_test_split</code><code class="p">,</code> &#13;
                                              <code class="n">forecast_horizon</code><code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p class="pagebreak-before">To comply with the LSTM architecture, the independent variables must be transformed into three-dimensional arrays. This is done using the following code:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">x_train</code> <code class="o">=</code> <code class="n">x_train</code><code class="o">.</code><code class="n">reshape</code><code class="p">((</code><code class="err">–</code><code class="mi">1</code><code class="p">,</code> <code class="n">num_lags</code><code class="p">,</code> <code class="mi">1</code><code class="p">))</code>&#13;
<code class="n">x_test</code> <code class="o">=</code> <code class="n">x_test</code><code class="o">.</code><code class="n">reshape</code><code class="p">((</code><code class="err">–</code><code class="mi">1</code><code class="p">,</code> <code class="n">num_lags</code><code class="p">,</code> <code class="mi">1</code><code class="p">))</code></pre>&#13;
&#13;
<p>Create the deep neural network architecture with a few extra layers:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="c1"># Create the LSTM model</code>&#13;
<code class="n">model</code> <code class="o">=</code> <code class="n">Sequential</code><code class="p">()</code>&#13;
<code class="c1"># Adding a first layer</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">LSTM</code><code class="p">(</code><code class="n">units</code> <code class="o">=</code> <code class="n">neurons</code><code class="p">,</code> <code class="n">input_shape</code> <code class="o">=</code> <code class="p">(</code><code class="n">num_lags</code><code class="p">,</code> <code class="mi">1</code><code class="p">)))</code>&#13;
<code class="c1"># Adding a second layer</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">Dense</code><code class="p">(</code><code class="n">neurons</code><code class="p">,</code> <code class="n">activation</code> <code class="o">=</code> <code class="s1">'relu'</code><code class="p">))</code> &#13;
<code class="c1"># Adding a third layer</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">Dense</code><code class="p">(</code><code class="n">neurons</code><code class="p">,</code> <code class="n">activation</code> <code class="o">=</code> <code class="s1">'relu'</code><code class="p">))</code> &#13;
<code class="c1"># Adding a fourth layer</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">Dense</code><code class="p">(</code><code class="n">neurons</code><code class="p">,</code> <code class="n">activation</code> <code class="o">=</code> <code class="s1">'relu'</code><code class="p">))</code> &#13;
<code class="c1"># Adding the output layer </code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">Dense</code><code class="p">(</code><code class="n">units</code> <code class="o">=</code> <code class="n">forecast_horizon</code><code class="p">))</code>&#13;
<code class="c1"># Compiling the model</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="n">loss</code> <code class="o">=</code> <code class="s1">'mean_squared_error'</code><code class="p">,</code> <code class="n">optimizer</code> <code class="o">=</code> <code class="s1">'adam'</code><code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p>Now, fit and predict the data:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">model</code><code class="o">.</code><code class="n">fit</code><code class="p">(</code><code class="n">x_train</code><code class="p">,</code> <code class="n">y_train</code><code class="p">,</code> <code class="n">epochs</code> <code class="o">=</code> <code class="n">num_epochs</code><code class="p">,</code> <code class="n">batch_size</code> <code class="o">=</code> <code class="n">batch_size</code><code class="p">)</code>&#13;
<code class="n">y_predicted</code> <code class="o">=</code> <code class="n">model</code><code class="o">.</code><code class="n">predict</code><code class="p">(</code><code class="n">x_test</code><code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p><a data-type="xref" href="#figure-11-11">Figure 11-11</a> compares the predicted values with the test values.</p>&#13;
&#13;
<figure><div class="figure" id="figure-11-11"><img alt="" class="iimagesbtc-col-pred-newpng" src="assets/dlff_1111.png"/>&#13;
<h6><span class="label">Figure 11-11. </span>Forecasting Bitcoin’s volatility; the model used is the LSTM <span class="keep-together">regression algorithm.</span></h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">The following are the results of the model:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">Accuracy</code> <code class="n">Train</code> <code class="o">=</code>  <code class="mf">66.56</code> <code class="o">%</code>&#13;
<code class="n">Accuracy</code> <code class="n">Test</code> <code class="o">=</code>  <code class="mf">63.59</code> <code class="o">%</code>&#13;
<code class="n">RMSE</code> <code class="n">Train</code> <code class="o">=</code>  <code class="mf">95.6086778521</code>&#13;
<code class="n">RMSE</code> <code class="n">Test</code> <code class="o">=</code>  <code class="mf">186.1401365824</code>&#13;
<code class="n">Correlation</code> <code class="n">In</code><code class="o">-</code><code class="n">Sample</code> <code class="n">Predicted</code><code class="o">/</code><code class="n">Train</code> <code class="o">=</code>  <code class="mf">0.807</code>&#13;
<code class="n">Correlation</code> <code class="n">Out</code><code class="o">-</code><code class="n">of</code><code class="o">-</code><code class="n">Sample</code> <code class="n">Predicted</code><code class="o">/</code><code class="n">Test</code> <code class="o">=</code>  <code class="mf">0.56</code></pre>&#13;
&#13;
<p>Keep in mind that the backtesting results may differ significantly due to the backtested period, time granularity, transaction costs, different quotations from different brokers, different hyperparameters, and different randomization. Optimization is a key component, and validation of the results must be done before forming an opinion on the algorithm. Your task is therefore to improve the results and get a better <span class="keep-together">prediction</span> on volatility.</p>&#13;
&#13;
<p>You may also wonder if you can predict Bitcoin’s returns directly with an accuracy better than random. The answer is yes, and if you need a few ideas of inputs that may help predict Bitcoin’s returns, check out the following nonexhaustive list:</p>&#13;
&#13;
<ul>&#13;
	<li>&#13;
	<p><em>Historical price data and its derivatives</em>: Using historical price data is a fundamental aspect of predicting returns. You can include features such as daily, weekly, or monthly price changes, moving averages, and price volatility.</p>&#13;
	</li>&#13;
	<li>&#13;
	<p><em>Trading volume</em>: The trading volume of Bitcoin provides valuable information about the level of market activity and liquidity. Higher trading volumes often accompany significant price movements.</p>&#13;
	</li>&#13;
	<li>&#13;
	<p><em>Market sentiment indicators</em>: Sentiment analysis from social media platforms, news articles, or forums can help gauge the overall market sentiment toward Bitcoin. Bitcoin’s Fear &amp; Greed index is a good candidate as it’s published on a daily basis and uses many fundamental variables to calculate its values.<sup><a data-type="noteref" href="ch11.html#id815" id="id815-marker">2</a></sup></p>&#13;
	</li>&#13;
	<li>&#13;
	<p><em>Network metrics</em>: Bitcoin’s blockchain data provides useful metrics, such as the number of transactions, hash rate, and difficulty level. These metrics reflect the activity and health of the Bitcoin network, which can influence prices.</p>&#13;
	</li>&#13;
	<li>&#13;
	<p><em>Market indicators</em>: Consider using general market indicators like the S&amp;P 500 or the VIX as external variables. Cryptocurrencies, including Bitcoin, can sometimes exhibit correlations with traditional financial markets.</p>&#13;
	</li>&#13;
	<li>&#13;
	<p><em>Cryptocurrency-specific indicators</em>: Other indicators specific to the cryptocurrency space, such as the total market capitalization of all cryptocurrencies and dominance ratio of Bitcoin, may provide insights into broader market conditions.</p>&#13;
	</li>&#13;
	<li>&#13;
	<p><em>Technical indicators</em>: Various technical analysis indicators, such as the RSI and volatility, can offer insights into potential price trends and reversals.</p>&#13;
	</li>&#13;
	<li>&#13;
	<p><em>Google trends</em>: Monitoring the popularity of search terms related to Bitcoin on Google Trends can provide insights into public interest and potential price <span class="keep-together">movements.</span></p>&#13;
	</li>&#13;
	<li>&#13;
	<p><em>Cryptocurrency exchange data</em>: Data from cryptocurrency exchanges, such as open interest, funding rates, and liquidation data, can offer insights into market dynamics and potential price shifts.<a contenteditable="false" data-primary="" data-startref="Chapter_11.html11" data-type="indexterm" id="id816"/><a contenteditable="false" data-primary="" data-startref="Chapter_11.html10" data-type="indexterm" id="id817"/><a contenteditable="false" data-primary="" data-startref="Chapter_11.html9" data-type="indexterm" id="id818"/></p>&#13;
	</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Real-Time Visualization of Training" data-type="sect1"><div class="sect1" id="id89">&#13;
<h1>Real-Time Visualization of Training</h1>&#13;
&#13;
<p><a contenteditable="false" data-primary="training, real-time visualization of" data-type="indexterm" id="Chapter_11.html12"/><a contenteditable="false" data-primary="visualization" data-secondary="of training" data-type="indexterm" id="Chapter_11.html13"/>What happens during training? Sure, you can see that the training process is on-going when you look at the progress bar of every epoch:</p>&#13;
&#13;
<p>Epoch 1/100<br/>&#13;
9/9 [=============================] – 3s 77ms/step - loss: 0.0052<br/>&#13;
Epoch 2/100<br/>&#13;
9/9 [=============================] – 1s 78ms/step - loss: 0.0026<br/>&#13;
Epoch 3/100<br/>&#13;
9/9 [=============================] – 1s 68ms/step - loss: 0.0015</p>&#13;
&#13;
<p>However, you can also code a dynamic plot that shows you the in-sample predictions getting updated through epochs as they approach the in-sample real values. This will be the first aim of this section. Before proceeding, refresh your knowledge of the terminologies:</p>&#13;
&#13;
<dl>&#13;
 <dt>In-sample real values</dt>&#13;
 <dd><p>These are the values contained in <code>y_train</code>. They are the real values the model uses to calibrate its training. They belong to the training set.</p></dd>&#13;
 &#13;
 <dt>In-sample predictions</dt>&#13;
 <dd><p>These are the values contained in <code>y_predicted_train</code>. They are the predictions the model outputs during its training. They belong to the training set and suffer from <em>look-ahead bias</em>, which happens when future information is used to make decisions or predictions that should have been made in the past based only on historical data available at that time.</p></dd>&#13;
 &#13;
 <dt class="pagebreak-before less_space">Out-of-sample real values</dt>&#13;
 <dd><p>These are the test values used to test the model’s ability to predict values on data that has never been seen before. They belong to the test set.</p></dd>&#13;
 &#13;
 <dt>Out-of-sample predictions</dt>&#13;
 <dd><p>These are the predictions that follow the training phase. They belong to the test set.</p></dd>&#13;
</dl>&#13;
&#13;
&#13;
<p>Let’s take an example that you are familiar with from <a data-type="xref" href="ch09.html#ch09">Chapter 9</a>, the ISM PMI data. The aim is to create a one-step forecast LSTM model of the differenced ISM PMI values while creating a dynamic plot during training that shows predictions being calibrated to the training set. First, import the required libraries:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>&#13;
<code class="kn">import</code> <code class="nn">matplotlib.pyplot</code> <code class="k">as</code> <code class="nn">plt</code>&#13;
<code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code>&#13;
<code class="kn">from</code> <code class="nn">keras.models</code> <code class="kn">import</code> <code class="n">Sequential</code>&#13;
<code class="kn">from</code> <code class="nn">keras.layers</code> <code class="kn">import</code> <code class="n">Dense</code><code class="p">,</code> <code class="n">LSTM</code>&#13;
<code class="kn">from</code> <code class="nn">master_function</code> <code class="kn">import</code> <code class="n">data_preprocessing</code>&#13;
<code class="kn">from</code> <code class="nn">master_function</code> <code class="kn">import</code> <code class="n">calculate_directional_accuracy</code>&#13;
<code class="kn">from</code> <code class="nn">sklearn.metrics</code> <code class="kn">import</code> <code class="n">mean_squared_error</code>&#13;
<code class="kn">import</code> <code class="nn">tensorflow</code> <code class="k">as</code> <code class="nn">tf</code>&#13;
<code class="kn">import</code> <code class="nn">random</code>&#13;
</pre>&#13;
&#13;
<p>From the <a href="https://oreil.ly/5YGHI">GitHub repository</a>, import and difference the ISM PMI data:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
 <code class="n">data</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">diff</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">reshape</code><code class="p">(</code><code class="n">pd</code><code class="o">.</code><code class="n">read_excel</code><code class="p">(</code><code class="s1">'ISM_PMI.xlsx'</code><code class="p">)</code><code class="o">.</code><code class="n">values</code><code class="p">,</code> <code class="p">(</code><code class="err">–</code><code class="mi">1</code><code class="p">)))</code></pre>&#13;
&#13;
<p>The next step is to set the hyperparameters and prepare the arrays as usual:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">num_lags</code> <code class="o">=</code> <code class="mi">100</code>&#13;
<code class="n">train_test_split</code> <code class="o">=</code> <code class="mf">0.80</code>&#13;
<code class="n">neurons</code> <code class="o">=</code> <code class="mi">200</code>&#13;
<code class="n">num_epochs</code> <code class="o">=</code> <code class="mi">200</code>&#13;
<code class="n">batch_size</code> <code class="o">=</code> <code class="mi">4</code>&#13;
<code class="c1"># Creating the training and test sets</code>&#13;
<code class="n">x_train</code><code class="p">,</code> <code class="n">y_train</code><code class="p">,</code> <code class="n">x_test</code><code class="p">,</code> <code class="n">y_test</code> <code class="o">=</code> <code class="n">data_preprocessing</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> &#13;
                                                      <code class="n">num_lags</code><code class="p">,</code> &#13;
                                                      <code class="n">train_test_split</code><code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p>To comply with the LSTM architecture, the independent variables must be transformed into three-dimensional arrays. This is done using the following code:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">x_train</code> <code class="o">=</code> <code class="n">x_train</code><code class="o">.</code><code class="n">reshape</code><code class="p">((</code><code class="err">–</code><code class="mi">1</code><code class="p">,</code> <code class="n">num_lags</code><code class="p">,</code> <code class="mi">1</code><code class="p">))</code>&#13;
<code class="n">x_test</code> <code class="o">=</code> <code class="n">x_test</code><code class="o">.</code><code class="n">reshape</code><code class="p">((</code><code class="err">–</code><code class="mi">1</code><code class="p">,</code> <code class="n">num_lags</code><code class="p">,</code> <code class="mi">1</code><code class="p">))</code></pre>&#13;
&#13;
<p class="pagebreak-before">Create the deep neural network architecture:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="c1"># Create the LSTM model</code>&#13;
<code class="n">model</code> <code class="o">=</code> <code class="n">Sequential</code><code class="p">()</code>&#13;
<code class="c1"># Adding a first layer</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">LSTM</code><code class="p">(</code><code class="n">units</code> <code class="o">=</code> <code class="n">neurons</code><code class="p">,</code> <code class="n">input_shape</code> <code class="o">=</code> <code class="p">(</code><code class="n">num_lags</code><code class="p">,</code> <code class="mi">1</code><code class="p">)))</code>&#13;
<code class="c1"># Adding a second layer</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">Dense</code><code class="p">(</code><code class="n">neurons</code><code class="p">,</code> <code class="n">activation</code> <code class="o">=</code> <code class="s1">'relu'</code><code class="p">))</code> &#13;
<code class="c1"># Adding a third layer</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">Dense</code><code class="p">(</code><code class="n">neurons</code><code class="p">,</code> <code class="n">activation</code> <code class="o">=</code> <code class="s1">'relu'</code><code class="p">))</code> &#13;
<code class="c1"># Adding a fourth layer</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">Dense</code><code class="p">(</code><code class="n">neurons</code><code class="p">,</code> <code class="n">activation</code> <code class="o">=</code> <code class="s1">'relu'</code><code class="p">))</code> &#13;
<code class="c1"># Adding the output layer </code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">Dense</code><code class="p">(</code><code class="n">units</code> <code class="o">=</code> <code class="mi">1</code><code class="p">))</code>&#13;
<code class="c1"># Compiling the model</code>&#13;
<code class="n">model</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="n">loss</code> <code class="o">=</code> <code class="s1">'mean_squared_error'</code><code class="p">,</code> <code class="n">optimizer</code> <code class="o">=</code> <code class="s1">'adam'</code><code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p>The following code fits the <code>x_train</code> data to the <code>y_train</code> data while plotting the predictions at every epoch:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="k">def</code> <code class="nf">update_plot</code><code class="p">(</code><code class="n">epoch</code><code class="p">,</code> <code class="n">logs</code><code class="p">):</code>&#13;
    <code class="k">if</code> <code class="n">epoch</code> <code class="o">%</code> <code class="mi">1</code> <code class="o">==</code> <code class="mi">0</code><code class="p">:</code>&#13;
        <code class="n">plt</code><code class="o">.</code><code class="n">cla</code><code class="p">()</code>&#13;
        <code class="n">y_predicted_train</code> <code class="o">=</code> <code class="n">model</code><code class="o">.</code><code class="n">predict</code><code class="p">(</code><code class="n">x_train</code><code class="p">)</code>&#13;
        <code class="n">plt</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="n">y_train</code><code class="p">,</code> <code class="n">label</code> <code class="o">=</code> <code class="s1">'Training data'</code><code class="p">,</code> &#13;
                 <code class="n">color</code> <code class="o">=</code> <code class="s1">'black'</code><code class="p">,</code> <code class="n">linewidth</code> <code class="o">=</code> <code class="mf">2.5</code><code class="p">)</code>&#13;
        <code class="n">plt</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="n">y_predicted_train</code><code class="p">,</code> <code class="n">label</code> <code class="o">=</code> <code class="s1">'Predicted data'</code><code class="p">,</code> &#13;
                 <code class="n">color</code> <code class="o">=</code> <code class="s1">'red'</code><code class="p">,</code> <code class="n">linewidth</code> <code class="o">=</code> <code class="mi">1</code><code class="p">)</code>&#13;
        <code class="n">plt</code><code class="o">.</code><code class="n">title</code><code class="p">(</code><code class="sa">f</code><code class="s1">'Training Epoch: </code><code class="si">{</code><code class="n">epoch</code><code class="si">}</code><code class="s1">'</code><code class="p">)</code>&#13;
        <code class="n">plt</code><code class="o">.</code><code class="n">xlabel</code><code class="p">(</code><code class="s1">'Time'</code><code class="p">)</code>&#13;
        <code class="n">plt</code><code class="o">.</code><code class="n">ylabel</code><code class="p">(</code><code class="s1">'Value'</code><code class="p">)</code>&#13;
        <code class="n">plt</code><code class="o">.</code><code class="n">legend</code><code class="p">()</code>&#13;
        <code class="n">plt</code><code class="o">.</code><code class="n">savefig</code><code class="p">(</code><code class="nb">str</code><code class="p">(</code><code class="n">random</code><code class="o">.</code><code class="n">randint</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">1000</code><code class="p">)))</code>&#13;
<code class="c1"># Create the dynamic plot</code>&#13;
<code class="n">fig</code> <code class="o">=</code> <code class="n">plt</code><code class="o">.</code><code class="n">figure</code><code class="p">()</code>&#13;
<code class="c1"># Train the model using the on_epoch_end callback</code>&#13;
<code class="k">class</code> <code class="nc">PlotCallback</code><code class="p">(</code><code class="n">tf</code><code class="o">.</code><code class="n">keras</code><code class="o">.</code><code class="n">callbacks</code><code class="o">.</code><code class="n">Callback</code><code class="p">):</code>&#13;
    <code class="k">def</code> <code class="nf">on_epoch_end</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">epoch</code><code class="p">,</code> <code class="n">logs</code> <code class="o">=</code> <code class="kc">None</code><code class="p">):</code>&#13;
        <code class="n">update_plot</code><code class="p">(</code><code class="n">epoch</code><code class="p">,</code> <code class="n">logs</code><code class="p">)</code>&#13;
        <code class="n">plt</code><code class="o">.</code><code class="n">pause</code><code class="p">(</code><code class="mf">0.001</code><code class="p">)</code>&#13;
<code class="n">plot_callback</code> <code class="o">=</code> <code class="n">PlotCallback</code><code class="p">()</code>&#13;
<code class="n">history</code> <code class="o">=</code> <code class="n">model</code><code class="o">.</code><code class="n">fit</code><code class="p">(</code><code class="n">x_train</code><code class="p">,</code> <code class="n">y_train</code><code class="p">,</code> <code class="n">epochs</code> <code class="o">=</code> <code class="n">num_epochs</code><code class="p">,</code> &#13;
                    <code class="n">batch_size</code> <code class="o">=</code> <code class="n">batch_size</code><code class="p">,</code> <code class="n">callbacks</code> <code class="o">=</code> <code class="p">[</code><code class="n">plot_callback</code><code class="p">])</code>&#13;
</pre>&#13;
&#13;
<p><a data-type="xref" href="#figure-11-12">Figure 11-12</a> shows the training at epoch 1. Notice how the algorithm is just starting out and is not quite capturing the relationship between the independent and <span class="keep-together">dependent</span> variables yet.</p>&#13;
&#13;
<figure><div class="figure" id="figure-11-12"><img alt="" class="iimagesepoch_11png" src="assets/dlff_1112.png"/>&#13;
<h6><span class="label">Figure 11-12. </span>ISM PMI data training in progress at epoch 1.</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-type="xref" href="#figure-11-13">Figure 11-13</a> shows the training at epoch 21. It looks like the algorithm is still calibrating itself to the features.</p>&#13;
&#13;
<figure><div class="figure" id="figure-11-13"><img alt="" class="iimagesepoch_24png" src="assets/dlff_1113.png"/>&#13;
<h6><span class="label">Figure 11-13. </span>ISM PMI data training in progress at epoch 21.</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-type="xref" href="#figure-11-14">Figure 11-14</a> shows the training at epoch 29. The model is starting to properly fit <span class="keep-together">the data.</span></p>&#13;
&#13;
<figure><div class="figure" id="figure-11-14"><img alt="" class="iimagesepoch_56png" src="assets/dlff_1114.png"/>&#13;
<h6><span class="label">Figure 11-14. </span>ISM PMI data training in progress at epoch 29.</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-type="xref" href="#figure-11-15">Figure 11-15</a> shows the training at epoch 62. The model seems to fit the data well, although with some errors, but this is not the main aim of this section.</p>&#13;
&#13;
<p>Dynamic training plots can be an interesting tool to see how the model is learning—and whether it’s actually learning something. <a contenteditable="false" data-primary="constant predictions" data-type="indexterm" id="id819"/>This helps with the problem of <em>constant predictions</em>, which occur when the model fails to capture any relationship between the dependent and independent variables.</p>&#13;
&#13;
<figure><div class="figure" id="figure-11-15"><img alt="" class="iimagesepoch_93png" src="assets/dlff_1115.png"/>&#13;
<h6><span class="label">Figure 11-15. </span>ISM PMI data training in progress at epoch 62.</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
<p>Several factors can lead to the problem of constant predictions in deep learning:</p>&#13;
&#13;
<dl>&#13;
 <dt>Poor model architecture</dt>&#13;
 <dd><p>If the model is not expressive enough, it may struggle to learn meaningful patterns, resorting to a simple, constant prediction instead.</p></dd>&#13;
 &#13;
 <dt>Limited or noisy data</dt>&#13;
 <dd><p>Insufficient or noisy data can hinder the model’s ability to learn meaningful patterns. If the data lacks diversity or contains significant errors, the model may converge to a constant forecast as the simplest way to minimize the loss.</p></dd>&#13;
 &#13;
 <dt>Improper loss function</dt>&#13;
 <dd><p>The choice of the loss function plays a vital role in guiding the model during training. If the loss function is not appropriate for the task or the model architecture, it may not encourage the model to make varied predictions, leading to <span class="keep-together">constant</span> forecasts.</p></dd>&#13;
 &#13;
 <dt>Poor hyperparameter tuning</dt>&#13;
 <dd><p>Hyperparameters, such as the batch size and the number of neurons, can significantly impact the training process. If these hyperparameters are not appropriately tuned, the model might not converge effectively, leading to constant predictions.</p></dd>&#13;
</dl>&#13;
&#13;
&#13;
<p class="pagebreak-before">At this point, you must have wondered what the architecture you built using the <code>Sequential()</code> and <code>Dense()</code> functions looks like. Naturally, it should look like the neural network graphs you have seen previously. To see this, you must <code>pip install</code> the required libraries from the prompt:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">pip</code> <code class="n">install</code> <code class="n">pydot</code>&#13;
<code class="n">pip</code> <code class="n">install</code> <code class="n">pydotplus</code>&#13;
<code class="n">pip</code> <code class="n">install</code> <code class="n">graphviz</code></pre>&#13;
&#13;
<p>Then download the <em>graphviz</em> binaries folder from the <a href="https://oreil.ly/SV5FO">official website</a>, extract the contents of the file, then set the <em>bin</em> folder as one of the paths of the Python interpreter (e.g., Spyder). Restart the kernel, and proceed to compile your model as usual. Finally, use the following code to print the architecture:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="kn">from</code> <code class="nn">tensorflow.keras.utils</code> <code class="kn">import</code> <code class="n">plot_model</code>&#13;
<code class="kn">from</code> <code class="nn">IPython.display</code> <code class="kn">import</code> <code class="n">Image</code>&#13;
<code class="n">plot_model</code><code class="p">(</code><code class="n">model</code><code class="p">,</code> <code class="n">to_file</code> <code class="o">=</code> <code class="s1">'Architecture.png'</code><code class="p">,</code> &#13;
           <code class="n">show_shapes</code> <code class="o">=</code> <code class="kc">True</code><code class="p">,</code> &#13;
           <code class="n">show_layer_names</code> <code class="o">=</code> <code class="kc">True</code><code class="p">)</code>&#13;
<code class="n">Image</code><code class="p">(</code><code class="s1">'Architecture.png'</code><code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p><a data-type="xref" href="#figure-11-16">Figure 11-16</a> shows the output of the code.</p>&#13;
&#13;
<figure><div class="figure" id="figure-11-16"><img alt="" class="iimagesarchitecturepng" src="assets/dlff_1116.png"/>&#13;
<h6><span class="label">Figure 11-16. </span>Model architecture example.</h6>&#13;
</div></figure>&#13;
&#13;
<p>The code outputs the current architecture of the compiled LSTM model.<a contenteditable="false" data-primary="" data-startref="Chapter_11.html13" data-type="indexterm" id="id820"/><a contenteditable="false" data-primary="" data-startref="Chapter_11.html12" data-type="indexterm" id="id821"/></p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="id90">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>This information-heavy chapter showed you a few ideas for using a selection of trading algorithms to forecast returns. It is mostly a way to stimulate critical and innovative thinking and to find new and innovative ideas from where trading signals may be derived. <a contenteditable="false" data-primary="filters" data-type="indexterm" id="id822"/>For example, you can try applying filters with the signals you get from the algorithms. <em>Filters </em>are like on/off switches that allow the signal based on whether a final condition is met or not. An example of a hypothetical trading strategy with a filter is to take the bullish signals only if the market is above its 200-day moving average and to take the bearish signals only if the market is below its 200-day moving average.</p>&#13;
&#13;
<p>Your main takeaway should be how things must be structured so that you can understand the backtesting process. Compared to this chapter, <a data-type="xref" href="ch12.html#ch12">Chapter 12</a> will be a gentle breeze as it explores risk management and fundamental tools aimed at enhancing the research process.</p>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="id806"><sup><a href="ch11.html#id806-marker">1</a></sup> Swing trading involves holding positions for a short- to medium-term period, typically a few days to a few weeks, to profit from price swings or price movements within a larger trend.</p><p data-type="footnote" id="id815"><sup><a href="ch11.html#id815-marker">2</a></sup> The index is used to gauge the emotions and sentiments of investors in the cryptocurrency market. It provides a numerical value on a scale from 0 to 100, where lower values indicate extreme fear and higher values indicate extreme greed. The index is designed to help traders and investors identify potential market turning points based on prevailing emotions.</p></div></div></section></body></html>