- en: Chapter 6\. Building Classes for Event-Based Backtesting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The actual tragedies of life bear no relation to one’s preconceived ideas. In
    the event, one is always bewildered by their simplicity, their grandeur of design,
    and by that element of the bizarre which seems inherent in them.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Jean Cocteau
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'On the one hand, *vectorized backtesting* with `NumPy` and `pandas` is generally
    convenient and efficient to implement due to the concise code, and it is fast
    to execute due to these packages being optimized for such operations. However,
    the approach cannot cope with all types of trading strategies nor with all phenomena
    that the trading reality presents an algorithmic trader with. When it comes to
    vectorized backtesting, potential shortcomings of the approach are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Look-ahead bias
  prefs: []
  type: TYPE_NORMAL
- en: Vectorized backtesting is based on the complete data set available and does
    not take into account that new data arrives incrementally.
  prefs: []
  type: TYPE_NORMAL
- en: Simplification
  prefs: []
  type: TYPE_NORMAL
- en: For example, fixed transaction costs cannot be modeled by vectorization, which
    is mainly based on relative returns. Also, fixed amounts per trade or the non-divisibility
    of single financial instruments (for example, a share of a stock) cannot be modeled
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: Non-recursiveness
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms, embodying trading strategies, might take recurse to state variables
    over time, like profit and loss up to a certain point in time or similar path-dependent
    statistics. Vectorization cannot cope with such features.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, *event-based backtesting* allows one to address these issues
    by a more realistic approach to model trading realities. On a basic level, an
    *event* is characterized by the arrival of new data. Backtesting a trading strategy
    for the Apple Inc. stock based on end-of-day data, an event would be a new closing
    price for the Apple stock. It can also be a change in an interest rate, or the
    hitting of a stop loss level. Advantages of the event-based backtesting approach
    generally are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Incremental approach
  prefs: []
  type: TYPE_NORMAL
- en: As in the trading reality, backtesting takes place on the premise that new data
    arrives incrementally, tick-by-tick and quote-by-quote.
  prefs: []
  type: TYPE_NORMAL
- en: Realistic modeling
  prefs: []
  type: TYPE_NORMAL
- en: One has complete freedom to model those processes that are triggered by a new
    and specific event.
  prefs: []
  type: TYPE_NORMAL
- en: Path dependency
  prefs: []
  type: TYPE_NORMAL
- en: It is straightforward to keep track of conditional, recursive, or otherwise
    path-dependent statistics, such as the maximum or minimum price seen so far, and
    to include them in the trading algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Reusability
  prefs: []
  type: TYPE_NORMAL
- en: Backtesting different types of trading strategies requires a similar base functionality
    that can be implemented and unified through object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: Close to trading
  prefs: []
  type: TYPE_NORMAL
- en: Certain elements of an event-based backtesting system can sometimes also be
    used for the automated implementation of the trading strategy.
  prefs: []
  type: TYPE_NORMAL
- en: In what follows, a new event is generally identified by a *bar*, which represents
    one unit of new data. For example, events can be *one-minute bars* for an intraday
    trading strategy or *one-day bars* for a trading strategy based on daily closing
    prices.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter is organized as follows. [“Backtesting Base Class”](#base_class)
    presents a base class for the event-based backtesting of trading strategies. [“Long-Only
    Backtesting Class”](#long_only) and [“Long-Short Backtesting Class”](#long_short)
    make use of the base class to implement long-only and long-short backtesting classes,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The goals of this chapter are to understand event-based modeling, to create
    classes that allow a more realistic backtesting, and to have a foundational backtesting
    infrastructure available as a starting point for further enhancements and refinements.
  prefs: []
  type: TYPE_NORMAL
- en: Backtesting Base Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to building the infrastructure—in the form of a Python class—for
    event-based backtesting, several requirements must be met:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving and preparing data
  prefs: []
  type: TYPE_NORMAL
- en: The base class shall take care of the data retrieval and possibly the preparation
    for the backtesting itself. To keep the discussion focused, end-of-day (EOD) data
    as read from a CSV file is the type of data the base class shall allow for.
  prefs: []
  type: TYPE_NORMAL
- en: Helper and convenience functions
  prefs: []
  type: TYPE_NORMAL
- en: It shall provide a couple of helper and convenience functions that make backtesting
    easier. Examples are functions for plotting data, printing out state variables,
    or returning date and price information for a given bar.
  prefs: []
  type: TYPE_NORMAL
- en: Placing orders
  prefs: []
  type: TYPE_NORMAL
- en: The base class shall cover the placing of basic buy and sell orders. For simplicity,
    only market buy and sell orders are modeled.
  prefs: []
  type: TYPE_NORMAL
- en: Closing out positions
  prefs: []
  type: TYPE_NORMAL
- en: At the end of any backtesting, any market positions need to be closed out. The
    base class shall take care of this final trade.
  prefs: []
  type: TYPE_NORMAL
- en: If the base class meets these requirements, respective classes to backtest strategies
    based on simple moving averages (SMAs), momentum, or mean reversion (see [Chapter 4](ch04.html#vectorized_backtesting)),
    as well as on machine learning-based prediction (see [Chapter 5](ch05.html#machine_learning)),
    can be built upon it. [“Backtesting Base Class”](#py_base_class) presents an implementation
    of such a base class called `BacktestBase`. The following is a walk through the
    single methods of this class to get an overview of its design.
  prefs: []
  type: TYPE_NORMAL
- en: 'With regard to the special method `__main__`, there are only a few noteworthy
    things. First, the initial amount available is stored twice, both in a private
    attribute `_amount` that is kept constant and in a regular attribute `amount`
    that represents the running balance. The default assumption is that there are
    no transaction costs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Stores the initial amount in a private attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the starting cash balance value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines fixed transaction costs per trade.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines proportional transaction costs per trade.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Units of the instrument (for example, number of shares) in the portfolio initially.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the initial position to market neutral.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO1-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the initial number of trades to zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO1-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets `self.verbose` to `True` to get full output.
  prefs: []
  type: TYPE_NORMAL
- en: 'During initialization, the `get_data` method is called, which retrieves EOD
    data from a CSV file for the provided symbol and the given time interval. It also
    calculates the log returns. The Python code that follows has been used extensively
    in Chapters [4](ch04.html#vectorized_backtesting) and [5](ch05.html#machine_learning).
    Therefore, it does not need to be explained in detail here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.plot_data()` method is just a simple helper method to plot the (adjusted
    close) values for the provided symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A method that gets frequently called is `.get_date_price()`. For a given `bar`,
    it returns the date and price information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`.print_balance()` prints out the current cash balance given a certain bar,
    while `.print_net_wealth()` does the same for the net wealth (= current balance
    plus value of trading position):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Two core methods are `.place_buy_order()` and `.place_sell_order()`. They allow
    the emulated buying and selling of units of a financial instrument. First is the
    `.place_buy_order()` method, which is commented on in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The date and price information for the given `bar` is retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: If no value for `units` is given…
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: …the number of `units` is calculated given the value for `amount`. (Note that
    one needs to be given.) The calculation does not include transaction costs.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The current cash balance is reduced by the cash outlays for the units of the
    instrument to be bought *plus* the proportional and fixed transaction costs. Note
    that it is not checked whether there is enough liquidity available or not.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The value of `self.units` is increased by the number of units bought.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO2-6)'
  prefs: []
  type: TYPE_NORMAL
- en: This increases the counter for the number of trades by one.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO2-7)'
  prefs: []
  type: TYPE_NORMAL
- en: If `self.verbose` is `True`…
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO2-8)'
  prefs: []
  type: TYPE_NORMAL
- en: …print out information about trade execution…
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO2-9)'
  prefs: []
  type: TYPE_NORMAL
- en: …the current cash balance…
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](assets/10.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO2-10)'
  prefs: []
  type: TYPE_NORMAL
- en: …and the current net wealth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, the `.place_sell_order()` method, which has only two minor adjustments
    compared to the `.place_buy_order()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The current cash balance is increased by the proceeds of the sale *minus* transactions
    costs.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The value of `self.units` is decreased by the number of units sold.
  prefs: []
  type: TYPE_NORMAL
- en: 'No matter what kind of trading strategy is backtested, the position at the
    end of the backtesting period needs to be closed out. The code in the `BacktestBase`
    class assumes that the position is not liquidated but rather accounted for with
    its asset value to calculate and print the performance figures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: No transaction costs are subtracted at the end.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The final balance consists of the current cash balance plus the value of the
    trading position.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This calculates the net performance in percent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final part of the Python script is the `__main__` section, which gets executed
    when the file is run as a script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It instantiates an object based on the `BacktestBase` class. This leads automatically
    to the data retrieval for the symbol provided. [Figure 6-1](#bt_plot_1) shows
    the resulting plot. The following output shows the meta information for the respective
    `DataFrame` object and the five most recent data rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![pfat 0601](assets/pfat_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. Plot of data as retrieved for `symbol` by the `BacktestBase` class
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The two subsequent sections present classes to backtest long-only and long-short
    trading strategies. Since these classes rely on the base class presented in this
    section, the implementation of the backtesting routines is rather concise.
  prefs: []
  type: TYPE_NORMAL
- en: Using object-oriented programming allows one to build a basic backtesting infrastructure
    in the form of a Python class. Standard functionality needed during the backtesting
    of different kinds of algorithmic trading strategies is made available by such
    a class in a non-redundant, easy-to-maintain fashion. It is also straightforward
    to enhance the base class to provide more features by default that might benefit
    a multitude of other classes built on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: Long-Only Backtesting Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Certain investor preferences or regulations might prohibit short selling as
    part of a trading strategy. As a consequence, a trader or portfolio manager is
    only allowed to enter long positions or to park capital in the form of cash or
    similar low risk assets, like money market accounts. [“Long-Only Backtesting Class”](#py_long_only)
    shows the code of a backtesting class for long-only strategies called `BacktestLongOnly`.
    Since it relies on and inherits from the `BacktestBase` class, the code to implement
    the three strategies based on SMAs, momentum, and mean reversion is rather concise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method `.run_mean_reversion_strategy()` implements the backtesting procedure
    for the mean reversion-based strategy. This method is commented on in detail,
    since it might be a bit trickier from an implementation standpoint. The basic
    insights, however, easily carry over to the methods implementing the other two
    strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning, this method prints out an overview of the major parameters
    for the backtesting.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The position is set to market neutral, which is done here for more clarity and
    should be the case anyway.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The current cash balance is reset to the initial amount in case another backtest
    run has overwritten the value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: This calculates the SMA values needed for the strategy implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO5-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The start value `SMA` ensures that there are SMA values available to start implementing
    and backtesting the strategy.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO5-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The condition checks whether the position is market neutral.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO5-8)'
  prefs: []
  type: TYPE_NORMAL
- en: If the position is market neutral, it is checked whether the current price is
    low enough relative to the SMA to trigger a buy order and to go long.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO5-9)'
  prefs: []
  type: TYPE_NORMAL
- en: This executes the buy order in the amount of the current cash balance.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO5-10)'
  prefs: []
  type: TYPE_NORMAL
- en: The market position is set to long.
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](assets/10.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO5-11)'
  prefs: []
  type: TYPE_NORMAL
- en: The condition checks whether the position is long the market.
  prefs: []
  type: TYPE_NORMAL
- en: '[![11](assets/11.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO5-12)'
  prefs: []
  type: TYPE_NORMAL
- en: If that is the case, it is checked whether the current price has returned to
    the SMA level or above.
  prefs: []
  type: TYPE_NORMAL
- en: '[![12](assets/12.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO5-13)'
  prefs: []
  type: TYPE_NORMAL
- en: In such a case, a sell order is placed for all units of the financial instrument.
  prefs: []
  type: TYPE_NORMAL
- en: '[![13](assets/13.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO5-14)'
  prefs: []
  type: TYPE_NORMAL
- en: The market position is set to neutral again.
  prefs: []
  type: TYPE_NORMAL
- en: '[![14](assets/14.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO5-15)'
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the backtesting period, the market position gets closed out if
    one is open.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the Python script in [“Long-Only Backtesting Class”](#py_long_only)
    yields backtesting results, as shown in the following. The examples illustrate
    the influence of fixed and proportional transaction costs. First, they eat into
    the performance in general. In any case, taking account of transaction costs reduces
    the performance. Second, they bring to light the importance of the number of trades
    a certain strategy triggers over time. Without transaction costs, the momentum
    strategy significantly outperforms the SMA-based strategy. With transaction costs,
    the SMA-based strategy outperforms the momentum strategy since it relies on fewer
    trades:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[Chapter 5](ch05.html#machine_learning) emphasizes that there are two sides
    of the performance coin: the hit ratio for the correct prediction of the market
    direction and the market timing (that is, when exactly the prediction is correct).
    The results shown here illustrate that there is even a “third side”: the number
    of trades triggered by a strategy. A strategy that demands a higher frequency
    of trades has to bear higher transaction costs that easily eat up an alleged outperformance
    over another strategy with no or low transaction costs. Among other things, this
    often makes the case for low-cost passive investment strategies based, for example,
    on exchange-traded funds (ETFs).'
  prefs: []
  type: TYPE_NORMAL
- en: Long-Short Backtesting Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[“Long-Short Backtesting Class”](#py_long_short) presents the `BacktestLongShort`
    class, which also inherits from the `BacktestBase` class. In addition to implementing
    the respective methods for the backtesting of the different strategies, it implements
    two additional methods to go long and short, respectively. Only the `.go_long()`
    method is commented on in detail, since the `.go_short()` method does exactly
    the same in the opposite direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to `bar`, the methods expect either a number for the units of the
    traded instrument or a currency amount.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: In the `.go_long()` case, it is first checked whether there is a short position.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: If so, this short position gets closed first.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: It is then checked whether `units` is given…
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO6-5)'
  prefs: []
  type: TYPE_NORMAL
- en: …which triggers a buy order accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO6-6)'
  prefs: []
  type: TYPE_NORMAL
- en: If `amount` is given, there can be two cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO6-7)'
  prefs: []
  type: TYPE_NORMAL
- en: First, the value is `all`, which translates into…
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO6-8)'
  prefs: []
  type: TYPE_NORMAL
- en: …all the available cash in the current cash balance.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO6-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Second, the value is a number that is then simply taken to place the respective
    buy order. Note that it is not checked whether there is enough liquidity or not.
  prefs: []
  type: TYPE_NORMAL
- en: To keep the implementation concise throughout, there are many simplifications
    in the Python classes that transfer responsibility to the user. For example, the
    classes do not take care of whether there is enough liquidity or not to execute
    a trade. This is an economic simplification since, in theory, one could assume
    enough or even unlimited credit for the algorithmic trader. As another example,
    certain methods expect that at least one of two parameters (either `units` or
    `amount`) is specified. There is no code that catches the case where both are
    not set. This is a technical simplification.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following presents the core loop from the `.run_mean_reversion_strategy()`
    method of the `BacktestLongShort` class. Again, the mean-reversion strategy is
    picked since the implementation is a bit more involved. For instance, it is the
    only strategy that also leads to intermediate market neutral positions. This necessitates
    more checks compared to the other two strategies, as seen in [“Long-Short Backtesting
    Class”](#py_long_short):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The first top-level condition checks whether the position is market neutral.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: If this is true, it is then checked whether the current price is low enough
    relative to the SMA.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: In such a case, the `.go_long()` method is called…
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: …and the market position is set to long.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO7-5)'
  prefs: []
  type: TYPE_NORMAL
- en: If the current price is high enough relative to the SMA, the `.go_short()` method
    is called…
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO7-6)'
  prefs: []
  type: TYPE_NORMAL
- en: …and the market position is set to short.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO7-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The second top-level condition checks for a long market position.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO7-8)'
  prefs: []
  type: TYPE_NORMAL
- en: In such a case, it is further checked whether the current price is at or above
    the SMA level again.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO7-9)'
  prefs: []
  type: TYPE_NORMAL
- en: If so, the long position gets closed out by selling all units in the portfolio.
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](assets/10.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO7-10)'
  prefs: []
  type: TYPE_NORMAL
- en: The market position is reset to neutral.
  prefs: []
  type: TYPE_NORMAL
- en: '[![11](assets/11.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO7-11)'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the third top-level condition checks for a short position.
  prefs: []
  type: TYPE_NORMAL
- en: '[![12](assets/12.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO7-12)'
  prefs: []
  type: TYPE_NORMAL
- en: If the current price is at or below the SMA…
  prefs: []
  type: TYPE_NORMAL
- en: '[![13](assets/13.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO7-13)'
  prefs: []
  type: TYPE_NORMAL
- en: …a buy order for all units short is triggered to close out the short position.
  prefs: []
  type: TYPE_NORMAL
- en: '[![14](assets/14.png)](#co_building_classes_for___span_class__keep_together__event_based_backtesting__span__CO7-14)'
  prefs: []
  type: TYPE_NORMAL
- en: The market position is then reset to neutral.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the Python script in [“Long-Short Backtesting Class”](#py_long_short)
    yields performance results that shed further light on strategy characteristics.
    One might be inclined to assume that adding the flexibility to short a financial
    instrument yields better results. However, reality shows that this is not necessarily
    true. All strategies perform worse both without and after transaction costs. Some
    configurations even pile up net losses or even a position of debt. Although these
    are specific results only, they illustrate that it is risky in such a context
    to jump to conclusions too early and to not take into account limits for piling
    up debt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Situations where trading might eat up all the initial equity and might even
    lead to a position of debt arise, for example, in the context of trading contracts-for-difference
    (CFDs). These are highly leveraged products for which the trader only needs to
    put down, say, 5% of the position value as the initial margin (when the leverage
    is 20). If the position value changes by, say, 10%, the trader might be required
    to meet a corresponding margin call. For a long position of 100,000 USD, equity
    of 5,000 USD is required. If the position drops to 90,000 USD, the equity is wiped
    out and the trader must put down 5,000 USD more to cover the losses. This assumes
    that no margin stop outs are in place that would close the position as soon as
    the remaining equity drops to 0 USD.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presents classes for the event-based backtesting of trading strategies.
    Compared to vectorized backtesting, event-based backtesting makes intentional
    and heavy use of loops and iterations to be able to tackle every single new event
    (generally, the arrival of new data) individually. This allows for a more flexible
    approach that can, among other things, easily cope with fixed transaction costs
    or more complex strategies (and variations thereof).
  prefs: []
  type: TYPE_NORMAL
- en: '[“Backtesting Base Class”](#base_class) presents a base class with certain
    methods useful for the backtesting of a variety of trading strategies. [“Long-Only
    Backtesting Class”](#long_only) and [“Long-Short Backtesting Class”](#long_short)
    build on this infrastructure to implement classes that allow the backtesting of
    long-only and long-short trading strategies. Mainly for comparison reasons, the
    implementations include all three strategies formally introduced in [Chapter 4](ch04.html#vectorized_backtesting).
    Taking the classes of this chapter as a starting point, enhancements and refinements
    are easily achieved.'
  prefs: []
  type: TYPE_NORMAL
- en: References and Further Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previous chapters introduce the basic ideas and concepts with regard to the
    three trading strategies covered in this chapter. This chapter for the first time
    makes a more systemic use of Python classes and object-oriented programming (OOP).
    A good introduction to OOP with Python and Python’s data model is found in Ramalho
    (2021). A more concise introduction to OOP applied to finance is found in Hilpisch
    (2018, ch. 6):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hilpisch, Yves. 2018\. *Python for Finance: Mastering Data-Driven Finance*.
    2nd ed. Sebastopol: O’Reilly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ramalho, Luciano. 2021\. *Fluent Python: Clear, Concise, and Effective Programming*.
    2nd ed. Sebastopol: O’Reilly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Python ecosystem provides a number of optional packages that allow the
    backtesting of algorithmic trading strategies. Four of them are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[bt](http://pmorissette.github.io/bt/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Backtrader](https://backtrader.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PyAlgoTrade](http://gbeced.github.io/pyalgotrade/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Zipline](https://github.com/quantopian/zipline)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zipline`, for example, powers the popular [Quantopian](http://quantopian.com)
    platform for the backtesting of algorithmic trading strategies but can also be
    installed and used locally.'
  prefs: []
  type: TYPE_NORMAL
- en: Although these packages might allow for a more thorough backtesting of algorithmic
    trading strategies than the rather simple classes presented in this chapter, the
    main goal of this book is to empower the reader and algorithmic trader to implement
    Python code in a self-contained fashion. Even if standard packages are later used
    to do the actual backtesting, a good understanding of the different approaches
    and their mechanics is beneficial, if not required.
  prefs: []
  type: TYPE_NORMAL
- en: Python Scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section presents Python scripts referenced and used in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Backtesting Base Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following Python code contains the base class for event-based backtesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Long-Only Backtesting Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following presents Python code with a class for the event-based backtesting
    of *long-only* strategies, with implementations for strategies based on *SMAs*,
    *momentum*, and *mean reversion*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Long-Short Backtesting Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following Python code contains a class for the event-based backtesting
    of *long-short* strategies, with implementations for strategies based on *SMAs*,
    *momentum*, and *mean reversion*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
