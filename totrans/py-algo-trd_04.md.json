["```py\nIn [1]: v = [1, 2, 3, 4, 5]\n\nIn [2]: sm = [2 * i for i in v]\n\nIn [3]: sm\nOut[3]: [2, 4, 6, 8, 10]\n```", "```py\nIn [4]: 2 * v\nOut[4]: [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\n```", "```py\nIn [5]: import numpy as np  ![1](assets/1.png)\n\nIn [6]: a = np.array(v)  ![2](assets/2.png)\n\nIn [7]: a  ![3](assets/3.png)\nOut[7]: array([1, 2, 3, 4, 5])\n\nIn [8]: type(a)  ![4](assets/4.png)\nOut[8]: numpy.ndarray\n\nIn [9]: 2 * a  ![5](assets/5.png)\nOut[9]: array([ 2,  4,  6,  8, 10])\n\nIn [10]: 0.5 * a + 2  ![6](assets/6.png)\nOut[10]: array([2.5, 3. , 3.5, 4. , 4.5])\n```", "```py\nIn [11]: a = np.arange(12).reshape((4, 3))  ![1](assets/1.png)\n\nIn [12]: a\nOut[12]: array([[ 0,  1,  2],\n                [ 3,  4,  5],\n                [ 6,  7,  8],\n                [ 9, 10, 11]])\n\nIn [13]: 2 * a\nOut[13]: array([[ 0,  2,  4],\n                [ 6,  8, 10],\n                [12, 14, 16],\n                [18, 20, 22]])\n\nIn [14]: a ** 2  ![2](assets/2.png)\nOut[14]: array([[  0,   1,   4],\n                [  9,  16,  25],\n                [ 36,  49,  64],\n                [ 81, 100, 121]])\n```", "```py\nIn [15]: a.mean()  ![1](assets/1.png)\nOut[15]: 5.5\n\nIn [16]: np.mean(a)  ![2](assets/2.png)\nOut[16]: 5.5\n\nIn [17]: a.mean(axis=0)  ![3](assets/3.png)\nOut[17]: array([4.5, 5.5, 6.5])\n\nIn [18]: np.mean(a, axis=1)  ![4](assets/4.png)\nOut[18]: array([ 1.,  4.,  7., 10.])\n```", "```py\nIn [19]: a = np.arange(15).reshape(5, 3)\n\nIn [20]: a\nOut[20]: array([[ 0,  1,  2],\n                [ 3,  4,  5],\n                [ 6,  7,  8],\n                [ 9, 10, 11],\n                [12, 13, 14]])\n```", "```py\nIn [21]: import pandas as pd  ![1](assets/1.png)\n\nIn [22]: columns = list('abc')  ![2](assets/2.png)\n\nIn [23]: columns\nOut[23]: ['a', 'b', 'c']\n\nIn [24]: index = pd.date_range('2021-7-1', periods=5, freq='B')  ![3](assets/3.png)\n\nIn [25]: index\nOut[25]: DatetimeIndex(['2021-07-01', '2021-07-02', '2021-07-05',\n          '2021-07-06',\n                        '2021-07-07'],\n                       dtype='datetime64[ns]', freq='B')\n\nIn [26]: df = pd.DataFrame(a, columns=columns, index=index)  ![4](assets/4.png)\n\nIn [27]: df\nOut[27]:              a   b   c\n         2021-07-01   0   1   2\n         2021-07-02   3   4   5\n         2021-07-05   6   7   8\n         2021-07-06   9  10  11\n         2021-07-07  12  13  14\n```", "```py\nIn [28]: 2 * df  ![1](assets/1.png)\nOut[28]:              a   b   c\n         2021-07-01   0   2   4\n         2021-07-02   6   8  10\n         2021-07-05  12  14  16\n         2021-07-06  18  20  22\n         2021-07-07  24  26  28\n\nIn [29]: df.sum()  ![2](assets/2.png)\nOut[29]: a    30\n         b    35\n         c    40\n         dtype: int64\n\nIn [30]: np.mean(df)  ![3](assets/3.png)\nOut[30]: a    6.0\n         b    7.0\n         c    8.0\n         dtype: float64\n```", "```py\nIn [31]: df['a'] + df['c']  ![1](assets/1.png)\nOut[31]: 2021-07-01     2\n         2021-07-02     8\n         2021-07-05    14\n         2021-07-06    20\n         2021-07-07    26\n         Freq: B, dtype: int64\n\nIn [32]: 0.5 * df.a + 2 * df.b - df.c  ![2](assets/2.png)\nOut[32]: 2021-07-01     0.0\n         2021-07-02     4.5\n         2021-07-05     9.0\n         2021-07-06    13.5\n         2021-07-07    18.0\n         Freq: B, dtype: float64\n```", "```py\nIn [33]: df['a'] > 5  ![1](assets/1.png)\nOut[33]: 2021-07-01    False\n         2021-07-02    False\n         2021-07-05     True\n         2021-07-06     True\n         2021-07-07     True\n         Freq: B, Name: a, dtype: bool\n\nIn [34]: df[df['a'] > 5]  ![2](assets/2.png)\nOut[34]:              a   b   c\n         2021-07-05   6   7   8\n         2021-07-06   9  10  11\n         2021-07-07  12  13  14\n```", "```py\nIn [35]: df['c'] > df['b']  ![1](assets/1.png)\nOut[35]: 2021-07-01    True\n         2021-07-02    True\n         2021-07-05    True\n         2021-07-06    True\n         2021-07-07    True\n         Freq: B, dtype: bool\n\nIn [36]: 0.15 * df.a + df.b > df.c  ![2](assets/2.png)\nOut[36]: 2021-07-01    False\n         2021-07-02    False\n         2021-07-05    False\n         2021-07-06     True\n         2021-07-07     True\n         Freq: B, dtype: bool\n```", "```py\nIn [37]: raw = pd.read_csv('http://hilpisch.com/pyalgo_eikon_eod_data.csv',\n                            index_col=0, parse_dates=True).dropna()  ![1](assets/1.png)\n\nIn [38]: raw.info()  ![2](assets/2.png)\n         <class 'pandas.core.frame.DataFrame'>\n         DatetimeIndex: 2516 entries, 2010-01-04 to 2019-12-31\n         Data columns (total 12 columns):\n          #   Column  Non-Null Count  Dtype\n         ---  ------  --------------  -----\n          0   AAPL.O  2516 non-null   float64\n          1   MSFT.O  2516 non-null   float64\n          2   INTC.O  2516 non-null   float64\n          3   AMZN.O  2516 non-null   float64\n          4   GS.N    2516 non-null   float64\n          5   SPY     2516 non-null   float64\n          6   .SPX    2516 non-null   float64\n          7   .VIX    2516 non-null   float64\n          8   EUR=    2516 non-null   float64\n          9   XAU=    2516 non-null   float64\n          10  GDX     2516 non-null   float64\n          11  GLD     2516 non-null   float64\n         dtypes: float64(12)\n         memory usage: 255.5 KB\n\nIn [39]: data = pd.DataFrame(raw['EUR='])  ![3](assets/3.png)\n\nIn [40]: data.rename(columns={'EUR=': 'price'}, inplace=True)  ![4](assets/4.png)\n\nIn [41]: data.info()  ![5](assets/5.png)\n         <class 'pandas.core.frame.DataFrame'>\n         DatetimeIndex: 2516 entries, 2010-01-04 to 2019-12-31\n         Data columns (total 1 columns):\n          #   Column  Non-Null Count  Dtype\n         ---  ------  --------------  -----\n          0   price   2516 non-null   float64\n         dtypes: float64(1)\n         memory usage: 39.3 KB\n```", "```py\nIn [42]: data['SMA1'] = data['price'].rolling(42).mean()  ![1](assets/1.png)\n\nIn [43]: data['SMA2'] = data['price'].rolling(252).mean()  ![2](assets/2.png)\n\nIn [44]: data.tail()  ![3](assets/3.png)\nOut[44]:              price      SMA1      SMA2\n         Date\n         2019-12-24  1.1087  1.107698  1.119630\n         2019-12-26  1.1096  1.107740  1.119529\n         2019-12-27  1.1175  1.107924  1.119428\n         2019-12-30  1.1197  1.108131  1.119333\n         2019-12-31  1.1210  1.108279  1.119231\n```", "```py\nIn [45]: %matplotlib inline\n         from pylab import mpl, plt\n         plt.style.use('seaborn')\n         mpl.rcParams['savefig.dpi'] = 300\n         mpl.rcParams['font.family'] = 'serif'\n\nIn [46]: data.plot(title='EUR/USD | 42 & 252 days SMAs',\n                   figsize=(10, 6));\n```", "```py\nIn [47]: data['position'] = np.where(data['SMA1'] > data['SMA2'],\n                                     1, -1)  ![1](assets/1.png)\n\nIn [48]: data.dropna(inplace=True)  ![2](assets/2.png)\n\nIn [49]: data['position'].plot(ylim=[-1.1, 1.1],\n                               title='Market Positioning',\n                               figsize=(10, 6));  ![3](assets/3.png)\n```", "```py\nIn [50]: data['returns'] = np.log(data['price'] / data['price'].shift(1))  ![1](assets/1.png)\n\nIn [51]: data['returns'].hist(bins=35, figsize=(10, 6));  ![2](assets/2.png)\n```", "```py\nIn [52]: data['strategy'] = data['position'].shift(1) * data['returns']  ![1](assets/1.png)\n\nIn [53]: data[['returns', 'strategy']].sum()  ![2](assets/2.png)\nOut[53]: returns    -0.176731\n         strategy    0.253121\n         dtype: float64\n\nIn [54]: data[['returns', 'strategy']].sum().apply(np.exp)  ![3](assets/3.png)\nOut[54]: returns     0.838006\n         strategy    1.288039\n         dtype: float64\n```", "```py\nIn [55]: data[['returns', 'strategy']].cumsum(\n                     ).apply(np.exp).plot(figsize=(10, 6));\n```", "```py\nIn [56]: data[['returns', 'strategy']].mean() * 252  ![1](assets/1.png)\nOut[56]: returns    -0.019671\n         strategy    0.028174\n         dtype: float64\n\nIn [57]: np.exp(data[['returns', 'strategy']].mean() * 252) - 1  ![1](assets/1.png)\nOut[57]: returns    -0.019479\n         strategy    0.028575\n         dtype: float64\n\nIn [58]: data[['returns', 'strategy']].std() * 252 ** 0.5  ![2](assets/2.png)\nOut[58]: returns     0.085414\n         strategy    0.085405\n         dtype: float64\n\nIn [59]: (data[['returns', 'strategy']].apply(np.exp) - 1).std() * 252 ** 0.5  ![2](assets/2.png)\nOut[59]: returns     0.085405\n         strategy    0.085373\n         dtype: float64\n```", "```py\nIn [60]: data['cumret'] = data['strategy'].cumsum().apply(np.exp)  ![1](assets/1.png)\n\nIn [61]: data['cummax'] = data['cumret'].cummax()  ![2](assets/2.png)\n\nIn [62]: data[['cumret', 'cummax']].dropna().plot(figsize=(10, 6));  ![3](assets/3.png)\n```", "```py\nIn [63]: drawdown = data['cummax'] - data['cumret']  ![1](assets/1.png)\n\nIn [64]: drawdown.max()  ![2](assets/2.png)\nOut[64]: 0.17779367070195917\n```", "```py\nIn [65]: temp = drawdown[drawdown == 0]  ![1](assets/1.png)\n\nIn [66]: periods = (temp.index[1:].to_pydatetime() -\n                    temp.index[:-1].to_pydatetime())  ![2](assets/2.png)\n\nIn [67]: periods[12:15]\nOut[67]: array([datetime.timedelta(days=1), datetime.timedelta(days=1),\n                datetime.timedelta(days=10)], dtype=object)\n\nIn [68]: periods.max()  ![3](assets/3.png)\nOut[68]: datetime.timedelta(days=596)\n```", "```py\nIn [69]: import SMAVectorBacktester as SMA  ![1](assets/1.png)\n\nIn [70]: smabt = SMA.SMAVectorBacktester('EUR=', 42, 252,\n                                         '2010-1-1', '2019-12-31')   ![2](assets/2.png)\n\nIn [71]: smabt.run_strategy()  ![3](assets/3.png)\nOut[71]: (1.29, 0.45)\n\nIn [72]: %%time\n         smabt.optimize_parameters((30, 50, 2),\n                                   (200, 300, 2))  ![4](assets/4.png)\n         CPU times: user 3.76 s, sys: 15.8 ms, total: 3.78 s\n         Wall time: 3.78 s\n\nOut[72]: (array([ 48., 238.]), 1.5)\n\nIn [73]: smabt.plot_results()  ![5](assets/5.png)\n```", "```py\nIn [74]: data = pd.DataFrame(raw['XAU='])\n\nIn [75]: data.rename(columns={'XAU=': 'price'}, inplace=True)\n\nIn [76]: data['returns'] = np.log(data['price'] / data['price'].shift(1))\n```", "```py\nIn [77]: data['position'] = np.sign(data['returns'])  ![1](assets/1.png)\n\nIn [78]: data['strategy'] = data['position'].shift(1) * data['returns']  ![2](assets/2.png)\n\nIn [79]: data[['returns', 'strategy']].dropna().cumsum(\n                     ).apply(np.exp).plot(figsize=(10, 6));  ![3](assets/3.png)\n```", "```py\nIn [80]: data['position'] = np.sign(data['returns'].rolling(3).mean())  ![1](assets/1.png)\n\nIn [81]: data['strategy'] = data['position'].shift(1) * data['returns']\n\nIn [82]: data[['returns', 'strategy']].dropna().cumsum(\n                 ).apply(np.exp).plot(figsize=(10, 6));\n```", "```py\nIn [83]: fn = '../data/AAPL_1min_05052020.csv'  ![1](assets/1.png)\n         # fn = '../data/SPX_1min_05052020.csv' ![1](assets/1.png)\n\nIn [84]: data = pd.read_csv(fn, index_col=0, parse_dates=True)  ![1](assets/1.png)\n\nIn [85]: data.info()  ![1](assets/1.png)\n         <class 'pandas.core.frame.DataFrame'>\n         DatetimeIndex: 241 entries, 2020-05-05 16:00:00 to 2020-05-05 20:00:00\n         Data columns (total 6 columns):\n          #   Column  Non-Null Count  Dtype\n         ---  ------  --------------  -----\n          0   HIGH    241 non-null    float64\n          1   LOW     241 non-null    float64\n          2   OPEN    241 non-null    float64\n          3   CLOSE   241 non-null    float64\n          4   COUNT   241 non-null    float64\n          5   VOLUME  241 non-null    float64\n         dtypes: float64(6)\n         memory usage: 13.2 KB\n\nIn [86]: data['returns'] = np.log(data['CLOSE'] /\n                                  data['CLOSE'].shift(1))  ![2](assets/2.png)\n\nIn [87]: to_plot = ['returns']  ![3](assets/3.png)\n\nIn [88]: for m in [1, 3, 5, 7, 9]:\n             data['position_%d' % m] = np.sign(data['returns'].rolling(m).mean())  ![4](assets/4.png)\n             data['strategy_%d' % m] = (data['position_%d' % m].shift(1) *\n                                        data['returns'])  ![5](assets/5.png)\n             to_plot.append('strategy_%d' % m)   ![6](assets/6.png)\n\nIn [89]: data[to_plot].dropna().cumsum().apply(np.exp).plot(\n             title='AAPL intraday 05\\. May 2020',\n             figsize=(10, 6), style=['-', '--', '--', '--', '--', '--']);  ![7](assets/7.png)\n```", "```py\nIn [90]: import MomVectorBacktester as Mom  ![1](assets/1.png)\n\nIn [91]: mombt = Mom.MomVectorBacktester('XAU=', '2010-1-1',\n                                         '2019-12-31', 10000, 0.0)  ![2](assets/2.png)\n\nIn [92]: mombt.run_strategy(momentum=3)  ![3](assets/3.png)\nOut[92]: (20797.87, 7395.53)\n\nIn [93]: mombt.plot_results()\nIn [94]: mombt = Mom.MomVectorBacktester('XAU=', '2010-1-1',\n                                         '2019-12-31', 10000, 0.001)  ![4](assets/4.png)\n\nIn [95]: mombt.run_strategy(momentum=3)  ![5](assets/5.png)\nOut[95]: (10749.4, -2652.93)\n\nIn [96]: mombt.plot_results()\n```", "```py\nIn [97]: data = pd.DataFrame(raw['GDX'])\n\nIn [98]: data.rename(columns={'GDX': 'price'}, inplace=True)\n\nIn [99]: data['returns'] = np.log(data['price'] /\n                                  data['price'].shift(1))\n\nIn [100]: SMA = 25  ![1](assets/1.png)\n\nIn [101]: data['SMA'] = data['price'].rolling(SMA).mean()  ![2](assets/2.png)\n\nIn [102]: threshold = 3.5  ![3](assets/3.png)\n\nIn [103]: data['distance'] = data['price'] - data['SMA']  ![4](assets/4.png)\n\nIn [104]: data['distance'].dropna().plot(figsize=(10, 6), legend=True)  ![5](assets/5.png)\n          plt.axhline(threshold, color='r')\n          plt.axhline(-threshold, color='r')\n          plt.axhline(0, color='r');\n```", "```py\nIn [105]: data['position'] = np.where(data['distance'] > threshold,\n                                      -1, np.nan)  ![1](assets/1.png)\n\nIn [106]: data['position'] = np.where(data['distance'] < -threshold,\n                                      1, data['position'])  ![2](assets/2.png)\n\nIn [107]: data['position'] = np.where(data['distance'] *\n                      data['distance'].shift(1) < 0, 0, data['position'])  ![3](assets/3.png)\n\nIn [108]: data['position'] = data['position'].ffill().fillna(0)  ![4](assets/4.png)\n\nIn [109]: data['position'].iloc[SMA:].plot(ylim=[-1.1, 1.1],\n                                         figsize=(10, 6));  ![5](assets/5.png)\n```", "```py\nIn [110]: data['strategy'] = data['position'].shift(1) * data['returns']\n\nIn [111]: data[['returns', 'strategy']].dropna().cumsum(\n                  ).apply(np.exp).plot(figsize=(10, 6));\n```", "```py\nIn [112]: import MRVectorBacktester as MR  ![1](assets/1.png)\n\nIn [113]: mrbt = MR.MRVectorBacktester('GLD', '2010-1-1', '2019-12-31',\n                                       10000, 0.001)  ![2](assets/2.png)\n\nIn [114]: mrbt.run_strategy(SMA=43, threshold=7.5)  ![3](assets/3.png)\nOut[114]: (13542.15, 646.21)\n\nIn [115]: mrbt.plot_results()  ![4](assets/4.png)\n```", "```py\n#\n# Python Module with Class\n# for Vectorized Backtesting\n# of SMA-based Strategies\n#\n# Python for Algorithmic Trading\n# (c) Dr. Yves J. Hilpisch\n# The Python Quants GmbH\n#\nimport numpy as np\nimport pandas as pd\nfrom scipy.optimize import brute\n\nclass SMAVectorBacktester(object):\n    ''' Class for the vectorized backtesting of SMA-based trading strategies.\n\n Attributes\n ==========\n symbol: str\n RIC symbol with which to work\n SMA1: int\n time window in days for shorter SMA\n SMA2: int\n time window in days for longer SMA\n start: str\n start date for data retrieval\n end: str\n end date for data retrieval\n\n Methods\n =======\n get_data:\n retrieves and prepares the base data set\n set_parameters:\n sets one or two new SMA parameters\n run_strategy:\n runs the backtest for the SMA-based strategy\n plot_results:\n plots the performance of the strategy compared to the symbol\n update_and_run:\n updates SMA parameters and returns the (negative) absolute performance\n optimize_parameters:\n implements a brute force optimization for the two SMA parameters\n '''\n\n    def __init__(self, symbol, SMA1, SMA2, start, end):\n        self.symbol = symbol\n        self.SMA1 = SMA1\n        self.SMA2 = SMA2\n        self.start = start\n        self.end = end\n        self.results = None\n        self.get_data()\n\n    def get_data(self):\n        ''' Retrieves and prepares the data.\n '''\n        raw = pd.read_csv('http://hilpisch.com/pyalgo_eikon_eod_data.csv',\n                          index_col=0, parse_dates=True).dropna()\n        raw = pd.DataFrame(raw[self.symbol])\n        raw = raw.loc[self.start:self.end]\n        raw.rename(columns={self.symbol: 'price'}, inplace=True)\n        raw['return'] = np.log(raw / raw.shift(1))\n        raw['SMA1'] = raw['price'].rolling(self.SMA1).mean()\n        raw['SMA2'] = raw['price'].rolling(self.SMA2).mean()\n        self.data = raw\n\n    def set_parameters(self, SMA1=None, SMA2=None):\n        ''' Updates SMA parameters and resp. time series.\n '''\n        if SMA1 is not None:\n            self.SMA1 = SMA1\n            self.data['SMA1'] = self.data['price'].rolling(\n                self.SMA1).mean()\n        if SMA2 is not None:\n            self.SMA2 = SMA2\n            self.data['SMA2'] = self.data['price'].rolling(self.SMA2).mean()\n\n    def run_strategy(self):\n        ''' Backtests the trading strategy.\n '''\n        data = self.data.copy().dropna()\n        data['position'] = np.where(data['SMA1'] > data['SMA2'], 1, -1)\n        data['strategy'] = data['position'].shift(1) * data['return']\n        data.dropna(inplace=True)\n        data['creturns'] = data['return'].cumsum().apply(np.exp)\n        data['cstrategy'] = data['strategy'].cumsum().apply(np.exp)\n        self.results = data\n        # gross performance of the strategy\n        aperf = data['cstrategy'].iloc[-1]\n        # out-/underperformance of strategy\n        operf = aperf - data['creturns'].iloc[-1]\n        return round(aperf, 2), round(operf, 2)\n\n    def plot_results(self):\n        ''' Plots the cumulative performance of the trading strategy\n compared to the symbol.\n '''\n        if self.results is None:\n            print('No results to plot yet. Run a strategy.')\n        title = '%s | SMA1=%d, SMA2=%d' % (self.symbol,\n                                               self.SMA1, self.SMA2)\n        self.results[['creturns', 'cstrategy']].plot(title=title,\n                                                     figsize=(10, 6))\n\n    def update_and_run(self, SMA):\n        ''' Updates SMA parameters and returns negative absolute performance\n (for minimazation algorithm).\n\n Parameters\n ==========\n SMA: tuple\n SMA parameter tuple\n '''\n        self.set_parameters(int(SMA[0]), int(SMA[1]))\n        return -self.run_strategy()[0]\n\n    def optimize_parameters(self, SMA1_range, SMA2_range):\n        ''' Finds global maximum given the SMA parameter ranges.\n\n Parameters\n ==========\n SMA1_range, SMA2_range: tuple\n tuples of the form (start, end, step size)\n '''\n        opt = brute(self.update_and_run, (SMA1_range, SMA2_range), finish=None)\n        return opt, -self.update_and_run(opt)\n\nif __name__ == '__main__':\n    smabt = SMAVectorBacktester('EUR=', 42, 252,\n                                '2010-1-1', '2020-12-31')\n    print(smabt.run_strategy())\n    smabt.set_parameters(SMA1=20, SMA2=100)\n    print(smabt.run_strategy())\n    print(smabt.optimize_parameters((30, 56, 4), (200, 300, 4)))\n```", "```py\n#\n# Python Module with Class\n# for Vectorized Backtesting\n# of Momentum-Based Strategies\n#\n# Python for Algorithmic Trading\n# (c) Dr. Yves J. Hilpisch\n# The Python Quants GmbH\n#\nimport numpy as np\nimport pandas as pd\n\nclass MomVectorBacktester(object):\n    ''' Class for the vectorized backtesting of\n momentum-based trading strategies.\n\n Attributes\n ==========\n symbol: str\n RIC (financial instrument) to work with\n start: str\n start date for data selection\n end: str\n end date for data selection\n amount: int, float\n amount to be invested at the beginning\n tc: float\n proportional transaction costs (e.g., 0.5% = 0.005) per trade\n\n Methods\n =======\n get_data:\n retrieves and prepares the base data set\n run_strategy:\n runs the backtest for the momentum-based strategy\n plot_results:\n plots the performance of the strategy compared to the symbol\n '''\n\n    def __init__(self, symbol, start, end, amount, tc):\n        self.symbol = symbol\n        self.start = start\n        self.end = end\n        self.amount = amount\n        self.tc = tc\n        self.results = None\n        self.get_data()\n\n    def get_data(self):\n        ''' Retrieves and prepares the data.\n '''\n        raw = pd.read_csv('http://hilpisch.com/pyalgo_eikon_eod_data.csv',\n                          index_col=0, parse_dates=True).dropna()\n        raw = pd.DataFrame(raw[self.symbol])\n        raw = raw.loc[self.start:self.end]\n        raw.rename(columns={self.symbol: 'price'}, inplace=True)\n        raw['return'] = np.log(raw / raw.shift(1))\n        self.data = raw\n\n    def run_strategy(self, momentum=1):\n        ''' Backtests the trading strategy.\n '''\n        self.momentum = momentum\n        data = self.data.copy().dropna()\n        data['position'] = np.sign(data['return'].rolling(momentum).mean())\n        data['strategy'] = data['position'].shift(1) * data['return']\n        # determine when a trade takes place\n        data.dropna(inplace=True)\n        trades = data['position'].diff().fillna(0) != 0\n        # subtract transaction costs from return when trade takes place\n        data['strategy'][trades] -= self.tc\n        data['creturns'] = self.amount * data['return'].cumsum().apply(np.exp)\n        data['cstrategy'] = self.amount * \\\n            data['strategy'].cumsum().apply(np.exp)\n        self.results = data\n        # absolute performance of the strategy\n        aperf = self.results['cstrategy'].iloc[-1]\n        # out-/underperformance of strategy\n        operf = aperf - self.results['creturns'].iloc[-1]\n        return round(aperf, 2), round(operf, 2)\n\n    def plot_results(self):\n        ''' Plots the cumulative performance of the trading strategy\n compared to the symbol.\n '''\n        if self.results is None:\n            print('No results to plot yet. Run a strategy.')\n        title = '%s | TC = %.4f' % (self.symbol, self.tc)\n        self.results[['creturns', 'cstrategy']].plot(title=title,\n                                                     figsize=(10, 6))\n\nif __name__ == '__main__':\n    mombt = MomVectorBacktester('XAU=', '2010-1-1', '2020-12-31',\n                                10000, 0.0)\n    print(mombt.run_strategy())\n    print(mombt.run_strategy(momentum=2))\n    mombt = MomVectorBacktester('XAU=', '2010-1-1', '2020-12-31',\n                                10000, 0.001)\n    print(mombt.run_strategy(momentum=2))\n```", "```py\n#\n# Python Module with Class\n# for Vectorized Backtesting\n# of Mean-Reversion Strategies\n#\n# Python for Algorithmic Trading\n# (c) Dr. Yves J. Hilpisch\n# The Python Quants GmbH\n#\nfrom MomVectorBacktester import *\n\nclass MRVectorBacktester(MomVectorBacktester):\n    ''' Class for the vectorized backtesting of\n mean reversion-based trading strategies.\n\n Attributes\n ==========\n symbol: str\n RIC symbol with which to work\n start: str\n start date for data retrieval\n end: str\n end date for data retrieval\n amount: int, float\n amount to be invested at the beginning\n tc: float\n proportional transaction costs (e.g., 0.5% = 0.005) per trade\n\n Methods\n =======\n get_data:\n retrieves and prepares the base data set\n run_strategy:\n runs the backtest for the mean reversion-based strategy\n plot_results:\n plots the performance of the strategy compared to the symbol\n '''\n\n    def run_strategy(self, SMA, threshold):\n        ''' Backtests the trading strategy.\n '''\n        data = self.data.copy().dropna()\n        data['sma'] = data['price'].rolling(SMA).mean()\n        data['distance'] = data['price'] - data['sma']\n        data.dropna(inplace=True)\n        # sell signals\n        data['position'] = np.where(data['distance'] > threshold,\n                                    -1, np.nan)\n        # buy signals\n        data['position'] = np.where(data['distance'] < -threshold,\n                                    1, data['position'])\n        # crossing of current price and SMA (zero distance)\n        data['position'] = np.where(data['distance'] *\n                                    data['distance'].shift(1) < 0,\n                                    0, data['position'])\n        data['position'] = data['position'].ffill().fillna(0)\n        data['strategy'] = data['position'].shift(1) * data['return']\n        # determine when a trade takes place\n        trades = data['position'].diff().fillna(0) != 0\n        # subtract transaction costs from return when trade takes place\n        data['strategy'][trades] -= self.tc\n        data['creturns'] = self.amount * \\\n            data['return'].cumsum().apply(np.exp)\n        data['cstrategy'] = self.amount * \\\n            data['strategy'].cumsum().apply(np.exp)\n        self.results = data\n        # absolute performance of the strategy\n        aperf = self.results['cstrategy'].iloc[-1]\n        # out-/underperformance of strategy\n        operf = aperf - self.results['creturns'].iloc[-1]\n        return round(aperf, 2), round(operf, 2)\n\nif __name__ == '__main__':\n    mrbt = MRVectorBacktester('GDX', '2010-1-1', '2020-12-31',\n                              10000, 0.0)\n    print(mrbt.run_strategy(SMA=25, threshold=5))\n    mrbt = MRVectorBacktester('GDX', '2010-1-1', '2020-12-31',\n                              10000, 0.001)\n    print(mrbt.run_strategy(SMA=25, threshold=5))\n    mrbt = MRVectorBacktester('GLD', '2010-1-1', '2020-12-31',\n                              10000, 0.001)\n    print(mrbt.run_strategy(SMA=42, threshold=7.5))\n```"]