- en: Chapter 10\. Natural Language Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Natural language processing (NLP) is a subfield of artificial intelligence used
    to aid computers in understanding natural human language. Most NLP techniques
    rely on machine learning to derive meaning from human languages. When text has
    been provided, the computer utilizes algorithms to extract meaning associated
    with every sentence and collect essential data from them. NLP manifests itself
    in different forms across many disciplines under various aliases, including (but
    not limited to) textual analysis, text mining, computational linguistics, and
    content analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In the financial landscape, one of the earliest applications of NLP was implemented
    by the US Securities and Exchange Commission (SEC). The group used text mining
    and natural language processing to detect accounting fraud. The ability of NLP
    algorithms to scan and analyze legal and other documents at a high speed provides
    banks and other financial institutions with enormous efficiency gains to help
    them meet compliance regulations and combat fraud.
  prefs: []
  type: TYPE_NORMAL
- en: In the investment process, uncovering investment insights requires not only
    domain knowledge of finance but also a strong grasp of data science and machine
    learning principles. NLP tools may help detect, measure, predict, and anticipate
    important market characteristics and indicators, such as market volatility, liquidity
    risks, financial stress, housing prices, and unemployment.
  prefs: []
  type: TYPE_NORMAL
- en: News has always been a key factor in investment decisions. It is well established
    that company-specific, macroeconomic, and political news strongly influence the
    financial markets. As technology advances, and market participants become more
    connected, the volume and frequency of news will continue to grow rapidly. Even
    today, the volume of daily text data being produced presents an untenable task
    for even a large team of fundamental researchers to navigate. Fundamental analysis
    assisted by NLP techniques is now critical to unlock the complete picture of how
    experts and the masses feel about the market.
  prefs: []
  type: TYPE_NORMAL
- en: In banks and other organizations, teams of analysts are dedicated to poring
    over, analyzing, and attempting to quantify qualitative data from news and SEC-mandated
    reporting. Automation using NLP is well suited in this context. NLP can provide
    in-depth support in the analysis and interpretation of various reports and documents.
    This reduces the strain that repetitive, low-value tasks put on human employees.
    It also provides a level of objectivity and consistency to otherwise subjective
    interpretations; mistakes from human error are lessened. NLP can also allow a
    company to garner insights that can be used to assess a creditor’s risk or gauge
    brand-related sentiment from content across the web.
  prefs: []
  type: TYPE_NORMAL
- en: With the rise in popularity of live chat software in banking and finance businesses,
    NLP-based chatbots are a natural evolution. The combination of robo-advisors with
    chatbots is expected to automate the entire process of wealth and portfolio management.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we present three NLP-based case studies that cover applications
    of NLP in algorithmic trading, chatbot creation, and document interpretation and
    automation. The case studies follow a standardized seven-step model development
    process presented in [Chapter 2](ch02.xhtml#Chapter2). Key model steps for NLP-based
    problems are data preprocessing, feature representation, and inference. As such,
    these areas, along with the related concepts and Python-based examples, are outlined
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[“Case Study 1: NLP and Sentiment Analysis–Based Trading Strategies”](#CaseStudy1NLP)
    demonstrates the usage of sentiment analysis and word embedding for a trading
    strategy. This case study highlights key focus areas for implementing an NLP-based
    trading strategy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [“Case Study 2: Chatbot Digital Assistant”](#CaseStudy2NLP), we create a
    chatbot and demonstrate how NLP enables chatbots to understand messages and respond
    appropriately. We leverage Python-based packages and modules to develop a chatbot
    in a few lines of code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[“Case Study 3: Document Summarization”](#CaseStudy3NLP) illustrates the use
    of an NLP-based *topic modeling* technique to discover hidden topics or themes
    across documents. The purpose of this case study is to demonstrate the usage of
    NLP to automatically summarize large collections of documents to facilitate organization
    and management, as well as search and recommendations.'
  prefs: []
  type: TYPE_NORMAL
- en: This Chapter’s Code Repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python code for this chapter is included under the [Chapter 10 - Natural
    Language Processing](https://oreil.ly/J2FFn) folder of the online GitHub repository
    for this chapter. For any new NLP-based case study, use the common template from
    the code repository and modify the elements specific to the case study. The templates
    are designed to run on the cloud (i.e., Kaggle, Google Colab, and AWS).
  prefs: []
  type: TYPE_NORMAL
- en: 'Natural Language Processing: Python Packages'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is one of the best options to build an NLP-based expert system, and a
    large variety of open source NLP libraries are available for Python programmers.
    These libraries and packages contain ready-to-use modules and functions to incorporate
    complex NLP steps and algorithms, making implementation fast, easy, and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will describe three Python-based NLP libraries we’ve found
    to be the most useful and that we will be using in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: NLTK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[NLTK](https://www.nltk.org) is the most famous Python NLP library, and it
    has led to incredible breakthroughs across several areas. Its modularized structure
    makes it excellent for learning and exploring NLP concepts. However, it has heavy
    functionality with a steep learning curve.'
  prefs: []
  type: TYPE_NORMAL
- en: 'NLTK can be installed using the typical installation procedure. After installing
    NLTK, NLTK Data needs to be downloaded. The NLTK Data package includes a pretrained
    tokenizer `punkt` for English, which can be downloaded as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: TextBlob
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[TextBlob](https://oreil.ly/tABh4) is built on top of NLTK. This is one of
    the best libraries for fast prototyping or building applications with minimal
    performance requirements. TextBlob makes text processing simple by providing an
    intuitive interface to NLTK. TextBlob can be imported using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: spaCy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[spaCy](https://spacy.io) is an NLP library designed to be fast, streamlined,
    and production-ready. Its philosophy is to present only one algorithm (the best
    one) for each purpose. We don’t have to make choices and can focus on being productive.
    spaCy uses its own pipeline to perform multiple preprocessing steps at the same
    time. We will demonstrate it in a subsequent section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'spaCy’s models can be installed as Python packages, just like any other module.
    To load a model, use `spacy.load` with the model’s shortcut link or package name
    or a path to the data directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In addition to these, there are a few other libraries, such as gensim, that
    we will explore for some of the examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Natural Language Processing: Theory and Concepts'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already established, NLP is a subfield of artificial intelligence
    concerned with programming computers to process textual data in order to gain
    useful insights. All NLP applications go through common sequential steps, which
    include some combination of preprocessing textual data and representing the text
    as predictive features before feeding them into a statistical inference algorithm.
    [Figure 10-1](#StepsNLP) outlines the major steps in an NLP-based application.
  prefs: []
  type: TYPE_NORMAL
- en: '![mlbf 1001](Images/mlbf_1001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1\. Natural language processing pipeline
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The next section reviews these steps. For a thorough coverage of the topic,
    the reader is referred to [*Natural Language Processing with Python*](https://www.oreilly.com/library/view/natural-language-processing/9780596803346)
    by Steven Bird, Ewan Klein, and Edward Loper (O’Reilly).
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Preprocessing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are usually multiple steps involved in preprocessing textual data for
    NLP. [Figure 10-1](#StepsNLP) shows the key components of the preprocessing steps
    for NLP. These are tokenization, stop words removal, stemming, lemmatization,
    PoS (part-of-speech) tagging, and NER (Name Entity Recognition).
  prefs: []
  type: TYPE_NORMAL
- en: 1.1\. Tokenization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Tokenization* is the task of splitting a text into meaningful segments, called
    tokens. These segments could be words, punctuation, numbers, or other special
    characters that are the building blocks of a sentence. A set of predetermined
    rules allows us to effectively convert a sentence into a list of tokens. The following
    code snippets show sample word tokenization using the NLTK and TextBlob packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The NLTK data package includes a pretrained `Punkt` tokenizer for English,
    which was previously loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at tokenization using TextBlob:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 1.2\. Stop words removal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At times, extremely common words that offer little value in modeling are excluded
    from the vocabulary. These words are called stop words. The code for removing
    stop words using the NLTK library is shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We first load the language model and store it in the stop words variable. The
    `stopwords.words('english')` is a set of default stop words for the English language
    model in NLTK. Next, we simply iterate through each word in the input text, and
    if the word exists in the stop word set of the NLTK language model, the word is
    removed. As we can see, stop words, such as *are* and *most*, are removed from
    the sentence.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3\. Stemming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Stemming* is the process of reducing inflected (or sometimes derived) words
    to their stem, base, or root form (generally a written word form). For example,
    if we were to stem the words *Stems*, *Stemming*, *Stemmed*, and *Stemitization*,
    the result would be a single word: *Stem*. The code for stemming using the NLTK
    library is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 1.4\. Lemmatization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A slight variant of stemming is *lemmatization*. The major difference between
    the two processes is that stemming can often create nonexistent words, whereas
    lemmas are actual words. An example of lemmatization is *run* as a base form for
    words like *running* and *ran*, or that the words *better* and *good* are considered
    the same lemma. The code for lemmatization using the TextBlob library is shown
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 1.5\. PoS tagging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Part-of-speech (PoS) tagging* is the process of assigning a token to its grammatical
    category (e.g., verb, noun, etc.) in order to understand its role within a sentence.
    PoS tags have been used for a variety of NLP tasks and are extremely useful since
    they provide a linguistic signal of how a word is being used within the scope
    of a phrase, sentence, or document.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After a sentence is split into tokens, a tagger, or PoS tagger, is used to
    assign each token to a part-of-speech category. Historically, [hidden Markov models
    (HMM)](https://oreil.ly/OpuRm) were used to create such taggers. More recently,
    artificial neural networks have been leveraged. The code for PoS tagging using
    the TextBlob library is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 1.6\. Named entity recognition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Named entity recognition* (NER) is an optional next step in data preprocessing
    that seeks to locate and classify named entities in text into predefined categories.
    These categories can include names of persons, organizations, locations, expressions
    of times, quantities, monetary values, or percentages. The NER performed using
    spaCy is shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Visualizing named entities in text using the `displacy` module, as shown in
    [Figure 10-2](#NER), can also be incredibly helpful in speeding up development
    and debugging the code and training process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![mlbf 1002](Images/mlbf_1002.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-2\. NER output
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '1.7\. spaCy: All of the above steps in one go'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All the preprocessing steps shown above can be performed in one step using spaCy.
    When we call *nlp* on a text, spaCy first tokenizes the text to produce a *Doc*
    object. The *Doc* is then processed in several different steps. This is also referred
    to as the *processing pipeline*. The pipeline used by the default models consists
    of a *tagger*, a *parser*, and an *entity recognizer*. Each pipeline component
    returns the processed *Doc*, which is then passed on to the next component, as
    demonstrated in [Figure 10-3](#PreprocessingPipeline).
  prefs: []
  type: TYPE_NORMAL
- en: '![mlbf 1003](Images/mlbf_1003.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-3\. spaCy pipeline (based on an image from [the spaCy website](https://oreil.ly/ZhMlp).
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Token | is_stop_word | lemma | POS |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Google | False | Google | PROPN |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | is | True | be | VERB |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | looking | False | look | VERB |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | at | True | at | ADP |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | buying | False | buy | VERB |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | U.K. | False | U.K. | PROPN |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | startup | False | startup | NOUN |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | for | True | for | ADP |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | $ | False | $ | SYM |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | 1 | False | 1 | NUM |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | billion | False | billion | NUM |'
  prefs: []
  type: TYPE_TB
- en: The output for each of the preprocessing steps is shown in the preceding table.
    Given that spaCy performs a wide range of NLP-related tasks in a single step,
    it is a highly recommended package. As such, we will be using spaCy extensively
    in our case studies.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the above preprocessing steps, there are other frequently used
    preprocessing steps, such as *lower casing* or *nonalphanumeric data removing*,
    that we can perform depending on the type of data. For example, data scraped from
    a website has to be cleansed further, including the removal of HTML tags. Data
    from a PDF report must be converted into a text format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other optional preprocessing steps include dependency parsing, coreference
    resolution, triplet extraction, and relation extraction:'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency parsing
  prefs: []
  type: TYPE_NORMAL
- en: Assigns a syntactic structure to sentences to make sense of how the words in
    the sentence relate to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Coreference resolution
  prefs: []
  type: TYPE_NORMAL
- en: The process of connecting tokens that represent the same entity. It is common
    in languages to introduce a subject with their name in one sentence and then refer
    to them as him/her/it in subsequent sentences.
  prefs: []
  type: TYPE_NORMAL
- en: Triplet extraction
  prefs: []
  type: TYPE_NORMAL
- en: The process of recording subject, verb, and object triplets when available in
    the sentence structure.
  prefs: []
  type: TYPE_NORMAL
- en: Relation extraction
  prefs: []
  type: TYPE_NORMAL
- en: A broader form of triplet extraction in which entities can have multiple interactions.
  prefs: []
  type: TYPE_NORMAL
- en: These additional steps should be performed only if they will help with the task
    at hand. We will demonstrate examples of these preprocessing steps in the case
    studies in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Feature Representation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The vast majority of NLP-related data, such as news feed articles, PDF reports,
    social media posts, and audio files, is created for human consumption. As such,
    it is often stored in an unstructured format, which cannot be readily processed
    by computers. In order for the preprocessed information to be conveyed to the
    statistical inference algorithm, the tokens need to be translated into predictive
    features. A model is used to embed raw text into a *vector space*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feature representation involves two things:'
  prefs: []
  type: TYPE_NORMAL
- en: A vocabulary of known words.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A measure of the presence of known words.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of the feature representation methods are:'
  prefs: []
  type: TYPE_NORMAL
- en: Bag of words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TF-IDF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Word embedding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pretrained models (e.g., word2vec, [GloVe](https://oreil.ly/u9SZG), spaCy’s
    word embedding model)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Customized deep learning–based feature representation^([1](ch10.xhtml#idm45174899480680))
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s learn more about each of these methods.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1\. Bag of words—word count
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In natural language processing, a common technique for extracting features from
    text is to place all words that occur in the text in a bucket. This approach is
    called a *bag of words* model. It’s referred to as a bag of words because any
    information about the structure of the sentence is lost. In this technique, we
    build a single matrix from a collection of texts, as shown in [Figure 10-4](#BagOfWords),
    in which each row represents a token and each column represents a document or
    sentence in our corpus. The values of the matrix represent the count of the number
    of instances of the token appearing.
  prefs: []
  type: TYPE_NORMAL
- en: '![mlbf 1004](Images/mlbf_1004.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-4\. Bag of words
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The `CountVectorizer` from sklearn provides a simple way to both tokenize a
    collection of text documents and encode new documents using that vocabulary. The
    `fit_transform` function learns the vocabulary from one or more documents and
    encodes each document in the word as a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We can see an array version of the encoded vector showing a count of one occurrence
    for each word except *the* (index 10), which has an occurrence of two. Word counts
    are a good starting point, but they are very basic. One issue with simple counts
    is that some words like *the* will appear many times, and their large counts will
    not be very meaningful in the encoded vectors. These bag of words representations
    are sparse because the vocabularies are vast, and a given word or document would
    be represented by a large vector comprised mostly of zero values.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2\. TF-IDF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An alternative is to calculate word frequencies, and by far the most popular
    method for that is *TF-IDF*, which stands for *Term Frequency–Inverse Document
    Frequency*:'
  prefs: []
  type: TYPE_NORMAL
- en: Term Frequency
  prefs: []
  type: TYPE_NORMAL
- en: This summarizes how often a given word appears within a document.
  prefs: []
  type: TYPE_NORMAL
- en: Inverse Document Frequency
  prefs: []
  type: TYPE_NORMAL
- en: This downscales words that appear a lot across documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put simply, TF-IDF is a word frequency score that tries to highlight words
    that are more interesting (i.e., frequent *within* a document, but not *across*
    documents). The *TfidfVectorizer* will tokenize documents, learn the vocabulary
    and the inverse document frequency weightings, and allow you to encode new documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the provided code snippet, a vocabulary of nine words is learned from the
    documents. Each word is assigned a unique integer index in the output vector.
    The sentences are encoded as a nine-element sparse array, and we can review the
    final scorings of each word with different values from the other words in the
    vocabulary.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3\. Word embedding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *word embedding* represents words and documents using a dense vector representation.
    In an embedding, words are represented by dense vectors in which a vector represents
    the projection of the word into a continuous vector space. The position of a word
    within the vector space is learned from text and is based on the words that surround
    the word when it is used. The position of a word in the learned vector space is
    referred to as its *embedding*.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the models of learning word embeddings from text include word2Vec, spaCy’s
    pretrained word embedding model, and GloVe. In addition to these carefully designed
    methods, a word embedding can be learned as part of a deep learning model. This
    can be a slower approach, but it tailors the model to a specific training dataset.
  prefs: []
  type: TYPE_NORMAL
- en: '2.3.1\. Pretrained model: Via spaCy'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: spaCy comes with built-in representation of text as vectors at different levels
    of word, sentence, and document. The underlying vector representations come from
    a word embedding model, which generally produces a dense, multidimensional semantic
    representation of words (as shown in the following example). The word embedding
    model includes 20,000 unique vectors with 300 dimensions. Using this vector representation,
    we can calculate similarities and dissimilarities between tokens, named entities,
    noun phrases, sentences, and documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The word embedding in spaCy is performed by first loading the model and then
    processing text. The vectors can be accessed directly using the `.vector` attribute
    of each processed token (i.e., word). The mean vector for the entire sentence
    is also calculated simply by using the vector, providing a very convenient input
    for machine learning models based on sentences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`Output:\`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The vector representation of the sentence for the first 10 features of the pretrained
    model is shown in the output.
  prefs: []
  type: TYPE_NORMAL
- en: '2.3.2\. Pretrained model: Word2Vec using gensim package'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Python-based implementation of the word2vec model using the [gensim package](https://oreil.ly/p9hOJ)
    is demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The vector representation of the sentence for the first five features of the
    pretrained word2vec model is shown above.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Inference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with other artificial intelligence tasks, an inference generated by an NLP
    application usually needs to be translated into a decision in order to be actionable.
    Inference falls under three machine learning categories covered in the previous
    chapters (i.e., supervised, unsupervised, and reinforcement learning). While the
    type of inference required depends on the business problem and the type of training
    data, the most commonly used algorithms are supervised and unsupervised.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most frequently used supervised methodologies in NLP is the *Naive
    Bayes* model, as it can produce reasonable accuracy using simple assumptions.
    A more complex supervised methodology is using artificial neural network architectures.
    In past years, these architectures, such as recurrent neural networks (RNNs),
    have dominated NLP-based inference.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the existing literature in NLP focuses on supervised learning. As such,
    unsupervised learning applications constitute a relatively less developed subdomain
    in which measuring *document similarity* is among the most common tasks. A popular
    unsupervised technique applied in NLP is *Latent Semantic Analysis* (LSA). LSA
    looks at relationships between a set of documents and the words they contain by
    producing a set of latent concepts related to the documents and terms. LSA has
    paved the way for a more sophisticated approach called *Latent Dirichlet Allocation*
    (LDA), under which documents are modeled as a finite mixture of topics. These
    topics in turn are modeled as a finite mixture over words in the vocabulary. LDA
    has been extensively used for *topic modeling*—a growing area of research in which
    NLP practitioners build probabilistic generative models to reveal likely topic
    attributions for words.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have reviewed many supervised and unsupervised learning models in the
    previous chapters, we will provide details only on Naive Bayes and LDA models
    in the next sections. These are used extensively in NLP and were not covered in
    the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1\. Supervised learning example—Naive Bayes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Naive Bayes is a family of algorithms based on applying [*Bayes’s theorem*](https://oreil.ly/bVeZK)
    with a strong (naive) assumption that every feature used to predict the category
    of a given sample is independent of the others. They are probabilistic classifiers
    and therefore will calculate the probability of each category using Bayes’s theorem.
    The category with the highest probability will be output.
  prefs: []
  type: TYPE_NORMAL
- en: In NLP, a Naive Bayes approach assumes that all word features are independent
    of each other given the class labels. Due to this simplifying assumption, Naive
    Bayes is very compatible with a bag-of-words word representation, and it has been
    demonstrated to be fast, reliable, and accurate in a number of NLP applications.
    Moreover, despite its simplifying assumptions, it is competitive with (and at
    times even outperforms) more complicated classifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at the usage of Naive Bayes for the inference in a sentiment analysis
    problem. We take a dataframe in which there are two sentences with sentiments
    assigned to each. In the next step, we convert the sentences into a feature representation
    using `CountVectorizer`. The features and sentiments are used to train and test
    the model using Naive Bayes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the Naive Bayes trains the model fairly well from the two sentences.
    The model gives a sentiment of zero and one for the test sentences “Apple price
    plunge” and “Amazon price jumps,” respectively, given the sentences used for training
    also had the keywords “plunge” and “jumps,” with corresponding sentiment assignments.
  prefs: []
  type: TYPE_NORMAL
- en: '3.2\. Unsupervised learning example: LDA'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'LDA is extensively used for *topic modeling* because it tends to produce meaningful
    topics that humans can interpret, assigns topics to new documents, and is extensible.
    It works by first making a key assumption: documents are generated by first selecting
    *topics*, and then, for each topic, a set of *words*. The algorithm then reverse
    engineers this process to find the topics in a document.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, we show an implementation of LDA for topic modeling.
    We take two sentences and convert the sentences into a feature representation
    using `CountVectorizer`. These features and the sentiments are used to train the
    model and produce two smaller matrices representing the topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We will be using LDA for topic modeling in the third case study of this chapter
    and will discuss the concepts and interpretation in detail.
  prefs: []
  type: TYPE_NORMAL
- en: To review, in order to approach any NLP-based problem, we need to follow the
    preprocessing, feature extraction, and inference steps. Now, let’s dive into the
    case studies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case Study 1: NLP and Sentiment Analysis–Based Trading Strategies'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Natural language processing offers the ability to quantify text. One can begin
    to ask questions such as: How positive or negative is this news? and How can we
    quantify words?'
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the most notable application of NLP is its use in algorithmic trading.
    NLP provides an efficient means of monitoring market sentiments. By applying NLP-based
    sentiment analysis techniques to news articles, reports, social media, or other
    web content, one can effectively determine whether those sources have a positive
    or negative senitment score. Sentiment scores can be used as a directional signal
    to buy stocks with positive scores and sell stocks with negative ones.
  prefs: []
  type: TYPE_NORMAL
- en: Trading strategies based on text data are becoming more popular as the amount
    of unstructured data increases. In this case study we are going to look at how
    one can use NLP-based sentiments to build a trading strategy.
  prefs: []
  type: TYPE_NORMAL
- en: This case study combines concepts presented in previous chapters. The overall
    model development steps of this case study are similar to the seven-step model
    development in prior case studies, with slight modifications.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/bracket_top.png)'
  prefs: []
  type: TYPE_IMG
- en: Blueprint for Building a Trading Strategy Based on Sentiment Analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 1\. Problem definition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our goal is to (1) use NLP to extract information from news headlines, (2) assign
    a sentiment to that information, and (3) use sentiment analysis to build a trading
    strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data used for this case study will be from the following sources:'
  prefs: []
  type: TYPE_NORMAL
- en: News headlines data compiled from the RSS feeds of several news websites
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of this study, we will look only at the headlines, not at the
    full text of the stories. Our dataset contains around 82,000 headlines from May
    2011 through December 2018.^([2](ch10.xhtml#idm45174898988232))
  prefs: []
  type: TYPE_NORMAL
- en: Yahoo Finance website for stock data
  prefs: []
  type: TYPE_NORMAL
- en: The return data for stocks used in this case study is derived from Yahoo Finance
    price data.
  prefs: []
  type: TYPE_NORMAL
- en: '[Kaggle](https://www.kaggle.com)'
  prefs: []
  type: TYPE_NORMAL
- en: We will use the labeled data of news sentiments for a classification-based sentiment
    analysis model. Note that this data may not be fully applicable to the case at
    hand and is used here for demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Stock market lexicon
  prefs: []
  type: TYPE_NORMAL
- en: '*Lexicon* refers to the component of an NLP system that contains information
    (semantic, grammatical) about individual words or word strings. This is created
    based on stock market conversations in microblogging services.^([3](ch10.xhtml#idm45174898982312))'
  prefs: []
  type: TYPE_NORMAL
- en: The key steps of this case study are outlined in [Figure 10-5](#StepsSentimentTrading).
  prefs: []
  type: TYPE_NORMAL
- en: '![mlbf 1005](Images/mlbf_1005.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-5\. Steps in a sentiment analysis–based trading strategy
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Once we are done with preprocessing, we will look at the different sentiment
    analysis models. The results from the sentiment analysis step are used to develop
    the trading strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Getting started—loading the data and Python packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 2.1\. Loading the Python packages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first set of libraries to be loaded are the NLP-specific libraries discussed
    above. Refer to the Jupyter notebook of this case study for details of the other
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 2.2\. Loading the data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this step, we load the stock price data from Yahoo Finance. We select 10
    stocks for this case study. These stocks are some of the largest stocks in the
    S&P 500 by market share:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![mlbf 10in01](Images/mlbf_10in01.png)'
  prefs: []
  type: TYPE_IMG
- en: The data contains the price and volume data of the stocks along with their ticker
    name. In the next step, we look at the news data.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Data preparation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this step, we load and preprocess the news data, followed by combining the
    news data with the stock return data. This combined dataset will be used for the
    model development.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1\. Preprocessing news data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The news data is downloaded from the News RSS feed, and the file is available
    in JSON format. The JSON files for different dates are kept under a zipped folder.
    The data is downloaded using the standard web-scraping Python package Beautiful
    Soup, which is an open source framework. Let us look at the content of the downloaded
    JSON file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the JSON format is not suitable for the algorithm. We need
    to get the news from the JSONs. Regex becomes the vital part of this step. Regex
    can find a pattern in the raw, messy text and perform actions accordingly. The
    following function parses HTML by using information encoded in the JSON file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us see how the output looks like after running the JSON parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the output is converted into a more readable format after JSON
    parsing.
  prefs: []
  type: TYPE_NORMAL
- en: 'While evaluating the sentiment analysis models, we also analyze the relationship
    between the sentiments and subsequent stock performance. In order to understand
    the relationship, we use *event return*, which is the return that corresponds
    to the event. We do this because at times the news is reported late (i.e., after
    market participants are aware of the announcement) or after market close. Having
    a slightly wider window ensures that we capture the essence of the event. *Event
    return* is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: <math><mrow><msub><mi>R</mi> <mrow><mi>t</mi><mo>–</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>R</mi> <mi>t</mi></msub> <mo>+</mo> <msub><mi>R</mi> <mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: where <math display="inline"><mrow><msub><mi>R</mi> <mrow><mi>t</mi><mo>–</mo><mn>1</mn></mrow></msub>
    <mo>,</mo> <msub><mi>R</mi> <mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></math>
    are the returns before and after the news data, and <math alttext="upper R Subscript
    t"><msub><mi>R</mi> <mi>t</mi></msub></math> is the return on the day of the news
    (i.e., time *t*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us extract the event return from the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have all the data in place. We will prepare a combined dataframe, which
    will have the news headlines mapped to the date, the returns (event return, current
    return, and next day’s return), and stock ticker. This dataframe will be used
    for building the sentiment analysis model and the trading strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | ticker | headline | date | eventRet | Close |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | AMZN | Whole Foods (WFMI) –5.2% following a downgrade… | 2011-05-02 |
    0.017650 | 201.19 |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | NFLX | Netflix (NFLX +1.1%) shares post early gains a… | 2011-05-02
    | –0.013003 | 33.88 |'
  prefs: []
  type: TYPE_TB
- en: 'Let us look at the overall shape of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In this step, we prepared a clean dataframe that has ticker, headline, event
    return, return for a given day, and future return for 10 stock tickers, totaling
    2,759 rows of data. Let us evaluate the models for sentiment analysis in the next
    step.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Evaluate models for sentiment analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will go through the following three approaches of computing
    sentiments for the news:'
  prefs: []
  type: TYPE_NORMAL
- en: Predefined model—TextBlob package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuned model—classification algorithms and LSTM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model based on financial lexicon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us go through the steps.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1\. Predefined model—TextBlob package
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `TextBlob sentiment` function is a pretrained model based on the Naive
    Bayes classification algorithm. The function maps adjectives that are frequently
    found in movie reviews^([4](ch10.xhtml#idm45174898012728)) to sentiment polarity
    scores ranging from –1 to +1 (negative to positive), converting a sentence to
    a numerical value. We apply this on all headline articles. An example of getting
    the sentiment for a news text is shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The sentiment for the statement is 0.5\. We apply this on all headlines we
    have in the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Let us inspect the scatterplot of the sentiments and returns to examine the
    correlation between the two for all 10 stocks.
  prefs: []
  type: TYPE_NORMAL
- en: '![mlbf 1006](Images/mlbf_1006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A plot for a single stock (APPL) is also shown in the following chart (see
    the code in the Jupyter notebook in the GitHub repository for this book for more
    details on the code):'
  prefs: []
  type: TYPE_NORMAL
- en: '![mlbf 10in03](Images/mlbf_10in03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the scatterplots, we can see that there is not a strong relationship between
    the news and the sentiments. The correlation between return and sentiments is
    positive (4.27%), which means that news with positive sentiments leads to positive
    return and is expected. However, the correlation is not very high. Even looking
    at the overall scatterplot, we see the majority of the sentiments concentrated
    around zero. This raises the question of whether a sentiment score trained on
    movie reviews is appropriate for stock prices. The `sentiment_assessments` attribute
    lists the underlying values for each token and can help us understand the reason
    for the overall sentiment of a sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We see that the statement has a positive sentiment of 0.5, but it appears the
    word “touching” gave rise to the positive sentiment. More intuitive words, such
    as “high,” do not. This example shows that the context of the training data is
    important for the sentiment score to be meaningful. There are many predefined
    packages and functions available for sentiment analysis, but it is important to
    be careful and have a thorough understanding of the problem’s context before using
    a function or an algorithm for sentiment analysis.
  prefs: []
  type: TYPE_NORMAL
- en: For this case study, we may need sentiments trained on the financial news. Let
    us take a look at that in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2\. Supervised learning—classification algorithms and LSTM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this step, we develop a customized model for sentiment analysis based on
    available labeled data. The label data for this is obtained from the [Kaggle website](https://www.kaggle.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | datetime | headline | ticker | sentiment |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1/16/2020 5:25 | $MMM fell on hard times but could be set to re… | MMM
    | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1/11/2020 6:43 | Wolfe Research Upgrades 3M $MMM to ¡§Peer Perf… | MMM
    | 1 |'
  prefs: []
  type: TYPE_TB
- en: The data has headlines for the news across 30 different stocks, totaling 9,470
    rows, and has sentiments labeled zero and one. We perform the classification steps
    using the classification model development template presented in [Chapter 6](ch06.xhtml#Chapter6).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to run a supervised learning model, we first need to convert the news
    headlines into a feature representation. For this exercise, the underlying vector
    representations come from a *spaCy word embedding model*, which generally produces
    a dense, multidimensional semantic representation of words (as shown in the example
    below). The word embedding model includes 20,000 unique vectors with 300 dimensions.
    We apply this on all headlines in the data processed in the previous step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have prepared the independent variable, we train the classification
    model in a similar manner as discussed in [Chapter 6](ch06.xhtml#Chapter6). We
    have the sentiments label zero or one as the dependent variable. We first divide
    the data into training and test sets and run the key classification models (i.e.,
    logistic regression, CART, SVM, random forest, and artificial neural network).
  prefs: []
  type: TYPE_NORMAL
- en: We will also include LSTM, which is an RNN-based model,^([5](ch10.xhtml#idm45174897768808))
    in the list of models considered. An RNN-based model performs well for NLP, because
    it stores the information for current features as well neighboring ones for prediction.
    It maintains a memory based on past information, which enables the model to predict
    the current output conditioned on long distance features and looks at the words
    in the context of the entire sentence, rather than simply looking at the individual
    words.
  prefs: []
  type: TYPE_NORMAL
- en: 'For us to be able to feed the data into our LSTM model, all input documents
    must have the same length. We use the Keras `tokenizer` function to tokenize the
    strings and then use `texts_to_sequences` to make sequences of words. More details
    can be found on the [Keras website](https://oreil.ly/2YS-P). We will limit the
    maximum review length to *max_words* by truncating longer reviews and pad shorter
    reviews with a null value (0). We can accomplish this using the `pad_sequences`
    function, also in Keras. The third parameter is the *input_length* (set to 50),
    which is the length of each comment sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code snippet, we use the Keras library to build an artificial
    neural network classifier based on an underlying LSTM model. The network starts
    with an *embedding* layer. This layer lets the system expand each token to a larger
    vector, allowing the network to represent a word in a meaningful way. The layer
    takes 20,000 as the first argument (i.e., the size of our vocabulary) and 300
    as the second input parameter (i.e., the dimension of the embedding). Finally,
    given that this is a classification problem and the output needs to be labeled
    as zero or one, the `KerasClassifier` function is used as a wrapper over the LSTM
    model to produce a binary (zero or one) output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The comparison of all the machine learning models is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![mlbf 10in04](Images/mlbf_10in04.png)'
  prefs: []
  type: TYPE_IMG
- en: As expected, the LSTM model has the best performance in the test set (accuracy
    of 96.7%) as compared to all other models. The performance of the ANN, with a
    training set accuracy of 99% and a test set accuracy of 93.8%, is comparable to
    the LSTM-based model. The performances of random forest (RF), SVM, and logistic
    regression (LR) are reasonable as well. CART and KNN do not perform as well as
    other models. CART shows high overfitting. Let us use the LSTM model for the computation
    of the sentiments in the data in the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3\. Unsupervised—model based on a financial lexicon
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this case study, we update the VADER lexicon with words and sentiments from
    a lexicon adapted to stock market conversations in microblogging services:'
  prefs: []
  type: TYPE_NORMAL
- en: Lexicons
  prefs: []
  type: TYPE_NORMAL
- en: 'Special dictionaries or vocabularies that have been created for analyzing sentiments.
    Most lexicons have a list of positive and negative *polar* words with some score
    associated with them. Using various techniques, such as the position of words,
    the surrounding words, context, parts of speech, and phrases, scores are assigned
    to the text documents for which we want to compute the sentiment. After aggregating
    these scores, we get the final sentiment:'
  prefs: []
  type: TYPE_NORMAL
- en: VADER (Valence Aware Dictionary for Sentiment Reasoning)
  prefs: []
  type: TYPE_NORMAL
- en: A prebuilt sentiment analysis model included in the NLTK package. It can give
    both positive and negative polarity scores as well as the strength of the emotion
    of a text sample. It is rule-based and relies heavily on human-rated texts. These
    are words or any textual form of communication labeled according to their semantic
    orientation as either positive or negative.
  prefs: []
  type: TYPE_NORMAL
- en: 'This lexical resource was automatically created using diverse statistical measures
    and a large set of labeled messages from StockTwits, which is a social media platform
    designed for sharing ideas among investors, traders, and entrepreneurs.^([6](ch10.xhtml#idm45174897534248))
    The sentiments are between –1 and 1, similar to the sentiments from TextBlob.
    In the following code snippet, we train the model based on the financial sentiments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us check the sentiment of a news item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the sentiments for all the news headlines based in our dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Let us look at the relationship between the returns and sentiments, which is
    computed using the lexicon-based methodology for the entire dataset.
  prefs: []
  type: TYPE_NORMAL
- en: '![mlbf 10in05](Images/mlbf_10in05.png)'
  prefs: []
  type: TYPE_IMG
- en: There are not many instances of high returns for lower sentiment scores, but
    the data may not be very clear. We will look deeper into the comparison of different
    types of sentiment analysis in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4\. Exploratory data analysis and comparison
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we compare the sentiments computed using the different techniques
    presented above. Let us look at the sample headlines and the sentiments from three
    different methodologies, followed by a visual analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | ticker | headline | sentiment_textblob | sentiment_LSTM | sentiment_lex
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 4620 | TSM | TSMC (TSM +1.8%) is trading higher after reporting its October
    sales rose 12.6% M/M. DigiTimes adds TSMC has seen a 20%+ jump in orders from
    QCOM, NVDA, SPRD, and Mediatek. The numbers suggest TSMC could beat its Q4 guidance
    (though December tends to be weak), and that chip demand could be stabilizing
    after getting hit hard by inventory corrections. (earlier) (UMC sales) | 0.036667
    | 1 | 0.5478 |'
  prefs: []
  type: TYPE_TB
- en: Looking at one of the headlines, the sentiment from this sentence is positive.
    However, the TextBlob sentiment result is smaller in magnitude, suggesting that
    the sentiment is more neutral. This points back to the previous assumption that
    the model trained on movie sentiments likely will not be accurate for stock sentiments.
    The classification-based model correctly suggests the sentiment is positive, but
    it is binary. `Sentiment_lex` has a more intuitive output with a significantly
    positive sentiment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us review the correlation of all the sentiments from different methodologies
    versus returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![mlbf 10in06](Images/mlbf_10in06.png)'
  prefs: []
  type: TYPE_IMG
- en: All sentiments have positive relationships with the returns, which is intuitive
    and expected. The sentiments from the lexicon methodology are highest, which means
    the stock’s event return can be predicted the best using the lexicon methodology.
    Recall that this methodology leverages financial terms in the model. The LSTM-based
    method also performs better than the TextBlob approach, but the performance is
    slightly worse compared to the lexicon-based methodology.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at the performance of the methodology at the ticker level. We chose
    a few tickers with the highest market cap for the analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![mlbf 10in07](Images/mlbf_10in07.png)'
  prefs: []
  type: TYPE_IMG
- en: Looking at the chart, the correlation from the lexicon methodology is highest
    across all stock tickers, which corroborates the conclusion from the previous
    analysis. It means the returns can be predicted the best using the lexicon methodology.
    The TextBlob-based sentiments show unintuitive results in some cases, such as
    with JPM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at the scatterplot for lexicon versus TextBlob methodologies for
    AMZN and GOOG. We will set the LSTM-based method aside since the binary sentiments
    will not be meaningful in the scatterplot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![mlbf 10in08](Images/mlbf_10in08.png)![mlbf 10in09](Images/mlbf_10in09.png)'
  prefs: []
  type: TYPE_IMG
- en: The lexicon-based sentiments on the left show a positive relationship between
    the sentiments and returns. Some of the points with the highest returns are associated
    with the most positive news. Also, the scatterplot is more uniformly distributed
    in the case of lexicon as compared to TextBlob. The sentiments for TextBlob are
    concentrated around zero, probably because the model is not able to categorize
    financial sentiments well. For the trading strategy, we will be using the lexicon-based
    sentiments, as these are the most appropriate based on the analysis in this section.
    The LSTM-based sentiments are good as well, but they are labeled either zero or
    one. The more granular lexicon-based sentiments are preferred.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Models evaluation—building a trading strategy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sentiment data can be used in several ways for building a trading strategy.
    The sentiments can be used as a stand-alone signal to decide buy, sell, or hold
    actions. The sentiment score or the word vectors can also be used to predict the
    return or price of a stock. That prediction can be used to build a trading strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we demonstrate a trading strategy in which we buy or sell
    a stock based on the following approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Buy a stock when the change in sentiment score (current sentiment score/previous
    sentiment score) is greater than 0.5\. Sell a stock when the change in sentiment
    score is less than –0.5\. The sentiment score used here is based on the lexicon-based
    sentiments computed in the previous step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the sentiments, we use moving average (based on the last 15 days)
    while making a buy or sell decision.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trades (i.e., buy or sell) are in 100 shares. The initial amount available for
    trading is set to $100,000.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The strategy threshold, the lot size, and the initial capital can be tweaked
    depending on the performance of the strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1\. Setting up a strategy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set up the trading strategy, we use *backtrader*, which is a convenient Python-based
    framework for implementing and backtesting trading strategies. Backtrader allows
    us to write reusable trading strategies, indicators, and analyzers instead of
    having to spend time building infrastructure. We use the [Quickstart code in the
    backtrader documentation](https://oreil.ly/lyYs4) as a base and adapt it to our
    sentiment-based trading strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet summarizes the buy and sell logic for the strategy.
    Refer to the Jupyter notebook of this case study for the detailed implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 5.2\. Results for individual stocks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, we run our strategy on GOOG and look at the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows the trading log for some of the days and the final return:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We analyze the backtesting result in the following plot produced by the backtrader
    package. Refer to the Jupyter notebook of this case study for the detailed version
    of this chart.
  prefs: []
  type: TYPE_NORMAL
- en: '![mlbf 10in10](Images/mlbf_10in10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The results show an overall profit of $49,719\. The chart is a typical chart^([7](ch10.xhtml#idm45174897105944))
    produced by the backtrader package and is divided into four panels:'
  prefs: []
  type: TYPE_NORMAL
- en: Top panel
  prefs: []
  type: TYPE_NORMAL
- en: The top panel is the *cash value observer*. It keeps track of the cash and the
    total portolio value during the life of the backtesting run. In this run, we started
    with $100,000 and ended with $149,719.
  prefs: []
  type: TYPE_NORMAL
- en: Second panel
  prefs: []
  type: TYPE_NORMAL
- en: This panel is the *trade observer*. It shows the realized profit/loss of each
    trade. A trade is defined as opening a position and taking the position back to
    zero (directly or crossing over from long to short or short to long). Looking
    at this panel, five out of eight trades are profitable for the strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Third panel
  prefs: []
  type: TYPE_NORMAL
- en: This panel is *buy sell observer*. It indicates where buy and sell operations
    have taken place. In general, we see that the buy action takes place when the
    stock price is increasing, and the sell action takes place when the stock price
    has started declining.
  prefs: []
  type: TYPE_NORMAL
- en: Bottom panel
  prefs: []
  type: TYPE_NORMAL
- en: This panel shows the sentiment score, varying between –1 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we choose one of the days (2015-07-17) when a buy action was triggered
    and analyze the news for Google on that and the previous day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, the news on the selected day mentions the upgrade of Google, a piece
    of positive news. The previous day mentions the revenue missing estimates, which
    is negative news. Hence, there was a significant change of the news sentiment
    on the selected day, resulting in a buy action triggered by the trading algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we run the strategy for FB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '![mlbf 10in12](Images/mlbf_10in12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The details of the backtesting results of the strategy are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Top panel
  prefs: []
  type: TYPE_NORMAL
- en: The cash value panel shows an overall profit of $8,041.
  prefs: []
  type: TYPE_NORMAL
- en: Second panel
  prefs: []
  type: TYPE_NORMAL
- en: The trade observer panel shows that six out of seven actions were profitable.
  prefs: []
  type: TYPE_NORMAL
- en: Third panel
  prefs: []
  type: TYPE_NORMAL
- en: The buy/sell observer shows that in general the buy (sell) action took place
    when the stock price was increasing (decreasing).
  prefs: []
  type: TYPE_NORMAL
- en: Bottom panel
  prefs: []
  type: TYPE_NORMAL
- en: It shows a high number of positive sentiments for FB around the 2013–2014 period.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3\. Results for multiple stocks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the previous step, we executed the trading strategy on individual stocks.
    Here, we run it on all 10 stocks for which we computed the sentiments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '![mlbf 10in13](Images/mlbf_10in13.png)'
  prefs: []
  type: TYPE_IMG
- en: The strategy performs quite well and yields an overall profit for all the stocks.
    As mentioned before, the buy and sell actions are performed in a lot size of 100\.
    Hence, the dollar amount used is proportional to the stock price. We see the highest
    nominal profit from AMZN and GOOG, which is primarily attributed to the high dollar
    amounts invested for these stocks given their high stock price. Other than overall
    profit, several other metrics, such as Sharpe ratio and maximum drawdown, can
    be used to analyze the performance.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4\. Varying the strategy time period
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous analysis, we used the time period from 2011 to 2018 for our
    backtesting. In this step, to further analyze the effectiveness of our strategy,
    we vary the time period of the backtesting and analyze the results. First, we
    run the strategy for all the stocks for the time period between 2012 and 2014:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '![mlbf 10in14](Images/mlbf_10in14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The strategy yields an overall profit for all the stocks except AMZN and WMT.
    Now we run the strategy between 2016 and 2018:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '![mlbf 10in15](Images/mlbf_10in15.png)'
  prefs: []
  type: TYPE_IMG
- en: We see a good performance of the sentiment-based strategy across all the stocks
    except AAPL, and we can conclude that it performs quite well on different time
    periods. The strategy can be adjusted by modifying the trading rules or lot sizes.
    Additional metrics can also be used to understand the performance of the strategy.
    The sentiments can also be used along with the other features, such as correlated
    variables and technical indicators for prediction.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case study, we looked at various ways in which unstructured data can
    be converted to structured data and then used for analysis and prediction using
    tools for NLP. We have demonstrated three different approaches, including deep
    learning models to develop a model for computing the sentiments. We performed
    a comparison of the models and concluded that one of the most important steps
    in training the model for sentiment analysis is using a domain-specific vocabulary.
  prefs: []
  type: TYPE_NORMAL
- en: We also used a pretrained English model by spaCy to convert a sentence into
    sentiments and used the sentiments as signals to develop a trading strategy. The
    initial results suggested that the model trained on a financial lexicon–based
    sentiment could prove to be a viable model for a trading strategy. Additional
    improvements to this can be made by using more complex pretrained sentiment analysis
    models, such as BERT by Google, or different pretrained NLP models available in
    open source platforms. Existing NLP libraries fill in some of the preprocessing
    and encoding steps to allow us to focus on the inference step.
  prefs: []
  type: TYPE_NORMAL
- en: We could build on the trading strategy by including more correlated variables,
    technical indicators, or even improved sentiment analysis by using more sophisticated
    preprocessing steps and models based on more relevant financial text data.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/bracket_bottom.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Case Study 2: Chatbot Digital Assistant'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Chatbots* are computer programs that maintain a conversation with a user in
    natural language. They can understand the user’s intent and send responses based
    on an organization’s business rules and data. These chatbots use deep learning
    and NLP to process language, enabling them to understand human speech.'
  prefs: []
  type: TYPE_NORMAL
- en: Chatbots are increasingly being implemented across many domains for financial
    services. Banking bots enable consumers to check their balance, transfer money,
    pay bills, and more. Brokering bots enable consumers to find investment options,
    make investments, and track balances. Customer support bots provide instant responses,
    dramatically increasing customer satisfaction. News bots deliver personalized
    current events information, while enterprise bots enable employees to check leave
    balance, file expenses, check their inventory balance, and approve transactions.
    In addition to automating the process of assisting customers and employees, chatbots
    can help financial institutions gain information about their customers. The bot
    phenomenon has the potential to cause broad disruption in many areas within the
    finance sector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the way bots are programmed, we can categorize chatbots into two
    variants:'
  prefs: []
  type: TYPE_NORMAL
- en: Rule-based
  prefs: []
  type: TYPE_NORMAL
- en: This variety of chatbots is trained according to rules. These chatbots do not
    learn through interactions and may sometimes fail to answer complex queries outside
    of the defined rules.
  prefs: []
  type: TYPE_NORMAL
- en: Self-learning
  prefs: []
  type: TYPE_NORMAL
- en: 'This variety of bots relies on ML and AI technologies to converse with users.
    Self-learning chatbots are further divided into *retrieval-based* and *generative*:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieval-based
  prefs: []
  type: TYPE_NORMAL
- en: These chatbot are trained to rank the best response from a finite set of predefined
    responses.
  prefs: []
  type: TYPE_NORMAL
- en: Generative
  prefs: []
  type: TYPE_NORMAL
- en: These chatbots are not built with predefined responses. Instead, they are trained
    using a large number of previous conversations. They require a very large amount
    of conversational data to train.
  prefs: []
  type: TYPE_NORMAL
- en: In this case study, we will prototype a self-learning chatbot that can answer
    financial questions.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/bracket_top.png)'
  prefs: []
  type: TYPE_IMG
- en: Blueprint for Creating a Custom Chatbot Using NLP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 1\. Problem definition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The goal of this case study is to build a basic prototype of a conversational
    chatbot powered by NLP. The primary purpose of this chatbot is to help a user
    retrieve a financial ratio about a particular company. Such chatbots are designed
    to quickly retrieve the details about a stock or an instrument that may help the
    user make a trading decision.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to retrieving a financial ratio, the chatbot could also engage in
    casual conversations with a user, perform basic mathematical calculations, and
    provide answers to questions from a list used to train it. We intend to use Python
    packages and functions for chatbot creation and to customize several components
    of the chatbot architecture to adapt to our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The chatbot prototype created in this case study is designed to understand user
    inputs and intention and retrieve the information they are seeking. It is a small
    prototype that could be enhanced for use as an information retrieval bot in banking,
    brokering, or customer support.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Getting started—loading the libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this case study, we will use two text-based libraries: spaCy and [ChatterBot](https://oreil.ly/_1DPE).
    spaCy has been previously introduced; ChatterBot is a Python library used to create
    simple chatbots with minimal programming required.'
  prefs: []
  type: TYPE_NORMAL
- en: An untrained instance of ChatterBot starts off with no knowledge of how to communicate.
    Each time a user enters a statement, the library saves the input and response
    text. As ChatterBot receives more inputs, the number of responses it can offer
    and the accuracy of those responses increase. The program selects the response
    by searching for the closest matching known statement to the input. It then returns
    the most likely response to that statement based on how frequently each response
    is issued by the people the bot communicates with.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1\. Load libraries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We import spaCy using the following Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The ChatterBot library has the modules `LogicAdapter`, `ChatterBotCorpusTrainer`,
    and `ListTrainer`. These modules are used by our bot in order to construct responses
    to user queries. We begin by importing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Other libraries used in this exercise are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Before we move to the customized chatbot, let us develop a chatbot using the
    default features of the ChatterBot package.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Training a default chatbot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ChatterBot and many other chatbot packages come with a data utility module
    that can be used to train chatbots. Here are the ChatterBot components we will
    be using:'
  prefs: []
  type: TYPE_NORMAL
- en: Logic adapters
  prefs: []
  type: TYPE_NORMAL
- en: 'Logic adapters determine the logic for how ChatterBot selects a response to
    a given input statement. It is possible to enter any number of logic adapters
    for your bot to use. In the example below, we are using two inbuilt adapters:
    *BestMatch*, which returns the best known responses, and *MathematicalEvaluation*,
    which performs mathematical operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Preprocessors
  prefs: []
  type: TYPE_NORMAL
- en: ChatterBot’s preprocessors are simple functions that modify the input statement
    a chatbot receives before the statement gets processed by the logic adapter. The
    preprocessors can be customized to perform different preprocessing steps, such
    as tokenization and lemmatization, in order to have clean and processed data.
    In the example below, the default preprocessor for cleaning white spaces, `clean_whitespace`,
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: Corpus training
  prefs: []
  type: TYPE_NORMAL
- en: ChatterBot comes with a corpus data and utility module that makes it easy to
    quickly train the bot to communicate. We use the already existing corpuses *english,
    english.greetings*, and *english.conversations* for training the chatbot.
  prefs: []
  type: TYPE_NORMAL
- en: List training
  prefs: []
  type: TYPE_NORMAL
- en: Just like the corpus training, we train the chatbot with the conversations that
    can be used for training using *ListTrainer*. In the example below, we have trained
    the chatbot using some sample commands. The chatbot can be trained using a significant
    amount of conversation data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the chatbot is trained, we can test the trained chatbot by having the
    following conversation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we see a chatbot that gives an intuitive reply in response
    to the input. The first two responses are due to the training on the English greetings
    and English conversation corpuses. Additionally, the responses to *Tell me a joke*
    and *what is a dollar* are due to the training on the English corpus. The computation
    in the fourth line is the result of the chatbot being trained on the `MathematicalEvaluation`
    logical adapter. The responses to *Help!* and *What is Bitcoin?* are the result
    of the customized list trainers. Additionally, we see two different replies to
    *What is Bitcoin?*, given that we trained it using the list trainers.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we move on to creating a chatbot designed to use a customized logical
    adapter to give financial ratios.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Data preparation: Customized chatbot'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We want our chatbot to be able to recognize and group subtly different inquiries.
    For example, one might want to ask about the company *Apple Inc.* by simply referring
    to it as *Apple*, and we would want to map it to a ticker—*AAPL*, in this case.
    Constructing commonly used phrases in order to refer to firms can be built by
    using a dictionary as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we want to build a map for financial ratios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The keys of this dictionary can be used to map to an internal system or API.
    Finally, we want the user to be able to request the phrase in multiple formats.
    Saying *Get me the [RATIO] for [COMPANY]* should be treated similarly to *What
    is the [RATIO] for [COMPANY]?* We build these sentence templates for our model
    to train on by building a list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 4.1\. Data construction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We begin constructing our model by creating *reverse* *dictionaries*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create sample statements for our model. We build a function that gives
    us a random sentence structure, inquiring about a random financial ratio for a
    random company. We will be creating a custom named entity recognition_ model in
    the spaCy framework. This requires training the model to pick up the word or phrase
    in a sample sentence. To train the spaCy model, we need to provide it with an
    example, such as *(*Get me the ROE for Citi*, {"entities”: [(11, 14, *RATIO*),
    (19, 23, *COMPANY*) ]})*.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.2\. Training data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first part of the training example is the sentence. The second is a dictionary
    that consists of entities and the starting and ending index of the label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us define the training data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 5\. Model creation and training
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once we have the training data, we construct a *blank* model in spaCy. spaCy’s
    models are statistical, and every decision they make—for example, which part-of-speech
    tag to assign, or whether a word is a named entity—is a prediction. This prediction
    is based on the examples the model has seen during training. To train a model,
    you first need training data—examples of text and the labels you want the model
    to predict. This could be a part-of-speech tag, a named entity, or any other information.
    The model is then shown the unlabeled text and makes a prediction. Because we
    know the correct answer, we can give the model feedback on its prediction in the
    form of an *error gradient* of the loss function. This calculates the difference
    between the training example and the expected output, as shown in [Figure 10-6](#MLTraining).
    The greater the difference, the more significant the gradient, and the more updates
    we need to make to our model.
  prefs: []
  type: TYPE_NORMAL
- en: '![mlbf 1007](Images/mlbf_1007.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-6\. Machine learning–based training in spaCy
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create an NER pipeline to our model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add the training labels that we use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 5.1\. Model optimization function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we start optimization of our models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Training the NER model is akin to updating the weights for each token. The most
    important step is to use a good optimizer. The more examples of our training data
    that we provide spaCy, the better it will be at recognizing generalized results.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2\. Custom logic adapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we build our custom logic adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: With this custom logic adapter, our chatbot will take each input statement and
    try to recognize a *RATIO* and/or *COMPANY* using our NER model. If the model
    finds exactly one *COMPANY* and exactly one *RATIO*, it constructs a URL to guide
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3\. Model usage—training and testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we begin using our chatbot by using the following import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: We construct our chatbot by adding the `FinancialRatioAdapter` logical adapter
    that we created above to the chatbot. Although the following code snippet only
    shows us adding the `FinancialRatioAdapter`, note that other logical adapters,
    lists, and corpuses used in the prior training of the chatbot are also included.
    Please refer to the Jupyter notebook of the case study for more details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we test our chatbot using the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: As shown above, the custom logic adapter for our chatbot finds a RATIO and/or
    COMPANY in the sentence using our NLP model. If an exact pair is detected, the
    model constructs a URL to guide the user to the answer. Additionally, other logical
    adapters, such as mathematical evaluation, work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Overall, this case study provides an introduction to a number of aspects of
    chatbot development.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ChatterBot library in Python allows us to build a simple interface
    to resolve user inputs. To train a blank model, one must have a substantial training
    dataset. In this case study, we looked at patterns available to us and used them
    to generate training samples. Getting the right amount of training data is usually
    the hardest part of constructing a custom chatbot.
  prefs: []
  type: TYPE_NORMAL
- en: This case study is a demo project, and significant enhancements can be made
    to each component to extend it to a wide variety of tasks. Additional preprocessing
    steps can be added to have cleaner data to work with. To generate a response from
    our bot for input questions, the logic can be refined further to incorporate better
    similarity measures and embeddings. The chatbot can be trained on a bigger dataset
    using more advanced ML techniques. A series of custom logic adapters can be used
    to construct a more sophisticated ChatterBot. This can be generalized to more
    interesting tasks, such as retrieving information from a database or asking for
    more input from the user.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/bracket_bottom.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Case Study 3: Document Summarization'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Document summarization refers to the selection of the most important points
    and topics in a document and arranging them in a comprehensive manner. As discussed
    earlier, analysts at banks and other financial service organizations pore over,
    analyze, and attempt to quantify qualitative data from news, reports, and documents.
    Document summarization using NLP can provide in-depth support in this analyzing
    and interpretation. When tailored to financial documents, such as earning reports
    and financial news, it can help analysts quickly derive key topics and market
    signals from content. Document summarization can also be used to improve reporting
    efforts and can provide timely updates on key matters.
  prefs: []
  type: TYPE_NORMAL
- en: In NLP, *topic models* (such as LDA, introduced earlier in the chapter) are
    the most frequently used tools for the extraction of sophisticated, interpretable
    text features. These models can surface key topics, themes, or signals from large
    collections of documents and can be effectively used for document summarization.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/bracket_top.png)'
  prefs: []
  type: TYPE_IMG
- en: Blueprint for Using NLP for Document Summarization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 1\. Problem definition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The goal of this case study is to effectively discover common topics from earnings
    call transcripts of publicly traded companies using LDA. A core advantage of this
    technique compared to other approaches, is that no prior knowledge of the topics
    is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Getting started—loading the data and Python packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 2.1\. Loading the Python packages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For this case study, we will extract the text from a PDF. Hence, the Python
    library *pdf-miner* is used for processing the PDF files into a text format. Libraries
    for feature extraction and topic modeling are also loaded. The libraries for the
    visualization will be loaded later in the case study:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Libraries for pdf conversion`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '`Libraries for feature extraction and topic modeling`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '`Other libraries`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 3\. Data preparation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `convert_pdf_to_txt` function defined below pulls out all characters from
    a PDF document except the images. The function simply takes in the PDF document,
    extracts all characters from the document, and outputs the extracted text as a
    Python list of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next step, the PDF is converted to text using the above function and
    saved in a text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us look at the raw document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The text extracted from the PDF document contains uninformative characters
    that need to be removed. These characters reduce the effectiveness of our models
    as they provide unnecessary count ratios. The following function uses a series
    of regular expression (*regex*) searches as well as list comprehension to replace
    uninformative characters with a blank space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 4\. Model construction and training
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `CountVectorizer` function from the sklearn module is used with minimal
    parameter tuning to represent the clean document as a *document term matrix*.
    This is performed because our modeling requires that strings be represented as
    integers. The `CountVectorizer` shows the number of times a word occurs in the
    list after the removal of stop words. The document term matrix was formatted into
    a Pandas dataframe in order to inspect the dataset. This dataframe shows the word-occurrence
    count of each term in the document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next step, the document term matrix will be used as the input data to
    the LDA algorithm for topic modeling. The algorithm was fitted to isolate five
    distinct topic contexts, as shown by the following code. This value can be adjusted
    depending on the level of granularity one intends to obtain from the modeling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code uses the *mglearn* library to display the top 10 words within
    each specific topic model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Each topic in the table is expected to represent a broader theme. However, given
    that we trained the model on only a single document, the themes across the topics
    may not be very distinct from each other.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the broader theme, topic 2 discusses quarters, months, and currency
    units related to asset valuation. Topic 3 reveals information on income from real
    estate, mortgages, and related instrument. Topic 5 also has terms related to asset
    valuation. The first topic references balance sheet items and derivatives. Topic
    4 is slightly similar to topic 1 and has words related to an investment process.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of overall theme, topics 2 and 5 are quite distinct from the others.
    There may also be some similarity between topics 1 and 4, based on the top words.
    In the next section, we will try to understand the separation between these topics
    using the Python library *pyLDAvis*.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Visualization of topics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we visualize the topics using different techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1\. Topic visualization
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Topic visualization* facilitates the evaluation of topic quality using human
    judgment. *pyLDAvis* is a library that displays the global relationships between
    topics while also facilitating their semantic evaluation by inspecting the terms
    most closely associated with each topic and, inversely, the topics associated
    with each term. It also addresses the challenge in which frequently used terms
    in a document tend to dominate the distribution over words that define a topic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Below, the *pyLDAvis_* library is used to visualize the topic models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '![mlbf 10in16](Images/mlbf_10in16.png)'
  prefs: []
  type: TYPE_IMG
- en: We notice that topics 2 and 5 are quite distant from each other. This is what
    we observed in the section above from the overall theme and list of words under
    these topics. Topics 1 and 4 are quite close, which validates our observation
    above. Such close topics should be analyzed more intricately and might be combined
    if needed. The relevance of the terms under each topic, as shown in the right
    panel of the chart, can also be used to understand the differences. Topics 3 and
    4 are relatively close as well, although topic 3 is quite distant from the others.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2\. Word cloud
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this step, a *word cloud* is generated for the entire document to note the
    most recurrent terms in the document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '`Output`'
  prefs: []
  type: TYPE_NORMAL
- en: '![mlbf 10in17](Images/mlbf_10in17.png)'
  prefs: []
  type: TYPE_IMG
- en: The word cloud generally agrees with the results from the topic modeling, as
    recurrent words, such as *loan*, *real estate*, *third quarter*, and *fair value*,
    are larger and bolder.
  prefs: []
  type: TYPE_NORMAL
- en: By integrating the information from the steps above, we may come up with the
    list of topics represented by the document. For the document in our case study,
    we see that words like *third quarter*, *first nine*, and *nine months* occur
    quite frequently. In the word list, there are several topics related to balance
    sheet items. So the document might be a third-quarter financial balance sheet
    with all credit and assets values in that quarter.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case study, we explored the use of topic modeling to gain insights into
    the content of a document. We demonstrated the use of the LDA model, which extracts
    plausible topics and allows us to gain a high-level understanding of large amounts
    of text in an automated way.
  prefs: []
  type: TYPE_NORMAL
- en: We performed extraction of the text from a document in PDF format and performed
    further data preprocessing. The results, alongside the visualizations, demonstrated
    that the topics are intuitive and meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the case study shows how machine learning and NLP can be applied across
    many domains—such as investment analysis, asset modeling, risk management, and
    regulatory compliance—to summarize documents, news, and reports in order to significantly
    reduce manual processing. Given this ability to quickly access and verify relevant,
    filtered information, analysts may be able to provide more comprehensive and informative
    reports on which management can base their decisions.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/bracket_bottom.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The field of NLP has made significant progress, resulting in technologies that
    have and will continue to revolutionize how financial institutions operate. In
    the near term, we are likely to see an increase in NLP-based technologies across
    different domains of finance, including asset management, risk management, and
    process automation. The adoption and understanding of NLP methodologies and related
    infrastructure are very important for financial institutions.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the concepts in Python, machine learning, and finance presented in
    this chapter through the case studies can be used as a blueprint for any other
    NLP-based problem in finance.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the concepts from case study 1, use NLP-based techniques to develop a
    trading strategy using Twitter data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case study 1, use the word2vec word embedding method to generate the word
    vectors and incorporate it into the trading strategy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the concepts from case study 2, test a few more logical adapters to the
    chatbot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the concepts from case study 3, perform topic modeling on a set of financial
    news articles for a given day and retrieve the key themes of the day.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch10.xhtml#idm45174899480680-marker)) A customized deep learning–based
    feature representation model is built in case study 1 of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch10.xhtml#idm45174898988232-marker)) The news can be downloaded by a
    simple web-scraping program in Python using packages such as Beautiful Soup. Readers
    should talk to the website or follow its terms of service in order to use the
    news for commercial purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '^([3](ch10.xhtml#idm45174898982312-marker)) The source of this lexicon is Nuno
    Oliveira, Paulo Cortez, and Nelson Areal, “Stock Market Sentiment Lexicon Acquisition
    Using Microblogging Data and Statistical Measures,” *Decision Support Systems*
    85 (March 2016): 62–73.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch10.xhtml#idm45174898012728-marker)) We also train a sentiment analysis
    model on the financial data in the subsequent section and compare the results
    against the TextBlob model.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch10.xhtml#idm45174897768808-marker)) Refer to [Chapter 5](ch05.xhtml#Chapter5)
    for more details on RNN models.
  prefs: []
  type: TYPE_NORMAL
- en: '^([6](ch10.xhtml#idm45174897534248-marker)) The source of this lexicon is Nuno
    Oliveira, Paulo Cortez, and Nelson Areal, “Stock Market Sentiment Lexicon Acquisition
    Using Microblogging Data and Statistical Measures,” *Decision Support Systems*
    85 (March 2016): 62–73.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch10.xhtml#idm45174897105944-marker)) Refer to the plotting section of
    the [backtrader website](https://oreil.ly/j2pT0) for more details on the backtrader’s
    charts and the panels.
  prefs: []
  type: TYPE_NORMAL
