- en: Chapter 3\. Data Types and Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bad programmers worry about the code. Good programmers worry about data structures
    and their relationships.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Linus Torvalds
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces basic data types and data structures of `Python`. Although
    the `Python` interpreter itself already brings a rich variety of data structures
    with it, `NumPy` and other libraries add to these in a valuable fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter is organized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[“Basic Data Types”](#data_types)'
  prefs: []
  type: TYPE_NORMAL
- en: The first section introduces basic data types such as `int`, `float`, and `string`.
  prefs: []
  type: TYPE_NORMAL
- en: '[“Basic Data Structures”](#data_structures)'
  prefs: []
  type: TYPE_NORMAL
- en: The next section introduces the fundamental data structures of Python (e.g.,
    `list` objects) and illustrates control structures, functional programming paradigms,
    and anonymous functions.
  prefs: []
  type: TYPE_NORMAL
- en: The spirit of this chapter is to provide a general introduction to `Python`
    specifics when it comes to data types and structures. If you are equipped with
    a background from another programing language, say `C` or `Matlab`, you should
    be able to easily grasp the differences that `Python` usage might bring along.
    The topics introduced here are all important and fundamental for the chapters
    to come.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter covers the following data types and structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '| object type | meaning | usage/model for |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | integer value | natural number |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | floating point number | real number |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | boolean value | something true or false |'
  prefs: []
  type: TYPE_TB
- en: '| `str` | string object | character, word, text |'
  prefs: []
  type: TYPE_TB
- en: '| `tuple` | immutable container | fixed set of objects, record |'
  prefs: []
  type: TYPE_TB
- en: '| `list` | mutable container | changing set of objects |'
  prefs: []
  type: TYPE_TB
- en: '| `dict` | mutable container | key-value store |'
  prefs: []
  type: TYPE_TB
- en: '| `set` | mutable container | collection of unique objects |'
  prefs: []
  type: TYPE_TB
- en: Basic Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Python` is a *dynamically typed* language, which means that the `Python` interpreter
    infers the type of an object at runtime. In comparison, compiled languages like
    `C` are generally *statically typed*. In these cases, the type of an object has
    to be attached to the object before compile time.^([1](ch03.html#idm140277701762352))'
  prefs: []
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most fundamental data types is the integer, or ``int``:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The built-in function `type` provides type information for all objects with
    standard and built-in types as well as for newly created classes and objects.
    In the latter case, the information provided depends on the description the programmer
    has stored with the class. There is a saying that “everything in `Python` is an
    object.” This means, for example, that even simple objects like the `int` object
    we just defined have built-in methods. For example, you can get the number of
    bits needed to represent the `int` object in-memory by calling the method `bit_length`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see that the number of bits needed increases the higher the integer
    value is that we assign to the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In general, there are so many different methods that it is hard to memorize
    all methods of all classes and objects. Advanced `Python` environments, like `IPython`,
    provide tab completion capabilities that show all methods attached to an object.
    You simply type the object name followed by a dot (e.g., `a.`) and then press
    the Tab key, e.g., `a.*tab*`. This then provides a collection of methods you can
    call on the object. Alternatively, the `Python` built-in function `dir` gives
    a complete list of attributes and methods of any object.
  prefs: []
  type: TYPE_NORMAL
- en: 'A specialty of `Python` is that integers can be arbitrarily large. Consider,
    for example, the googol number 10^(100). `Python` has no problem with such large
    numbers, which are technically `long` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Large Integers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Python` integers can be arbitrarily large. The interpreter simply uses as
    many bits/bytes as needed to represent the numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Arithmetical operations on integers are easy to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Floats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last expression return the generally *desired* result of 0.25 (this is different
    in basic Python 2.7). This brings us to the next basic data type, the `float`
    object. Adding a dot to an integer value, like in `1.` or `1.0`, causes `Python`
    to interpret the object as a `float`. Expressions involving a `float` also return
    a `float` object in general:^([2](ch03.html#idm140277701533120))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A `float` is a bit more involved in that the computerized representation of
    rational or real numbers is in general not exact and depends on the specific technical
    approach taken. To illustrate what this implies, let us define another `float`
    object `b`. `float` objects like this one are always represented internally up
    to a certain degree of accuracy only. This becomes evident when adding 0.1 to
    `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for this is that +`float`+s are internally represented in binary
    format; that is, a decimal number <math alttext="0 less-than n less-than 1"><mrow><mn>0</mn>
    <mo><</mo> <mi>n</mi> <mo><</mo> <mn>1</mn></mrow></math> is represented by a
    series of the form <math alttext="n equals StartFraction x Over 2 EndFraction
    plus StartFraction y Over 4 EndFraction plus StartFraction z Over 8 EndFraction
    plus period period period"><mrow><mi>n</mi> <mo>=</mo> <mfrac><mi>x</mi> <mn>2</mn></mfrac>
    <mo>+</mo> <mfrac><mi>y</mi> <mn>4</mn></mfrac> <mo>+</mo> <mfrac><mi>z</mi> <mn>8</mn></mfrac>
    <mo>+</mo> <mo>.</mo> <mo>.</mo> <mo>.</mo></mrow></math> . For certain floating-point
    numbers the binary representation might involve a large number of elements or
    might even be an infinite series. However, given a fixed number of bits used to
    represent such a number — i.e., a fixed number of terms in the representation
    series—inaccuracies are the consequence. Other numbers can be represented *perfectly*
    and are therefore stored exactly even with a finite number of bits available.
    Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'One half, i.e., 0.5, is stored exactly because it has an exact (finite) binary
    representation as <math alttext="normal dollar-sign 0.5 equals one-half normal
    dollar-sign"><mrow><mi>$</mi> <mn>0</mn> <mo>.</mo> <mn>5</mn> <mo>=</mo> <mfrac><mn>1</mn>
    <mn>2</mn></mfrac> <mi>$</mi></mrow></math> . However, for `b = 0.35` we get something
    different than the expected rational number <math alttext="normal dollar-sign
    0.35 equals seven-twenty-ths normal dollar-sign"><mrow><mi>$</mi> <mn>0</mn> <mo>.</mo>
    <mn>35</mn> <mo>=</mo> <mfrac><mn>7</mn> <mn>20</mn></mfrac> <mi>$</mi></mrow></math>
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The precision is dependent on the number of bits used to represent the number.
    In general, all platforms that `Python` runs on use the IEEE 754 double-precision
    standard (i.e., 64 bits), for internal representation.^([3](ch03.html#idm140277701447424))
    This translates into a 15-digit relative accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: Since this topic is of high importance for several application areas in finance,
    it is sometimes necessary to ensure the exact, or at least best possible, representation
    of numbers. For example, the issue can be of importance when summing over a large
    set of numbers. In such a situation, a certain kind and/or magnitude of representation
    error might, in aggregate, lead to significant deviations from a benchmark value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The module `decimal` provides an arbitrary-precision object for floating-point
    numbers and several options to address precision issues when working with such
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can change the precision of the representation by changing the respective
    attribute value of the `Context` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_mastering_the_basics_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Lower precision than default.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_mastering_the_basics_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Higher precision than default.
  prefs: []
  type: TYPE_NORMAL
- en: 'If needed, the precision can in this way be adjusted to the exact problem at
    hand and one can operate with floating-point objects that exhibit different degrees
    of accuracy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Arbitrary-Precision Floats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The module `decimal` provides an arbitrary-precision floating-point number object.
    In finance, it might sometimes be necessary to ensure high precision and to go
    beyond the 64-bit double-precision standard.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In programming, evaluating a comparison or logical expression, such as `4 >
    3`, `4.5 <= 3.25` or `(4 > 3) and (3 > 2)` , yields one of `True` or `False` as
    output, two important Python keywords. Others are, for example, `def`, `for` or
    `if`. A complete list of Python keywords is available in the `keyword` module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`True` and `False` are of data type `bool`, standing for a Boolean value. The
    following code shows Python’s *comparison* operators applied to the same operands
    with the resulting `bool` objects.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_mastering_the_basics_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Is greater.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_mastering_the_basics_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Is greater or equal.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](images/3.png)](#co_mastering_the_basics_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Is smaller.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](images/4.png)](#co_mastering_the_basics_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Is smaller or equal.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](images/5.png)](#co_mastering_the_basics_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Is equal.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](images/6.png)](#co_mastering_the_basics_CO2-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Is not equal.
  prefs: []
  type: TYPE_NORMAL
- en: Often, *logical* operators are applied on `bool` objects, which in turn yields
    another `bool` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Of course, both types of operators are often combined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: One major application are is to control the code flow via other Python keywords,
    such as `if` or `while` (more examples later in the chapter).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_mastering_the_basics_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: If condition holds true, execute code to follow.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_mastering_the_basics_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The code to be executed if condition holds true.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](images/3.png)](#co_mastering_the_basics_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Initializes the parameter `i` with 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](images/4.png)](#co_mastering_the_basics_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: As long as the condition holds true, execute and repeat the code to follow.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](images/5.png)](#co_mastering_the_basics_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Prints a text and the value of parameter `i`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](images/6.png)](#co_mastering_the_basics_CO3-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Increases the parameter value by 1; `i += 1` is the same as `i = i + 1`.
  prefs: []
  type: TYPE_NORMAL
- en: Numerically, Python attaches a value of 0 to `False` and a value of 1 to `True`.
    When transforming number to `bool` objects via the `bool()` function, a 0 gives
    `False` while all other numbers give `True`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we can represent natural and floating-point numbers, we turn to text.
    The basic data type to represent text in `Python` is the `string`. The ``string``
    object has a number of really helpful built-in methods. In fact, `Python` is generally
    considered to be a good choice when it comes to working with text files of any
    kind and any size. A `string` object is generally defined by single or double
    quotation marks or by converting another object using the `str` function (i.e.,
    using the object’s standard or user-defined `string` representation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With regard to the built-in methods, you can, for example, capitalize the first
    word in this object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can split it into its single-word components to get a `list` object
    of all the words (more on `list` objects later):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also search for a word and get the position (i.e., index value) of
    the first letter of the word back in a successful case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If the word is not in the `string` object, the method returns -1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Replacing characters in a string is a typical task that is easily accomplished
    with the `replace` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The stripping of strings—i.e., deletion of certain leading/lagging characters—is
    also often necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 3-1](#string_methods) lists a number of helpful methods of the `string`
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-1\. Selected string methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Arguments | Returns/result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `capitalize` | `()` | Copy of the string with first letter capitalized |'
  prefs: []
  type: TYPE_TB
- en: '| `count` | `(sub[, start[, end]])` | Count of the number of occurrences of
    substring |'
  prefs: []
  type: TYPE_TB
- en: '| `decode` | `([encoding[, errors]])` | Decoded version of the string, using
    `encoding` (e.g., UTF-8) |'
  prefs: []
  type: TYPE_TB
- en: '| `encode` | `([encoding+[, errors]])` | Encoded version of the string |'
  prefs: []
  type: TYPE_TB
- en: '| `find` | `(sub[, start[, end]])` | (Lowest) index where substring is found
    |'
  prefs: []
  type: TYPE_TB
- en: '| `join` | `(seq)` | Concatenation of strings in sequence `seq` |'
  prefs: []
  type: TYPE_TB
- en: '| `replace` | `(old, new[, count])` | Replaces `old` by `new` the first `count`
    times |'
  prefs: []
  type: TYPE_TB
- en: '| `split` | `([sep[, maxsplit]])` | List of words in string with `sep` as separator
    |'
  prefs: []
  type: TYPE_TB
- en: '| `splitlines` | `([keepends])` | Separated lines with line ends/breaks if
    `keepends` is `True` |'
  prefs: []
  type: TYPE_TB
- en: '| `strip` | `(chars)` | Copy of string with leading/lagging characters in `chars`
    removed |'
  prefs: []
  type: TYPE_TB
- en: '| `upper` | `()` | Copy with all letters capitalized |'
  prefs: []
  type: TYPE_TB
- en: Caution
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A fundamental change from Python 2.7 (first edition of the book) to Python 3.6
    (now used for the second edition) is the encoding and decoding of string objects
    and the introduction of Unicode (see [*https://docs.python.org/3/howto/unicode.html*](https://docs.python.org/3/howto/unicode.html)).
    This chapter does not allow to go into the many details important in this context.
    For the purposes of this book, which mainly deals with numerical data and standard
    strings containing English words, this omission seems justified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Excursion: Printing and String Replacements'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Printing `str` objects or string representations of other Python objects is
    usually accomplished by the `print()` function (used to be a statement in Python
    2.7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_mastering_the_basics_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Prints a `str` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_mastering_the_basics_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Prints a `str` object referenced by a variable name.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](images/3.png)](#co_mastering_the_basics_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Prints the string representation of an `int` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](images/4.png)](#co_mastering_the_basics_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies the final character(s) when printing; default is a line break `\n`
    as seen before.
  prefs: []
  type: TYPE_NORMAL
- en: Python offers powerful string replacement operations. There is the old way via
    the `%` character and the new way via curley brackets `{}` and `format()`. Both
    are still applied in practice. This section cannot provide an exhaustive illustration
    of all options, but the following code snippets show some important ones. First,
    the *old* way of doing it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_mastering_the_basics_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`int` object replacement.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_mastering_the_basics_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: With fixed number of characters.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](images/3.png)](#co_mastering_the_basics_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: With leading zeros if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](images/4.png)](#co_mastering_the_basics_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: '`float` object replacement.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](images/5.png)](#co_mastering_the_basics_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: With fixed number of decimals.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](images/6.png)](#co_mastering_the_basics_CO5-6)'
  prefs: []
  type: TYPE_NORMAL
- en: With fixed number of characters (and filled up decimals).
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](images/7.png)](#co_mastering_the_basics_CO5-7)'
  prefs: []
  type: TYPE_NORMAL
- en: With fixed number of characters and decimals …
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](images/8.png)](#co_mastering_the_basics_CO5-8)'
  prefs: []
  type: TYPE_NORMAL
- en: … and leading zeros if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](images/9.png)](#co_mastering_the_basics_CO5-9)'
  prefs: []
  type: TYPE_NORMAL
- en: '`str` object replacement.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](images/10.png)](#co_mastering_the_basics_CO5-10)'
  prefs: []
  type: TYPE_NORMAL
- en: With fixed number of characters.
  prefs: []
  type: TYPE_NORMAL
- en: The same examples now implemented in the *new* way. Notice the slight differences
    in the output in some places.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: String replacements are particularly useful in the context of multiple printing
    operations where the printed data is updated, for instance, during a `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Excursion: Regular Expressions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A powerful tool when working with `string` objects is *regular expressions*.
    `Python` provides such functionality in the module `re`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you are faced with a large text file, such as a comma-separated value
    (`CSV`) file, which contains certain time series and respective date-time information.
    More often than not, the date-time information is delivered in a format that `Python`
    cannot interpret directly. However, the date-time information can generally be
    described by a regular expression. Consider the following `string` object, containing
    three date-time elements, three integers, and three strings. Note that triple
    quotation marks allow the definition of strings over multiple rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The following regular expression describes the format of the date-time information
    provided in the `string` object:^([4](ch03.html#idm140277697069680))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Equipped with this regular expression, we can go on and find all the date-time
    elements. In general, applying regular expressions to `string` objects also leads
    to performance improvements for typical parsing tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When parsing `string` objects, consider using regular expressions, which can
    bring both convenience and performance to such operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting `string` objects can then be parsed to generate `Python datetime`
    objects (cf. [Link to Come] for an overview of handling date and time data with
    `Python`). To parse the `string` objects containing the date-time information,
    we need to provide information of how to parse—again as a `string` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Later chapters provide more information on date-time data, the handling of such
    data, and `datetime` objects and their methods. This is just meant to be a teaser
    for this important topic in finance.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a general rule, data structures are objects that contain a possibly large
    number of other objects. Among those that `Python` provides as built-in structures
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tuple`'
  prefs: []
  type: TYPE_NORMAL
- en: An immutable collection of arbitrary objects; only a few methods available
  prefs: []
  type: TYPE_NORMAL
- en: '`list`'
  prefs: []
  type: TYPE_NORMAL
- en: A mutable collection of arbitrary objects; many methods available
  prefs: []
  type: TYPE_NORMAL
- en: '`dict`'
  prefs: []
  type: TYPE_NORMAL
- en: A key-value store object
  prefs: []
  type: TYPE_NORMAL
- en: '`set`'
  prefs: []
  type: TYPE_NORMAL
- en: An unordered collection object for other *unique* objects
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `tuple` is an advanced data structure, yet it’s still quite simple and limited
    in its applications. It is defined by providing objects in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even drop the parentheses and provide multiple objects, just separated
    by commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Like almost all data structures in `Python` the ``tuple`` has a built-in index,
    with the help of which you can retrieve single or multiple elements of the `tuple`.
    It is important to remember that `Python` uses *zero-based numbering*, such that
    the third element of a `tuple` is at index position 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Zero-Based Numbering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In contrast to some other programming languages like `Matlab`, `Python` uses
    zero-based numbering schemes. For example, the first element of a `tuple` object
    has index value 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are only two special methods that this object type provides: `count`
    and `index`. The first counts the number of occurrences of a certain object and
    the second gives the index value of the first appearance of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`tuple` objects are *immutable* objects. This means that they, once defined,
    cannot be changed easily.'
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Objects of type `list` are much more flexible and powerful in comparison to
    `tuple` objects. From a finance point of view, you can achieve a lot working only
    with `list` objects, such as storing stock price quotes and appending new data.
    A `list` object is defined through brackets and the basic capabilities and behavior
    are similar to those of `tuple` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`list` objects can also be defined or converted by using the function `list`.
    The following code generates a new `list` object by converting the `tuple` object
    from the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the characteristics of `tuple` objects, ``list`` objects are
    also expandable and reducible via different methods. In other words, whereas `string`
    and `tuple` objects are *immutable* sequence objects (with indexes) that cannot
    be changed once created, `list` objects are *mutable* and can be changed via different
    operations. You can append `list` objects to an existing `list` object, and more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_mastering_the_basics_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Append `list` object at the end.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_mastering_the_basics_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Append elements of the `list` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](images/3.png)](#co_mastering_the_basics_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Insert object before index position.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](images/4.png)](#co_mastering_the_basics_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Remove first occurence of object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](images/5.png)](#co_mastering_the_basics_CO6-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Removes and returns object at index position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Slicing is also easily accomplished. Here, *slicing* refers to an operation
    that breaks down a data set into smaller parts (of interest):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_mastering_the_basics_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 3rd to 5th element.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-2](#list_methods) provides a summary of selected operations and methods
    of the `list` object.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-2\. Selected operations and methods of list objects
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Arguments | Returns/result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `l[i] = x` | `[i]` | Replaces `i`-th element by `x` |'
  prefs: []
  type: TYPE_TB
- en: '| `l[i:j:k] = s` | `[i:j:k]` | Replaces every `k`-th element from `i` to `j
    - 1` by `s` |'
  prefs: []
  type: TYPE_TB
- en: '| `append` | `(x)` | Appends `x` to object |'
  prefs: []
  type: TYPE_TB
- en: '| `count` | `(x)` | Number of occurrences of object `x` |'
  prefs: []
  type: TYPE_TB
- en: '| `del l[i:j:k]` | `[i:j:k]` | Deletes elements with index values `i` to `j
    – 1` |'
  prefs: []
  type: TYPE_TB
- en: '| `extend` | `(s)` | Appends all elements of `s` to object |'
  prefs: []
  type: TYPE_TB
- en: '| `index` | `(x[, i[, j]])` | First index of `x` between elements `i` and `j
    – 1` |'
  prefs: []
  type: TYPE_TB
- en: '| `insert` | `(i, x)` | Inserts `x` at/before index `i` |'
  prefs: []
  type: TYPE_TB
- en: '| `remove` | `(i)` | Removes element with index `i` |'
  prefs: []
  type: TYPE_TB
- en: '| `pop` | `(i)` | Removes element with index `i` and return it |'
  prefs: []
  type: TYPE_TB
- en: '| `reverse` | `()` | Reverses all items in place |'
  prefs: []
  type: TYPE_TB
- en: '| `sort` | `([cmp[, key[, reverse]]])` | Sorts all items in place |'
  prefs: []
  type: TYPE_TB
- en: 'Excursion: Control Structures'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although a topic in itself, *control structures* like `for` loops are maybe
    best introduced in `Python` based on `list` objects. This is due to the fact that
    looping in general takes place over `list` objects, which is quite different to
    what is often the standard in other languages. Take the following example. The
    `for` loop loops over the elements of the `list` object `l` with index values
    2 to 4 and prints the square of the respective elements. Note the importance of
    the indentation (whitespace) in the second line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This provides a really high degree of flexibility in comparison to the typical
    counter-based looping. Counter-based looping is also an option with `Python`,
    but is accomplished based on the (standard) `list` object `range`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_mastering_the_basics_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Parameters are `start`, `end`, `step size`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For comparison, the same loop is implemented using `range` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Looping over Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In `Python` you can loop over arbitrary `list` objects, no matter what the content
    of the object is. This often avoids the introduction of a counter.
  prefs: []
  type: TYPE_NORMAL
- en: '`Python` also provides the typical (conditional) control elements `if`, `elif`,
    and `else`. Their use is comparable in other languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_mastering_the_basics_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`%` stands for modulo.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, `while` provides another means to control the flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'A specialty of `Python` is so-called `list` *comprehensions*. Instead of looping
    over existing `list` objects, this approach generates `list` objects via loops
    in a rather compact fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In a certain sense, this already provides a first means to generate “something
    like” vectorized code in that loops are rather more implicit than explicit (vectorization
    of code is discussed in more detail later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'Excursion: Functional Programming'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Python` provides a number of tools for functional programming support as well—i.e.,
    the application of a function to a whole set of inputs (in our case `list` objects).
    Among these tools are `filter`, `map`, and `reduce`. However, we need a function
    definition first. To start with something really simple, consider a function `f`
    that returns the square of the input `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, functions can be arbitrarily complex, with multiple input/parameter
    objects and even multiple outputs, (return objects). However, consider the following
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The return object is a Boolean. Such a function can be applied to a whole `list`
    object by using `map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To this end, we can also provide a function definition directly as an argument
    to `map`, by using `lambda` or *anonymous* functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions can also be used to filter a `list` object. In the following example,
    the filter returns elements of a `list` object that match the Boolean condition
    as defined by the `even` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: List Comprehensions, Functional Programming, Anonymous Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It can be considered *good practice* to avoid loops on the `Python` level as
    far as possible. `list` comprehensions and functional programming tools like `map`,
    `filter`, and `reduce` provide means to write code without (explicit) loops that
    is both compact and in general more readable. `lambda` or anonymous functions
    are also powerful tools in this context.
  prefs: []
  type: TYPE_NORMAL
- en: Dicts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`dict` objects are dictionaries, and also mutable sequences, that allow data
    retrieval by keys that can, for example, be `string` objects. They are so-called
    *key-value stores*. While `list` objects are ordered and sortable, `dict` objects
    are unordered and unsortable. An example best illustrates further differences
    to `list` objects. Curly brackets are what define `dict` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this class of objects has a number of built-in methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several methods to get `iterator` objects from the `dict` object.
    The objects behave like `list` objects when iterated over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 3-3](#dict_methods) provides a summary of selected operations and methods
    of the `dict` object.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-3\. Selected operations and methods of dict objects
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Arguments | Returns/result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `d[k]` | `[k]` | Item of `d` with key `k` |'
  prefs: []
  type: TYPE_TB
- en: '| `d[k] = x` | `[k]` | Sets item key `k` to `x` |'
  prefs: []
  type: TYPE_TB
- en: '| `del d[k]` | `[k]` | Deletes item with key `k` |'
  prefs: []
  type: TYPE_TB
- en: '| `clear` | `()` | Removes all items |'
  prefs: []
  type: TYPE_TB
- en: '| `copy` | `()` | Makes a copy |'
  prefs: []
  type: TYPE_TB
- en: '| `has_key` | `(k)` | `True` if `k` is a key |'
  prefs: []
  type: TYPE_TB
- en: '| `items` | `()` | Iterator over all items |'
  prefs: []
  type: TYPE_TB
- en: '| `keys` | `()` | Iterator over all keys |'
  prefs: []
  type: TYPE_TB
- en: '| `values` | `()` | Iterator over all values |'
  prefs: []
  type: TYPE_TB
- en: '| `popitem` | `(k)` | Returns and removes item with key `k` |'
  prefs: []
  type: TYPE_TB
- en: '| `update` | `([e])` | Updates items with items from `e` |'
  prefs: []
  type: TYPE_TB
- en: Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last data structure we will consider is the `set` object. Although set
    theory is a cornerstone of mathematics and also finance theory, there are not
    too many practical applications for `set` objects. The objects are unordered collections
    of other objects, containing every element only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'With `set` objects, you can implement operations as you are used to in mathematical
    set theory. For example, you can generate unions, intersections, and differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_mastering_the_basics_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: All of `s` and `t`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_mastering_the_basics_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Both in `s` and `t`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](images/3.png)](#co_mastering_the_basics_CO10-3)'
  prefs: []
  type: TYPE_NORMAL
- en: In `s` but not in `t`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](images/4.png)](#co_mastering_the_basics_CO10-4)'
  prefs: []
  type: TYPE_NORMAL
- en: In `t` but not in `s`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](images/5.png)](#co_mastering_the_basics_CO10-5)'
  prefs: []
  type: TYPE_NORMAL
- en: In either one but not both.
  prefs: []
  type: TYPE_NORMAL
- en: 'One application of `set` objects is to get rid of duplicates in a `list` object.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](images/1.png)](#co_mastering_the_basics_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 1,000 random integers between 0 and 10.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](images/2.png)](#co_mastering_the_basics_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Number of elements in `l`.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic `Python` interpreter provides already a rich set of flexible data
    structures. From a finance point of view, the following can be considered the
    most important ones:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic data types
  prefs: []
  type: TYPE_NORMAL
- en: In finance, the classes `int`, `float`, and `string` provide the atomic data
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Standard data structures
  prefs: []
  type: TYPE_NORMAL
- en: The classes `tuple`, `list`, `dict`, and `set` have many application areas in
    finance, with `list` being the most flexible workhorse in general.
  prefs: []
  type: TYPE_NORMAL
- en: Further Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focuses on those issues that might be of particular importance
    for finance algorithms and applications. However, it can only represent a starting
    point for the exploration of data structures and data modeling in `Python`. There
    are a number of valuable resources available to go deeper from here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Good references in book form are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Goodrich, Michael et al. (2013): *Data Structures and Algorithms in Python.*
    John Wiley & Sons, Hoboken, NJ.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Harrison, Matt (2017): *Illustrated Guide to Python 3.* Treading on Python
    Series.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ramalho, Luciano (2016): *Fluent Python*. O’Reilly, Beijing et al.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch03.html#idm140277701762352-marker)) The [`Cython` library](http://www.cython.org)
    brings static typing and compiling features to `Python` that are comparable to
    those in `C`. In fact, `Cython` is a hybrid language of `Python` and `C`.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch03.html#idm140277701533120-marker)) Here and in the following discussion,
    terms like *float*, *float object*, etc. are used interchangeably, acknowledging
    that every *float* is also an *object*. The same holds true for other object types.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch03.html#idm140277701447424-marker)) Cf. [*http://en.wikipedia.org/wiki/Double-precision_floating-point_format*](http://en.wikipedia.org/wiki/Double-precision_floating-point_format).
  prefs: []
  type: TYPE_NORMAL
- en: '^([4](ch03.html#idm140277697069680-marker)) It is not possible to go into details
    here, but there is a wealth of information available on the Internet about regular
    expressions in general and for `Python` in particular. For an introduction to
    this topic, refer to Fitzgerald, Michael (2012): *Introducing Regular Expressions*.
    O’Reilly, Sebastopol, CA.'
  prefs: []
  type: TYPE_NORMAL
