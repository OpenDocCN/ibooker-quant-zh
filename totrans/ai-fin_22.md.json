["```py\nIn [1]: import math\n        import numpy as np\n        import pandas as pd\n        from pylab import plt, mpl\n        plt.style.use('seaborn')\n        mpl.rcParams['savefig.dpi'] = 300\n        mpl.rcParams['font.family'] = 'serif'\n        np.set_printoptions(suppress=True)\n\nIn [2]: def activation(x, act='linear', deriv=False):\n            if act == 'sigmoid':\n                if deriv:\n                    out = activation(x, 'sigmoid', False)\n                    return out * (1 - out)\n                return 1 / (1 + np.exp(-x))\n            elif act == 'relu':\n                if deriv:\n                    return np.where(x > 0, 1, 0)\n                return np.maximum(x, 0)\n            elif act == 'softplus':\n                if deriv:\n                    return activation(x, act='sigmoid')\n                return np.log(1 + np.exp(x))\n            elif act == 'linear':\n                if deriv:\n                    return 1\n                return x\n            else:\n                raise ValueError('Activation function not known.')\n\nIn [3]: x = np.linspace(-1, 1, 20)\n\nIn [4]: activation(x, 'sigmoid')\nOut[4]: array([0.26894142, 0.29013328, 0.31228169, 0.33532221, 0.35917484,\n               0.38374461, 0.40892261, 0.43458759, 0.46060812, 0.48684514,\n               0.51315486, 0.53939188, 0.56541241, 0.59107739, 0.61625539,\n               0.64082516, 0.66467779, 0.68771831, 0.70986672, 0.73105858])\n\nIn [5]: activation(x, 'sigmoid', True)\nOut[5]: array([0.19661193, 0.20595596, 0.21476184, 0.22288122, 0.23016827,\n               0.23648468, 0.24170491, 0.24572122, 0.24844828, 0.24982695,\n               0.24982695, 0.24844828, 0.24572122, 0.24170491, 0.23648468,\n               0.23016827, 0.22288122, 0.21476184, 0.20595596, 0.19661193])\n```", "```py\nIn [6]: class sinn:\n            def __init__(self, act='linear', lr=0.01, steps=100,\n                         verbose=False, psteps=200):\n                self.act = act\n                self.lr = lr\n                self.steps = steps\n                self.verbose = verbose\n                self.psteps = psteps\n            def forward(self):\n                ''' Forward propagation.\n '''\n                self.l2 = activation(np.dot(self.l0, self.w), self.act)\n            def backward(self):\n                ''' Backward propagation.\n '''\n                self.e = self.l2 - self.y\n                d = self.e * activation(self.l2, self.act, True)\n                u = self.lr * np.dot(self.l0.T, d)\n                self.w -= u\n            def metrics(self, s):\n                ''' Performance metrics.\n '''\n                mse = (self.e ** 2).mean()\n                acc = float(sum(self.l2.round() == self.y) / len(self.y))\n                self.res = self.res.append(\n                    pd.DataFrame({'mse': mse, 'acc': acc}, index=[s,])\n                )\n                if s % self.psteps == 0 and self.verbose:\n                        print(f'step={s:5d} | mse={mse:.6f}')\n                        print(f'           | acc={acc:.6f}')\n            def fit(self, l0, y, steps=None, seed=None):\n                ''' Fitting step.\n '''\n                self.l0 = l0\n                self.y = y\n                if steps is None:\n                    steps = self.steps\n                self.res = pd.DataFrame()\n                samples, features = l0.shape\n                if seed is not None:\n                    np.random.seed(seed)\n                self.w = np.random.random((features, 1))\n                for s in range(1, steps + 1):\n                    self.forward()\n                    self.backward()\n                    self.metrics(s)\n            def predict(self, X):\n                ''' Prediction step.\n '''\n                return activation(np.dot(X, self.w), self.act)\n```", "```py\nIn [7]: features = 5\n        samples = 5\n\nIn [8]: np.random.seed(10)\n        l0 = np.random.standard_normal((samples, features))\n        l0\nOut[8]: array([[ 1.3315865 ,  0.71527897, -1.54540029, -0.00838385,  0.62133597],\n               [-0.72008556,  0.26551159,  0.10854853,  0.00429143, -0.17460021],\n               [ 0.43302619,  1.20303737, -0.96506567,  1.02827408,  0.22863013],\n               [ 0.44513761, -1.13660221,  0.13513688,  1.484537  , -1.07980489],\n               [-1.97772828, -1.7433723 ,  0.26607016,  2.38496733,  1.12369125]])\n\nIn [9]: np.linalg.matrix_rank(l0)\nOut[9]: 5\n\nIn [10]: y = np.random.random((samples, 1))\n         y\nOut[10]: array([[0.8052232 ],\n                [0.52164715],\n                [0.90864888],\n                [0.31923609],\n                [0.09045935]])\n\nIn [11]: reg = np.linalg.lstsq(l0, y, rcond=-1)[0]  ![1](Images/1.png)\n\nIn [12]: reg  ![1](Images/1.png)\nOut[12]: array([[-0.74919308],\n                [ 0.00146473],\n                [-1.49864704],\n                [-0.02498757],\n                [-0.82793882]])\n\nIn [13]: np.allclose(np.dot(l0, reg), y)  ![1](Images/1.png)\nOut[13]: True\n```", "```py\nIn [14]: model = sinn(lr=0.015, act='linear', steps=6000,\n                     verbose=True, psteps=1000)\n\nIn [15]: %time model.fit(l0, y, seed=100)\n         step= 1000 | mse=0.008086\n                    | acc=0.000000\n         step= 2000 | mse=0.000545\n                    | acc=0.000000\n         step= 3000 | mse=0.000037\n                    | acc=0.000000\n         step= 4000 | mse=0.000002\n                    | acc=0.000000\n         step= 5000 | mse=0.000000\n                    | acc=0.000000\n         step= 6000 | mse=0.000000\n                    | acc=0.000000\n         CPU times: user 5.23 s, sys: 29.7 ms, total: 5.26 s\n         Wall time: 5.26 s\n\nIn [16]: model.predict(l0)\nOut[16]: array([[0.80512489],\n                [0.52144986],\n                [0.90872498],\n                [0.31919803],\n                [0.09045743]])\n\nIn [17]: model.predict(l0) - y  ![1](Images/1.png)\nOut[17]: array([[-0.0000983 ],\n                [-0.00019729],\n                [ 0.0000761 ],\n                [-0.00003806],\n                [-0.00000191]])\n```", "```py\nIn [18]: features = 5\n         samples = 10\n\nIn [19]: np.random.seed(3)\n         l0 = np.random.randint(0, 2, (samples, features))\n         l0\nOut[19]: array([[0, 0, 1, 1, 0],\n                [0, 0, 1, 1, 1],\n                [0, 1, 1, 1, 0],\n                [1, 1, 0, 0, 0],\n                [0, 1, 1, 0, 0],\n                [0, 1, 0, 0, 0],\n                [0, 1, 0, 1, 1],\n                [0, 1, 0, 0, 1],\n                [1, 0, 0, 1, 0],\n                [1, 0, 1, 1, 1]])\n\nIn [20]: np.linalg.matrix_rank(l0)\nOut[20]: 5\n\nIn [21]: y = np.random.randint(0, 2, (samples, 1))\n         y\nOut[21]: array([[1],\n                [0],\n                [1],\n                [0],\n                [0],\n                [1],\n                [1],\n                [1],\n                [0],\n                [0]])\n\nIn [22]: model = sinn(lr=0.01, act='sigmoid')  ![1](Images/1.png)\n\nIn [23]: %time model.fit(l0, y, 4000)\n         CPU times: user 3.57 s, sys: 9.6 ms, total: 3.58 s\n         Wall time: 3.59 s\n\nIn [24]: model.l2\nOut[24]: array([[0.51118415],\n                [0.34390898],\n                [0.84733758],\n                [0.07601979],\n                [0.40505454],\n                [0.84145926],\n                [0.95592461],\n                [0.72680243],\n                [0.11219587],\n                [0.00806003]])\n\nIn [25]: model.predict(l0).round() == y  ![2](Images/2.png)\nOut[25]: array([[ True],\n                [ True],\n                [ True],\n                [ True],\n                [ True],\n                [ True],\n                [ True],\n                [ True],\n                [ True],\n                [ True]])\n\nIn [26]: ax = model.res['acc'].plot(figsize=(10, 6),\n                     title='Prediction Accuracy | Classification')\n         ax.set(xlabel='steps', ylabel='accuracy');\n```", "```py\nIn [27]: class shnn:\n             def __init__(self, units=12, act='linear', lr=0.01, steps=100,\n                          verbose=False, psteps=200, seed=None):\n                 self.units = units\n                 self.act = act\n                 self.lr = lr\n                 self.steps = steps\n                 self.verbose = verbose\n                 self.psteps = psteps\n                 self.seed = seed\n             def initialize(self):\n                 ''' Initializes the random weights.\n '''\n                 if self.seed is not None:\n                     np.random.seed(self.seed)\n                 samples, features = self.l0.shape\n                 self.w0 = np.random.random((features, self.units))\n                 self.w1 = np.random.random((self.units, 1))\n             def forward(self):\n                 ''' Forward propagation.\n '''\n                 self.l1 = activation(np.dot(self.l0, self.w0), self.act)\n                 self.l2 = activation(np.dot(self.l1, self.w1), self.act)\n             def backward(self):\n                 ''' Backward propagation.\n '''\n                 self.e = self.l2 - self.y\n                 d2 = self.e * activation(self.l2, self.act, True)\n                 u2 = self.lr * np.dot(self.l1.T, d2)\n                 self.w1 -= u2\n                 e1 = np.dot(d2, self.w1.T)\n                 d1 = e1 * activation(self.l1, self.act, True)\n                 u1 = self.lr * np.dot(self.l0.T, d1)\n                 self.w0 -= u1\n             def metrics(self, s):\n                 ''' Performance metrics.\n '''\n                 mse = (self.e ** 2).mean()\n                 acc = float(sum(self.l2.round() == self.y) / len(self.y))\n                 self.res = self.res.append(\n                     pd.DataFrame({'mse': mse, 'acc': acc}, index=[s,])\n                 )\n                 if s % self.psteps == 0 and self.verbose:\n                         print(f'step={s:5d} | mse={mse:.5f}')\n                         print(f'           | acc={acc:.5f}')\n             def fit(self, l0, y, steps=None):\n                 ''' Fitting step.\n '''\n                 self.l0 = l0\n                 self.y = y\n                 if steps is None:\n                     steps = self.steps\n                 self.res = pd.DataFrame()\n                 self.initialize()\n                 self.forward()\n                 for s in range(1, steps + 1):\n                     self.backward()\n                     self.forward()\n                     self.metrics(s)\n             def predict(self, X):\n                 ''' Prediction step.\n '''\n                 l1 = activation(np.dot(X, self.w0), self.act)\n                 l2 = activation(np.dot(l1, self.w1), self.act)\n                 return l2\n```", "```py\nIn [28]: features = 5\n         samples = 10\n\nIn [29]: l0 = np.random.standard_normal((samples, features))\n\nIn [30]: np.linalg.matrix_rank(l0)\nOut[30]: 5\n\nIn [31]: y = np.random.random((samples, 1))\n\nIn [32]: reg = np.linalg.lstsq(l0, y, rcond=-1)[0]\n\nIn [33]: (np.dot(l0, reg)  - y)\nOut[33]: array([[-0.10226341],\n                [-0.42357164],\n                [-0.25150491],\n                [-0.30984143],\n                [-0.85213261],\n                [-0.13791373],\n                [-0.52336502],\n                [-0.50304204],\n                [-0.7728686 ],\n                [-0.3716898 ]])\n\nIn [34]: ((np.dot(l0, reg)  - y) ** 2).mean()\nOut[34]: 0.23567187607888118\n```", "```py\nIn [35]: model = shnn(lr=0.01, units=16, act='softplus',\n                      verbose=True, psteps=2000, seed=100)\n\nIn [36]: %time model.fit(l0, y, 8000)\n         step= 2000 | mse=0.00205\n                    | acc=0.00000\n         step= 4000 | mse=0.00098\n                    | acc=0.00000\n         step= 6000 | mse=0.00043\n                    | acc=0.00000\n         step= 8000 | mse=0.00022\n                    | acc=0.00000\n         CPU times: user 8.15 s, sys: 69.2 ms, total: 8.22 s\n         Wall time: 8.3 s\n\nIn [37]: model.l2 - y\nOut[37]: array([[-0.00390976],\n                [-0.00522077],\n                [ 0.02053932],\n                [-0.0042113 ],\n                [-0.0006624 ],\n                [-0.01001395],\n                [ 0.01783203],\n                [-0.01498316],\n                [-0.0177866 ],\n                [ 0.02782519]])\n```", "```py\nIn [38]: model = shnn(lr=0.025, act='sigmoid', steps=200,\n                      verbose=True, psteps=50, seed=100)\n\nIn [39]: l0.round()\nOut[39]: array([[ 0., -1., -2.,  1., -0.],\n                [-1., -2., -0., -0., -2.],\n                [ 0.,  1., -1., -1., -1.],\n                [-0.,  0., -1., -0., -1.],\n                [ 1., -1.,  1.,  1., -1.],\n                [ 1., -1.,  1., -2.,  1.],\n                [-1., -0.,  1., -1.,  1.],\n                [ 1.,  2., -1., -0., -0.],\n                [-1.,  0.,  0.,  0.,  2.],\n                [ 0.,  0., -0.,  1.,  1.]])\n\nIn [40]: np.linalg.matrix_rank(l0)\nOut[40]: 5\n\nIn [41]: y.round()\nOut[41]: array([[0.],\n                [1.],\n                [1.],\n                [1.],\n                [1.],\n                [1.],\n                [0.],\n                [1.],\n                [0.],\n                [0.]])\n\nIn [42]: model.fit(l0.round(), y.round())\n         step=   50 | mse=0.26774\n                    | acc=0.60000\n         step=  100 | mse=0.22556\n                    | acc=0.60000\n         step=  150 | mse=0.19939\n                    | acc=0.70000\n         step=  200 | mse=0.16924\n                    | acc=1.00000\n\nIn [43]: ax = model.res.plot(figsize=(10, 6), secondary_y='mse')\n         ax.get_legend().set_bbox_to_anchor((0.2, 0.5));\n```", "```py\nIn [44]: url = 'http://hilpisch.com/aiif_eikon_eod_data.csv'\n\nIn [45]: raw = pd.read_csv(url, index_col=0, parse_dates=True).dropna()\n\nIn [46]: sym = 'EUR='\n\nIn [47]: data = pd.DataFrame(raw[sym])\n\nIn [48]: lags = 5\n         cols = []\n         data['r'] = np.log(data / data.shift(1))\n         data['d'] = np.where(data['r'] > 0, 1, 0)  ![1](Images/1.png)\n         for lag in range(1, lags + 1):\n             col = f'lag_{lag}'\n             data[col] = data['r'].shift(lag)  ![2](Images/2.png)\n             cols.append(col)\n         data.dropna(inplace=True)\n         data[cols] = (data[cols] - data[cols].mean()) / data[cols].std()  ![3](Images/3.png)\n\nIn [49]: data.head()\nOut[49]:               EUR=         r  d     lag_1     lag_2     lag_3     lag_4  \\\n         Date\n         2010-01-12  1.4494 -0.001310  0  1.256582  1.177935 -1.142025  0.560551\n         2010-01-13  1.4510  0.001103  1 -0.214533  1.255944  1.178974 -1.142118\n         2010-01-14  1.4502 -0.000551  0  0.213539 -0.214803  1.256989  1.178748\n         2010-01-15  1.4382 -0.008309  0 -0.079986  0.213163 -0.213853  1.256758\n         2010-01-19  1.4298 -0.005858  0 -1.456028 -0.080289  0.214140 -0.214000\n\n                        lag_5\n         Date\n         2010-01-12 -0.511372\n         2010-01-13  0.560740\n         2010-01-14 -1.141841\n         2010-01-15  1.178904\n         2010-01-19  1.256910\n```", "```py\nIn [50]: model = shnn(lr=0.0001, act='sigmoid', steps=10000,\n                      verbose=True, psteps=2000, seed=100)\n\nIn [51]: y = data['d'].values.reshape(-1, 1)\n\nIn [52]: %time model.fit(data[cols].values, y)\n         step= 2000 | mse=0.24964\n                    | acc=0.51594\n         step= 4000 | mse=0.24951\n                    | acc=0.52390\n         step= 6000 | mse=0.24945\n                    | acc=0.52231\n         step= 8000 | mse=0.24940\n                    | acc=0.52510\n         step=10000 | mse=0.24936\n                    | acc=0.52430\n         CPU times: user 9min 1s, sys: 40.9 s, total: 9min 42s\n         Wall time: 1min 21s\n\nIn [53]: data['p'] = np.where(model.predict(data[cols]) > 0.5, 1, -1)  ![1](Images/1.png)\n\nIn [54]: data['p'].value_counts()  ![1](Images/1.png)\nOut[54]:  1    1257\n         -1    1253\n         Name: p, dtype: int64\n\nIn [55]: data['s'] = data['p'] * data['r']  ![2](Images/2.png)\n\nIn [56]: data[['r', 's']].sum().apply(np.exp)  ![3](Images/3.png)\nOut[56]: r    0.772411\n         s    1.885677\n         dtype: float64\n\nIn [57]: data[['r', 's']].cumsum().apply(np.exp).plot(figsize=(10, 6));  ![4](Images/4.png)\n```"]