- en: Chapter 5\. Linear Algebra
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç¬¬5ç«  çº¿æ€§ä»£æ•°
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä»‹ç»
- en: Linear algebra is an essential part of computational finance, and as such it
    is a necessary and fundamental component for financial C++ software development.
    Options existing at present in the Standard Library are mostly limited to the
    `valarray` container, to be discussed briefly below. Over the last 15 years or
    so, some very good open source matrix algebra libraries have emerged that have
    been adopted by the financial software industry, as well as other computationally
    intensive domains such as data science and medical research. Progress is also
    being made toward linear algebra capabilities eventually being adopted into the
    Standard Library in C++23 and C++26.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: çº¿æ€§ä»£æ•°æ˜¯è®¡ç®—é‡‘èçš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œå› æ­¤å¯¹äºé‡‘èC++è½¯ä»¶å¼€å‘è€Œè¨€ï¼Œå®ƒæ˜¯ä¸€ä¸ªå¿…è¦ä¸”åŸºæœ¬çš„ç»„ä»¶ã€‚ç›®å‰åœ¨æ ‡å‡†åº“ä¸­å­˜åœ¨çš„é€‰é¡¹å¤§å¤šé™äº`valarray`å®¹å™¨ï¼Œç¨åå°†ç®€è¦è®¨è®ºã€‚
- en: As C++ did not have all the convenient built-in multidimensional array capabilities
    that came with Fortran platforms, quantitative programmers making the transition
    to C++ back in the 1990â€™s often found themselves in an inconvenient situation
    with limited options. These included building up this functionality mostly from
    scratch, wrestling with interfaces to numerical Fortran libraries such as BLAS
    and LAPACK, or somehow convincing management to invest in a third-party C++ commercial
    library.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºC++åœ¨ä¸Šä¸–çºª90å¹´ä»£æ²¡æœ‰Fortranå¹³å°æä¾›çš„ä¾¿åˆ©çš„å†…ç½®å¤šç»´æ•°ç»„åŠŸèƒ½ï¼Œé‚£äº›è½¬å‘C++çš„é‡åŒ–ç¨‹åºå‘˜ç»å¸¸é™·å…¥ä¸ä¾¿ä¹‹å¢ƒï¼Œé€‰é¡¹æœ‰é™ã€‚è¿™äº›é€‰é¡¹åŒ…æ‹¬ä»å¤´å¼€å§‹æ„å»ºè¿™äº›åŠŸèƒ½ï¼Œä¸æ•°å€¼Fortranåº“ï¼ˆå¦‚BLASå’ŒLAPACKï¼‰çš„æ¥å£æ–—äº‰ï¼Œæˆ–ä»¥æŸç§æ–¹å¼è¯´æœç®¡ç†å±‚æŠ•èµ„äºç¬¬ä¸‰æ–¹C++å•†ä¸šåº“ã€‚
- en: Contrived DIY solutions that were sometimes employed, based on what was available
    in C++ at the time, included representing a matrix as a `vector` of `vector`(s),
    or holding data in a two-dimensional dynamic C-array. Neither of these was particular
    palatable, with the former being cumbersome and inefficient, and the latter exposing
    the software to the risks associated with raw pointers and dynamic memory management.
    One seemingly useful feature available in the Standard Library, but not without
    controversy, was `std::valarray`. It has survived to the current day, and it provides
    vectorized operations and functions highly suitable for matrix and vector math.
    Its pros and cons will be presented momentarily.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æ—¶æœ‰æ—¶é‡‡ç”¨çš„äººä¸ºDIYè§£å†³æ–¹æ¡ˆåŒ…æ‹¬å°†çŸ©é˜µè¡¨ç¤ºä¸º`vector`çš„`vector`ï¼Œæˆ–å°†æ•°æ®ä¿å­˜åœ¨äºŒç»´åŠ¨æ€Cæ•°ç»„ä¸­ã€‚è¿™ä¸¤ç§æ–¹æ³•éƒ½ä¸å¤ªç†æƒ³ï¼Œå‰è€…ç¹çä¸”ä½æ•ˆï¼Œåè€…åˆ™æš´éœ²è½¯ä»¶äºåŸå§‹æŒ‡é’ˆå’ŒåŠ¨æ€å†…å­˜ç®¡ç†ç›¸å…³çš„é£é™©ã€‚æ ‡å‡†åº“ä¸­ä¼¼ä¹æœ‰ç”¨çš„ä¸€ä¸ªç‰¹æ€§æ˜¯`std::valarray`ï¼Œä½†ä¹Ÿä¸æ˜¯æ²¡æœ‰äº‰è®®ã€‚å®ƒä¸€ç›´å­˜æ´»è‡³ä»Šï¼Œæä¾›äº†é€‚åˆçŸ©é˜µå’Œå‘é‡æ•°å­¦çš„å‘é‡åŒ–æ“ä½œå’Œå‡½æ•°ã€‚å®ƒçš„ä¼˜ç¼ºç‚¹å°†åœ¨ç¨åè®¨è®ºã€‚
- en: The situation has improved substantially over the years with the release of
    multiple open-source linear algebra libraries for C++. Among these, two that have
    gained considerable critical mass in computational finance are the [Eigen](https://eigen.tuxfamily.org)
    library **{1}**, and [Armadillo](http://arma.sourceforge.net) **{2}**. A third
    option that has risen to some prominence in high-performance computing (HPC) is
    the [Blaze](https://bitbucket.org/blaze-lib/blaze) library **{3}**. An earlier
    library, [uBLAS](https://www.boost.org/doc/libs/1_81_0/libs/numeric/ublas/doc/index.html),
    **{4}** is also available as part of the Boost libraries; however, it does not
    include the matrix decompositions and other capabilities available in the aforementioned
    offerings.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: å¤šå¹´æ¥ï¼Œæƒ…å†µæœ‰äº†æ˜¾è‘—æ”¹å–„ï¼Œå‘å¸ƒäº†å¤šä¸ªå¼€æºçº¿æ€§ä»£æ•°åº“ä¾›C++ä½¿ç”¨ã€‚åœ¨è¿™äº›åº“ä¸­ï¼Œä¸¤ä¸ªåœ¨è®¡ç®—é‡‘èé¢†åŸŸä¸­è·å¾—äº†ç›¸å½“å¤§æ‰¹è¯„ç¾¤ä½“çš„æ˜¯[Eigen](https://eigen.tuxfamily.org)åº“
    **{1}** å’Œ[Armadillo](http://arma.sourceforge.net) **{2}**ã€‚åœ¨é«˜æ€§èƒ½è®¡ç®—ï¼ˆHPCï¼‰é¢†åŸŸï¼Œç¬¬ä¸‰ä¸ªå¤‡å—å…³æ³¨çš„é€‰æ‹©æ˜¯[Blaze](https://bitbucket.org/blaze-lib/blaze)åº“
    **{3}**ã€‚æ—©æœŸçš„åº“[uBLAS](https://www.boost.org/doc/libs/1_81_0/libs/numeric/ublas/doc/index.html)
    **{4}** ä¹Ÿä½œä¸ºBooståº“çš„ä¸€éƒ¨åˆ†å¯ç”¨ï¼›ä½†å®ƒä¸åŒ…æ‹¬å‰è¿°åº“ä¸­æä¾›çš„çŸ©é˜µåˆ†è§£å’Œå…¶ä»–åŠŸèƒ½ã€‚
- en: As a side note, open source R interface packages are available for each of these
    libraries. **{5}** These packages enable the integration of C++ code dependent
    on one or more of these libraries into R packages, usually to enhance run-time
    performance.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºä¸€ä¸ªæ—æ³¨ï¼Œè¿™äº›åº“å„è‡ªéƒ½æœ‰å¼€æºRæ¥å£åŒ… **{5}**ã€‚è¿™äº›åŒ…ä½¿å¾—ä¾èµ–äºå…¶ä¸­ä¸€ä¸ªæˆ–å¤šä¸ªåº“çš„C++ä»£ç å¯ä»¥é›†æˆåˆ°RåŒ…ä¸­ï¼Œé€šå¸¸æ˜¯ä¸ºäº†æé«˜è¿è¡Œæ—¶æ€§èƒ½ã€‚
- en: More recently, NVIDIA has released [GPU-accelerated C++ linear algebra libraries](https://developer.nvidia.com/gpu-accelerated-libraries#linear-algebra)
    as part of its HPC SDK. **{6}**.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€è¿‘ï¼ŒNVIDIAå‘å¸ƒäº†ä½œä¸ºå…¶HPC SDKçš„ä¸€éƒ¨åˆ†çš„[GPUåŠ é€ŸC++çº¿æ€§ä»£æ•°åº“](https://developer.nvidia.com/gpu-accelerated-libraries#linear-algebra)
    **{6}**ã€‚
- en: A comparative list of both open source and commercial C++ linear algebra libraries,
    including those mentioned here, can be found on [Wikipedia](https://en.wikipedia.org/wiki/Comparison_of_linear_algebra_libraries).**{7}**
    A more in-depth view of the Eigen library follows later in this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: åŒ…æ‹¬è¿™é‡Œæåˆ°çš„å†…å®¹åœ¨å†…ï¼Œæ¯”è¾ƒåˆ—è¡¨ä¸­æ¶µç›–äº†å¼€æºå’Œå•†ä¸šC++çº¿æ€§ä»£æ•°åº“ï¼Œå¯åœ¨[Wikipedia](https://en.wikipedia.org/wiki/Comparison_of_linear_algebra_libraries)ä¸Šæ‰¾åˆ°**{7}**ã€‚æœ¬ç« åé¢å°†æ›´è¯¦ç»†åœ°ä»‹ç»Eigenåº“ã€‚
- en: New features planned for C++23 and C++26 look set to finally provide the Standard
    Library with long overdue robust and well-supported linear algebra capabilities.
    Central among these new features is the `std::mdspan` multi-dimensional array
    representation planned for C++23\. C++26 should then be updated with both a standardized
    interface to external BLAS-compatible libraries, as well as its own set of linear
    algebra facilities.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: è®¡åˆ’ä¸­çš„C++23å’ŒC++26çš„æ–°åŠŸèƒ½ä¼¼ä¹æœ€ç»ˆå°†ä¸ºæ ‡å‡†åº“æä¾›æ—¢å¼ºå¤§åˆå¾—åˆ°é•¿ä¹…æ”¯æŒçš„çº¿æ€§ä»£æ•°åŠŸèƒ½ã€‚è¿™äº›æ–°åŠŸèƒ½ä¸­çš„æ ¸å¿ƒæ˜¯ä¸ºC++23è®¡åˆ’çš„`std::mdspan`å¤šç»´æ•°ç»„è¡¨ç¤ºã€‚C++26åº”å½“éšåæ›´æ–°ï¼Œå¢åŠ ä¸€ä¸ªæ ‡å‡†åŒ–æ¥å£ä»¥æ”¯æŒå¤–éƒ¨BLASå…¼å®¹åº“ï¼Œä»¥åŠå…¶è‡ªèº«çš„çº¿æ€§ä»£æ•°å·¥å…·é›†ã€‚
- en: Below, we will first take a trip back in time and examine convenient mathematical
    features of `valarray`, and then demonstrate how it can be used as a proxy for
    a matrix. Following that, we will dive into the Eigen library of the present and
    demonstrate the basic matrix operations, along with matrix decompositions frequently
    used in financial modeling. Finally, a glimpse of the proposals for near-future
    Standard Library releases will also be presented.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢ï¼Œæˆ‘ä»¬é¦–å…ˆå°†æ—¶å…‰å€’æµï¼Œæ¢è®¨`valarray`çš„æ–¹ä¾¿æ•°å­¦ç‰¹æ€§ï¼Œç„¶åæ¼”ç¤ºå®ƒå¦‚ä½•ä½œä¸ºçŸ©é˜µçš„ä»£ç†ä½¿ç”¨ã€‚éšåï¼Œæˆ‘ä»¬å°†æ·±å…¥ä»‹ç»å½“å‰çš„Eigenåº“ï¼Œå¹¶å±•ç¤ºåŸºæœ¬çš„çŸ©é˜µæ“ä½œï¼Œä»¥åŠåœ¨é‡‘èå»ºæ¨¡ä¸­ç»å¸¸ä½¿ç”¨çš„çŸ©é˜µåˆ†è§£ã€‚æœ€åï¼Œè¿˜å°†ç®€è¦ä»‹ç»è¿‘æœŸæ ‡å‡†åº“å‘å¸ƒçš„å»ºè®®ã€‚
- en: valarray and Matrix Operations
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`valarray`å’ŒçŸ©é˜µæ“ä½œ'
- en: The workhorse STL container `std::vector`, as we have seen, is an option for
    representing a vector in the mathematical sense. Common vector arithmetic, such
    as inner products, can be performed using STL algorithms. However, having been
    â€œdesigned to be a general mechanism for holding valuesâ€¦â€‹and to fit into the architecture
    of containers, iterators, and algorithmsâ€ {2.5 Stroustrup, Tour 2E} **{8}**, the
    common arithmetic vector operators such as addition and multiplication were not
    included as members in its implementation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»çœ‹åˆ°ï¼Œä½œä¸ºå·¥ä½œé©¬çš„STLå®¹å™¨`std::vector`æ˜¯è¡¨ç¤ºæ•°å­¦å‘é‡çš„ä¸€ä¸ªé€‰é¡¹ã€‚å¯ä»¥ä½¿ç”¨STLç®—æ³•æ‰§è¡Œå¸¸è§çš„å‘é‡ç®—æœ¯ï¼Œå¦‚å†…ç§¯ã€‚ç„¶è€Œï¼Œâ€œè®¾è®¡ä¸ºä¸€ç§ç”¨äºä¿å­˜å€¼çš„é€šç”¨æœºåˆ¶...å¹¶ä¸”é€‚åº”å®¹å™¨ã€è¿­ä»£å™¨å’Œç®—æ³•çš„æ¶æ„â€
    {2.5 Stroustrup, Tour 2E} **{8}**ï¼Œä½œä¸ºå…¶å®ç°çš„ä¸€éƒ¨åˆ†ï¼Œå¸¸è§çš„ç®—æœ¯å‘é‡è¿ç®—ç¬¦å¦‚åŠ æ³•å’Œä¹˜æ³•å¹¶æœªåŒ…å«åœ¨å…¶ä¸­ã€‚
- en: A Standard Library container class separate from the STL, called `valarray`,
    does support arithmetic operators and provides â€œoptimizations that are often considered
    essential for serious numerical workâ€ {ibid}. With slice and stride functions
    also accompanying the `valarray` class, it can also facilitate representation
    arrays of higher dimension, in particular a matrix.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªç‹¬ç«‹äºSTLçš„æ ‡å‡†åº“å®¹å™¨ç±»ï¼Œç§°ä¸º`valarray`ï¼Œç¡®å®æ”¯æŒç®—æœ¯è¿ç®—ç¬¦ï¼Œå¹¶æä¾›â€œé€šå¸¸è¢«è®¤ä¸ºæ˜¯ä¸¥è‚ƒæ•°å€¼å·¥ä½œæ‰€å¿…éœ€çš„ä¼˜åŒ–â€ {ibid}ã€‚éšç€åˆ‡ç‰‡å’Œæ­¥å¹…å‡½æ•°ä¹Ÿä¼´éšåœ¨`valarray`ç±»æ—ï¼Œå®ƒä¹Ÿå¯ä»¥ä¿ƒè¿›æ›´é«˜ç»´åº¦çš„æ•°ç»„è¡¨ç¤ºï¼Œç‰¹åˆ«æ˜¯çŸ©é˜µã€‚
- en: While `valarray` has these very useful properties that would seem to make it
    an obvious choice for matrix math, it has played to mixed reviews. This dates
    back to its original specification which was never fully complete due to debates
    over whether to require a new technique at the time, expression templates (to
    be introduced shortly), that can significantly optimize performance. In the end,
    this was not mandated. As a result, [â€œinitial implementations were slow, and thus
    users did not want to rely on it.â€](https://wg21.link/p1673) **{9}**
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶`valarray`å…·æœ‰è¿™äº›éå¸¸æœ‰ç”¨çš„å±æ€§ï¼Œä¼¼ä¹ä½¿å…¶æˆä¸ºçŸ©é˜µè¿ç®—çš„æ˜æ˜¾é€‰æ‹©ï¼Œä½†å®ƒå´é¥±å—å¥½è¯„ä¸å·®è¯„å¹¶å­˜ã€‚è¿™ä¸€æƒ…å†µå¯ä»¥è¿½æº¯åˆ°å…¶æœ€åˆçš„è§„èŒƒï¼Œç”±äºå½“æ—¶æ˜¯å¦è¦æ±‚ä¸€ç§æ–°çš„æŠ€æœ¯â€”â€”è¡¨è¾¾å¼æ¨¡æ¿ï¼ˆå³å°†æ¨å‡ºï¼‰ï¼Œå¯ä»¥æ˜¾è‘—ä¼˜åŒ–æ€§èƒ½è€Œè¿›è¡Œçš„è¾©è®ºè€Œä»æœªå®Œå…¨å®Œæˆã€‚æœ€ç»ˆï¼Œè¿™ä¸€è¦æ±‚æœªè¢«å¼ºåˆ¶æ‰§è¡Œã€‚å› æ­¤ï¼Œâ€œæœ€åˆçš„å®ç°é€Ÿåº¦è¾ƒæ…¢ï¼Œå› æ­¤ç”¨æˆ·ä¸æ„¿ä¾èµ–å®ƒã€‚â€ï¼ˆæ¥æºï¼š[é“¾æ¥](https://wg21.link/p1673)
    **{9}**ï¼‰
- en: As of the time of this writing, however, two of the mainstream Standard Library
    distributions have implemented expression template versions of `valarray`, namely
    those that accompany the gcc and Clang compilers. In addition, the [Intel oneAPI
    DPC++/C++ Compiler](https://www.intel.com/content/www/us/en/developer/articles/tool/oneapi-standalone-components.html#dpcpp-cpp)
    **{10}** ships with its own high-performance implementation of `valarray`. And
    as an incidental remark, specializations of `begin` and `end` functions were included
    as enhancements in C++11.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æˆªè‡³æœ¬æ–‡æ’°å†™æ—¶ï¼Œä¸¤ä¸ªä¸»æµçš„æ ‡å‡†åº“å‘è¡Œç‰ˆå·²ç»å®ç°äº† `valarray` çš„è¡¨è¾¾å¼æ¨¡æ¿ç‰ˆæœ¬ï¼Œå³ä¼´éšç€ gcc å’Œ Clang ç¼–è¯‘å™¨çš„é‚£äº›ç‰ˆæœ¬ã€‚æ­¤å¤–ï¼Œ[Intel
    oneAPI DPC++/C++ Compiler](https://www.intel.com/content/www/us/en/developer/articles/tool/oneapi-standalone-components.html#dpcpp-cpp)
    **{10}** è¿˜é…å¤‡äº†å…¶è‡ªå·±çš„é«˜æ€§èƒ½ `valarray` å®ç°ã€‚ä½œä¸ºä¸€ä¸ªé™„å¸¦è¯´æ˜ï¼Œ`begin` å’Œ `end` å‡½æ•°çš„ç‰¹åŒ–ä¹Ÿä½œä¸º C++11 çš„å¢å¼ºåŠŸèƒ½åŒ…å«åœ¨å†…ã€‚
- en: 'The moral of the story seems to be: know the capabilities of the implementation
    you intend to use. If its performance is suitable for your needs, then it can
    potentially be a very convenient option for matrix/vector operations, and vectorized
    versions of common mathematical functions. In addition, examining the properties
    of `valarray` may provide some context for future linear algebra enhancements
    planned for the Standard Library, with similar functionality in some cases, even
    though the implementations behind the scenes will be considerably different.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: æ•…äº‹çš„å¯“æ„ä¼¼ä¹æ˜¯ï¼šäº†è§£ä½ æ‰“ç®—ä½¿ç”¨çš„å®ç°çš„èƒ½åŠ›ã€‚å¦‚æœå…¶æ€§èƒ½é€‚åˆä½ çš„éœ€æ±‚ï¼Œé‚£ä¹ˆå®ƒå¯èƒ½æ˜¯çŸ©é˜µ/å‘é‡æ“ä½œä»¥åŠå¸¸è§æ•°å­¦å‡½æ•°çš„çŸ¢é‡åŒ–ç‰ˆæœ¬çš„éå¸¸ä¾¿åˆ©é€‰é¡¹ã€‚æ­¤å¤–ï¼Œæ£€æŸ¥
    `valarray` çš„å±æ€§å¯èƒ½ä¸ºæ ‡å‡†åº“è®¡åˆ’ä¸­æœªæ¥çš„çº¿æ€§ä»£æ•°å¢å¼ºæä¾›ä¸€äº›èƒŒæ™¯ï¼Œå°½ç®¡åœ¨å¹•åçš„å®ç°åœ¨æŸäº›æƒ…å†µä¸‹ä¼šæœ‰æ˜¾è‘—å·®å¼‚ã€‚
- en: Arithmetic Operators and Math functions
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç®—æœ¯è¿ç®—ç¬¦å’Œæ•°å­¦å‡½æ•°
- en: The `valarray` container supports the standard arithmetic operators on an element-by-element
    basis, as well as scalar multiplication.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`valarray` å®¹å™¨æ”¯æŒæŒ‰å…ƒç´ è¿›è¡Œçš„æ ‡å‡†ç®—æœ¯è¿ç®—ç¬¦ï¼Œä»¥åŠæ ‡é‡ä¹˜æ³•ã€‚'
- en: 'For example, the vector sum expression <math alttext="3 bold v 1 plus one-half
    bold v 2"><mrow><mn>3</mn> <msub><mi>ğ¯</mi> <mn>1</mn></msub> <mo>+</mo> <mfrac><mn>1</mn>
    <mn>2</mn></mfrac> <msub><mi>ğ¯</mi> <mn>2</mn></msub></mrow></math> can be naturally
    transcribed from a mathematical statement into C++ using `valarray` objects:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œå‘é‡å’Œè¡¨è¾¾å¼ <math alttext="3 bold v 1 plus one-half bold v 2"><mrow><mn>3</mn>
    <msub><mi>ğ¯</mi> <mn>1</mn></msub> <mo>+</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac>
    <msub><mi>ğ¯</mi> <mn>2</mn></msub></mrow></math> å¯ä»¥è‡ªç„¶åœ°è½¬å½•ä¸º C++ ä¸­ä½¿ç”¨ `valarray` å¯¹è±¡çš„æ•°å­¦è¯­å¥ï¼š
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The result is
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æœæ˜¯
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Element-by-element* multiplication is also implemented with the `*` operator:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*é€å…ƒç´ *ä¹˜æ³•ä¹Ÿæ˜¯é€šè¿‡`*`è¿ç®—ç¬¦å®ç°çš„ï¼š'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This gives us
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç»™äº†æˆ‘ä»¬
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The dot (or inner) product of <math alttext="v 1"><msub><mi>v</mi> <mn>1</mn></msub></math>
    and <math alttext="v 2"><msub><mi>v</mi> <mn>2</mn></msub></math> is easily obtained
    by summing the preceding result by invoking the `sum()` member function on the
    `valarray` class:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: å‘é‡ <math alttext="v 1"><msub><mi>v</mi> <mn>1</mn></msub></math> å’Œ <math alttext="v
    2"><msub><mi>v</mi> <mn>2</mn></msub></math> çš„ç‚¹ï¼ˆæˆ–å†…ï¼‰ç§¯å¯é€šè¿‡åœ¨ `valarray` ç±»çš„ `sum()`
    æˆå‘˜å‡½æ•°ä¸Šè°ƒç”¨å‰è¿°ç»“æœæ¥è½»æ¾è·å¾—ï¼š
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In addition to `sum`, `valarray` also has `max` and `min` functions, along
    with an `apply(.)` member function that applies an auxiliary function similar
    to `std::transform`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: é™¤äº† `sum` å¤–ï¼Œ`valarray` è¿˜æœ‰ `max` å’Œ `min` å‡½æ•°ï¼Œä»¥åŠä¸€ä¸ª `apply(.)` æˆå‘˜å‡½æ•°ï¼Œå®ƒç±»ä¼¼äº `std::transform`
    åº”ç”¨è¾…åŠ©å‡½æ•°ï¼š
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A subset of the `cmath` functions is conveniently defined for vectorized operations
    on the entirety of a `valarray`. For example, the following operations will return
    a `valarray` containing the images of the respective functions applied to each
    element in `v1` and `neg_val` below. Note that we can also negate each element
    in the same way as a plain numerical type with the subtraction operator.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmath` å‡½æ•°çš„å­é›†è¢«æ–¹ä¾¿åœ°å®šä¹‰ç”¨äº `valarray` çš„çŸ¢é‡åŒ–æ“ä½œã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹æ“ä½œå°†è¿”å›ä¸€ä¸ªåŒ…å«åº”ç”¨äº `v1` å’Œ `neg_val`
    ä¸­æ¯ä¸ªå…ƒç´ çš„ç›¸åº”å‡½æ•°æ˜ åƒçš„ `valarray`ã€‚è¯·æ³¨æ„ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥åƒæ™®é€šæ•°å€¼ç±»å‹ä¸€æ ·ä½¿ç”¨å‡æ³•è¿ç®—ç¬¦å¯¹æ¯ä¸ªå…ƒç´ å–åã€‚'
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, as of C++11, specializations of the `begin` and `end` functions analagous
    to those provided for STL containers have been implemented for `valarray`. A simple
    example is as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæˆªè‡³ C++11ï¼Œç±»ä¼¼äºä¸º STL å®¹å™¨æä¾›çš„ `begin` å’Œ `end` å‡½æ•°çš„ç‰¹åŒ–å·²ç»ä¸º `valarray` å®ç°ã€‚ä¸€ä¸ªç®€å•çš„ä¾‹å­å¦‚ä¸‹ï¼š
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Given the `apply(.)` member function on `valarray` and the built-in vectorized
    mathematical functions that are already available, STL algorithms `for_each` and
    `transform` might not be needed as often in the case of `valarray` compared to
    STL containers, however.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: é‰´äºåœ¨`valarray`ä¸Šç»™å®š`apply(.)`æˆå‘˜å‡½æ•°å’Œå·²æœ‰çš„å†…ç½®å‘é‡åŒ–æ•°å­¦å‡½æ•°ï¼Œä¸STLå®¹å™¨ç›¸æ¯”ï¼Œåœ¨`valarray`çš„æƒ…å†µä¸‹ï¼Œå¯èƒ½ä¸ç»å¸¸éœ€è¦ä½¿ç”¨STLç®—æ³•`for_each`å’Œ`transform`ã€‚
- en: valarray as a Matrix Proxy
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä½œä¸ºçŸ©é˜µä»£ç†çš„`valarray`
- en: '`valarray` provides the facilities to represent multidimensional arrays. In
    our case, we are specifically concerned with representing a two-dimensional array
    as a proxy for a matrix. This can be achieved with the `slice(.)` member function
    that can extract a reference to an individual row or column.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`valarray`æä¾›äº†è¡¨ç¤ºå¤šç»´æ•°ç»„çš„åŠŸèƒ½ã€‚åœ¨æˆ‘ä»¬çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ç‰¹åˆ«å…³æ³¨å°†äºŒç»´æ•°ç»„è¡¨ç¤ºä¸ºçŸ©é˜µçš„ä»£ç†ã€‚è¿™å¯ä»¥é€šè¿‡`slice(.)`æˆå‘˜å‡½æ•°æ¥å®ç°ï¼Œè¯¥å‡½æ•°å¯ä»¥æå–å¯¹å•ä¸ªè¡Œæˆ–åˆ—çš„å¼•ç”¨ã€‚'
- en: To demonstrate this, let us first lighten the notation by defining the alias
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†æ¼”ç¤ºè¿™ä¸€ç‚¹ï¼Œè®©æˆ‘ä»¬é¦–å…ˆé€šè¿‡å®šä¹‰åˆ«åæ¥ç®€åŒ–è¡¨ç¤ºæ–¹å¼
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, create a `valarray` object `val`, with the code formatted in a way to
    make it look like a 4 <math alttext="times"><mo>Ã—</mo></math> 3 matrix:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼Œåˆ›å»ºä¸€ä¸ª`valarray`å¯¹è±¡`val`ï¼Œå¹¶å°†ä»£ç æ ¼å¼åŒ–ï¼Œä½¿å…¶çœ‹èµ·æ¥åƒä¸€ä¸ª4 <math alttext="times"><mo>Ã—</mo></math>
    3çŸ©é˜µï¼š
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first row can be retrieved using the `std::slice` function, defined for
    a `valarray`, using the square bracket operator.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: å¯ä»¥ä½¿ç”¨ä¸º`valarray`å®šä¹‰çš„`std::slice`å‡½æ•°æ£€ç´¢ç¬¬ä¸€è¡Œï¼Œä½¿ç”¨æ–¹æ‹¬å·æ“ä½œç¬¦ã€‚
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'What this says is:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¥è¯çš„æ„æ€æ˜¯ï¼š
- en: 'Go to the first element of the `valarray`: index 0, value = 1.0.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è½¬åˆ°`valarray`çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼šç´¢å¼•0ï¼Œå€¼ä¸º1.0ã€‚
- en: Choose 3 elements, beginning with the first
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: é€‰æ‹©3ä¸ªå…ƒç´ ï¼Œä»ç¬¬ä¸€ä¸ªå¼€å§‹
- en: Using a *stride* of 1, which in this case means to choose three consecutive
    rowwise elements
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨*æ­¥é•¿*ä¸º1ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹æ„å‘³ç€é€‰æ‹©è¿ç»­çš„ä¸‰ä¸ªæŒ‰è¡Œæ’åˆ—çš„å…ƒç´ 
- en: 'Similarly, the second column can be retrieved, using in this case a stride
    of 3, the number of columns:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: åŒæ ·åœ°ï¼Œç¬¬äºŒåˆ—å¯ä»¥ä½¿ç”¨æ­¥é•¿ä¸º3æ¥æ£€ç´¢ï¼Œåˆ—æ•°ä¸ºï¼š
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It is important to note the `slice(.)` function returns a lighter `slice_array`
    typeâ€‰â€”â€‰that acts as a reference to the selected elementsâ€‰â€”â€‰rather than a full
    `valarray`. It does not, however, provide the necessary member functions and operators
    to access individual elements or compute, say, new rows comprising a matrix product.
    If we want to apply these functions to row or column data, we will need to construct
    corresponding new `valarray` objects. This will be seen in the next example, computing
    the dot product of a row in one matrix by the column in another, a necessary option
    in carrying out matrix multiplication.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ`slice(.)`å‡½æ•°è¿”å›ä¸€ä¸ªè¾ƒè½»çš„`slice_array`ç±»å‹ï¼Œä½œä¸ºæ‰€é€‰å…ƒç´ çš„å¼•ç”¨ï¼Œè€Œä¸æ˜¯å®Œæ•´çš„`valarray`ã€‚ç„¶è€Œï¼Œå®ƒå¹¶ä¸æä¾›è®¿é—®å•ä¸ªå…ƒç´ æˆ–è®¡ç®—æ–°è¡Œï¼ˆä¾‹å¦‚çŸ©é˜µä¹˜ç§¯ï¼‰æ‰€éœ€çš„æˆå‘˜å‡½æ•°å’Œè¿ç®—ç¬¦ã€‚å¦‚æœæˆ‘ä»¬æƒ³å°†è¿™äº›å‡½æ•°åº”ç”¨äºè¡Œæˆ–åˆ—æ•°æ®ï¼Œæˆ‘ä»¬å°†éœ€è¦æ„é€ ç›¸åº”çš„æ–°`valarray`å¯¹è±¡ã€‚è¿™å°†åœ¨ä¸‹ä¸€ä¸ªç¤ºä¾‹ä¸­çœ‹åˆ°ï¼Œå³è®¡ç®—ä¸€ä¸ªçŸ©é˜µä¸­ä¸€è¡Œä¸å¦ä¸€ä¸ªçŸ©é˜µä¸­ä¸€åˆ—çš„ç‚¹ç§¯ï¼Œè¿™åœ¨æ‰§è¡ŒçŸ©é˜µä¹˜æ³•æ—¶æ˜¯å¿…éœ€çš„é€‰é¡¹ã€‚
- en: To demonstrate this, suppose we have a 5 <math alttext="times"><mo>Ã—</mo></math>
    3 and a 3 <math alttext="times"><mo>Ã—</mo></math> 5 matrix, each represented as
    a `valarray`. Note that we are also storing the number of rows and columns of
    each in separate variables.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†æ¼”ç¤ºè¿™ä¸€ç‚¹ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ª5 <math alttext="times"><mo>Ã—</mo></math> 3å’Œä¸€ä¸ª3 <math alttext="times"><mo>Ã—</mo></math>
    5çš„çŸ©é˜µï¼Œæ¯ä¸ªéƒ½è¡¨ç¤ºä¸º`valarray`ã€‚æ³¨æ„ï¼Œæˆ‘ä»¬è¿˜åˆ†åˆ«å­˜å‚¨äº†æ¯ä¸ªçš„è¡Œæ•°å’Œåˆ—æ•°ã€‚
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we were to apply matrix multiplication, it would require taking the dot
    product of each row of the first â€œmatrixâ€ by each column of the second. As an
    example, in order to get the dot product of the third row by the second column,
    we would first need the slice for each:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬è¦åº”ç”¨çŸ©é˜µä¹˜æ³•ï¼Œéœ€è¦è®¡ç®—ç¬¬ä¸€ä¸ªâ€œçŸ©é˜µâ€çš„æ¯ä¸€è¡Œä¸ç¬¬äºŒä¸ªâ€œçŸ©é˜µâ€çš„æ¯ä¸€åˆ—çš„ç‚¹ç§¯ã€‚ä¾‹å¦‚ï¼Œä¸ºäº†è·å¾—ç¬¬ä¸‰è¡Œä¸ç¬¬äºŒåˆ—çš„ç‚¹ç§¯ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦å¯¹æ¯ä¸ªè¿›è¡Œåˆ‡ç‰‡ï¼š
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'However, neither element-by-element multiplication nor the `sum()` member function
    is defined on a `slice_array`, so we need to construct corresponding `valarray`
    objects:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œ`slice_array`ä¸Šæ—¢ä¸å®šä¹‰é€å…ƒç´ ä¹˜æ³•ï¼Œä¹Ÿä¸å®šä¹‰`sum()`æˆå‘˜å‡½æ•°ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦æ„é€ ç›¸åº”çš„`valarray`å¯¹è±¡ï¼š
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The dot product is then computed in the usual way:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæŒ‰é€šå¸¸çš„æ–¹å¼è®¡ç®—ç‚¹ç§¯ï¼š
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Caution
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: æ³¨æ„
- en: 'As previously noted, a `slice_array` acts as a reference to a block within
    a `valarray`. Operations and member functions such as `\*` and `sum` are not defined
    on `slice_array`, but assignment operators such as `*=` and `+=` are. Therefore,
    modification of a `slice_array` such as in the following example will also be
    reflected in the `valarray` itself. If we take the first row of `va01` as a slice:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚å‰é¢æ‰€è¿°ï¼Œ`slice_array`å……å½“`valarray`ä¸­å—çš„å¼•ç”¨ã€‚åœ¨`slice_array`ä¸Šæœªå®šä¹‰æ“ä½œå’Œæˆå‘˜å‡½æ•°ï¼Œå¦‚`\*`å’Œ`sum`ï¼Œä½†æ˜¯èµ‹å€¼è¿ç®—ç¬¦å¦‚`*=`å’Œ`+=`æ˜¯å®šä¹‰è¿‡çš„ã€‚å› æ­¤ï¼Œå¯¹`slice_array`çš„ä¿®æ”¹ï¼Œå¦‚ä¸‹é¢çš„ç¤ºä¾‹ä¸­æ‰€ç¤ºï¼Œä¹Ÿä¼šåæ˜ åœ¨`valarray`æœ¬èº«ä¸­ã€‚å¦‚æœæˆ‘ä»¬å°†`va01`çš„ç¬¬ä¸€è¡Œä½œä¸ºä¸€ä¸ªåˆ‡ç‰‡ï¼š
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: and then apply assignment operators
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶ååº”ç”¨èµ‹å€¼è¿ç®—ç¬¦
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: then the `valarray` contents would be
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶å`valarray`çš„å†…å®¹å°†æ˜¯
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In summary, `valarray` conveniently provides the ability to apply mathematical
    operators and functions on an entire array, similar to Fortran 90, as well as
    more math-focused languages such as R and Matlab . As a reminder, however, performance
    can be highly dependent on the implementation used in your Standard Library distribution.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: æ€»ä¹‹ï¼Œ`valarray`æ–¹ä¾¿åœ°æä¾›äº†åœ¨æ•´ä¸ªæ•°ç»„ä¸Šåº”ç”¨æ•°å­¦è¿ç®—ç¬¦å’Œå‡½æ•°çš„èƒ½åŠ›ï¼Œç±»ä¼¼äºFortran 90ï¼Œä»¥åŠæ›´å¤šä¸“æ³¨äºæ•°å­¦çš„è¯­è¨€å¦‚Rå’ŒMatlabã€‚ç„¶è€Œï¼Œè¯·è®°ä½ï¼Œæ€§èƒ½å¾ˆå¤§ç¨‹åº¦ä¸Šå–å†³äºæ‚¨æ ‡å‡†åº“åˆ†å‘ä¸­ä½¿ç”¨çš„å®ç°ã€‚
- en: More information about `valarray`, its history, and its pros and cons can be
    found in [the online supplemental chapter accompanying Josuttis, _The C++ Standard
    Library, second edition](http://www.cppstdlib.com/cppstdlib_supplementary.pdf)).
    **{11}**
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰å…³`valarray`ã€å…¶å†å²ä»¥åŠå…¶ä¼˜ç¼ºç‚¹çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…[ã€ŠC++æ ‡å‡†åº“ ç¬¬äºŒç‰ˆã€‹é™„å¸¦çš„åœ¨çº¿è¡¥å……ç« èŠ‚](http://www.cppstdlib.com/cppstdlib_supplementary.pdf))ã€‚**{11}**
- en: Subsequent to `valarray` and C++98, there have been some very positive developments
    regarding linear algebra in C++, some of which will now be presented.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨`valarray`å’ŒC++98ä¹‹åï¼ŒC++åœ¨çº¿æ€§ä»£æ•°æ–¹é¢æœ‰äº†ä¸€äº›éå¸¸ç§¯æçš„å‘å±•ï¼Œå…¶ä¸­ä¸€äº›ç°åœ¨å°†è¢«ä»‹ç»ã€‚
- en: Eigen
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eigen
- en: The first release of the Eigen library became available in 2006\. Since then,
    it has been expanded to version 3.4.0 as of August of 2021\. Starting with version
    3.3.1, it has been licensed under the reasonably liberal Mozilla Public License
    (MPL) 2.0.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Eigenåº“çš„ç¬¬ä¸€ä¸ªç‰ˆæœ¬äº2006å¹´å‘å¸ƒã€‚è‡ªé‚£æ—¶èµ·ï¼Œæˆªè‡³2021å¹´8æœˆï¼Œå®ƒå·²æ‰©å±•åˆ°ç‰ˆæœ¬3.4.0ã€‚ä»ç‰ˆæœ¬3.3.1å¼€å§‹ï¼Œå®ƒå·²æ ¹æ®åˆç†å®½æ¾çš„Mozilla
    Public License (MPL) 2.0è®¸å¯å‘å¸ƒã€‚
- en: Eigen is comprised of template code that makes inclusion into other C++ projects
    very easy, in that in its standard installation there is no linking necessary
    to external binary files. Its incorporation of expression templates, facilitating
    lazy evaluation, provides for enhanced computational performance. It also received
    a a further boost in popularity after being chosen for incorporation into the
    well-respected [TensorFlow](https://www.tensorflow.org) **{12}** machine learning
    library, as well as the [Stan Math Library](https://mc-stan.org/users/interfaces/math).
    **{13}** More background on its suitability and popularity in finance is presented
    in a recent [Quantstart](https://www.quantstart.com/articles/Eigen-Library-for-Matrix-Algebra-in-C/)
    article **{14}**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Eigenç”±æ¨¡æ¿ä»£ç ç»„æˆï¼Œä½¿å…¶éå¸¸å®¹æ˜“åŒ…å«åˆ°å…¶ä»–C++é¡¹ç›®ä¸­ï¼Œåœ¨å…¶æ ‡å‡†å®‰è£…ä¸­ä¸éœ€è¦é“¾æ¥åˆ°å¤–éƒ¨äºŒè¿›åˆ¶æ–‡ä»¶ã€‚å®ƒçš„è¡¨è¾¾å¼æ¨¡æ¿çš„æ•´åˆï¼Œä¿ƒè¿›äº†æƒ°æ€§è¯„ä¼°ï¼Œæä¾›äº†å¢å¼ºçš„è®¡ç®—æ€§èƒ½ã€‚åœ¨è¢«é€‰æ‹©ç”¨äºè‘—åçš„[TensorFlow](https://www.tensorflow.org)æœºå™¨å­¦ä¹ åº“ä»¥åŠ[Stanæ•°å­¦åº“](https://mc-stan.org/users/interfaces/math)åˆå¹¶ä¹‹åï¼Œå®ƒçš„å—æ¬¢è¿ç¨‹åº¦è¿›ä¸€æ­¥æå‡ã€‚**{12}**
    å…³äºå®ƒåœ¨é‡‘èé¢†åŸŸé€‚ç”¨æ€§å’Œå—æ¬¢è¿ç¨‹åº¦çš„æ›´å¤šèƒŒæ™¯å¯ä»¥åœ¨æœ€è¿‘çš„[Quantstart](https://www.quantstart.com/articles/Eigen-Library-for-Matrix-Algebra-in-C/)æ–‡ç« ä¸­æ‰¾åˆ°ã€‚**{13}**
- en: Finally, the Eigen library is very well documented, with a tutorial and examples
    to help the newcomer get up and running quickly.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼ŒEigenåº“æœ‰éå¸¸å¥½çš„æ–‡æ¡£ï¼Œé…æœ‰æ•™ç¨‹å’Œç¤ºä¾‹ï¼Œå¯ä»¥å¸®åŠ©æ–°æ‰‹å¿«é€Ÿä¸Šæ‰‹ã€‚
- en: Lazy Evaluation
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æƒ°æ€§è¯„ä¼°
- en: Lazy evaluation defers and minimizes the number of operations required in matrix
    and vector operations. Expression templates in C++ are used to encapsulate arithmetic
    operations â€“ that is, expressions â€“ inside templates such that they are delayed
    until they are actually needed. This can reduce the total number of operations,
    assignments, and temporary objects that are created when using conventional approaches.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: æƒ°æ€§è¯„ä¼°æ¨è¿Ÿå’Œæœ€å°åŒ–äº†çŸ©é˜µå’Œå‘é‡è¿ç®—ä¸­æ‰€éœ€çš„æ“ä½œæ•°ã€‚C++ä¸­çš„è¡¨è¾¾å¼æ¨¡æ¿ç”¨äºå°è£…ç®—æœ¯æ“ä½œï¼ˆå³è¡¨è¾¾å¼ï¼‰åœ¨æ¨¡æ¿å†…ï¼Œå»¶è¿Ÿç›´åˆ°å®é™…éœ€è¦å®ƒä»¬ã€‚è¿™å¯ä»¥å‡å°‘ä½¿ç”¨ä¼ ç»Ÿæ–¹æ³•æ—¶åˆ›å»ºçš„æ€»æ“ä½œæ•°ã€èµ‹å€¼å’Œä¸´æ—¶å¯¹è±¡çš„æ•°é‡ã€‚
- en: An example of lazy evaluation that follows is based on a more comprehensive
    and illustrative discussion in the book by [Peter Gottschling on modern C++ for
    scientific programing](https://www.pearson.com/en-us/subject-catalog/p/discovering-modern-c-/P200000000286/9780136677642).
    **{15}**
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢æ˜¯åŸºäºæ›´å…¨é¢å’Œå›¾è§£è®¨è®ºçš„å»¶è¿Ÿè¯„ä¼°ç¤ºä¾‹ï¼Œå¯ä»¥åœ¨[å½¼å¾—Â·æˆˆç‰¹æ—çš„ç°ä»£ç§‘å­¦ç¨‹åºè®¾è®¡ä¸­](https://www.pearson.com/en-us/subject-catalog/p/discovering-modern-c-/P200000000286/9780136677642)æ‰¾åˆ°æ›´è¯¦ç»†çš„ä¿¡æ¯ã€‚
    **{15}**
- en: Suppose you have four vectors in the mathematical sense, each with the same
    fixed number of elements, say
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æ‚¨åœ¨æ•°å­¦æ„ä¹‰ä¸Šæœ‰å››ä¸ªå‘é‡ï¼Œæ¯ä¸ªå‘é‡éƒ½æœ‰ç›¸åŒæ•°é‡çš„å›ºå®šå…ƒç´ ï¼Œæ¯”å¦‚
- en: <math alttext="bold v 1 comma bold v 2 comma bold v 3 comma bold v 4" display="block"><mrow><msub><mi>ğ¯</mi>
    <mn>1</mn></msub> <mo>,</mo> <msub><mi>ğ¯</mi> <mn>2</mn></msub> <mo>,</mo> <msub><mi>ğ¯</mi>
    <mn>3</mn></msub> <mo>,</mo> <msub><mi>ğ¯</mi> <mn>4</mn></msub></mrow></math>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold v 1 comma bold v 2 comma bold v 3 comma bold v 4" display="block"><mrow><msub><mi>ğ¯</mi>
    <mn>1</mn></msub> <mo>,</mo> <msub><mi>ğ¯</mi> <mn>2</mn></msub> <mo>,</mo> <msub><mi>ğ¯</mi>
    <mn>3</mn></msub> <mo>,</mo> <msub><mi>ğ¯</mi> <mn>4</mn></msub></mrow></math>
- en: and you wish to store their sum in a vector *y*. The traditional approach would
    be to define the addition operator, take successive sums and store them in temporary
    objects, ultimately computing the final sum and assigning it to *y*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¶ä¸”æ‚¨å¸Œæœ›å°†å®ƒä»¬çš„å’Œå­˜å‚¨åœ¨å‘é‡*y*ä¸­ã€‚ä¼ ç»Ÿæ–¹æ³•æ˜¯å®šä¹‰åŠ æ³•è¿ç®—ç¬¦ï¼Œè¿ç»­æ±‚å’Œå¹¶å°†å®ƒä»¬å­˜å‚¨åœ¨ä¸´æ—¶å¯¹è±¡ä¸­ï¼Œæœ€ç»ˆè®¡ç®—æœ€ç»ˆå’Œå¹¶åˆ†é…ç»™*y*ã€‚
- en: 'In code, the operator could be defined in the generic sense such that vector
    addition would be defined for any arithmetic type:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä»£ç ä¸­ï¼Œæ“ä½œç¬¦å¯ä»¥ä»¥é€šç”¨æ–¹å¼å®šä¹‰ï¼Œä½¿å¾—å‘é‡åŠ æ³•å¯¹äºä»»ä½•ç®—æœ¯ç±»å‹éƒ½å®šä¹‰æ˜ç¡®ï¼š
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Computing the sum of four vectors as follows
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: è®¡ç®—å››ä¸ªå‘é‡çš„å’Œå¦‚ä¸‹
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'results in the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¼è‡´ä»¥ä¸‹ç»“æœï¼š
- en: 4 - 1 = 3 `vector` instances created (two temporary plus one final `y` instance)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 - 1 = 3ä¸ª`vector`å®ä¾‹åˆ›å»ºï¼ˆä¸¤ä¸ªä¸´æ—¶åŠ ä¸€ä¸ªæœ€ç»ˆçš„`y`å®ä¾‹ï¼‰
- en: (4 - 1) <math alttext="times"><mo>Ã—</mo></math> 3 assignments of `double` variables
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (4 - 1) <math alttext="times"><mo>Ã—</mo></math> 3ä¸ª`double`å˜é‡çš„åˆ†é…
- en: As the number of vectors (say *m*) and the number of elements in each vector
    (say *n*) get larger, this generalizes to
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: å½“å‘é‡æ•°é‡ï¼ˆæ¯”å¦‚*m*ï¼‰å’Œæ¯ä¸ªå‘é‡ä¸­çš„å…ƒç´ æ•°é‡ï¼ˆæ¯”å¦‚*n*ï¼‰å¢åŠ æ—¶ï¼Œè¿™å°†å˜å¾—æ›´åŠ æ™®éï¼š
- en: 'm â€“ 1 `vector` objects allocated on the heap: m - 2 temporary, plus one return
    object (`y`)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: m â€“ 1ä¸ªå †ä¸Šåˆ†é…çš„`vector`å¯¹è±¡ï¼šm - 2ä¸ªä¸´æ—¶å¯¹è±¡ï¼ŒåŠ ä¸Šä¸€ä¸ªè¿”å›å¯¹è±¡(`y`)
- en: <math alttext="left-parenthesis m minus 1 right-parenthesis n"><mrow><mo>(</mo>
    <mi>m</mi> <mo>-</mo> <mn>1</mn> <mo>)</mo> <mi>n</mi></mrow></math> assignments
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math alttext="left-parenthesis m minus 1 right-parenthesis n"><mrow><mo>(</mo>
    <mi>m</mi> <mo>-</mo> <mn>1</mn> <mo>)</mo> <mi>n</mi></mrow></math> åˆ†é…
- en: With lazy evaluation, we can reduce the total number of steps, and thus improve
    efficiency for â€œlargeâ€ *m* and *n*. More specifically, this can be accomplished
    by delaying the addition until all the data is ready, and then only at that time
    perform the sums for each element in the result. In code, this could be accomplished
    by writing a function as follows.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨å»¶è¿Ÿè¯„ä¼°ï¼Œæˆ‘ä»¬å¯ä»¥å‡å°‘æ€»æ­¥éª¤æ•°ï¼Œä»è€Œæé«˜â€œå¤§â€*m*å’Œ*n*çš„æ•ˆç‡ã€‚æ›´å…·ä½“åœ°è¯´ï¼Œè¿™å¯ä»¥é€šè¿‡å»¶è¿Ÿæ·»åŠ ç›´åˆ°æ‰€æœ‰æ•°æ®å‡†å¤‡å¥½ï¼Œç„¶åä»…åœ¨é‚£æ—¶ä¸ºç»“æœä¸­çš„æ¯ä¸ªå…ƒç´ æ‰§è¡Œæ±‚å’Œæ¥å®ç°ã€‚åœ¨ä»£ç ä¸­ï¼Œè¿™å¯ä»¥é€šè¿‡ç¼–å†™å¦‚ä¸‹å‡½æ•°æ¥å®ç°ã€‚
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, in this case,
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ
- en: There are *no* temporary `vector` objects created; only the `sum` result is
    necessary
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ²¡æœ‰ä¸´æ—¶`vector`å¯¹è±¡ï¼›åªéœ€è¦`sum`ç»“æœ
- en: The number of assignments is reduced to *n* = 4
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å‡å°‘åˆ†é…æ•°é‡è‡³ *n* = 4
- en: The Eigen documentation provides additional background in the section [Lazy
    Evaluation and Aliasing](https://eigen.tuxfamily.org/dox/TopicLazyEvaluation.html).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Eigenæ–‡æ¡£åœ¨[å»¶è¿Ÿè¯„ä¼°å’Œåˆ«å](https://eigen.tuxfamily.org/dox/TopicLazyEvaluation.html)éƒ¨åˆ†æä¾›äº†æ›´å¤šèƒŒæ™¯ä¿¡æ¯ã€‚
- en: The previous example demonstrates how lazy evaluation can work, but the obvious
    problem is it would be unrealistic to write individual sum functions for all possible
    fixed numbers of vectors. Generalizing with expression templates is a far more
    challenging problem that will not be included here, but more information can be
    found in the Gottschling book {ibid 12}, as well as in Chapter 27 of the comprehensive
    book on C++ templates by [Vandevoorde, Josuttis, and Gregor](http://tmplbook.com/)
    **{16}**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šè¿°ç¤ºä¾‹æ¼”ç¤ºäº†å»¶è¿Ÿè¯„ä¼°å¦‚ä½•å·¥ä½œï¼Œä½†æ˜¾è€Œæ˜“è§çš„é—®é¢˜æ˜¯ä¸ºæ‰€æœ‰å¯èƒ½çš„å›ºå®šå‘é‡æ•°ç¼–å†™å•ç‹¬çš„æ±‚å’Œå‡½æ•°æ˜¯ä¸ç°å®çš„ã€‚ä½¿ç”¨è¡¨è¾¾å¼æ¨¡æ¿è¿›è¡Œæ³›åŒ–æ˜¯ä¸€ä¸ªæ›´å…·æŒ‘æˆ˜æ€§çš„é—®é¢˜ï¼Œè¿™é‡Œä¸åŒ…æ‹¬è¯¦ç»†ä»‹ç»ï¼Œä½†å¯ä»¥åœ¨æˆˆç‰¹æ—çš„ä¹¦ä¸­æ‰¾åˆ°æ›´å¤šä¿¡æ¯{ibid
    12}ï¼Œä»¥åŠåœ¨[Vandevoordeã€Josuttiså’ŒGregorçš„C++æ¨¡æ¿ç»¼åˆä¹¦ç±](http://tmplbook.com/)çš„ç¬¬27ç« ä¸­ **{16}**ã€‚
- en: Like any other optimization tool, it should not be applied blindly in the belief
    it will automatically make your code more efficient, as again there are cases
    where performance could actually be degraded.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ä»»ä½•å…¶ä»–ä¼˜åŒ–å·¥å…·ä¸€æ ·ï¼Œä¸åº”ç›²ç›®åº”ç”¨ä»¥ä¸ºå®ƒä¼šè‡ªåŠ¨ä½¿æ‚¨çš„ä»£ç æ›´é«˜æ•ˆï¼Œå› ä¸ºåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæ€§èƒ½å®é™…ä¸Šå¯èƒ½ä¼šé™ä½ã€‚
- en: Finally, for a very interesting presentation of a real-world case study of expression
    templates in financial risk management, a talk on the subject [presented by Bowie
    Owens at CppCon 2019](https://www.youtube.com/watch?v=4IUCBx5fIv0) **{17}** is
    very well worth watching.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œå¯¹äºé‡‘èé£é™©ç®¡ç†ä¸­è¡¨è¾¾å¼æ¨¡æ¿çš„éå¸¸æœ‰è¶£çš„å®é™…æ¡ˆä¾‹æ¼”ç¤ºï¼Œå»ºè®®è§‚çœ‹ç”±Bowie Owensåœ¨CppCon 2019ä¸Šå±•ç¤ºçš„ä¸»é¢˜æ¼”è®² [presented
    by Bowie Owens at CppCon 2019](https://www.youtube.com/watch?v=4IUCBx5fIv0) **{17}**
    ã€‚
- en: Eigen Matrices and Vectors
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EigençŸ©é˜µå’Œå‘é‡
- en: The heart of the Eigen library is, not surprisingly, the `Matrix` template class.
    It is scoped with the `Eigen` namespace and requires the `Dense` header file be
    included. At the time of this writing, corresponding module imports have not yet
    been standardized. This means the header file will need to be included in the
    global fragment of a module.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Eigenåº“çš„æ ¸å¿ƒä¸å‡ºæ„å¤–åœ°æ˜¯`Matrix`æ¨¡æ¿ç±»ã€‚å®ƒåœ¨`Eigen`å‘½åç©ºé—´ä¸­å®šä¹‰ï¼Œå¹¶éœ€è¦åŒ…å«`Dense`å¤´æ–‡ä»¶ã€‚åœ¨æ’°å†™æœ¬æ–‡æ—¶ï¼Œå¯¹åº”çš„æ¨¡å—å¯¼å…¥å°šæœªæ ‡å‡†åŒ–ã€‚è¿™æ„å‘³ç€å¤´æ–‡ä»¶éœ€è¦åŒ…å«åœ¨æ¨¡å—çš„å…¨å±€ç‰‡æ®µä¸­ã€‚
- en: The `Matrix` class carries six template parameters, but a variety of aliases
    are provided as specific types. These include fixed square matrix dimensions up
    to a maximum of four, as well as dynamic types for arbitrary numbers of rows and
    columns. The numerical type that a `Matrix` holds is also a template parameter,
    but this setting is also incorporated into individual aliases. For example, the
    following code will construct and display a fixed 3 <math alttext="times"><mo>Ã—</mo></math>
    3 matrix of `double` values, and a 4 <math alttext="times"><mo>Ã—</mo></math> 4
    matrix of `int`s. Braced (uniform) initialization by row can be used to load the
    data at construction.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Matrix`ç±»å…·æœ‰å…­ä¸ªæ¨¡æ¿å‚æ•°ï¼Œä½†æä¾›äº†å¤šç§åˆ«åä½œä¸ºç‰¹å®šç±»å‹ã€‚è¿™äº›åŒ…æ‹¬å›ºå®šæ–¹é˜µç»´åº¦æœ€å¤šä¸ºå››çš„ç±»å‹ï¼Œä»¥åŠç”¨äºä»»æ„è¡Œå’Œåˆ—æ•°çš„åŠ¨æ€ç±»å‹ã€‚`Matrix`æ‰€æŒæœ‰çš„æ•°å€¼ç±»å‹ä¹Ÿæ˜¯ä¸€ä¸ªæ¨¡æ¿å‚æ•°ï¼Œä½†æ­¤è®¾ç½®ä¹Ÿå·²åˆå¹¶åˆ°å„ä¸ªåˆ«åä¸­ã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹ä»£ç å°†æ„é€ å¹¶æ˜¾ç¤ºä¸€ä¸ª`double`å€¼çš„å›ºå®š3
    <math alttext="times"><mo>Ã—</mo></math> 3çŸ©é˜µï¼Œä»¥åŠä¸€ä¸ª`int`çš„4 <math alttext="times"><mo>Ã—</mo></math>
    4çŸ©é˜µã€‚åœ¨æ„é€ æ—¶å¯ä»¥ä½¿ç”¨èŠ±æ‹¬å·ï¼ˆç»Ÿä¸€ï¼‰åˆå§‹åŒ–æŒ‰è¡ŒåŠ è½½æ•°æ®ã€‚'
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note also that the `<<` stream operator is overloaded, so the result can be
    easily displayed on the screen (in row-major order).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: è¿˜è¦æ³¨æ„`<<`æµæ“ä½œç¬¦è¢«é‡è½½ï¼Œå› æ­¤å¯ä»¥è½»æ¾åœ°å°†ç»“æœæ˜¾ç¤ºåœ¨å±å¹•ä¸Šï¼ˆæŒ‰è¡Œä¸»åºï¼‰ã€‚
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Individual rows and columns can also be accessed, using 0-based indexing. The
    first column of the first matrix, and the third column of the second, for example
    are obtained with respective accessor functions:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: å¯ä»¥è®¿é—®å•ç‹¬çš„è¡Œå’Œåˆ—ï¼Œä½¿ç”¨åŸºäº0çš„ç´¢å¼•ã€‚ä¾‹å¦‚ï¼Œç¬¬ä¸€ä¸ªçŸ©é˜µçš„ç¬¬ä¸€åˆ—å’Œç¬¬äºŒä¸ªçŸ©é˜µçš„ç¬¬ä¸‰åˆ—å¯ä»¥åˆ†åˆ«é€šè¿‡ç›¸åº”çš„è®¿é—®å™¨å‡½æ•°è·å–ï¼š
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This results in the following screen output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯¼è‡´ä»¥ä¸‹å±å¹•è¾“å‡ºï¼š
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Technically speaking, the type returned by either the `row` or `col` accessor
    is an `Eigen::Block`. It is similar to a `slice_array` accessed from a `valarray`,
    in that it acts as a lighter weight reference to the data. Unlike `slice_array`,
    it does not carry any mathematical operators such as `+=`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ä»æŠ€æœ¯ä¸Šè®²ï¼Œç”±`row`æˆ–`col`è®¿é—®å™¨è¿”å›çš„ç±»å‹æ˜¯`Eigen::Block`ã€‚å®ƒç±»ä¼¼äºä»`valarray`è®¿é—®çš„`slice_array`ï¼Œå› ä¸ºå®ƒä½œä¸ºå¯¹æ•°æ®çš„è½»é‡çº§å¼•ç”¨ã€‚ä¸`slice_array`ä¸åŒï¼Œå®ƒä¸åŒ…å«ä»»ä½•æ•°å­¦è¿ç®—ç¬¦ï¼Œå¦‚`+=`ã€‚
- en: For most of the financial examples considered in this book, the dimensions of
    a matrix will not be known a priori, nor will they necessarily be of a square
    matrix. In addition, the contents will usually be real numbers. For these reasons,
    we will primarily be concerned with the Eigen dynamic form for `double` types,
    aliased as `Eigen::MatrixXd`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæœ¬ä¹¦ä¸­è€ƒè™‘çš„å¤§å¤šæ•°é‡‘èç¤ºä¾‹ï¼ŒçŸ©é˜µçš„ç»´åº¦äº‹å…ˆä¸ä¼šçŸ¥é“ï¼Œä¹Ÿä¸ä¸€å®šæ˜¯æ–¹é˜µã€‚æ­¤å¤–ï¼Œå†…å®¹é€šå¸¸æ˜¯å®æ•°ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°†ä¸»è¦å…³æ³¨`double`ç±»å‹çš„EigenåŠ¨æ€å½¢å¼ï¼Œåˆ«åä¸º`Eigen::MatrixXd`ã€‚
- en: Note
  id: totrans-110
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: æ³¨æ„
- en: As just mentioned, we will primarily use the dynamic Eigen `MatrixXd` form of
    a matrix (with `d` indicating `double` numerical elements); however, member and
    non-member functions will usually apply to any class derived from the `Matrix`
    template class. Where these functions are discussed, their relations with `Matrix`
    rather than `MatrixXd` may also be mentioned. Similarly, vector representation
    in Eigen will use `VectorXd`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æ­£å¦‚åˆšæ‰æåˆ°çš„ï¼Œæˆ‘ä»¬ä¸»è¦ä½¿ç”¨åŠ¨æ€çš„Eigen `MatrixXd`çŸ©é˜µå½¢å¼ï¼ˆå…¶ä¸­`d`è¡¨ç¤º`double`æ•°å€¼å…ƒç´ ï¼‰ï¼›ç„¶è€Œï¼Œæˆå‘˜å‡½æ•°å’Œéæˆå‘˜å‡½æ•°é€šå¸¸é€‚ç”¨äºä»»ä½•ä»`Matrix`æ¨¡æ¿ç±»æ´¾ç”Ÿçš„ç±»ã€‚è®¨è®ºè¿™äº›å‡½æ•°æ—¶ï¼Œå®ƒä»¬ä¸`Matrix`è€Œä¸æ˜¯`MatrixXd`çš„å…³ç³»ä¹Ÿå¯èƒ½è¢«æåŠã€‚ç±»ä¼¼åœ°ï¼ŒEigenä¸­çš„å‘é‡è¡¨ç¤ºå°†ä½¿ç”¨`VectorXd`ã€‚
- en: Linear algebra will inevitably involve subscripts and superscripts, eg <math
    alttext="x Subscript i j"><msub><mi>x</mi> <mrow><mi>i</mi><mi>j</mi></mrow></msub></math>
    , where in mathematical notation *i* might run from 1 to *m*, and *j* from 1 to
    *n*. However, C++ is 0-indexed, so a mathematical statement where *i* = 1 will
    be represented by `i = 0` in C++, *j* = *n* by `j = n - 1`, and so forth.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: çº¿æ€§ä»£æ•°å¿…ç„¶æ¶‰åŠä¸‹æ ‡å’Œä¸Šæ ‡ï¼Œä¾‹å¦‚ <math alttext="x Subscript i j"><msub><mi>x</mi> <mrow><mi>i</mi><mi>j</mi></mrow></msub></math>
    ï¼Œåœ¨æ•°å­¦ç¬¦å·ä¸­ï¼Œ*i* å¯èƒ½ä» 1 åˆ° *m*ï¼Œ*j* ä» 1 åˆ° *n*ã€‚ç„¶è€Œï¼ŒC++ ä¸­æ˜¯ä» 0 å¼€å§‹ç´¢å¼•çš„ï¼Œå› æ­¤æ•°å­¦è¯­å¥ä¸­çš„ *i* = 1 å°†åœ¨ C++
    ä¸­è¡¨ç¤ºä¸º `i = 0`ï¼Œ*j* = *n* å°†è¡¨ç¤ºä¸º `j = n - 1`ï¼Œä¾æ­¤ç±»æ¨ã€‚
- en: 'Construction of a `MatrixXd` can take on many forms. Data can be entered as
    before in row-major order, with the number of rows and columns implied by uniform
    initialization of individual rows. Alternatively, the dimensions can be used as
    constructor arguments, with the data input by streaming in row-major order. And,
    one more approach is to set each element one-by-one. An example of each is shown
    here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: æ„é€  `MatrixXd` å¯ä»¥é‡‡ç”¨å¤šç§å½¢å¼ã€‚æ•°æ®å¯ä»¥æŒ‰è¡Œä¸»åºè¾“å…¥ï¼Œæ¯è¡Œçš„åˆå§‹åŒ–ç»Ÿä¸€å†³å®šäº†è¡Œæ•°å’Œåˆ—æ•°ã€‚æˆ–è€…ï¼Œå¯ä»¥ä½¿ç”¨æ„é€ å‡½æ•°å‚æ•°ä½œä¸ºç»´åº¦ï¼Œé€šè¿‡æŒ‰è¡Œä¸»åºæµå¼è¾“å…¥æ•°æ®ã€‚è¿˜æœ‰ä¸€ç§æ–¹æ³•æ˜¯é€ä¸ªè®¾ç½®æ¯ä¸ªå…ƒç´ ã€‚è¿™é‡Œå±•ç¤ºäº†æ¯ç§æ–¹æ³•çš„ç¤ºä¾‹ï¼š
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that the round bracket operator serves as both a mutator and an accessor,
    as demonstrated in the third example.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼Œåœ†æ‹¬å·è¿ç®—ç¬¦åŒæ—¶ä½œä¸ºæ”¹å˜å™¨å’Œè®¿é—®å™¨ï¼Œå¦‚ç¬¬ä¸‰ä¸ªç¤ºä¾‹æ‰€ç¤ºã€‚
- en: 'Two special cases, where either the number of columns or rows is one, are aliased
    as `VectorXd` and `RowVectorXd`. Construction options are similar to the `MatrixXd`
    examples above, again as shown in the Eigen documentation:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸¤ä¸ªç‰¹æ®Šæƒ…å†µï¼Œå…¶ä¸­åˆ—æ•°æˆ–è¡Œæ•°ä¸ºä¸€ï¼Œåˆ«åä¸º `VectorXd` å’Œ `RowVectorXd`ã€‚æ„é€ é€‰é¡¹ä¸ä¸Šè¿° `MatrixXd` çš„ç¤ºä¾‹ç±»ä¼¼ï¼Œå¦‚åŒåœ¨
    Eigen æ–‡æ¡£ä¸­å±•ç¤ºçš„é‚£æ ·ï¼š
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Matrix and Vector Math Operations
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: çŸ©é˜µå’Œå‘é‡æ•°å­¦è¿ç®—
- en: Matrix addition and subtraction are are conveniently implemented as overloads
    of the `+` and `-` operators, not unlike `valarray`. Similarly, these apply to
    vectors. Unlike `valarray`, however, the multiplication operator `*` refers to
    matrix multiplication rather than an element-by-element product. A separate set
    of functions is available for a wide range of element-by-element operations.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: çŸ©é˜µåŠ æ³•å’Œå‡æ³•éƒ½æ–¹ä¾¿åœ°é€šè¿‡`+`å’Œ`-`è¿ç®—ç¬¦çš„é‡è½½å®ç°ï¼Œç±»ä¼¼äº`valarray`ã€‚åŒæ ·ï¼Œè¿™äº›ä¹Ÿé€‚ç”¨äºå‘é‡ã€‚ä½†ä¸`valarray`ä¸åŒçš„æ˜¯ï¼Œä¹˜æ³•è¿ç®—ç¬¦`*`è¡¨ç¤ºçŸ©é˜µä¹˜æ³•è€Œä¸æ˜¯é€å…ƒç´ ä¹˜ç§¯ã€‚é’ˆå¯¹å¹¿æ³›çš„é€å…ƒç´ æ“ä½œï¼Œæä¾›äº†å•ç‹¬çš„å‡½æ•°é›†ã€‚
- en: 'To multiply two matrices `A` and `B`, the code follows in natural mathematical
    order:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: è¦å°†ä¸¤ä¸ªçŸ©é˜µ `A` å’Œ `B` ç›¸ä¹˜ï¼Œä»£ç éµå¾ªè‡ªç„¶çš„æ•°å­¦é¡ºåºï¼š
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This gives us as output:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä½¿æˆ‘ä»¬çš„è¾“å‡ºç»“æœä¸ºï¼š
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Caution
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: æ³¨æ„
- en: In the Eigen documentation, it is strongly recommended to â€œnot use the auto
    keywords with Eigenâ€™s expressions, unless you are 100% sure about what you are
    doing. In particular, do not use the auto keyword as a replacement for a `Matrix<>`
    type.â€
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Eigen æ–‡æ¡£ä¸­ï¼Œå¼ºçƒˆå»ºè®®â€œä¸è¦åœ¨ Eigen çš„è¡¨è¾¾å¼ä¸­ä½¿ç”¨ `auto` å…³é”®å­—ï¼Œé™¤éä½ å¯¹è‡ªå·±æ‰€åšçš„äº‹æƒ…éå¸¸ç¡®å®šã€‚ç‰¹åˆ«æ˜¯ï¼Œä¸è¦å°† `auto`
    å…³é”®å­—ç”¨ä½œ `Matrix<>` ç±»å‹çš„æ›¿ä»£å“ã€‚â€
- en: The reasons behind this require an advanced discussion about templates that
    tie in with lazy evaluation. Lazy Evaluation provides advantages in efficiency,
    but it also can involve return types using `auto` that might be in the form of
    a reference rather than a full `Matrix` type. This can result in unexpected or
    undefined behavior. It becomes less of an issue as you become more familiar with
    various Eigen types, but for this introductory presentation, we will mostly heed
    this admonishment.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶èƒŒåçš„åŸå› éœ€è¦è¿›è¡Œå…³äºä¸æ‡’æƒ°æ±‚å€¼ç›¸å…³çš„æ¨¡æ¿çš„é«˜çº§è®¨è®ºã€‚æ‡’æƒ°æ±‚å€¼åœ¨æ•ˆç‡ä¸Šæä¾›äº†ä¼˜åŠ¿ï¼Œä½†å®ƒä¹Ÿå¯èƒ½æ¶‰åŠè¿”å›ç±»å‹çš„ä½¿ç”¨ `auto`ï¼Œå¯èƒ½æ˜¯å¼•ç”¨è€Œä¸æ˜¯å®Œæ•´çš„
    `Matrix` ç±»å‹ã€‚è¿™å¯èƒ½å¯¼è‡´æ„å¤–æˆ–æœªå®šä¹‰çš„è¡Œä¸ºã€‚éšç€æ‚¨å¯¹å„ç§ Eigen ç±»å‹çš„äº†è§£è¶Šæ¥è¶Šæ·±å…¥ï¼Œè¿™ä¸ªé—®é¢˜ä¼šå˜å¾—ä¸é‚£ä¹ˆé‡è¦ï¼Œä½†åœ¨è¿™ä¸ªå…¥é—¨æ¼”ç¤ºä¸­ï¼Œæˆ‘ä»¬å¤§å¤šæ•°æ—¶å€™ä¼šéµå¾ªè¿™ä¸ªè­¦å‘Šã€‚
- en: More information can be found [in the documentation](https://eigen.tuxfamily.org/dox/TopicPitfalls.html).
    **{18}**
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: æ›´å¤šä¿¡æ¯è¯·å‚é˜…[æ–‡æ¡£](https://eigen.tuxfamily.org/dox/TopicPitfalls.html)ã€‚**{18}**
- en: 'The `*` operator is also overloaded for matrix-vector and row vector-matrix
    multiplication. As an example, suppose we have a portfolio of three funds, with
    correlation matrix of the returns and the vector of individual fund volatilities
    given (annualized). As is a typical problem, we might need to construct the covariance
    matrix given the data in this form in order to calculate the portfolio volatility.
    First, to form the covariance matrix, we would pre- and post-multiply the correlation
    matrix by diagonal matrices containing the fund volatilities:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`*` è¿ç®—ç¬¦è¿˜è¢«é‡è½½ç”¨äºçŸ©é˜µ-å‘é‡å’Œè¡Œå‘é‡-çŸ©é˜µä¹˜æ³•ã€‚ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªåŒ…å«ä¸‰ç§åŸºé‡‘çš„æŠ•èµ„ç»„åˆï¼Œå…·æœ‰æ”¶ç›Šç›¸å…³æ€§çŸ©é˜µå’Œç»™å®šçš„ä¸ªåˆ«åŸºé‡‘æ³¢åŠ¨ç‡å‘é‡ï¼ˆå¹´åŒ–ï¼‰ã€‚ä½œä¸ºä¸€ä¸ªå…¸å‹é—®é¢˜ï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦ä»¥è¿™ç§å½¢å¼æ„é€ åæ–¹å·®çŸ©é˜µï¼Œä»¥è®¡ç®—æŠ•èµ„ç»„åˆæ³¢åŠ¨ç‡ã€‚é¦–å…ˆï¼Œä¸ºäº†å½¢æˆåæ–¹å·®çŸ©é˜µï¼Œæˆ‘ä»¬å°†é€šè¿‡åŒ…å«åŸºé‡‘æ³¢åŠ¨ç‡çš„å¯¹è§’çŸ©é˜µå¯¹ç›¸å…³æ€§çŸ©é˜µè¿›è¡Œå‰ç½®å’Œåç½®ä¹˜æ³•ï¼š'
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note how the `VectorXd` member function `asDiagonal()` conveniently forms a
    diagonal matrix with the vector elements along the diagonal.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ `VectorXd` çš„æˆå‘˜å‡½æ•° `asDiagonal()` å¦‚ä½•æ–¹ä¾¿åœ°å½¢æˆä¸€ä¸ªä»¥å‘é‡å…ƒç´ ä¸ºå¯¹è§’çº¿çš„å¯¹è§’çŸ©é˜µã€‚
- en: Then, given a vector of fund weights <math alttext="omega"><mi>Ï‰</mi></math>
    adding to 1, the portfolio volatility is then the square root of the quadratic
    form
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œç»™å®šä¸€ä¸ªèµ„é‡‘æƒé‡å‘é‡ <math alttext="omega"><mi>Ï‰</mi></math> æ€»å’Œä¸º 1ï¼ŒæŠ•èµ„ç»„åˆæ³¢åŠ¨ç‡åˆ™æ˜¯äºŒæ¬¡å½¢å¼çš„å¹³æ–¹æ ¹
- en: <math alttext="omega Superscript sans-serif upper T Baseline bold upper Sigma
    omega" display="block"><mrow><msup><mi>Ï‰</mi> <mi>ğ–³</mi></msup> <mi>Î£</mi> <mi>Ï‰</mi></mrow></math>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="omega Superscript sans-serif upper T Baseline bold upper Sigma
    omega" display="block"><mrow><msup><mi>Ï‰</mi> <mi>ğ–³</mi></msup> <mi>Î£</mi> <mi>Ï‰</mi></mrow></math>
- en: 'where <math alttext="bold upper Sigma"><mi>Î£</mi></math> is the covariance
    matrix:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­ <math alttext="bold upper Sigma"><mi>Î£</mi></math> æ˜¯åæ–¹å·®çŸ©é˜µï¼š
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For element-by-element matrix multiplication, use the `cwiseProduct` member
    function. As an example, to multiply the individual elements in matrices of like
    dimension, say <math alttext="bold upper A"><mi>ğ€</mi></math> and <math alttext="bold
    upper B Superscript sans-serif upper T"><msup><mi>ğ</mi> <mi>ğ–³</mi></msup></math>
    , we would write:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºé€å…ƒç´ çŸ©é˜µä¹˜æ³•ï¼Œä½¿ç”¨ `cwiseProduct` æˆå‘˜å‡½æ•°ã€‚ä¾‹å¦‚ï¼Œè¦å¯¹ç»´åº¦ç›¸åŒçš„çŸ©é˜µ <math alttext="bold upper A"><mi>ğ€</mi></math>
    å’Œ <math alttext="bold upper B Superscript sans-serif upper T"><msup><mi>ğ</mi>
    <mi>ğ–³</mi></msup></math> ä¸­çš„ä¸ªåˆ«å…ƒç´ è¿›è¡Œä¹˜æ³•è¿ç®—ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·å†™ï¼š
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There is in fact a set of `cwise...` (meaning *coefficient-wise*) member functions
    on an Eigen `Matrix` that perform element-by-element operations on two compatible
    matrices, such as `cwiseQuotient` and `cwiseNotEqual`. There are also unary `cwise`
    member functions that return the absolute value and square root of each element.
    These can be found in the [Eigen documentation](https://eigen.tuxfamily.org/dox/group__QuickRefPage.html#title6)
    here. **{19}**
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šï¼ŒEigen çš„ `Matrix` ä¸Šæœ‰ä¸€ç»„ `cwise...`ï¼ˆæ„æ€æ˜¯é€ç³»æ•°ï¼‰æˆå‘˜å‡½æ•°ï¼Œå¯ä»¥åœ¨ä¸¤ä¸ªå…¼å®¹çŸ©é˜µä¸Šæ‰§è¡Œé€å…ƒç´ æ“ä½œï¼Œå¦‚ `cwiseQuotient`
    å’Œ `cwiseNotEqual`ã€‚è¿˜æœ‰ä¸€å…ƒçš„ `cwise` æˆå‘˜å‡½æ•°ï¼Œè¿”å›æ¯ä¸ªå…ƒç´ çš„ç»å¯¹å€¼å’Œå¹³æ–¹æ ¹ã€‚è¿™äº›å¯ä»¥åœ¨[Eigenæ–‡æ¡£](https://eigen.tuxfamily.org/dox/group__QuickRefPage.html#title6)ä¸­æ‰¾åˆ°ã€‚**{19}**
- en: The result of the `*` operator when applied to two vectors depends upon which
    vector is transposed. For two vectors u and v, the dot (inner) product is computed
    as
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`*` è¿ç®—ç¬¦åº”ç”¨äºä¸¤ä¸ªå‘é‡æ—¶ï¼Œå–å†³äºå“ªä¸ªå‘é‡è¢«è½¬ç½®ã€‚å¯¹äºä¸¤ä¸ªå‘é‡ u å’Œ vï¼Œç‚¹ï¼ˆå†…ï¼‰ç§¯è®¡ç®—ä¸º'
- en: <math alttext="bold u Superscript sans-serif upper T Baseline bold v" display="block"><mrow><msup><mi>ğ®</mi>
    <mi>ğ–³</mi></msup> <mi>ğ¯</mi></mrow></math>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold u Superscript sans-serif upper T Baseline bold v" display="block"><mrow><msup><mi>ğ®</mi>
    <mi>ğ–³</mi></msup> <mi>ğ¯</mi></mrow></math>
- en: 'while the outer product results when the transpose is applied to v:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: å½“åº”ç”¨è½¬ç½®äº v æ—¶ï¼Œå¤–ç§¯çš„ç»“æœæ˜¯ï¼š
- en: <math display="block"><msup><mstyle style="font-weight:bold"><mi>u</mi> <mi>v</mi></mstyle>
    <mi>T</mi></msup></math>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><msup><mstyle style="font-weight:bold"><mi>u</mi> <mi>v</mi></mstyle>
    <mi>T</mi></msup></math>
- en: 'So, one needs to be careful when using the `*` operator with vectors. Suppose
    we have:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œåœ¨ä½¿ç”¨å‘é‡å’Œ `*` è¿ç®—ç¬¦æ—¶éœ€è¦å°å¿ƒã€‚å‡è®¾æˆ‘ä»¬æœ‰ï¼š
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The respective results of the following vector multiplications will be different:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢çš„å‘é‡ä¹˜æ³•å°†å¾—åˆ°ä¸åŒçš„ç»“æœï¼š
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The first would result in a real value of 2.5, while the second would give
    us a singular 3 <math alttext="times"><mo>Ã—</mo></math> 3 matrix:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ä¸ªå°†äº§ç”Ÿä¸€ä¸ªå®å€¼ä¸º 2.5ï¼Œè€Œç¬¬äºŒä¸ªå°†ç»™å‡ºä¸€ä¸ª 3 <math alttext="times"><mo>Ã—</mo></math> 3 çš„çŸ©é˜µï¼š
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: To make life easier, Eigen provides a member function, `dot`, on the `VectorXd`
    class. By instead writing
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ç®€åŒ–æ“ä½œï¼ŒEigen åœ¨ `VectorXd` ç±»ä¸Šæä¾›äº†ä¸€ä¸ªæˆå‘˜å‡½æ•° `dot`ã€‚é€šè¿‡ä»¥ä¸‹æ–¹å¼ç¼–å†™
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: it should perhaps make it clearer which product we want. The result would be
    the same as before, plus the operation is commutative.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ–è®¸åº”è¯¥æ›´æ¸…æ¥šåœ°è¡¨æ˜æˆ‘ä»¬æƒ³è¦å“ªç§ä¹˜ç§¯ã€‚ç»“æœå°†ä¸ä»¥å‰ç›¸åŒï¼Œæ­¤æ“ä½œä¹Ÿæ˜¯å¯äº¤æ¢çš„ã€‚
- en: STL Compatibility
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STL å…¼å®¹æ€§
- en: A very nice feature of both the Eigen `Vector` and `Matrix` classes is their
    compatibility with the Standard Template Library. This means you can iterate through
    an Eigen container, apply STL algorithms, and exchange data with STL containers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Eigen `Vector` å’Œ `Matrix` ç±»çš„ä¸€ä¸ªéå¸¸å¥½çš„ç‰¹æ€§æ˜¯å®ƒä»¬ä¸æ ‡å‡†æ¨¡æ¿åº“çš„å…¼å®¹æ€§ã€‚è¿™æ„å‘³ç€ä½ å¯ä»¥éå† Eigen å®¹å™¨ï¼Œåº”ç”¨ STL
    ç®—æ³•ï¼Œå¹¶ä¸ STL å®¹å™¨äº¤æ¢æ•°æ®ã€‚
- en: STL and `VectorXd`
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: STL å’Œ `VectorXd`
- en: 'As a first example, suppose you wish to generate 12 random variates from a
    t-distribution and place the results in a `VectorXd` container. The process is
    essentially the same as what we saw using a `std::vector` and applying the `std::generate`
    algorithm with a lambda auxiliary function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºç¬¬ä¸€ä¸ªä¾‹å­ï¼Œå‡è®¾æ‚¨å¸Œæœ›ä»tåˆ†å¸ƒä¸­ç”Ÿæˆ12ä¸ªéšæœºå˜é‡ï¼Œå¹¶å°†ç»“æœæ”¾å…¥`VectorXd`å®¹å™¨ä¸­ã€‚è¯¥è¿‡ç¨‹æœ¬è´¨ä¸Šä¸æˆ‘ä»¬çœ‹åˆ°çš„ä½¿ç”¨`std::vector`å¹¶åº”ç”¨å¸¦æœ‰lambdaè¾…åŠ©å‡½æ•°çš„`std::generate`ç®—æ³•ç›¸åŒï¼š
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-156
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: æ³¨æ„
- en: 'Prior to the recent Eigen 3.4 release, the `begin` and `end` member functions
    were not defined. In this case, you would need to instead use the `data` and `size`
    functions, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ€è¿‘çš„Eigen 3.4ç‰ˆæœ¬å‘å¸ƒä¹‹å‰ï¼Œ`begin`å’Œ`end`æˆå‘˜å‡½æ•°æœªå®šä¹‰ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ‚¨éœ€è¦ä½¿ç”¨`data`å’Œ`size`å‡½æ•°ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Non-modifying algorithms such as `std::max_element` are also valid:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: éä¿®æ”¹ç®—æ³•ï¼ˆå¦‚`std::max_element`ï¼‰ä¹Ÿæ˜¯æœ‰æ•ˆçš„ï¼š
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Numeric algorithms, for example `std::inner_product`, can also be applied:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: æ•°å€¼ç®—æ³•ï¼Œä¾‹å¦‚`std::inner_product`ï¼Œä¹Ÿå¯ä»¥åº”ç”¨ï¼š
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The cleaner C++20 range versions are also supported on `VectorXd`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`VectorXd`ä¸Šä¹Ÿæ”¯æŒæ›´å¹²å‡€çš„C++20èŒƒå›´ç‰ˆæœ¬ï¼š'
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Constructing a Matrix from STL Container Data
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ä»STLå®¹å™¨æ•°æ®æ„é€ çŸ©é˜µ
- en: Matrix data can also be obtained from STL containers. This is convenient, as
    data can often arrive via interfaces from other sources where Eigen might not
    be included. The key is to use an `Eigen::Map`, which sets up a reference to (view
    of) the `vector` data rather than taking a copy of it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: çŸ©é˜µæ•°æ®ä¹Ÿå¯ä»¥ä»STLå®¹å™¨ä¸­è·å–ã€‚è¿™å¾ˆæ–¹ä¾¿ï¼Œå› ä¸ºæ•°æ®é€šå¸¸å¯ä»¥é€šè¿‡ä»å…¶ä»–æœªåŒ…å«Eigençš„æºæ¥å£æ¥æ”¶ã€‚å…³é”®æ˜¯ä½¿ç”¨`Eigen::Map`ï¼Œå®ƒè®¾ç½®å¯¹ï¼ˆè§†å›¾çš„ï¼‰`vector`æ•°æ®çš„å¼•ç”¨ï¼Œè€Œä¸æ˜¯å¤åˆ¶å®ƒã€‚
- en: As a first example, data residing in a `std::vector` container can be transferred
    to an `Eigen::Map`, which in turn can be used as the constructor argument for
    a `MatrixXd`. Note that the `Map` takes in a pointer to the first element in the
    `vector` (using the `data` member function), and the number of rows and columns,
    in its constructor.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºç¬¬ä¸€ä¸ªä¾‹å­ï¼Œå­˜å‚¨åœ¨`std::vector`å®¹å™¨ä¸­çš„æ•°æ®å¯ä»¥è½¬ç§»åˆ°`Eigen::Map`ï¼Œç„¶åå¯ä»¥ç”¨ä½œ`MatrixXd`çš„æ„é€ å‡½æ•°å‚æ•°ã€‚æ³¨æ„ï¼Œ`Map`åœ¨å…¶æ„é€ å‡½æ•°ä¸­æ¥å—æŒ‡å‘`vector`ç¬¬ä¸€ä¸ªå…ƒç´ çš„æŒ‡é’ˆï¼ˆä½¿ç”¨`data`æˆå‘˜å‡½æ•°ï¼‰ï¼Œä»¥åŠè¡Œæ•°å’Œåˆ—æ•°ã€‚
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'By default, `mtx_map` will provide row/column access to the data. Note that
    unlike creating a `MatrixXd` as before with an initializer list of data, the order
    will be column-major rather than row-major. Using `cout` yields the following
    output:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: é»˜è®¤æƒ…å†µä¸‹ï¼Œ`mtx_map`å°†æä¾›å¯¹æ•°æ®çš„è¡Œ/åˆ—è®¿é—®ã€‚è¯·æ³¨æ„ï¼Œä¸ä»¥å‰ä½¿ç”¨æ•°æ®åˆå§‹åŒ–åˆ—è¡¨åˆ›å»º`MatrixXd`ä¸åŒï¼Œé¡ºåºå°†æ˜¯åˆ—ä¸»åºè€Œä¸æ˜¯è¡Œä¸»åºã€‚ä½¿ç”¨`cout`è¾“å‡ºå¦‚ä¸‹ï¼š
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As a `Map` is a lighter weight view of the data in `v`, it does not carry with
    it all of the functionality as found on a `Matrix` object, in a sense similar
    to a slice taken from a`valarray`. If you need this functionality, then you can
    construct a `MatrixXd` instance by putting the `Map` object in its constructor:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äº`Map`æ˜¯å¯¹`v`ä¸­æ•°æ®çš„è½»é‡çº§è§†å›¾ï¼Œå®ƒä¸åƒä»¥å‰ç”¨æ•°æ®åˆå§‹åŒ–åˆ—è¡¨åˆ›å»º`MatrixXd`å¯¹è±¡é‚£æ ·å…·æœ‰æ‰€æœ‰åŠŸèƒ½ã€‚åœ¨æŸç§æ„ä¹‰ä¸Šç±»ä¼¼äºä»`valarray`ä¸­å–å‡ºçš„åˆ‡ç‰‡ã€‚å¦‚æœæ‚¨éœ€è¦æ­¤åŠŸèƒ½ï¼Œåˆ™å¯ä»¥é€šè¿‡å°†`Map`å¯¹è±¡æ”¾å…¥å…¶æ„é€ å‡½æ•°ä¸­æ¥æ„é€ `MatrixXd`å®ä¾‹ï¼š
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The default arrangement of the data in a `Map` will be in *column-major order*,
    which is different from the earlier `MatrixXd` examples constructed with numerical
    data. If row-major is required, you can specify row-major at the outset, but this
    will require an `Eigen::Matrix` template parameter with storage explicitly set
    to `RowMajor`, as `MatrixXd` does not have its own template parameter for storage
    method:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`ä¸­æ•°æ®çš„é»˜è®¤æ’åˆ—é¡ºåºå°†æ˜¯*åˆ—ä¸»åº*ï¼Œè¿™ä¸æ—©æœŸä½¿ç”¨æ•°å€¼æ•°æ®æ„é€ çš„`MatrixXd`ç¤ºä¾‹ä¸åŒã€‚å¦‚æœéœ€è¦è¡Œä¸»åºï¼Œå¯ä»¥åœ¨ä¸€å¼€å§‹æŒ‡å®šè¡Œä¸»åºï¼Œä½†è¿™å°†éœ€è¦å°†`Eigen::Matrix`æ¨¡æ¿å‚æ•°æ˜ç¡®è®¾ç½®ä¸º`RowMajor`ï¼Œå› ä¸º`MatrixXd`æ²¡æœ‰è‡ªå·±çš„å­˜å‚¨æ–¹æ³•æ¨¡æ¿å‚æ•°ï¼š'
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If the matrix is square, you can just transpose the `Map` in place to put it
    in row-major order:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœçŸ©é˜µæ˜¯æ–¹é˜µï¼Œæ‚¨å¯ä»¥ç›´æ¥å°±åœ°è½¬ç½®`Map`ä»¥å°†å…¶æ”¾ç½®åœ¨è¡Œä¸»åºä¸­ï¼š
- en: '[PRE46]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The result is then:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æœå¦‚ä¸‹ï¼š
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Warning
  id: totrans-179
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: è­¦å‘Š
- en: Attempting to transpose a non-square matrix using `Map` can result in a program
    crash. In this case, you will need to create a full `MatrixXd` object before applying
    `transposeInPlace`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: å°è¯•ä½¿ç”¨`Map`è½¬ç½®éæ–¹é˜µå¯èƒ½å¯¼è‡´ç¨‹åºå´©æºƒã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ‚¨éœ€è¦åœ¨åº”ç”¨`transposeInPlace`ä¹‹å‰åˆ›å»ºä¸€ä¸ªå®Œæ•´çš„`MatrixXd`å¯¹è±¡ã€‚
- en: Applying STL Algorithms to a Matrix
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: å°†STLç®—æ³•åº”ç”¨äºçŸ©é˜µ
- en: 'STL algorithms can also be applied to matrices row by row, or column by column.
    Suppose we have a 4 <math alttext="times"><mo>Ã—</mo></math> 3 matrix as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: STLç®—æ³•ä¹Ÿå¯ä»¥æŒ‰è¡Œæˆ–æŒ‰åˆ—åº”ç”¨äºçŸ©é˜µã€‚å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ª4 <math alttext="times"><mo>Ã—</mo></math> 3çŸ©é˜µå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `rowwise()` member function on an Eigen `Matrix` sets up an iteration by
    row. Each `row` is a reference to (view of) the respective data, so we can square
    each element of the matrix in place as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Eigenä¸­çš„`rowwise()`æˆå‘˜å‡½æ•°åœ¨`Matrix`ä¸Šè®¾ç½®æŒ‰è¡Œè¿­ä»£ã€‚æ¯ä¸ª`row`æ˜¯å¯¹ç›¸åº”æ•°æ®çš„å¼•ç”¨ï¼ˆè§†å›¾ï¼‰ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥æŒ‰å¦‚ä¸‹æ–¹å¼å°±åœ°å¯¹çŸ©é˜µçš„æ¯ä¸ªå…ƒç´ è¿›è¡Œå¹³æ–¹ï¼š
- en: '[PRE49]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `colwise()` member function is similar, in this case sorting each column
    of the matrix:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`colwise()`æˆå‘˜å‡½æ•°ç±»ä¼¼ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯¹çŸ©é˜µçš„æ¯ä¸€åˆ—è¿›è¡Œæ’åºï¼š'
- en: '[PRE50]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The end result after applying both algorithms gives us
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: åº”ç”¨è¿™ä¸¤ç§ç®—æ³•åçš„æœ€ç»ˆç»“æœæ˜¯
- en: '[PRE51]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Each element has been squared, and each column has been rearranged in ascending
    order.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: æ¯ä¸ªå…ƒç´ å·²ç»è¢«å¹³æ–¹ï¼Œå¹¶ä¸”æ¯åˆ—å·²æŒ‰å‡åºé‡æ–°æ’åˆ—ã€‚
- en: 'Financial programmers often need to write code that will compute the log returns
    on a set of equity or fund prices. For example, suppose we have a set of 11 monthly
    prices for three ETFâ€™s, in the following three columns:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: é‡‘èç¨‹åºå‘˜ç»å¸¸éœ€è¦ç¼–å†™ä»£ç æ¥è®¡ç®—ä¸€ç»„è‚¡ç¥¨æˆ–åŸºé‡‘ä»·æ ¼çš„å¯¹æ•°æ”¶ç›Šç‡ã€‚ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä¸‰ä¸ªETFçš„11ä¸ªæœˆä»·æ ¼ï¼Œåˆ†åˆ«æ”¾åœ¨ä»¥ä¸‹ä¸‰åˆ—ä¸­ï¼š
- en: '[PRE52]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The first step in computing log returns is to compute the natural log of each
    price. This can be done by applying the `transform` algorithm row by row:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: è®¡ç®—å¯¹æ•°æ”¶ç›Šç‡çš„ç¬¬ä¸€æ­¥æ˜¯è®¡ç®—æ¯ä¸ªä»·æ ¼çš„è‡ªç„¶å¯¹æ•°ã€‚å¯ä»¥é€šè¿‡é€è¡Œåº”ç”¨`transform`ç®—æ³•æ¥å®Œæˆï¼š
- en: '[PRE53]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, to get the log returns, we need to subtract from each log price its predecessor.
    For this, we can apply the `adjacent_difference` numeric algorithm to each column:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œè¦è·å¾—å¯¹æ•°æ”¶ç›Šç‡ï¼Œæˆ‘ä»¬éœ€è¦ä»æ¯ä¸ªå¯¹æ•°ä»·æ ¼ä¸­å‡å»å…¶å‰ä»»ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹æ¯åˆ—åº”ç”¨`adjacent_difference`æ•°å€¼ç®—æ³•ï¼š
- en: '[PRE54]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This result is still an 11 <math alttext="times"><mo>Ã—</mo></math> 3 matrix,
    with the first row still containing the logs of the prices in the first row.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤ç»“æœä»ç„¶æ˜¯ä¸€ä¸ª11 <math alttext="times"><mo>Ã—</mo></math> 3çŸ©é˜µï¼Œç¬¬ä¸€è¡Œä»åŒ…å«ç¬¬ä¸€è¡Œä¸­ä»·æ ¼çš„å¯¹æ•°ã€‚
- en: '[PRE55]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'What we want are the monthly returns alone, so we need to remove the first
    row. This can be achieved by applying the `seq` function, introduced in Eigen
    3.4, which provides an intuitive way of extracting a submatrix view (an `Eigen::Block`)
    from a `Matrix` object. The example here shows how to extract all rows below the
    first:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬éœ€è¦çš„æ˜¯ä»…æœˆåº¦å›æŠ¥ï¼Œå› æ­¤éœ€è¦ç§»é™¤ç¬¬ä¸€è¡Œã€‚è¿™å¯ä»¥é€šè¿‡åº”ç”¨Eigen 3.4ä¸­å¼•å…¥çš„`seq`å‡½æ•°æ¥å®ç°ï¼Œå®ƒæä¾›äº†ä»`Matrix`å¯¹è±¡ä¸­æå–å­çŸ©é˜µè§†å›¾ï¼ˆ`Eigen::Block`ï¼‰çš„ç›´è§‚æ–¹å¼ã€‚è¿™é‡Œçš„ç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•æå–ç¬¬ä¸€è¡Œä»¥ä¸‹çš„æ‰€æœ‰è¡Œï¼š
- en: '[PRE56]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'What this says is:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¥è¯çš„æ„æ€æ˜¯ï¼š
- en: 'Start with the second row (index 1) and include all rows down to the last row:
    `Eigen::seq(1, Eigen::last)`'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä»ç¬¬äºŒè¡Œï¼ˆç´¢å¼•ä¸º1ï¼‰å¼€å§‹ï¼ŒåŒ…æ‹¬åˆ°æœ€åä¸€è¡Œçš„æ‰€æœ‰è¡Œï¼š`Eigen::seq(1, Eigen::last)`
- en: 'Take all columns from the first (index 0) to the last: `Eigen::seq(0, Eigen::last)`'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä»ç¬¬ä¸€ä¸ªï¼ˆç´¢å¼•ä¸º0ï¼‰åˆ°æœ€åä¸€ä¸ªåˆ—è·å–æ‰€æœ‰åˆ—ï¼š`Eigen::seq(0, Eigen::last)`
- en: Use this submatrix data alone in the constructor for the resulting `returns_mtx`
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä»…ä½¿ç”¨æ„é€ è¿”å›çš„`returns_mtx`ä¸­çš„æ­¤å­çŸ©é˜µæ•°æ®ã€‚
- en: 'The results held in `returns_mtx` are then the log returns alone:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`returns_mtx`ä¸­ä¿å­˜çš„ç»“æœä»…ä¸ºå¯¹æ•°æ”¶ç›Šç‡ï¼š'
- en: '[PRE57]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, suppose the portfolio allocation is fixed at 35%, 40%, and 25% for each
    respective fund (columnwise). We can get the monthly portfolio returns by multiplying
    the vector of allocations by `returns_mtx`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œå‡è®¾æŠ•èµ„ç»„åˆåˆ†é…åˆ†åˆ«å›ºå®šåœ¨35%ã€40%å’Œ25%ï¼ˆæŒ‰åˆ—ï¼‰ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡å°†åˆ†é…å‘é‡ä¹˜ä»¥`returns_mtx`æ¥è·å¾—æ¯æœˆçš„æŠ•èµ„ç»„åˆå›æŠ¥ï¼š
- en: '[PRE58]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The result is
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æœæ˜¯
- en: '[PRE59]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Matrix Decompositions and Applications
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: çŸ©é˜µåˆ†è§£ä¸åº”ç”¨
- en: Matrix decompositions are of course essential for a variety of financial engineering
    problems. Below, we will discuss a few examples.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: çŸ©é˜µåˆ†è§£åœ¨å„ç§é‡‘èå·¥ç¨‹é—®é¢˜ä¸­å½“ç„¶è‡³å…³é‡è¦ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†è®¨è®ºå‡ ä¸ªç¤ºä¾‹ã€‚
- en: Systems of Linear Equations and the LU Decomposition
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: çº¿æ€§æ–¹ç¨‹ç»„å’ŒLUåˆ†è§£
- en: Systems of linear equations are ubiquitous in finance and economics, particularly
    in optimization, hedging, and forecasting problems. To show how solutions can
    be found in Eigen, let us just look at a generic problem and implement it in code.
    The LU (Lower/Upper-triangular matrix) decomposition is a common approach in numerical
    methods. As opposed to coding it ourselves, Eigen can get the job done in two
    lines of code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨é‡‘èå’Œç»æµä¸­ï¼Œçº¿æ€§æ–¹ç¨‹ç»„æ˜¯æ— å¤„ä¸åœ¨çš„ï¼Œç‰¹åˆ«æ˜¯åœ¨ä¼˜åŒ–ã€å¥—æœŸä¿å€¼å’Œé¢„æµ‹é—®é¢˜ä¸­ã€‚ä¸ºäº†å±•ç¤ºå¦‚ä½•åœ¨Eigenä¸­æ‰¾åˆ°è§£å†³æ–¹æ¡ˆï¼Œè®©æˆ‘ä»¬çœ‹ä¸€ä¸ªé€šç”¨é—®é¢˜å¹¶åœ¨ä»£ç ä¸­å®ç°å®ƒã€‚LUï¼ˆä¸‹/ä¸Šä¸‰è§’çŸ©é˜µï¼‰åˆ†è§£æ˜¯æ•°å€¼æ–¹æ³•ä¸­çš„å¸¸è§æ–¹æ³•ã€‚ä¸è‡ªå·±ç¼–å†™ä»£ç ç›¸åï¼ŒEigenå¯ä»¥åœ¨ä¸¤è¡Œä»£ç ä¸­å®Œæˆå·¥ä½œã€‚
- en: 'Suppose we want to solve the following system of linear equations for <math
    alttext="x 1"><msub><mi>x</mi> <mn>1</mn></msub></math> , <math alttext="x 2"><msub><mi>x</mi>
    <mn>2</mn></msub></math> , and <math alttext="x 3"><msub><mi>x</mi> <mn>3</mn></msub></math>
    :'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬æƒ³è¦è§£å†³ä»¥ä¸‹çº¿æ€§æ–¹ç¨‹ç»„ï¼Œæ±‚è§£<math alttext="x 1"><msub><mi>x</mi> <mn>1</mn></msub></math>ï¼Œ<math
    alttext="x 2"><msub><mi>x</mi> <mn>2</mn></msub></math>å’Œ<math alttext="x 3"><msub><mi>x</mi>
    <mn>3</mn></msub></math>ï¼š
- en: <math alttext="3 x 1 minus 5 x 2 plus x 3 equals 0" display="block"><mrow><mn>3</mn>
    <msub><mi>x</mi> <mn>1</mn></msub> <mo>-</mo> <mn>5</mn> <msub><mi>x</mi> <mn>2</mn></msub>
    <mo>+</mo> <msub><mi>x</mi> <mn>3</mn></msub> <mo>=</mo> <mn>0</mn></mrow></math><math
    alttext="minus x 1 minus x 2 plus x 3 equals negative 4" display="block"><mrow><mo>-</mo>
    <msub><mi>x</mi> <mn>1</mn></msub> <mo>-</mo> <msub><mi>x</mi> <mn>2</mn></msub>
    <mo>+</mo> <msub><mi>x</mi> <mn>3</mn></msub> <mo>=</mo> <mo>-</mo> <mn>4</mn></mrow></math><math
    alttext="2 x 1 minus 4 x 2 plus x 3 equals negative 1" display="block"><mrow><mn>2</mn>
    <msub><mi>x</mi> <mn>1</mn></msub> <mo>-</mo> <mn>4</mn> <msub><mi>x</mi> <mn>2</mn></msub>
    <mo>+</mo> <msub><mi>x</mi> <mn>3</mn></msub> <mo>=</mo> <mo>-</mo> <mn>1</mn></mrow></math>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="3 x 1 minus 5 x 2 plus x 3 equals 0" display="block"><mrow><mn>3</mn>
    <msub><mi>x</mi> <mn>1</mn></msub> <mo>-</mo> <mn>5</mn> <msub><mi>x</mi> <mn>2</mn></msub>
    <mo>+</mo> <msub><mi>x</mi> <mn>3</mn></msub> <mo>=</mo> <mn>0</mn></mrow></math><math
    alttext="minus x 1 minus x 2 plus x 3 equals negative 4" display="block"><mrow><mo>-</mo>
    <msub><mi>x</mi> <mn>1</mn></msub> <mo>-</mo> <msub><mi>x</mi> <mn>2</mn></msub>
    <mo>+</mo> <msub><mi>x</mi> <mn>3</mn></msub> <mo>=</mo> <mo>-</mo> <mn>4</mn></mrow></math><math
    alttext="2 x 1 minus 4 x 2 plus x 3 equals negative 1" display="block"><mrow><mn>2</mn>
    <msub><mi>x</mi> <mn>1</mn></msub> <mo>-</mo> <mn>4</mn> <msub><mi>x</mi> <mn>2</mn></msub>
    <mo>+</mo> <msub><mi>x</mi> <mn>3</mn></msub> <mo>=</mo> <mo>-</mo> <mn>1</mn></mrow></math>
- en: This sets up the usual matrix equation
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™è®¾ç½®äº†é€šå¸¸çš„çŸ©é˜µæ–¹ç¨‹
- en: <math alttext="bold upper A bold x equals bold b" display="block"><mrow><mi>ğ€ğ±</mi>
    <mo>=</mo> <mi>ğ›</mi></mrow></math>
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold upper A bold x equals bold b" display="block"><mrow><mi>ğ€ğ±</mi>
    <mo>=</mo> <mi>ğ›</mi></mrow></math>
- en: where
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: where
- en: <math alttext="bold x equals Start 1 By 3 Matrix 1st Row 1st Column x 1 2nd
    Column x 2 3rd Column x 3 EndMatrix Superscript sans-serif upper T" display="block"><mrow><mi>ğ±</mi>
    <mo>=</mo> <msup><mfenced open="[" close="]"><mtable><mtr><mtd><msub><mi>x</mi>
    <mn>1</mn></msub></mtd> <mtd><msub><mi>x</mi> <mn>2</mn></msub></mtd> <mtd><msub><mi>x</mi>
    <mn>3</mn></msub></mtd></mtr></mtable></mfenced> <mi>ğ–³</mi></msup></mrow></math>
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold x equals Start 1 By 3 Matrix 1st Row 1st Column x 1 2nd
    Column x 2 3rd Column x 3 EndMatrix Superscript sans-serif upper T" display="block"><mrow><mi>ğ±</mi>
    <mo>=</mo> <msup><mfenced open="[" close="]"><mtable><mtr><mtd><msub><mi>x</mi>
    <mn>1</mn></msub></mtd> <mtd><msub><mi>x</mi> <mn>2</mn></msub></mtd> <mtd><msub><mi>x</mi>
    <mn>3</mn></msub></mtd></mtr></mtable></mfenced> <mi>ğ–³</mi></msup></mrow></math>
- en: The matrix <math alttext="bold upper A"><mi>ğ€</mi></math> contains the coefficients,
    and the column vector <math alttext="bold b"><mi>ğ›</mi></math> contains the constants
    on the right-hand side of the equations. The LU algorithm decomposes the matrix
    <math alttext="bold upper A"><mi>ğ€</mi></math> into the product of lower- and
    upper-triangular matrices <math alttext="bold upper L"><mi>ğ‹</mi></math> and <math
    alttext="bold upper U"><mi>ğ”</mi></math> in order to solve for <math alttext="bold
    x"><mi>ğ±</mi></math> .
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: çŸ©é˜µ <math alttext="bold upper A"><mi>ğ€</mi></math> åŒ…å«ç³»æ•°ï¼Œåˆ—å‘é‡ <math alttext="bold
    b"><mi>ğ›</mi></math> åŒ…å«æ–¹ç¨‹å³ä¾§çš„å¸¸æ•°ã€‚LU ç®—æ³•å°†çŸ©é˜µ <math alttext="bold upper A"><mi>ğ€</mi></math>
    åˆ†è§£ä¸ºä¸‹ä¸‰è§’å’Œä¸Šä¸‰è§’çŸ©é˜µçš„ä¹˜ç§¯ <math alttext="bold upper L"><mi>ğ‹</mi></math> å’Œ <math alttext="bold
    upper U"><mi>ğ”</mi></math>ï¼Œä»¥ä¾¿è§£ <math alttext="bold x"><mi>ğ±</mi></math> ã€‚
- en: 'In Eigen, form the matrix <math alttext="bold upper A"><mi>ğ€</mi></math> and
    the vector <math alttext="bold b"><mi>ğ›</mi></math> :'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Eigen ä¸­ï¼Œå½¢æˆçŸ©é˜µ <math alttext="bold upper A"><mi>ğ€</mi></math> å’Œå‘é‡ <math alttext="bold
    b"><mi>ğ›</mi></math>ï¼š
- en: _
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: _
- en: '[PRE60]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The next step is to create an instance of the `Eigen::FullPivLU` class with
    template parameter `MatrixXd`. This sets up the LU decomposition. To find the
    vector containing the solution, all that is left to do is call the `solve(.)`
    member function on this object. This means two lines of code, as promised:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹ä¸€æ­¥æ˜¯åˆ›å»º `Eigen::FullPivLU` ç±»çš„å®ä¾‹ï¼Œä½¿ç”¨æ¨¡æ¿å‚æ•° `MatrixXd`ã€‚è¿™è®¾ç½®äº†LUåˆ†è§£ã€‚è¦æ‰¾åˆ°åŒ…å«è§£çš„å‘é‡ï¼Œåªéœ€åœ¨æ­¤å¯¹è±¡ä¸Šè°ƒç”¨
    `solve(.)` æˆå‘˜å‡½æ•°ã€‚è¿™æ„å‘³ç€åªéœ€ä¸¤è¡Œä»£ç ï¼Œå¦‚çº¦å®šï¼š
- en: '[PRE61]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The solution for `x` is then (from top to bottom <math alttext="x 1"><msub><mi>x</mi>
    <mn>1</mn></msub></math> , <math alttext="x 2"><msub><mi>x</mi> <mn>2</mn></msub></math>
    , <math alttext="x 3"><msub><mi>x</mi> <mn>3</mn></msub></math> )
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: è§£ `x` çš„è§£æ³•æ˜¯ï¼ˆä»ä¸Šåˆ°ä¸‹ <math alttext="x 1"><msub><mi>x</mi> <mn>1</mn></msub></math>
    , <math alttext="x 2"><msub><mi>x</mi> <mn>2</mn></msub></math> , <math alttext="x
    3"><msub><mi>x</mi> <mn>3</mn></msub></math> ï¼‰
- en: _
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: _
- en: '[PRE62]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Several other decomposition methods are available in Eigen for solving linear
    systems, where as is often the case a choice between speed and accuracy needs
    to be considered. The LU decomposition in the example above is among the best
    for accuracy, although there are others that may be faster but do not offer the
    same level of stability. The complete list can be found here:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Eigen ä¸­è¿˜æä¾›äº†å…¶ä»–å‡ ç§åˆ†è§£æ–¹æ³•æ¥è§£çº¿æ€§ç³»ç»Ÿï¼Œé€šå¸¸éœ€è¦åœ¨é€Ÿåº¦å’Œç²¾åº¦ä¹‹é—´åšå‡ºé€‰æ‹©ã€‚ä¸Šé¢ç¤ºä¾‹ä¸­çš„LUåˆ†è§£åœ¨ç²¾åº¦æ–¹é¢æ˜¯æœ€ä½³çš„ï¼Œå°½ç®¡è¿˜æœ‰å…¶ä»–ä¸€äº›å¯èƒ½æ›´å¿«ä½†ç¨³å®šæ€§ä¸åŒçš„æ–¹æ³•ã€‚å®Œæ•´åˆ—è¡¨å¯åœ¨æ­¤å¤„æ‰¾åˆ°ï¼š
- en: '[Basic linear solving](http://eigen.tuxfamily.org/dox/group__TutorialLinearAlgebra.html)
    **{20}**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[åŸºæœ¬çº¿æ€§æ±‚è§£](http://eigen.tuxfamily.org/dox/group__TutorialLinearAlgebra.html)
    **{20}**'
- en: 'A comparison of the matrix decomposition methods in Eigen is also available:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Eigen ä¸­çš„çŸ©é˜µåˆ†è§£æ–¹æ³•æ¯”è¾ƒä¹Ÿå¯ç”¨ï¼š
- en: '[Catalogue of decompositions offered by Eigen](http://eigen.tuxfamily.org/dox/group__TopicLinearAlgebraDecompositions.html)
    **{21}**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[Eigen æä¾›çš„åˆ†è§£ç›®å½•](http://eigen.tuxfamily.org/dox/group__TopicLinearAlgebraDecompositions.html)
    **{21}**'
- en: Fund Tracking with Multiple Regression and the Singular Value Decomposition
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ä½¿ç”¨å¤šå…ƒå›å½’å’Œå¥‡å¼‚å€¼åˆ†è§£è¿›è¡ŒåŸºé‡‘è·Ÿè¸ª
- en: Another common programming problem in finance is fund tracking with multiple
    regression. Examples include
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: é‡‘èä¸­å¦ä¸€ä¸ªå¸¸è§çš„ç¼–ç¨‹é—®é¢˜æ˜¯ä½¿ç”¨å¤šå…ƒå›å½’è¿›è¡ŒåŸºé‡‘è·Ÿè¸ªã€‚ä¾‹å¦‚
- en: Tracking whether a fund of hedge funds is following its stated allocation targets
    by regressing its returns on a set of hedge fund style index returns.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿½è¸ªä¸€ä¸ªå¯¹å†²åŸºé‡‘ç»„åˆæ˜¯å¦æŒ‰ç…§å…¶å£°æ˜çš„é…ç½®ç›®æ ‡è¿›è¡Œï¼Œé€šè¿‡å°†å…¶å›æŠ¥ä¸ä¸€ç»„å¯¹å†²åŸºé‡‘é£æ ¼æŒ‡æ•°çš„å›å½’è¿›è¡Œæ¯”è¾ƒã€‚
- en: Tracking the sensitivity of a portfolio to changes in different market sectors.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿½è¸ªæŠ•èµ„ç»„åˆå¯¹ä¸åŒå¸‚åœºéƒ¨é—¨å˜åŒ–çš„æ•æ„Ÿæ€§ã€‚
- en: Tracking the goodness of fit of mutual funds offered in guaranteed investment
    products such as variable annuities, with respect to their respective fund group
    benchmarks.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿½è¸ªæä¾›åœ¨ä¿æœ¬æŠ•èµ„äº§å“ï¼ˆå¦‚å¯å˜å¹´é‡‘ï¼‰ä¸­çš„äº’æƒ åŸºé‡‘çš„é€‚åº”æ€§ï¼Œå…³äºå…¶å„è‡ªçš„åŸºé‡‘ç»„æŒ‡æ•°ã€‚
- en: In multiple regression, one is tasked with finding a vector
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å¤šå…ƒå›å½’ä¸­ï¼Œä»»åŠ¡æ˜¯æ‰¾åˆ°ä¸€ä¸ªå‘é‡
- en: <math alttext="ModifyingAbove beta With caret equals Start 1 By 4 Matrix 1st
    Row 1st Column beta 1 2nd Column beta 2 3rd Column  ellipsis 4th Column beta Subscript
    n EndMatrix Superscript sans-serif upper T Baseline slash slash ModifyingAbove
    beta With caret equals Start 1 By 4 Matrix 1st Row 1st Column beta 1 2nd Column
    beta 2 3rd Column  ellipsis 4th Column beta Subscript n EndMatrix Superscript
    down-tack Baseline slash slash Start 1 By 4 Matrix 1st Row 1st Column beta 1 2nd
    Column beta 2 3rd Column  ellipsis 4th Column beta Subscript n Baseline EndMatrix
    slash slash ModifyingAbove beta With caret equals Start 1 By 4 Matrix 1st Row
    1st Column beta 1 2nd Column beta 2 3rd Column  ellipsis 4th Column beta Subscript
    n Baseline EndMatrix slash slash ModifyingAbove beta With caret equals Start 1
    By 4 Matrix 1st Row 1st Column beta 1 2nd Column beta 2 3rd Column  ellipsis 4th
    Column beta Subscript n EndMatrix Superscript sans-serif upper T Baseline slash
    slash Start 1 By 3 Matrix 1st Row 1st Column w Subscript t Superscript left-parenthesis
    1 right-parenthesis Baseline 2nd Column  ellipsis 3rd Column w Subscript t Superscript
    left-parenthesis m right-parenthesis Baseline EndMatrix slash slash ModifyingAbove
    beta With caret equals left-bracket beta 1 beta 2 ellipsis beta Subscript n Baseline
    right-bracket Superscript sans-serif upper T" display="block"><mrow><mover accent="true"><mi>Î²</mi>
    <mo>^</mo></mover> <mo>=</mo> <msup><mfenced open="[" close="]"><mtable><mtr><mtd><msub><mi>Î²</mi>
    <mn>1</mn></msub></mtd> <mtd><msub><mi>Î²</mi> <mn>2</mn></msub></mtd> <mtd><mo>â‹¯</mo></mtd><mtd><msub><mi>Î²</mi>
    <mi>n</mi></msub></mtd></mtr></mtable></mfenced> <mi>ğ–³</mi></msup> <mo>/</mo>
    <mo>/</mo> <mover accent="true"><mi>Î²</mi> <mo>^</mo></mover> <mo>=</mo> <msup><mfenced
    open="[" close="]"><mtable><mtr><mtd><msub><mi>Î²</mi> <mn>1</mn></msub></mtd>
    <mtd><msub><mi>Î²</mi> <mn>2</mn></msub></mtd> <mtd><mo>â‹¯</mo></mtd><mtd><msub><mi>Î²</mi>
    <mi>n</mi></msub></mtd></mtr></mtable></mfenced> <mi>âŠ¤</mi></msup> <mo>/</mo>
    <mo>/</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><msub><mi>Î²</mi> <mn>1</mn></msub></mtd>
    <mtd><msub><mi>Î²</mi> <mn>2</mn></msub></mtd> <mtd><mo>â‹¯</mo></mtd> <mtd><msub><mi>Î²</mi>
    <mi>n</mi></msub></mtd></mtr></mtable></mfenced> <mo>/</mo> <mo>/</mo> <mover
    accent="true"><mi>Î²</mi> <mo>^</mo></mover> <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mrow><msub><mi>Î²</mi>
    <mn>1</mn></msub></mrow></mtd> <mtd><msub><mi>Î²</mi> <mn>2</mn></msub></mtd> <mtd><mo>â‹¯</mo></mtd>
    <mtd><msub><mi>Î²</mi> <mi>n</mi></msub></mtd></mtr></mtable></mfenced> <mo>/</mo>
    <mo>/</mo> <mover accent="true"><mi>Î²</mi> <mo>^</mo></mover> <mo>=</mo> <msup><mfenced
    open="[" close="]"><mtable><mtr><mtd><mrow><msub><mi>Î²</mi> <mn>1</mn></msub></mrow></mtd>
    <mtd><msub><mi>Î²</mi> <mn>2</mn></msub></mtd> <mtd><mo>â‹¯</mo></mtd><mtd><msub><mi>Î²</mi>
    <mi>n</mi></msub></mtd></mtr></mtable></mfenced> <mi>ğ–³</mi></msup> <mo>/</mo>
    <mo>/</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><msubsup><mi>w</mi> <mi>t</mi>
    <mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow></msubsup></mtd> <mtd><mo>â‹¯</mo></mtd>
    <mtd><msubsup><mi>w</mi> <mi>t</mi> <mrow><mo>(</mo><mi>m</mi><mo>)</mo></mrow></msubsup></mtd></mtr></mtable></mfenced>
    <mo>/</mo> <mo>/</mo> <mover accent="true"><mi>Î²</mi> <mo>^</mo></mover> <mo>=</mo>
    <msup><mrow><mo>[</mo><msub><mi>Î²</mi> <mn>1</mn></msub> <msub><mi>Î²</mi> <mn>2</mn></msub>
    <mo>â‹¯</mo><msub><mi>Î²</mi> <mi>n</mi></msub> <mo>]</mo></mrow> <mi>ğ–³</mi></msup></mrow></math>
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="ModifyingAbove beta With caret equals Start 1 By 4 Matrix 1st
    Row 1st Column beta 1 2nd Column beta 2 3rd Column  ellipsis 4th Column beta Subscript
    n EndMatrix Superscript sans-serif upper T Baseline slash slash ModifyingAbove
    beta With caret equals Start 1 By 4 Matrix 1st Row 1st Column beta 1 2nd Column
    beta 2 3rd Column  ellipsis 4th Column beta Subscript n EndMatrix Superscript
    down-tack Baseline slash slash Start 1 By 4 Matrix 1st Row 1st Column beta 1 2nd
    Column beta 2 3rd Column  ellipsis 4th Column beta Subscript n Baseline EndMatrix
    slash slash ModifyingAbove beta With caret equals Start 1 By 4 Matrix 1st Row
    1st Column beta 1 2nd Column beta 2 3rd Column  ellipsis 4th Column beta Subscript
    n Baseline EndMatrix slash slash ModifyingAbove beta With caret equals Start 1
    By 4 Matrix 1st Row 1st Column beta 1 2nd Column beta 2 3rd Column  ellipsis 4th
    Column beta Subscript n EndMatrix Superscript sans-serif upper T Baseline slash
    slash Start 1 By 3 Matrix 1st Row 1st Column w Subscript t Superscript left-parenthesis
    1 right-parenthesis Baseline 2nd Column  ellipsis 3rd Column w Subscript t Superscript
    left-parenthesis m right-parenthesis Baseline EndMatrix slash slash ModifyingAbove
    beta With caret equals left-bracket beta 1 beta 2 ellipsis beta Subscript n Baseline
    right-bracket Superscript sans-serif upper T" display="block"><mrow><mover accent="true"><mi>Î²</mi>
    <mo>^</mo></mover> <mo>=</mo> <msup><mfenced open="[" close="]"><mtable><mtr><mtd><msub><mi>Î²</mi>
    <mn>1</mn></msub></mtd> <mtd><msub><mi>Î²</mi> <mn>2</mn></msub></mtd> <mtd><mo>â‹¯</mo></mtd><mtd><msub><mi>Î²</mi>
    <mi>n</mi></msub></mtd></mtr></mtable></mfenced> <mi>ğ–³</mi></msup> <mo>/</mo>
    <mo>/</mo> <mover accent="true"><mi>Î²</mi> <mo>^</mo></mover> <mo>=</mo> <msup><mfenced
    open="[" close="]"><mtable><mtr><mtd><msub><mi>Î²</mi> <mn>1</mn></msub></mtd>
    <mtd><msub><mi>Î²</mi> <mn>2</mn></msub></mtd> <mtd><mo>â‹¯</mo></mtd><mtd><msub><mi>Î²</mi>
    <mi>n</mi></msub></mtd></mtr></mtable></mfenced> <mi>âŠ¤</mi></msup> <mo>/</mo>
    <mo>/</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><msub><mi>Î²</mi> <mn>1</mn></msub></mtd>
    <mtd><msub><mi>Î²</mi> <mn>2</mn></msub></mtd> <mtd><mo>â‹¯</mo></mtd> <mtd><msub><mi>Î²</mi>
    <mi>n</mi></msub></mtd></mtr></mtable></mfenced> <mo>/</mo> <mo>/</mo> <mover
    accent="true"><mi>Î²</mi> <mo>^</mo></mover> <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mrow><msub><mi>Î²</mi>
    <mn>1</mn></msub></mrow></mtd> <mtd><msub><mi>Î²</mi> <mn>2</mn></msub></mtd> <mtd><mo>â‹¯</mo></mtd>
    <mtd><msub><mi>Î²</mi> <mi>n</mi></msub></mtd></mtr></mtable></mfenced> <mo>/</mo>
    <mo>/</mo> <mover accent="true"><mi>Î²</mi> <mo>^</mo></mover> <mo>=</mo> <msup><mfenced
    open="[" close="]"><mtable><mtr><mtd><mrow><msub><mi>Î²</mi> <mn>1</mn></msub></mrow></mtd>
    <mtd><msub><mi>Î²</mi> <mn>2</mn></msub></mtd> <mtd><mo>â‹¯</mo></mtd><mtd><msub><mi>Î²</mi>
    <mi>n</mi></msub></mtd></mtr></mtable></mfenced> <mi>ğ–³</mi></msup> <mo>/</mo>
    <mo>/</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><msubsup><mi>w</mi> <mi>t</mi>
    <mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow></msubsup></mtd> <mtd><mo>â‹¯</mo></mtd>
    <mtd><msubsup><mi>w</mi> <mi>t</mi> <mrow><mo>(</mo><mi>m</mi><mo>)</mo></mrow></msubsup></mtd></mtr></mtable></mfenced>
    <mo>/</mo> <mo>/</mo> <mover accent="true"><mi>Î²</mi> <mo>^</mo></mover> <mo>=</mo>
    <msup><mrow><mo>[</mo><msub><mi>Î²</mi> <mn>1</mn></msub> <msub><mi>Î²</mi> <mn>2</mn></msub>
    <mo>â‹¯</mo><msub><mi>Î²</mi> <mi>n</mi></msub> <mo>]</mo></mrow> <mi>ğ–³</mi></msup></mrow></math>
- en: that satisfies the matrix form of the normal equations
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿å¾—æ»¡è¶³æ­£è§„æ–¹ç¨‹çš„çŸ©é˜µå½¢å¼
- en: <math display="block"><mrow><mover><mi>ğ›ƒ</mi> <mo stretchy="false" style="math-style:normal;math-depth:0;">^</mo></mover>
    <mo>=</mo> <msup><mrow><mo fence="true" form="prefix">[</mo> <mtable columnalign="center"><mtr><mtd><mrow><msup><mi
    mathvariant="bold">X</mi> <mi>ğ–³</mi></msup> <mi mathvariant="bold">X</mi></mrow></mtd></mtr></mtable>
    <mo fence="true" form="postfix">]</mo></mrow> <mrow><mo>âˆ’</mo> <mn>1</mn></mrow></msup>
    <msup><mi mathvariant="bold">X</mi> <mi>ğ–³</mi></msup> <mi mathvariant="bold">Y</mi>
    <mo lspace="0em" rspace="0em">â„</mo> <mo lspace="0em" rspace="0em">â„</mo> <mover><mi>ğ›ƒ</mi>
    <mo stretchy="false" style="math-style:normal;math-depth:0;">^</mo></mover> <mo>=</mo>
    <mo form="prefix" stretchy="false">[</mo> <msup><mi mathvariant="bold">X</mi>
    <mi>ğ–³</mi></msup> <mi mathvariant="bold">X</mi> <msup><mo form="postfix" stretchy="false">]</mo>
    <mrow><mo>âˆ’</mo> <mn>1</mn></mrow></msup> <msup><mi mathvariant="bold">X</mi>
    <mi>ğ–³</mi></msup> <mi>ğ²</mi></mrow></math>
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><mover><mi>ğ›ƒ</mi> <mo stretchy="false" style="math-style:normal;math-depth:0;">^</mo></mover>
    <mo>=</mo> <msup><mrow><mo fence="true" form="prefix">[</mo> <mtable columnalign="center"><mtr><mtd><mrow><msup><mi
    mathvariant="bold">X</mi> <mi>ğ–³</mi></msup> <mi mathvariant="bold">X</mi></mrow></mtd></mtr></mtable>
    <mo fence="true" form="postfix">]</mo></mrow> <mrow><mo>âˆ’</mo> <mn>1</mn></mrow></msup>
    <msup><mi mathvariant="bold">X</mi> <mi>ğ–³</mi></msup> <mi mathvariant="bold">Y</mi>
    <mo lspace="0em" rspace="0em">â„</mo> <mo lspace="0em" rspace="0em">â„</mo> <mover><mi>ğ›ƒ</mi>
    <mo stretchy="false" style="math-style:normal;math-depth:0;">^</mo></mover> <mo>=</mo>
    <mo form="prefix" stretchy="false">[</mo> <msup><mi mathvariant="bold">X</mi>
    <mi>ğ–³</mi></msup> <mi mathvariant="bold">X</mi> <msup><mo form="postfix" stretchy="false">]</mo>
    <mrow><mo>âˆ’</mo> <mn>1</mn></mrow></msup> <msup><mi mathvariant="bold">X</mi>
    <mi>ğ–³</mi></msup> <mi>ğ²</mi></mrow></math>
- en: where <math alttext="bold upper X"><mi>ğ—</mi></math> is the design matrix containing
    *p* columns of independent variable data, and *n* observations (rows), with the
    number of observations *n* â€œcomfortablyâ€ greater than the number of data columns
    *p* to ensure stability. This is typically the case in these types of fund tracking
    applications.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­ <math alttext="bold upper X"><mi>ğ—</mi></math> æ˜¯åŒ…å« *p* åˆ—è‡ªå˜é‡æ•°æ®å’Œ *n* ä¸ªè§‚å¯Ÿï¼ˆè¡Œï¼‰çš„è®¾è®¡çŸ©é˜µï¼Œä¸”è§‚å¯Ÿæ•°
    *n* â€œèˆ’é€‚åœ°â€å¤§äºæ•°æ®åˆ—æ•° *p*ï¼Œä»¥ç¡®ä¿ç¨³å®šæ€§ã€‚è¿™åœ¨è¿™ç±»åŸºé‡‘è¿½è¸ªåº”ç”¨ä¸­é€šå¸¸æ˜¯æƒ…å†µã€‚
- en: Note
  id: totrans-244
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: æ³¨æ„
- en: For fund tracking applications, the intercept term <math alttext="beta 0"><msub><mi>Î²</mi>
    <mn>0</mn></msub></math> can usually be dropped, so it is omitted here. For regression
    cases where an intercept is required, a final column of ones needs to be appended
    to the design matrix when using Eigen. _
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºåŸºé‡‘è¿½è¸ªåº”ç”¨ç¨‹åºï¼Œæ‹¦æˆªé¡¹ <math alttext="beta 0"><msub><mi>Î²</mi> <mn>0</mn></msub></math>
    é€šå¸¸å¯ä»¥è¢«åˆ é™¤ï¼Œå› æ­¤åœ¨æ­¤å¤„è¢«çœç•¥ã€‚å¯¹äºéœ€è¦æˆªè·çš„å›å½’æ¡ˆä¾‹ï¼Œå½“ä½¿ç”¨Eigenæ—¶ï¼Œéœ€è¦åœ¨è®¾è®¡çŸ©é˜µä¸­é™„åŠ ä¸€ä¸ªå…¨ä¸º1çš„æœ€åä¸€åˆ—ã€‚ _
- en: A commonly employed solution is the compact Singular Value Decomposition (SVD),
    which replaces the matrix <math alttext="bold upper X"><mi>ğ—</mi></math> with
    the decomposition <math alttext="bold upper U bold upper Sigma bold upper V Superscript
    upper T"><mrow><mi>ğ”</mi> <mi>Î£</mi> <msup><mi>ğ•</mi> <mi>T</mi></msup></mrow></math>
    , where <math alttext="bold upper U"><mi>ğ”</mi></math> is an <math alttext="n
    times p"><mrow><mi>n</mi> <mo>Ã—</mo> <mi>p</mi></mrow></math> matrix, <math alttext="bold
    upper V"><mi>ğ•</mi></math> is <math alttext="p times p"><mrow><mi>p</mi> <mo>Ã—</mo>
    <mi>p</mi></mrow></math> , and <math alttext="bold upper Sigma"><mi>Î£</mi></math>
    is a <math alttext="p times p"><mrow><mi>p</mi> <mo>Ã—</mo> <mi>p</mi></mrow></math>
    diagonal matrix of strictly positive values. Making this substitution in the original
    formula for <math alttext="ModifyingAbove beta With caret"><mover accent="true"><mi>Î²</mi>
    <mo>^</mo></mover></math> , we get
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ç§å¸¸ç”¨çš„è§£å†³æ–¹æ¡ˆæ˜¯ç´§å‡‘çš„å¥‡å¼‚å€¼åˆ†è§£ï¼ˆSVDï¼‰ï¼Œå®ƒç”¨åˆ†è§£ <math alttext="bold upper U bold upper Sigma bold
    upper V Superscript upper T"><mrow><mi>ğ”</mi> <mi>Î£</mi> <msup><mi>ğ•</mi> <mi>T</mi></msup></mrow></math>
    æ›¿æ¢çŸ©é˜µ <math alttext="bold upper X"><mi>ğ—</mi></math>ï¼Œå…¶ä¸­ <math alttext="bold upper
    U"><mi>ğ”</mi></math> æ˜¯ä¸€ä¸ª <math alttext="n times p"><mrow><mi>n</mi> <mo>Ã—</mo>
    <mi>p</mi></mrow></math> çŸ©é˜µï¼Œ<math alttext="bold upper V"><mi>ğ•</mi></math> æ˜¯ <math
    alttext="p times p"><mrow><mi>p</mi> <mo>Ã—</mo> <mi>p</mi></mrow></math> çŸ©é˜µï¼Œ<math
    alttext="bold upper Sigma"><mi>Î£</mi></math> æ˜¯ä¸€ä¸ªç”±ä¸¥æ ¼æ­£æ•°å€¼æ„æˆçš„ <math alttext="p times
    p"><mrow><mi>p</mi> <mo>Ã—</mo> <mi>p</mi></mrow></math> å¯¹è§’çŸ©é˜µã€‚å°†è¿™ä¸€æ›¿æ¢åº”ç”¨åˆ° <math alttext="ModifyingAbove
    beta With caret"><mover accent="true"><mi>Î²</mi> <mo>^</mo></mover></math> çš„åŸå§‹å…¬å¼ä¸­ï¼Œæˆ‘ä»¬å¾—åˆ°
- en: <math alttext="ModifyingAbove beta With caret equals bold upper V bold upper
    Sigma bold upper U Superscript sans-serif upper T Baseline bold y" display="block"><mrow><mover
    accent="true"><mi>Î²</mi> <mo>^</mo></mover> <mo>=</mo> <mi>ğ•</mi> <mi>Î£</mi> <msup><mi>ğ”</mi>
    <mi>ğ–³</mi></msup> <mi>ğ²</mi></mrow></math>
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="ModifyingAbove beta With caret equals bold upper V bold upper
    Sigma bold upper U Superscript sans-serif upper T Baseline bold y" display="block"><mrow><mover
    accent="true"><mi>Î²</mi> <mo>^</mo></mover> <mo>=</mo> <mi>ğ•</mi> <mi>Î£</mi> <msup><mi>ğ”</mi>
    <mi>ğ–³</mi></msup> <mi>ğ²</mi></mrow></math>
- en: Eigen provides two SVD solvers that can be used for obtaining the least squares
    estimates of the regression coefficients. The first of these, as described in
    the Eigen documentation, is the [Jacobi SVD decomposition of a rectangular matrix_](https://eigen.tuxfamily.org/dox-devel/classEigen_1_1JacobiSVD.html)
    **{22}**. The documentation also states the Jacobi version is recommended for
    design matrices of 16 columns or less, which is sometimes sufficient for fund
    tracking problems.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Eigen æä¾›äº†ä¸¤ä¸ªå¯ç”¨äºè·å–å›å½’ç³»æ•°æœ€å°äºŒä¹˜ä¼°è®¡çš„SVDæ±‚è§£å™¨ã€‚å…¶ä¸­ä¹‹ä¸€ï¼Œå¦‚Eigenæ–‡æ¡£ä¸­æ‰€è¿°ï¼Œæ˜¯ [Jacobi SVD decomposition
    of a rectangular matrix_](https://eigen.tuxfamily.org/dox-devel/classEigen_1_1JacobiSVD.html)
    **{22}**ã€‚æ–‡æ¡£è¿˜æŒ‡å‡ºï¼ŒJacobi ç‰ˆæœ¬å»ºè®®ç”¨äºè®¾è®¡çŸ©é˜µåˆ—æ•°ä¸è¶…è¿‡16åˆ—çš„æƒ…å†µï¼Œè¿™åœ¨æŸäº›åŸºé‡‘è¿½è¸ªé—®é¢˜ä¸­å·²è¶³å¤Ÿã€‚
- en: 'The way this works is given the design matrix predictor data contained in a
    `MatrixXd X`, Eigen sets up the SVD logic inside the class template `Eigen::JacobiSVD`.
    Then, given the response data contained in a `VectorXd Y`, solving for <math alttext="ModifyingAbove
    beta With caret"><mover accent="true"><mi>Î²</mi> <mo>^</mo></mover></math> is
    again just two lines of code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§å·¥ä½œæ–¹å¼æ˜¯ï¼Œåœ¨ç»™å®šè®¾è®¡çŸ©é˜µé¢„æµ‹æ•°æ®åŒ…å«åœ¨ `MatrixXd X` ä¸­æ—¶ï¼ŒEigen åœ¨ç±»æ¨¡æ¿ `Eigen::JacobiSVD` ä¸­è®¾ç½®äº†SVDé€»è¾‘ã€‚ç„¶åï¼Œç»™å®šå“åº”æ•°æ®åŒ…å«åœ¨
    `VectorXd Y` ä¸­ï¼Œæ±‚è§£ <math alttext="ModifyingAbove beta With caret"><mover accent="true"><mi>Î²</mi>
    <mo>^</mo></mover></math> åªéœ€ä¸¤è¡Œä»£ç ï¼š
- en: '[PRE63]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note
  id: totrans-251
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: æ³¨æ„
- en: 'The `Eigen::ComputeThinU | Eigen::ComputeThinV` bitwise-or parameter instructs
    the program to use the compact version of SVD. If the full SVD is desired, then
    the above `JacobiSVD` instantiation would be:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`Eigen::ComputeThinU | Eigen::ComputeThinV` çš„æŒ‰ä½æˆ–å‚æ•°æŒ‡ç¤ºç¨‹åºä½¿ç”¨SVDçš„ç´§å‡‘ç‰ˆæœ¬ã€‚å¦‚æœéœ€è¦å®Œæ•´çš„SVDï¼Œåˆ™ä»¥ä¸Š`JacobiSVD`å®ä¾‹åŒ–å°†æ˜¯ï¼š'
- en: '[PRE64]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In this case, the <math alttext="bold upper U"><mi>ğ”</mi></math> matrix will
    be <math alttext="n times n"><mrow><mi>n</mi> <mo>Ã—</mo> <mi>n</mi></mrow></math>
    , and <math alttext="bold upper Sigma"><mi>Î£</mi></math> will be an <math alttext="n
    times p"><mrow><mi>n</mi> <mo>Ã—</mo> <mi>p</mi></mrow></math> pseudoinverse.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ<math alttext="bold upper U"><mi>ğ”</mi></math> çŸ©é˜µå°†æ˜¯ <math alttext="n
    times n"><mrow><mi>n</mi> <mo>Ã—</mo> <mi>n</mi></mrow></math> ï¼Œ<math alttext="bold
    upper Sigma"><mi>Î£</mi></math> å°†æ˜¯ <math alttext="n times p"><mrow><mi>n</mi> <mo>Ã—</mo>
    <mi>p</mi></mrow></math> ä¼ªé€†ã€‚
- en: There are no default settings.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: æ²¡æœ‰é»˜è®¤è®¾ç½®ã€‚
- en: As an example, suppose we have three sector ETFâ€™s and wish to examine their
    relationship to the broader market (eg the S&P 500), and suppose we have 30 daily
    observations.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä¸‰ä¸ªè¡Œä¸šETFï¼Œå¹¶å¸Œæœ›ç ”ç©¶å®ƒä»¬ä¸æ›´å¹¿æ³›å¸‚åœºï¼ˆå¦‚æ ‡å‡†æ™®å°”500æŒ‡æ•°ï¼‰çš„å…³ç³»ï¼Œå‡è®¾æˆ‘ä»¬æœ‰30å¤©çš„æ¯æ—¥è§‚å¯Ÿæ•°æ®ã€‚
- en: 'The design matrix will contain the three ETF returns and is stored in a `MatrixXd`
    called `X`, as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: è®¾è®¡çŸ©é˜µå°†åŒ…å«ä¸‰ä¸ªETFå›æŠ¥ï¼Œå¹¶å­˜å‚¨åœ¨åä¸º`X`çš„`MatrixXd`ä¸­ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE65]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Similarly, the market returns are stored in a `VectorXd` array `Y`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ç±»ä¼¼åœ°ï¼Œå¸‚åœºå›æŠ¥ä»¥`VectorXd`æ•°ç»„`Y`å­˜å‚¨ï¼š
- en: '[PRE66]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Obtaining the regression coefficients is just a matter of compiling and running
    the SVD using the two lines of code shown at the outset, which gives us for `beta`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: è·å¾—å›å½’ç³»æ•°åªæ˜¯é€šè¿‡ç¼–è¯‘å’Œè¿è¡Œåœ¨ä¸€å¼€å§‹æ˜¾ç¤ºçš„ä¸¤è¡Œä»£ç ï¼Œè¿™ç»™æˆ‘ä»¬`beta`ï¼š
- en: '[PRE67]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The <math alttext="bold upper U"><mi>ğ”</mi></math> and <math alttext="bold
    upper V"><mi>ğ•</mi></math> matrices can also be obtained if desired, along with
    the <math alttext="bold upper Sigma"><mi>Î£</mi></math> matrix, using the following
    accessor functions:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœéœ€è¦ï¼Œè¿˜å¯ä»¥ä½¿ç”¨ä»¥ä¸‹è®¿é—®å™¨å‡½æ•°è·å¾—<math alttext="bold upper U"><mi>ğ”</mi></math> å’Œ <math alttext="bold
    upper V"><mi>ğ•</mi></math> çŸ©é˜µï¼Œä»¥åŠ <math alttext="bold upper Sigma"><mi>Î£</mi></math>
    çŸ©é˜µï¼š
- en: '[PRE68]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: An alternative SVD solver, the [*Bidiagonal Divide and Conquer SVD*](https://eigen.tuxfamily.org/dox-devel/classEigen_1_1BDCSVD.html),
    **{23}** is also available in Eigen. Per the documentation, it is recommended
    for design matrices with greater than 16 columns for better performance.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€ç§å¯é€‰çš„SVDæ±‚è§£å™¨ï¼Œ[*Bidiagonal Divide and Conquer SVD*](https://eigen.tuxfamily.org/dox-devel/classEigen_1_1BDCSVD.html)ï¼Œ**{23}**
    ä¹Ÿå¯åœ¨Eigenä¸­æ‰¾åˆ°ã€‚æ ¹æ®æ–‡æ¡£ï¼Œæ¨èç”¨äºè®¾è®¡çŸ©é˜µåˆ—æ•°å¤§äº16çš„æƒ…å†µä»¥è·å¾—æ›´å¥½çš„æ€§èƒ½ã€‚
- en: 'The setup is the same as the Jacobi case, but using the `BDCSVD` class in place
    of `JacobiSVD`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: è®¾ç½®ä¸Jacobiæƒ…å†µç›¸åŒï¼Œä½†ä½¿ç”¨`JacobiSVD`çš„ä½ç½®ä¸Šçš„`BDCSVD`ç±»ï¼š
- en: '[PRE69]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: It should be noted Eigen also provides QR decompositions as well as the capability
    of just coding in the normal equations with Eigen matrices and operations. As
    noted in the documentation, [*Solving linear least squares systems*](https://eigen.tuxfamily.org/dox-devel/group__LeastSquares.html),
    these can be faster than SVD methods, but they can be less accurate. **{24}**
    These are alternatives you might want to consider if speed is an issue, but under
    the right conditions.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: å€¼å¾—æ³¨æ„çš„æ˜¯Eigenè¿˜æä¾›QRåˆ†è§£ä»¥åŠä½¿ç”¨EigençŸ©é˜µå’Œæ“ä½œè¿›è¡Œæ­£å¸¸æ–¹ç¨‹æ±‚è§£çš„èƒ½åŠ›ã€‚å¦‚æ–‡æ¡£æ‰€è¿°ï¼Œ[*è§£çº¿æ€§æœ€å°äºŒä¹˜ç³»ç»Ÿ*](https://eigen.tuxfamily.org/dox-devel/group__LeastSquares.html)ï¼Œè¿™äº›æ–¹æ³•å¯èƒ½æ¯”SVDæ–¹æ³•æ›´å¿«ï¼Œä½†å¯èƒ½ç²¾åº¦è¾ƒä½ã€‚**{24}**
    å¦‚æœé€Ÿåº¦æ˜¯é—®é¢˜ï¼Œè¿™äº›éƒ½æ˜¯æ‚¨å¯ä»¥è€ƒè™‘çš„å¤‡é€‰æ–¹æ¡ˆï¼Œä½†éœ€è¦åœ¨é€‚å½“çš„æ¡ä»¶ä¸‹ä½¿ç”¨ã€‚
- en: Correlated Random Equity Paths and the Cholesky Decomposition
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ç›¸å…³çš„éšæœºè‚¡ç¥¨è·¯å¾„å’Œä¹”åˆ—æ–¯åŸºåˆ†è§£
- en: 'The Cholesky decomposition is a popular tool in finance for generating correlated
    Monte Carlo equity path simulations. For example, when pricing basket options,
    covariances between movements in the basket securities need to be accounted for,
    specifically in generating correlated random normal draws. This is in contrast
    to generating a random price path for a single underlying security, as we saw
    in Chapter 8:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨é‡‘èä¸­ï¼Œä¹”åˆ—æ–¯åŸºåˆ†è§£æ˜¯ç”Ÿæˆç›¸å…³çš„è’™ç‰¹å¡æ´›è‚¡ç¥¨è·¯å¾„æ¨¡æ‹Ÿçš„ä¸€ç§å¸¸ç”¨å·¥å…·ã€‚ä¾‹å¦‚ï¼Œåœ¨å®šä»·ç¯®å­æœŸæƒæ—¶ï¼Œéœ€è¦è€ƒè™‘ç¯®å­è¯åˆ¸è¿åŠ¨ä¹‹é—´çš„åæ–¹å·®ï¼Œç‰¹åˆ«æ˜¯åœ¨ç”Ÿæˆç›¸å…³çš„éšæœºæ­£æ€æŠ½å–æ—¶ã€‚è¿™ä¸ç”Ÿæˆå•ä¸ªåŸºç¡€è¯åˆ¸çš„éšæœºä»·æ ¼è·¯å¾„å½¢æˆå¯¹æ¯”ï¼Œæ­£å¦‚æˆ‘ä»¬åœ¨ç¬¬8ç« ä¸­çœ‹åˆ°çš„é‚£æ ·ã€‚
- en: <math alttext="upper S Subscript t Baseline equals upper S Subscript t minus
    1 Baseline e Superscript left-parenthesis StartFraction r minus sigma squared
    Over 2 EndFraction right-parenthesis normal upper Delta t plus sigma epsilon Super
    Subscript t Superscript StartRoot normal upper Delta t EndRoot" display="block"><mrow><msub><mi>S</mi>
    <mi>t</mi></msub> <mo>=</mo> <msub><mi>S</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <msup><mi>e</mi> <mrow><mrow><mo>(</mo><mfrac><mrow><mi>r</mi><mo>-</mo><msup><mi>Ïƒ</mi>
    <mn>2</mn></msup></mrow> <mn>2</mn></mfrac><mo>)</mo></mrow><mi>Î”</mi><mi>t</mi><mo>+</mo><mi>Ïƒ</mi><msub><mi>Îµ</mi>
    <mi>t</mi></msub> <msqrt><mrow><mi>Î”</mi><mi>t</mi></mrow></msqrt></mrow></msup></mrow></math>
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper S Subscript t Baseline equals upper S Subscript t minus
    1 Baseline e Superscript left-parenthesis StartFraction r minus sigma squared
    Over 2 EndFraction right-parenthesis normal upper Delta t plus sigma epsilon Super
    Subscript t Superscript StartRoot normal upper Delta t EndRoot" display="block"><mrow><msub><mi>S</mi>
    <mi>t</mi></msub> <mo>=</mo> <msub><mi>S</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <msup><mi>e</mi> <mrow><mrow><mo>(</mo><mfrac><mrow><mi>r</mi><mo>-</mo><msup><mi>Ïƒ</mi>
    <mn>2</mn></msup></mrow> <mn>2</mn></mfrac><mo>)</mo></mrow><mi>Î”</mi><mi>t</mi><mo>+</mo><mi>Ïƒ</mi><msub><mi>Îµ</mi>
    <mi>t</mi></msub> <msqrt><mrow><mi>Î”</mi><mi>t</mi></mrow></msqrt></mrow></msup></mrow></math>
- en: where again <math alttext="epsilon Subscript t Baseline tilde upper N left-parenthesis
    0 comma 1 right-parenthesis"><mrow><msub><mi>Îµ</mi> <mi>t</mi></msub> <mo>âˆ¼</mo>
    <mi>N</mi> <mrow><mo>(</mo> <mn>0</mn> <mo>,</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
    , <math alttext="sigma"><mi>Ïƒ</mi></math> is the equity volatility, and <math
    alttext="r"><mi>r</mi></math> represents the risk-free interest rate,
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­å†æ¬¡ <math alttext="epsilon Subscript t Baseline tilde upper N left-parenthesis
    0 comma 1 right-parenthesis"><mrow><msub><mi>Îµ</mi> <mi>t</mi></msub> <mo>âˆ¼</mo>
    <mi>N</mi> <mrow><mo>(</mo> <mn>0</mn> <mo>,</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>ï¼Œ<math
    alttext="sigma"><mi>Ïƒ</mi></math> æ˜¯è‚¡ç¥¨çš„æ³¢åŠ¨ç‡ï¼Œ<math alttext="r"><mi>r</mi></math>
    è¡¨ç¤ºæ— é£é™©åˆ©ç‡ï¼Œ
- en: In the case of a basket option, we now need to generate a path for each of say
    *m* assets at each time <math alttext="t"><mi>t</mi></math> , where the <math
    alttext="sigma epsilon Subscript t"><mrow><mi>Ïƒ</mi> <msub><mi>Îµ</mi> <mi>t</mi></msub></mrow></math>
    term is replaced by a random term <math alttext="w Subscript t Superscript left-parenthesis
    i right-parenthesis"><msubsup><mi>w</mi> <mi>t</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup></math>
    that is again based on a standard normal draw, but whose fluctuations also contain
    correlations with the other assets in the basket. Therefore, we need to generate
    a set of prices <math alttext="StartSet upper S Subscript t Superscript left-parenthesis
    i right-parenthesis Baseline EndSet"><mfenced separators="" open="{" close="}"><msubsup><mi>S</mi>
    <mi>t</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup></mfenced></math>
    where
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç¯®å­æœŸæƒçš„æƒ…å†µä¸‹ï¼Œç°åœ¨æˆ‘ä»¬éœ€è¦ä¸ºæ¯ä¸ªèµ„äº§ï¼ˆæ€»æ•°ä¸º *m* ä¸ªï¼‰åœ¨æ¯ä¸ªæ—¶é—´ç‚¹ <math alttext="t"><mi>t</mi></math> ç”Ÿæˆä¸€æ¡è·¯å¾„ï¼Œå…¶ä¸­æœ¯è¯­
    <math alttext="sigma epsilon Subscript t"><mrow><mi>Ïƒ</mi> <msub><mi>Îµ</mi> <mi>t</mi></msub></mrow></math>
    è¢«ä¸€ä¸ªéšæœºé¡¹ <math alttext="w Subscript t Superscript left-parenthesis i right-parenthesis"><msubsup><mi>w</mi>
    <mi>t</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup></math> å–ä»£ï¼Œè¿™ä¸ªéšæœºé¡¹å†æ¬¡åŸºäºæ ‡å‡†æ­£æ€åˆ†å¸ƒæŠ½å–ï¼Œä½†å…¶æ³¢åŠ¨ä¹ŸåŒ…å«ä¸ç¯®å­ä¸­å…¶ä»–èµ„äº§çš„ç›¸å…³æ€§ã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦ç”Ÿæˆä¸€ç»„ä»·æ ¼
    <math alttext="StartSet upper S Subscript t Superscript left-parenthesis i right-parenthesis
    Baseline EndSet"><mfenced separators="" open="{" close="}"><msubsup><mi>S</mi>
    <mi>t</mi> <mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msubsup></mfenced></math>ï¼Œå…¶ä¸­
- en: <math alttext="upper S Subscript t Superscript left-parenthesis 1 right-parenthesis
    Baseline equals upper S Subscript t minus 1 Superscript left-parenthesis 1 right-parenthesis
    Baseline e Superscript left-parenthesis StartFraction r minus sigma squared Over
    2 EndFraction right-parenthesis normal upper Delta t plus w Super Subscript t
    Super Superscript left-parenthesis 1 right-parenthesis Superscript StartRoot normal
    upper Delta t EndRoot Baseline left-parenthesis asterisk right-parenthesis" display="block"><mrow><msubsup><mi>S</mi>
    <mi>t</mi> <mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow></msubsup> <mo>=</mo> <msubsup><mi>S</mi>
    <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow> <mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow></msubsup>
    <msup><mi>e</mi> <mrow><mrow><mo>(</mo><mfrac><mrow><mi>r</mi><mo>-</mo><msup><mi>Ïƒ</mi>
    <mn>2</mn></msup></mrow> <mn>2</mn></mfrac><mo>)</mo></mrow><mi>Î”</mi><mi>t</mi><mo>+</mo><msubsup><mi>w</mi>
    <mi>t</mi> <mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow></msubsup> <msqrt><mrow><mi>Î”</mi><mi>t</mi></mrow></msqrt></mrow></msup>
    <mrow><mo>(</mo> <mo>*</mo> <mo>)</mo></mrow></mrow></math><math alttext="period"
    display="block"><mo>.</mo></math><math alttext="period" display="block"><mo>.</mo></math><math
    alttext="period" display="block"><mo>.</mo></math><math alttext="upper S Subscript
    t Superscript left-parenthesis m right-parenthesis Baseline equals upper S Subscript
    t minus 1 Superscript left-parenthesis m right-parenthesis Baseline e Superscript
    left-parenthesis StartFraction r minus sigma squared Over 2 EndFraction right-parenthesis
    normal upper Delta t plus w Super Subscript t Super Superscript left-parenthesis
    m right-parenthesis Superscript StartRoot normal upper Delta t EndRoot" display="block"><mrow><msubsup><mi>S</mi>
    <mi>t</mi> <mrow><mo>(</mo><mi>m</mi><mo>)</mo></mrow></msubsup> <mo>=</mo> <msubsup><mi>S</mi>
    <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow> <mrow><mo>(</mo><mi>m</mi><mo>)</mo></mrow></msubsup>
    <msup><mi>e</mi> <mrow><mrow><mo>(</mo><mfrac><mrow><mi>r</mi><mo>-</mo><msup><mi>Ïƒ</mi>
    <mn>2</mn></msup></mrow> <mn>2</mn></mfrac><mo>)</mo></mrow><mi>Î”</mi><mi>t</mi><mo>+</mo><msubsup><mi>w</mi>
    <mi>t</mi> <mrow><mo>(</mo><mi>m</mi><mo>)</mo></mrow></msubsup> <msqrt><mrow><mi>Î”</mi><mi>t</mi></mrow></msqrt></mrow></msup></mrow></math>
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper S Subscript t Superscript left-parenthesis 1 right-parenthesis
    Baseline equals upper S Subscript t minus 1 Superscript left-parenthesis 1 right-parenthesis
    Baseline e Superscript left-parenthesis StartFraction r minus sigma squared Over
    2 EndFraction right-parenthesis normal upper Delta t plus w Super Subscript t
    Super Superscript left-parenthesis 1 right-parenthesis Superscript StartRoot normal
    upper Delta t EndRoot Baseline left-parenthesis asterisk right-parenthesis" display="block"><mrow><msubsup><mi>S</mi>
    <mi>t</mi> <mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow></msubsup> <mo>=</mo> <msubsup><mi>S</mi>
    <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow> <mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow></msubsup>
    <msup><mi>e</mi> <mrow><mrow><mo>(</mo><mfrac><mrow><mi>r</mi><mo>-</mo><msup><mi>Ïƒ</mi>
    <mn>2</mn></msup></mrow> <mn>2</mn></mfrac><mo>)</mo></mrow><mi>Î”</mi><mi>t</mi><mo>+</mo><msubsup><mi>w</mi>
    <mi>t</mi> <mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow></msubsup> <msqrt><mrow><mi>Î”</mi><mi>t</mi></mrow></msqrt></mrow></msup>
    <mrow><mo>(</mo> <mo>*</mo> <mo>)</mo></mrow></mrow></math><math alttext="period"
    display="block"><mo>ã€‚</mo></math><math alttext="period" display="block"><mo>ã€‚</mo></math><math
    alttext="period" display="block"><mo>ã€‚</mo></math><math alttext="upper S Subscript
    t Superscript left-parenthesis m right-parenthesis Baseline equals upper S Subscript
    t minus 1 Superscript left-parenthesis m right-parenthesis Baseline e Superscript
    left-parenthesis StartFraction r minus sigma squared Over 2 EndFraction right-parenthesis
    normal upper Delta t plus w Super Subscript t Super Superscript left-parenthesis
    m right-parenthesis Superscript StartRoot normal upper Delta t EndRoot" display="block"><mrow><msubsup><mi>S</mi>
    <mi>t</mi> <mrow><mo>(</mo><mi>m</mi><mo>)</mo></mrow></msubsup> <mo>=</mo> <msubsup><mi>S</mi>
    <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow> <mrow><mo>(</mo><mi>m</mi><mo>)</mo></mrow></msubsup>
    <msup><mi>e</mi> <mrow><mrow><mo>(</mo><mfrac><mrow><mi>r</mi><mo>-</mo><msup><mi>Ïƒ</mi>
    <mn>2</mn></msup></mrow> <mn>2</mn></mfrac><mo>)</mo></mrow><mi>Î”</mi><mi>t</mi><mo>+</mo><msubsup><mi>w</mi>
    <mi>t</mi> <mrow><mo>(</mo><mi>m</mi><mo>)</mo></mrow></msubsup> <msqrt><mrow><mi>Î”</mi><mi>t</mi></mrow></msqrt></mrow></msup></mrow></math>
- en: for each asset <math alttext="i equals 1 comma ellipsis comma m"><mrow><mi>i</mi>
    <mo>=</mo> <mn>1</mn> <mo>,</mo> <mo>â‹¯</mo> <mo>,</mo> <mi>m</mi></mrow></math>
    at each time step <math alttext="t Subscript j Baseline comma j equals 1 comma
    ellipsis comma n"><mrow><msub><mi>t</mi> <mi>j</mi></msub> <mo>,</mo> <mi>j</mi>
    <mo>=</mo> <mn>1</mn> <mo>,</mo> <mo>â‹¯</mo> <mo>,</mo> <mi>n</mi></mrow></math>
    . Our task is to calculate the random but correlated vector
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæ¯ä¸ªèµ„äº§ <math alttext="i equals 1 comma ellipsis comma m"><mrow><mi>i</mi> <mo>=</mo>
    <mn>1</mn> <mo>,</mo> <mo>â‹¯</mo> <mo>,</mo> <mi>m</mi></mrow></math> åœ¨æ¯ä¸ªæ—¶é—´æ­¥ <math
    alttext="t Subscript j Baseline comma j equals 1 comma ellipsis comma n"><mrow><msub><mi>t</mi>
    <mi>j</mi></msub> <mo>,</mo> <mi>j</mi> <mo>=</mo> <mn>1</mn> <mo>,</mo> <mo>â‹¯</mo>
    <mo>,</mo> <mi>n</mi></mrow></math> ã€‚æˆ‘ä»¬çš„ä»»åŠ¡æ˜¯è®¡ç®—éšæœºä½†ç›¸å…³çš„å‘é‡
- en: <math alttext="Start 1 By 3 Matrix 1st Row 1st Column w Subscript t Superscript
    left-parenthesis 1 right-parenthesis 2nd Column  ellipsis 3rd Column w Subscript
    t Superscript left-parenthesis m right-parenthesis EndMatrix Superscript sans-serif
    upper T" display="block"><msup><mfenced open="[" close="]"><mtable><mtr><mtd><msubsup><mi>w</mi>
    <mi>t</mi> <mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow></msubsup></mtd> <mtd><mo>â‹¯</mo></mtd><mtd><msubsup><mi>w</mi>
    <mi>t</mi> <mrow><mo>(</mo><mi>m</mi><mo>)</mo></mrow></msubsup></mtd></mtr></mtable></mfenced>
    <mi>ğ–³</mi></msup></math>
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 1 By 3 Matrix 1st Row 1st Column w Subscript t Superscript
    left-parenthesis 1 right-parenthesis 2nd Column  ellipsis 3rd Column w Subscript
    t Superscript left-parenthesis m right-parenthesis EndMatrix Superscript sans-serif
    upper T" display="block"><msup><mfenced open="[" close="]"><mtable><mtr><mtd><msubsup><mi>w</mi>
    <mi>t</mi> <mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow></msubsup></mtd> <mtd><mo>â‹¯</mo></mtd><mtd><msubsup><mi>w</mi>
    <mi>t</mi> <mrow><mo>(</mo><mi>m</mi><mo>)</mo></mrow></msubsup></mtd></mtr></mtable></mfenced>
    <mi>ğ–³</mi></msup></math>
- en: for each time <math alttext="t"><mi>t</mi></math> . This is where the Cholesky
    decomposition â€“ available in Eigen â€“ comes into play. For an <math alttext="n
    times n"><mrow><mi>n</mi> <mo>Ã—</mo> <mi>n</mi></mrow></math> covariance matrix
    <math alttext="bold upper Sigma"><mi>Î£</mi></math> , assuming it is positive definite,
    will have a Cholesky decomposition
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæ¯ä¸ªæ—¶é—´ <math alttext="t"><mi>t</mi></math>ã€‚è¿™å°±æ˜¯Choleskyåˆ†è§£çš„ä½œç”¨ã€‚å¯¹äºä¸€ä¸ª <math alttext="n
    times n"><mrow><mi>n</mi> <mo>Ã—</mo> <mi>n</mi></mrow></math> åæ–¹å·®çŸ©é˜µ <math alttext="bold
    upper Sigma"><mi>Î£</mi></math>ï¼Œå‡è®¾å®ƒæ˜¯æ­£å®šçš„ï¼Œå°†æœ‰ä¸€ä¸ªCholeskyåˆ†è§£
- en: <math alttext="bold upper Sigma equals upper L upper L Superscript sans-serif
    upper T" display="block"><mrow><mi>Î£</mi> <mo>=</mo> <mi>L</mi> <msup><mi>L</mi>
    <mi>ğ–³</mi></msup></mrow></math>
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold upper Sigma equals upper L upper L Superscript sans-serif
    upper T" display="block"><mrow><mi>Î£</mi> <mo>=</mo> <mi>L</mi> <msup><mi>L</mi>
    <mi>ğ–³</mi></msup></mrow></math>
- en: where *L* is a lower triangular matrix. Then, for a vector of standard normal
    variates <math alttext="bold z"><mi>ğ³</mi></math> ,
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­ *L* æ˜¯ä¸€ä¸ªä¸‹ä¸‰è§’çŸ©é˜µã€‚ç„¶åï¼Œå¯¹äºæ ‡å‡†æ­£æ€å˜é‡å‘é‡ <math alttext="bold z"><mi>ğ³</mi></math>ï¼Œ
- en: <math alttext="Start 1 By 4 Matrix 1st Row 1st Column z 1 2nd Column z 2 3rd
    Column  ellipsis 4th Column z Subscript m EndMatrix Superscript sans-serif upper
    T" display="block"><msup><mfenced open="[" close="]"><mtable><mtr><mtd><msub><mi>z</mi>
    <mn>1</mn></msub></mtd> <mtd><msub><mi>z</mi> <mn>2</mn></msub></mtd> <mtd><mo>â‹¯</mo></mtd><mtd><msub><mi>z</mi>
    <mi>m</mi></msub></mtd></mtr></mtable></mfenced> <mi>ğ–³</mi></msup></math>
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 1 By 4 Matrix 1st Row 1st Column z 1 2nd Column z 2 3rd
    Column  ellipsis 4th Column z Subscript m EndMatrix Superscript sans-serif upper
    T" display="block"><msup><mfenced open="[" close="]"><mtable><mtr><mtd><msub><mi>z</mi>
    <mn>1</mn></msub></mtd> <mtd><msub><mi>z</mi> <mn>2</mn></msub></mtd> <mtd><mo>â‹¯</mo></mtd><mtd><msub><mi>z</mi>
    <mi>m</mi></msub></mtd></mtr></mtable></mfenced> <mi>ğ–³</mi></msup></math>
- en: 'the <math alttext="n times 1"><mrow><mi>n</mi> <mo>Ã—</mo> <mn>1</mn></mrow></math>
    vector generated by <math alttext="bold upper L bold z Superscript sans-serif
    upper T"><mrow><mi>ğ‹</mi> <msup><mi>ğ³</mi> <mi>ğ–³</mi></msup></mrow></math> will
    provide a set of correlated volatilities that can be used to generate in a single
    time step a random scenario of prices for each underlying security. For each time
    step <math alttext="t"><mi>t</mi></math> , we replace <math alttext="bold z"><mi>ğ³</mi></math>
    with <math alttext="bold z Subscript bold t"><msub><mi>ğ³</mi> <mi>ğ­</mi></msub></math>
    to then arrive at our desired result:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ç”± <math alttext="n times 1"><mrow><mi>n</mi> <mo>Ã—</mo> <mn>1</mn></mrow></math>
    å‘é‡ç”Ÿæˆçš„ <math alttext="bold upper L bold z Superscript sans-serif upper T"><mrow><mi>ğ‹</mi>
    <msup><mi>ğ³</mi> <mi>ğ–³</mi></msup></mrow></math> å°†æä¾›ä¸€ç»„ç›¸å…³æ³¢åŠ¨ç‡ï¼Œå¯ä»¥ç”¨æ¥ç”Ÿæˆæ¯ä¸ªåŸºç¡€è¯åˆ¸çš„ä»·æ ¼çš„éšæœºåœºæ™¯ã€‚å¯¹äºæ¯ä¸ªæ—¶é—´æ­¥
    <math alttext="t"><mi>t</mi></math>ï¼Œæˆ‘ä»¬ç”¨ <math alttext="bold z"><mi>ğ³</mi></math>
    æ›¿æ¢ä¸º <math alttext="bold z Subscript bold t"><msub><mi>ğ³</mi> <mi>ğ­</mi></msub></math>ï¼Œä»è€Œå¾—åˆ°æˆ‘ä»¬æƒ³è¦çš„ç»“æœï¼š
- en: <math alttext="bold w Subscript bold t Baseline equals bold upper L bold z Subscript
    t Superscript sans-serif upper T" display="block"><mrow><msub><mi>ğ°</mi> <mi>ğ­</mi></msub>
    <mo>=</mo> <msubsup><mi>ğ‹ğ³</mi> <mi>t</mi> <mi>ğ–³</mi></msubsup></mrow></math>
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold w Subscript bold t Baseline equals bold upper L bold z Subscript
    t Superscript sans-serif upper T" display="block"><mrow><msub><mi>ğ°</mi> <mi>ğ­</mi></msub>
    <mo>=</mo> <msubsup><mi>ğ‹ğ³</mi> <mi>t</mi> <mi>ğ–³</mi></msubsup></mrow></math>
- en: This can then be extended an arbitrary number of n time steps by placing each
    vector <math alttext="bold z Subscript bold t"><msub><mi>ğ³</mi> <mi>ğ­</mi></msub></math>
    into a column of a matrix, say <math alttext="bold upper Z"><mi>ğ™</mi></math>
    . Then, we can generate the entire set of vectors of correlated random variables
    in one step, and place the results in a matrix
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œé€šè¿‡å°†æ¯ä¸ªå‘é‡ <math alttext="bold z Subscript bold t"><msub><mi>ğ³</mi> <mi>ğ­</mi></msub></math>
    æ”¾ç½®åˆ°çŸ©é˜µçš„ä¸€åˆ—ä¸­ï¼Œæ¯”å¦‚ <math alttext="bold upper Z"><mi>ğ™</mi></math>ï¼Œå¯ä»¥æ‰©å±•ä»»æ„æ•°é‡çš„ n ä¸ªæ—¶é—´æ­¥éª¤ã€‚ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥ä¸€æ¬¡ç”Ÿæˆä¸€æ•´å¥—ç›¸å…³éšæœºå˜é‡å‘é‡ï¼Œå¹¶å°†ç»“æœæ”¾ç½®åœ¨ä¸€ä¸ªçŸ©é˜µä¸­
- en: <math alttext="bold upper W equals bold upper L bold upper Z" display="block"><mrow><mi>ğ–</mi>
    <mo>=</mo> <mi>ğ‹ğ™</mi></mrow></math>
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold upper W equals bold upper L bold upper Z" display="block"><mrow><mi>ğ–</mi>
    <mo>=</mo> <mi>ğ‹ğ™</mi></mrow></math>
- en: Eigen provides a Cholesky decomposition of a `MatrixXd` object, using the `Eigen::LLT`
    class template with parameter `MatrixXd`. It again consists of creating an object
    of this class, and then calling a member function, `matrixL`, which returns the
    matrix <math alttext="bold upper L"><mi>ğ‹</mi></math> above.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Eigen æä¾›äº†å¯¹ `MatrixXd` å¯¹è±¡çš„ Cholesky åˆ†è§£ï¼Œä½¿ç”¨ `Eigen::LLT` ç±»æ¨¡æ¿å’Œå‚æ•° `MatrixXd`ã€‚å®ƒå†æ¬¡åŒ…æ‹¬åˆ›å»ºè¿™ä¸ªç±»çš„å¯¹è±¡ï¼Œç„¶åè°ƒç”¨æˆå‘˜å‡½æ•°
    `matrixL`ï¼Œè¯¥å‡½æ•°è¿”å›ä¸Šè¿°çŸ©é˜µ <math alttext="bold upper L"><mi>ğ‹</mi></math>ã€‚
- en: As an example, suppose we have four securities in the basket, with the following
    covariance matrix.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸¾ä¸ªä¾‹å­ï¼Œå‡è®¾æˆ‘ä»¬ç¯®å­é‡Œæœ‰å››ç§è¯åˆ¸ï¼Œå…¶åæ–¹å·®çŸ©é˜µå¦‚ä¸‹ã€‚
- en: '[PRE70]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The Cholesky decomposition is set up when the matrix data is used to construct
    the `Eigen::LLT` object. Calling the member function `matrixL()` computes the
    decomposition and returns the resulting lower triangle matrix:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ä½¿ç”¨çŸ©é˜µæ•°æ®æ„é€  `Eigen::LLT` å¯¹è±¡æ—¶ï¼ŒCholeskyåˆ†è§£è¢«è®¾ç½®ã€‚è°ƒç”¨æˆå‘˜å‡½æ•° `matrixL()` è®¡ç®—åˆ†è§£å¹¶è¿”å›ç»“æœçš„ä¸‹ä¸‰è§’çŸ©é˜µï¼š
- en: '[PRE71]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This gives us
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç»™äº†æˆ‘ä»¬
- en: '[PRE72]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Suppose now there will be six time steps in the Monte Carlo model over a period
    of one year. This means we will need six vectors containing four standard normal
    variates each. For this, we can use the Standard Library `<random>` functions
    and generate a 4 <math alttext="times"><mo>Ã—</mo></math> 6 matrix, and place the
    random vectors in consecutive columns.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨å‡è®¾åœ¨è’™ç‰¹å¡ç½—æ¨¡å‹ä¸­å°†æœ‰å…­ä¸ªæ—¶é—´æ­¥é•¿ï¼ŒæŒç»­ä¸€å¹´ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å°†éœ€è¦å…­ä¸ªåŒ…å«å››ä¸ªæ ‡å‡†æ­£æ€å˜é‡çš„å‘é‡ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ ‡å‡†åº“ `<random>` å‡½æ•°ç”Ÿæˆä¸€ä¸ª
    4 <math alttext="times"><mo>Ã—</mo></math> 6 çŸ©é˜µï¼Œå¹¶å°†éšæœºå‘é‡æ”¾ç½®åœ¨è¿ç»­çš„åˆ—ä¸­ã€‚
- en: 'First, create a `MatrixXd` object with four rows and six columns:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œåˆ›å»ºä¸€ä¸ªæœ‰å››è¡Œå…­åˆ—çš„ `MatrixXd` å¯¹è±¡ï¼š
- en: '[PRE73]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The first step will be to populate this matrix with uncorrelated standard normal
    draws. As we did previously (in Chapter 8), we can set up a random engine and
    distribution, and capture these in a lambda to generate the standard normal variates:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œå°†æ­¤çŸ©é˜µç”¨æ— å…³çš„æ ‡å‡†æ­£æ€åˆ†å¸ƒå¡«å……ã€‚å¦‚æˆ‘ä»¬ä¹‹å‰æ‰€åšï¼ˆç¬¬8ç« ï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥è®¾ç½®ä¸€ä¸ªéšæœºå¼•æ“å’Œåˆ†å¸ƒï¼Œå¹¶å°†å®ƒä»¬æ•è·åœ¨ä¸€ä¸ªlambdaå‡½æ•°ä¸­ä»¥ç”Ÿæˆæ ‡å‡†æ­£æ€å˜é‡ï¼š
- en: '[PRE74]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Because each column in a `MatrixXd` can be accessed as a `VectorXd`, we can
    again iterate columnwise through the matrix and apply the `std::ranges::transform`
    algorithm to each in a range-based `for` loop.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸ºæ¯ä¸ª`MatrixXd`ä¸­çš„åˆ—å¯ä»¥è¢«è§†ä¸º`VectorXd`ï¼Œæˆ‘ä»¬å¯ä»¥å†æ¬¡é€šè¿‡çŸ©é˜µæŒ‰åˆ—è¿›è¡Œè¿­ä»£ï¼Œå¹¶åœ¨åŸºäºèŒƒå›´çš„`for`å¾ªç¯ä¸­å¯¹æ¯åˆ—åº”ç”¨`std::ranges::transform`ç®—æ³•ã€‚
- en: '[PRE75]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This interim result would resemble the following, with actual results depending
    on the compiler (in this case using the Microsoft Visual Studio 2022 compiler):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤ä¸­æœŸç»“æœå°†ç±»ä¼¼äºä»¥ä¸‹å†…å®¹ï¼Œå®é™…ç»“æœå–å†³äºç¼–è¯‘å™¨ï¼ˆåœ¨æœ¬ä¾‹ä¸­ä½¿ç”¨Microsoft Visual Studio 2022ç¼–è¯‘å™¨ï¼‰ï¼š
- en: '[PRE76]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Then, to get the *correlated* normal values, multiply the above result by the
    Cholesky matrix, and reassign `corr_norms` to the result.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œä¸ºäº†å¾—åˆ°*ç›¸å…³*æ­£å¸¸å€¼ï¼Œå°†ä¸Šè¿°ç»“æœä¹˜ä»¥CholeskyçŸ©é˜µï¼Œå¹¶å°†`corr_norms`é‡æ–°åˆ†é…ä¸ºç»“æœã€‚
- en: '[PRE77]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This result, which corresponds to the matrix <math alttext="bold upper W"><mi>ğ–</mi></math>
    in the mathematical derivation, comes out to be:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªç»“æœå¯¹åº”äºæ•°å­¦æ¨å¯¼ä¸­çš„çŸ©é˜µ<math alttext="bold upper W"><mi>ğ–</mi></math>ï¼Œå…¶ç»“æœå¦‚ä¸‹ï¼š
- en: '[PRE78]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Each successive column in `corr_norms` will provide a set of four correlated
    random variates that can be substituted in for <math alttext="w Subscript t Superscript
    left-parenthesis 1 right-parenthesis Baseline ellipsis w Subscript t Superscript
    left-parenthesis 4 right-parenthesis"><mrow><msubsup><mi>w</mi> <mi>t</mi> <mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow></msubsup>
    <mo>â‹¯</mo> <msubsup><mi>w</mi> <mi>t</mi> <mrow><mo>(</mo><mn>4</mn><mo>)</mo></mrow></msubsup></mrow></math>
    at each time <math alttext="t equals 1 comma ellipsis comma 6"><mrow><mi>t</mi>
    <mo>=</mo> <mn>1</mn> <mo>,</mo> <mo>â‹¯</mo> <mo>,</mo> <mn>6</mn></mrow></math>
    in (*) above. First, we will need the spot prices of the four underlying equities,
    which can be stored in an Eigen `VectorXd` (pretend they are retrieved from a
    live market feed). For example:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`corr_norms`ä¸­çš„æ¯ä¸ªè¿ç»­åˆ—å°†æä¾›ä¸€ç»„å››ä¸ªç›¸å…³éšæœºå˜é‡ï¼Œå¯ä»¥æ›¿æ¢(*)ä¸­æ¯ä¸ªæ—¶é—´ç‚¹<math alttext="w Subscript t
    Superscript left-parenthesis 1 right-parenthesis Baseline ellipsis w Subscript
    t Superscript left-parenthesis 4 right-parenthesis"><mrow><msubsup><mi>w</mi>
    <mi>t</mi> <mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow></msubsup> <mo>â‹¯</mo> <msubsup><mi>w</mi>
    <mi>t</mi> <mrow><mo>(</mo><mn>4</mn><mo>)</mo></mrow></msubsup></mrow></math>ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦å››ä¸ªåŸºç¡€è‚¡ç¥¨çš„ç°è´§ä»·æ ¼ï¼Œå¯ä»¥å­˜å‚¨åœ¨Eigençš„`VectorXd`ä¸­ï¼ˆå‡è®¾å®ƒä»¬æ¥è‡ªå®æ—¶å¸‚åœºæ•°æ®æºï¼‰ã€‚ä¾‹å¦‚ï¼š'
- en: '[PRE79]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Next, we will need a matrix in which to store a random price path for each equity,
    starting with each spot price, to be stored in an additional first column, making
    it a 4 <math alttext="times"><mo>Ã—</mo></math> 7 matrix.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªçŸ©é˜µæ¥å­˜å‚¨æ¯ä¸ªè‚¡ç¥¨çš„éšæœºä»·æ ¼è·¯å¾„ï¼Œä»æ¯ä¸ªç°è´§ä»·æ ¼å¼€å§‹ï¼Œåœ¨é¢å¤–çš„ç¬¬ä¸€åˆ—ä¸­å­˜å‚¨ï¼Œä½¿å…¶æˆä¸ºä¸€ä¸ª4 <math alttext="times"><mo>Ã—</mo></math>
    7çŸ©é˜µã€‚
- en: '[PRE80]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Suppose then, the time to maturity is one year, divided into six equal time
    steps. From this, we can get the <math alttext="normal upper Delta t"><mrow><mi>Î”</mi>
    <mi>t</mi></mrow></math> value, say `dt`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾åˆ°æœŸæ—¶é—´ä¸ºä¸€å¹´ï¼Œåˆ†ä¸ºå…­ä¸ªç­‰æ—¶é—´æ­¥ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°<math alttext="normal upper Delta t"><mrow><mi>Î”</mi>
    <mi>t</mi></mrow></math>å€¼ï¼Œæ¯”å¦‚`dt`ã€‚
- en: '[PRE81]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Each successive price for a given underlying equity, as shown in (*), can be
    computed in a lambda, where `price` is the previous price in the scenario, and
    `vol` is the volatility of the particular equity.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚(*)ä¸­æ‰€ç¤ºï¼Œæ¯ä¸ªç»™å®šåŸºç¡€è‚¡ç¥¨çš„æ¯ä¸ªè¿ç»­ä»·æ ¼å¯ä»¥åœ¨lambdaå‡½æ•°ä¸­è®¡ç®—ï¼Œå…¶ä¸­`price`æ˜¯åœºæ™¯ä¸­çš„å‰æœŸä»·æ ¼ï¼Œè€Œ`vol`æ˜¯ç‰¹å®šè‚¡ç¥¨çš„æ³¢åŠ¨ç‡ã€‚
- en: '[PRE82]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Finally, for each underlying equity at each time step, we can set up an iteration
    and call the lambda at each step:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œåœ¨æ¯ä¸ªæ—¶é—´æ­¥éª¤çš„æ¯ä¸ªåŸºç¡€è‚¡ç¥¨ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥è®¾ç½®ä¸€ä¸ªè¿­ä»£ï¼Œå¹¶åœ¨æ¯ä¸ªæ­¥éª¤è°ƒç”¨lambdaå‡½æ•°ï¼š
- en: '[PRE83]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: For this example, the results are
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæ­¤ç¤ºä¾‹ï¼Œç»“æœå¦‚ä¸‹ï¼š
- en: '[PRE84]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Again, results may vary due to differences in the implementation of `<random>`
    between different Standard Library releases among vendors.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¬¡æé†’ï¼Œç”±äºä¸åŒä¾›åº”å•†çš„æ ‡å‡†åº“ç‰ˆæœ¬ä¸­`<random>`å®ç°çš„å·®å¼‚ï¼Œç»“æœå¯èƒ½ä¼šæœ‰æ‰€ä¸åŒã€‚
- en: Yield Curve Dynamics and Principal Components Analysis
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: æ”¶ç›Šç‡æ›²çº¿åŠ¨æ€å’Œä¸»æˆåˆ†åˆ†æ
- en: Principal Components Analysis (PCA) is a go-to tool for determining the sources
    and magnitudes of variation that drive changes in the shape of a yield curve.
    Given a covariance matrix of daily changes in yields spanning a range of bond
    maturities, PCA is employed by first calculating the eigenvalues of this matrix,
    and ordering them from highest to lowest. Then, the weightings are calculated
    by dividing each eigenvalue by the some of all the eigenvalues.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸»æˆåˆ†åˆ†æï¼ˆPCAï¼‰æ˜¯ç¡®å®šé©±åŠ¨æ”¶ç›Šç‡æ›²çº¿å½¢çŠ¶å˜åŒ–çš„å˜åŠ¨æºå’Œå¹…åº¦çš„å·¥å…·ã€‚é€šè¿‡é¦–å…ˆè®¡ç®—è·¨å¤šä¸ªå€ºåˆ¸åˆ°æœŸæœŸé™çš„æ¯æ—¥æ”¶ç›Šç‡å˜åŒ–çš„åæ–¹å·®çŸ©é˜µçš„ç‰¹å¾å€¼ï¼Œå¹¶æŒ‰é™åºæ’åºï¼Œç„¶åé€šè¿‡å°†æ¯ä¸ªç‰¹å¾å€¼é™¤ä»¥æ‰€æœ‰ç‰¹å¾å€¼çš„æ€»å’Œæ¥è®¡ç®—æƒé‡ã€‚
- en: Empirical research has shown the contribution of first three eigenvalues will
    comprise nearly the entirety of the weightings, where the first weighting corresponds
    to parallel shifts in the yield curve, the second corresponds to variations in
    its â€œtiltâ€ or â€œslopeâ€, and the third to the curvature. The reasons and details
    behind this can be found in Chapter 18 of the very fine computational finance
    book by [Ruppert and Matteson](https://link.springer.com/book/10.1007/978-1-4939-2614-5)
    **{25}**, and in Chapter 3 of the classic text on interest rate derivatives by
    Rebonato **{26}**.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: å®è¯ç ”ç©¶è¡¨æ˜ï¼Œå‰ä¸‰ä¸ªç‰¹å¾å€¼çš„è´¡çŒ®å‡ ä¹æ„æˆäº†æƒé‡çš„å…¨éƒ¨ï¼Œå…¶ä¸­ç¬¬ä¸€ä¸ªæƒé‡å¯¹åº”äºæ”¶ç›Šæ›²çº¿çš„å¹³è¡Œç§»åŠ¨ï¼Œç¬¬äºŒä¸ªå¯¹åº”äºå…¶â€œå€¾æ–œâ€æˆ–â€œæ–œç‡â€çš„å˜åŒ–ï¼Œç¬¬ä¸‰ä¸ªå¯¹åº”äºæ›²ç‡ã€‚å…³äºè¿™ä¸€ç‚¹çš„åŸå› å’Œè¯¦ç»†å†…å®¹å¯ä»¥åœ¨Ruppertå’ŒMattesonçš„è®¡ç®—é‡‘èä¼˜ç§€è‘—ä½œç¬¬18ç« ä¸­æ‰¾åˆ°
    **{25}**ï¼Œä»¥åŠRebonatoå…³äºåˆ©ç‡è¡ç”Ÿå“çš„ç»å…¸æ–‡æœ¬ç¬¬3ç« ä¸­ **{26}**ã€‚
- en: Rigorous statistical tests exist for measuring significance, but the weights
    alone can provide a relative estimated measure of each source of variation.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: å­˜åœ¨ä¸¥æ ¼çš„ç»Ÿè®¡æ£€éªŒæ¥è¡¡é‡æ˜¾è‘—æ€§ï¼Œä½†ä»…æƒé‡æœ¬èº«å¯ä»¥æä¾›æ¯ä¸ªå˜åŒ–æ¥æºçš„ç›¸å¯¹ä¼°è®¡é‡ã€‚
- en: Section 18.2 of the text by Ruppert and Matteson {op cit 25} provides an excellent
    example on how to apply principal components analysis to publicly available US
    Treasury yield data {put URL here}. The resulting covariance matrixâ€‰â€”â€‰input as
    constructor data for the following `MatrixXd` object, is based on fluctuations
    in differenced [US Treasury yields](https://home.treasury.gov/resource-center/data-chart-center/interest-rates/TextView?type=daily_treasury_yield_curve&field_tdr_date_value_month=202212)
    **{28}** for eleven different maturities, ranging from one month to 30 years.
    The underlying data is taken from the period from January 1990 to October 2008.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Ruppertå’ŒMattesonçš„æ–‡æœ¬ç¬¬18.2èŠ‚ {op cit 25} æä¾›äº†ä¸€ä¸ªå…³äºå¦‚ä½•åº”ç”¨ä¸»æˆåˆ†åˆ†æåˆ°å…¬å¼€å¯ç”¨çš„ç¾å›½å›½å€ºæ”¶ç›Šæ•°æ®çš„ä¼˜ç§€ç¤ºä¾‹ {put
    URL here}ã€‚ç»“æœçš„åæ–¹å·®çŸ©é˜µâ€‰â€”â€‰ä½œä¸ºä¸‹è¿°`MatrixXd`å¯¹è±¡çš„æ„é€ å™¨æ•°æ®ï¼ŒåŸºäºåä¸€ç§ä¸åŒåˆ°æœŸé™çš„ç¾å›½å›½å€ºæ”¶ç›Šç‡çš„æ³¢åŠ¨ï¼Œä»ä¸€ä¸ªæœˆåˆ°30å¹´ã€‚åŸºç¡€æ•°æ®æ¥è‡ª1990å¹´1æœˆåˆ°2008å¹´10æœˆçš„æ—¶æœŸã€‚
- en: To calculate the eigenvalues, first load the covariance matrix data into the
    upper triangular region of a `MatrixXd` instance.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: è¦è®¡ç®—ç‰¹å¾å€¼ï¼Œé¦–å…ˆå°†åæ–¹å·®çŸ©é˜µæ•°æ®åŠ è½½åˆ°`MatrixXd`å®ä¾‹çš„ä¸Šä¸‰è§’åŒºåŸŸã€‚
- en: '[PRE85]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'As a real symmetric matrix is trivially self-adjoint (no complex components),
    Eigen can apply a function `selfadjointView<.>()` to an upper (or lower) triangular
    matrix to define a view of a symmetric covariance matrix. The eigenvalues (all
    real) can then be obtained by applying the `eigenvalues()` function on the symmetric
    result:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºå®å¯¹ç§°çŸ©é˜µåœ¨æ— å¤æ‚åˆ†é‡æ—¶æ˜¯å¹³å‡¡è‡ªå…±è½­çš„ï¼ŒEigenå¯ä»¥å°†`selfadjointView<.>()`å‡½æ•°åº”ç”¨äºä¸Šï¼ˆæˆ–ä¸‹ï¼‰ä¸‰è§’çŸ©é˜µï¼Œä»¥å®šä¹‰å¯¹ç§°åæ–¹å·®çŸ©é˜µçš„è§†å›¾ã€‚ç„¶åï¼Œå¯ä»¥é€šè¿‡åœ¨å¯¹ç§°ç»“æœä¸Šåº”ç”¨`eigenvalues()`å‡½æ•°æ¥è·å¾—ç‰¹å¾å€¼ï¼ˆå…¨éƒ¨ä¸ºå®æ•°ï¼‰ï¼š
- en: '[PRE86]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In order to determine the weight of each principal component, we need to divide
    each eigenvalue by the sum of all the eigenvalues:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ç¡®å®šæ¯ä¸ªä¸»æˆåˆ†çš„æƒé‡ï¼Œæˆ‘ä»¬éœ€è¦å°†æ¯ä¸ªç‰¹å¾å€¼é™¤ä»¥æ‰€æœ‰ç‰¹å¾å€¼çš„æ€»å’Œï¼š
- en: '[PRE87]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'And finally, to view the results in order of the principal components, the
    weighted values need to be arranged from largest to smallest:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œä¸ºäº†æŒ‰ä¸»æˆåˆ†é¡ºåºæŸ¥çœ‹ç»“æœï¼Œéœ€è¦å°†åŠ æƒå€¼ä»å¤§åˆ°å°æ’åˆ—ï¼š
- en: '[PRE88]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Examining the contents of `eigenvals`, we would find the following results:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: æ£€æŸ¥`eigenvals`çš„å†…å®¹ï¼Œæˆ‘ä»¬ä¼šå‘ç°ä»¥ä¸‹ç»“æœï¼š
- en: '[PRE89]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: From this, we can see the effects of parallel shifts and the â€œtiltâ€ of the yield
    curve are the dominant effects, with relative weights of 67.2% and and 21.3%,
    while the curvature effect is smaller at 7.4%.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±æ­¤å¯è§ï¼Œå¹³è¡Œç§»åŠ¨å’Œæ”¶ç›Šæ›²çº¿çš„â€œå€¾æ–œâ€æ•ˆåº”æ˜¯ä¸»å¯¼æ•ˆåº”ï¼Œç›¸å¯¹æƒé‡åˆ†åˆ«ä¸º67.2%å’Œ21.3%ï¼Œè€Œæ›²ç‡æ•ˆåº”è¾ƒå°ï¼Œä¸º7.4%ã€‚
- en: 'Future Directions: Linear Algebra in the Standard Library'
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æœªæ¥æ–¹å‘ï¼šæ ‡å‡†åº“ä¸­çš„çº¿æ€§ä»£æ•°
- en: Three proposals related to linear algebra have been submitted to the ISO C++
    committee.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: å·²å‘ISO C++å§”å‘˜ä¼šæäº¤äº†ä¸‰ä¸ªä¸çº¿æ€§ä»£æ•°ç›¸å…³çš„ææ¡ˆã€‚
- en: '`std::mdspan`: [A polymorphic multidimensional array reference (P0009)](https://wg21.link/p0009)
    **{28}**'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::mdspan`ï¼š[ä¸€ä¸ªå¤šæ€å¤šç»´æ•°ç»„å¼•ç”¨ï¼ˆP0009ï¼‰](https://wg21.link/p0009) **{28}**'
- en: '[A free function linear algebra interface based on the BLAS (P1673)](https://wg21.link/p1673)
    **{29}**'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[åŸºäºBLASçš„è‡ªç”±å‡½æ•°çº¿æ€§ä»£æ•°æ¥å£ï¼ˆP1673ï¼‰](https://wg21.link/p1673) **{29}**'
- en: '[Add linear algebra support to the C++ standard library (P1385)](https://wg21.link/p1385)
    **{30}**'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[å‘C++æ ‡å‡†åº“æ·»åŠ çº¿æ€§ä»£æ•°æ”¯æŒï¼ˆP1385ï¼‰](https://wg21.link/p1385) **{30}**'
- en: '`mdspan` (P0009) can impose a multidimensional array structure on a reference
    to a container, such as an STL `vector`. Using the example of a `vector` containing
    the data, and a referring `mdspan` representing a matrix, the number of rows and
    columns are set at construction of the `mdspan`. An `mdspan` can also take the
    form of higher dimensional arrays, but for our purposes we will concern ourselves
    with the two-dimensional case for matrix representations. `mdspan` is officially
    slated for release in C++23.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`mdspan`ï¼ˆP0009ï¼‰å¯ä»¥åœ¨å¯¹å®¹å™¨çš„å¼•ç”¨ä¸Šæ–½åŠ å¤šç»´æ•°ç»„ç»“æ„ï¼Œä¾‹å¦‚STL `vector`ã€‚ä½¿ç”¨åŒ…å«æ•°æ®çš„`vector`å’Œè¡¨ç¤ºçŸ©é˜µçš„å¼•ç”¨`mdspan`ä½œä¸ºç¤ºä¾‹ï¼Œåœ¨æ„é€ `mdspan`æ—¶è®¾ç½®è¡Œæ•°å’Œåˆ—æ•°ã€‚`mdspan`ä¹Ÿå¯ä»¥é‡‡ç”¨æ›´é«˜ç»´åº¦çš„æ•°ç»„å½¢å¼ï¼Œä½†æˆ‘ä»¬çš„ç›®çš„æ˜¯å…³æ³¨çŸ©é˜µè¡¨ç¤ºçš„äºŒç»´æƒ…å†µã€‚`mdspan`æ­£å¼è®¡åˆ’åœ¨C++23ä¸­å‘å¸ƒã€‚'
- en: The second proposal (P1673) is for a standard interface to external linear algebra
    â€œbased on the dense Basic Linear Algebra Subroutines (BLAS)â€, corresponding â€œto
    a subset of the BLAS Standard.â€ {op cit 29}. In other words, code could be written
    independently of whichever external linear algebra library is used, making code
    maintenance much easier and less error-prone. As noted in the proposal, the â€œinterface
    is designed in the spirit of the C++ Standard Libraryâ€™s algorithmsâ€, and â€œuses
    mdspanâ€¦â€‹, to represent matrices and vectorsâ€ {ibid}. Furthermore, the â€œinterface
    is designed in the spirit of the C++ Standard Libraryâ€™s algorithms"{ibid}. It
    is currently planned for C++26.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬äºŒä¸ªææ¡ˆï¼ˆP1673ï¼‰æ˜¯ä¸ºå¤–éƒ¨çº¿æ€§ä»£æ•°æä¾›æ ‡å‡†æ¥å£ï¼Œâ€œåŸºäºå¯†é›†å‹åŸºæœ¬çº¿æ€§ä»£æ•°å­ç¨‹åºï¼ˆBLASï¼‰â€ï¼Œå¯¹åº”äºâ€œBLASæ ‡å‡†çš„å­é›†â€ã€‚æ¢å¥è¯è¯´ï¼Œæ— è®ºä½¿ç”¨å“ªä¸ªå¤–éƒ¨çº¿æ€§ä»£æ•°åº“ï¼Œä»£ç éƒ½å¯ä»¥ç‹¬ç«‹ç¼–å†™ï¼Œä»è€Œä½¿ä»£ç ç»´æŠ¤æ›´åŠ å®¹æ˜“ä¸”ä¸æ˜“å‡ºé”™ã€‚æ­£å¦‚ææ¡ˆä¸­æ‰€è¿°ï¼Œâ€œæ¥å£çš„è®¾è®¡ä»¥C++æ ‡å‡†åº“çš„ç®—æ³•ç²¾ç¥ä¸ºåŸºç¡€â€ï¼Œå¹¶ä½¿ç”¨â€œmdspanâ€¦â€¦è¡¨ç¤ºçŸ©é˜µå’Œå‘é‡â€ï¼ˆåŒä¸Šï¼‰ã€‚æ­¤å¤–ï¼Œâ€œæ¥å£çš„è®¾è®¡ä»¥C++æ ‡å‡†åº“çš„ç®—æ³•ç²¾ç¥ä¸ºåŸºç¡€â€ï¼ˆåŒä¸Šï¼‰ã€‚ç›®å‰è®¡åˆ’åœ¨C++26ä¸­å‘å¸ƒã€‚
- en: The third proposal (P1385) is to provide actual BLAS-type functionality within
    the Standard Library. Its primary goal is to â€œprovide a (sic) matrix vocabulary
    types for representing the mathematical objects and fundamental operations relevant
    to linear algebraâ€ (op cit {30}). This proposal is also currently planned for
    release with C++26.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸‰ä¸ªææ¡ˆï¼ˆP1385ï¼‰æ˜¯åœ¨æ ‡å‡†åº“ä¸­æä¾›å®é™…çš„BLASç±»å‹åŠŸèƒ½ã€‚å…¶ä¸»è¦ç›®æ ‡æ˜¯â€œä¸ºè¡¨ç¤ºä¸çº¿æ€§ä»£æ•°ç›¸å…³çš„æ•°å­¦å¯¹è±¡å’ŒåŸºæœ¬æ“ä½œæä¾›çŸ©é˜µè¯æ±‡ç±»å‹â€ï¼ˆè§30é¡µï¼‰ã€‚è¯¥ææ¡ˆç›®å‰ä¹Ÿè®¡åˆ’åœ¨C++26ä¸­å‘å¸ƒã€‚
- en: mdspan (P0009)
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: mdspanï¼ˆP0009ï¼‰
- en: 'As mentioned above, for representing a matrix, `mdspan` establishes a reference
    to a contiguous container and then imposes the number of rows and columns. If
    these parameters are known at compile time, creating an `mdspan` is easy:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚ä¸Šæ‰€è¿°ï¼Œä¸ºäº†è¡¨ç¤ºçŸ©é˜µï¼Œ`mdspan`å»ºç«‹å¯¹è¿ç»­å®¹å™¨çš„å¼•ç”¨ï¼Œç„¶åå¼ºåŠ è¡Œæ•°å’Œåˆ—æ•°ã€‚å¦‚æœè¿™äº›å‚æ•°åœ¨ç¼–è¯‘æ—¶å·²çŸ¥ï¼Œåˆ›å»º`mdspan`å¾ˆå®¹æ˜“ï¼š
- en: '[PRE90]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Note that `mdspan` uses the `data()` member function on `vector` to access its
    contents.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œ`mdspan`ä½¿ç”¨`vector`çš„`data()`æˆå‘˜å‡½æ•°è®¿é—®å…¶å†…å®¹ã€‚
- en: In `mdspan` parlance, rows and columns are referred to as *extents*, with the
    number of rows and columns accessed by the index of each, 0 for rows and 1 for
    columns. The total number of extents is referred to as the *rank*, so in this
    case, the rank is 2\. For higher-order multidimensional arrays, the rank would
    be greater than two.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨`mdspan`æœ¯è¯­ä¸­ï¼Œè¡Œå’Œåˆ—è¢«ç§°ä¸º*extents*ï¼Œé€šè¿‡æ¯ä¸ªç´¢å¼•è®¿é—®è¡Œæ•°å’Œåˆ—æ•°ï¼Œè¡Œæ•°ç´¢å¼•ä¸º0ï¼Œåˆ—æ•°ç´¢å¼•ä¸º1ã€‚æ€»çš„*rank*è¡¨ç¤ºä¸º2ï¼Œå¯¹äºæ›´é«˜é˜¶çš„å¤šç»´æ•°ç»„ï¼Œ*rank*ä¼šå¤§äºä¸¤ä¸ªã€‚
- en: '[PRE91]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Note
  id: totrans-348
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: æ³¨æ„
- en: The term *rank* as applied to `mdspan` is not the same as the mathematical definition
    of the rank of a matrix. This naming might unfortunately seem confusing, but itâ€™s
    something one should be aware of.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¯è¯­*rank*åœ¨åº”ç”¨äº`mdspan`æ—¶ä¸çŸ©é˜µç§©çš„æ•°å­¦å®šä¹‰ä¸åŒã€‚è¿™ç§å‘½åå¯èƒ½ä¼šä»¤äººå›°æƒ‘ï¼Œä½†è¿™æ˜¯éœ€è¦æ³¨æ„çš„äº‹é¡¹ã€‚
- en: 'Elements of the `mdspan` object will be accessible with another new feature
    in C++23, namely the square bracket operator with multiple indices:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨C++23ä¸­ï¼Œ`mdspan`å¯¹è±¡çš„å…ƒç´ å¯ä»¥é€šè¿‡å¦ä¸€ä¸ªæ–°åŠŸèƒ½è®¿é—®ï¼Œå³å…·æœ‰å¤šä¸ªç´¢å¼•çš„æ–¹æ‹¬å·è¿ç®—ç¬¦ï¼š
- en: '[PRE92]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This is a welcome improvement, as it will no longer be necessary to put each
    index in a separate bracket pair, as was the case with C-style arrays:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªå—æ¬¢è¿çš„æ”¹è¿›ï¼Œå› ä¸ºä¸å†éœ€è¦å°†æ¯ä¸ªç´¢å¼•æ”¾åœ¨å•ç‹¬çš„æ‹¬å·å¯¹ä¸­ï¼Œå°±åƒCé£æ ¼æ•°ç»„çš„æƒ…å†µä¸€æ ·ã€‚
- en: '[PRE93]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The run-time result of the previous nested loop displays a 3 <math alttext="times"><mo>Ã—</mo></math>
    2 matrix:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šè¿°åµŒå¥—å¾ªç¯çš„è¿è¡Œæ—¶ç»“æœæ˜¾ç¤ºä¸€ä¸ª3 <math alttext="times"><mo>Ã—</mo></math> 2çŸ©é˜µï¼š
- en: '[PRE94]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'It is also possible to define a matrix with different dimensions to the same
    data:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹Ÿå¯ä»¥ä½¿ç”¨ç›¸åŒçš„æ•°æ®å®šä¹‰å…·æœ‰ä¸åŒç»´åº¦çš„çŸ©é˜µï¼š
- en: '[PRE95]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Applying the same loop above, but replacing `mds1` with `mds2` would then display
    as expected:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: åº”ç”¨ä¸Šè¿°ç›¸åŒçš„å¾ªç¯ï¼Œä½†å°†`mds1`æ›¿æ¢ä¸º`mds2`ï¼Œåˆ™ä¼šå¦‚é¢„æœŸæ˜¾ç¤ºï¼š
- en: '[PRE96]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: One thing to be careful of is modifying data in the `mdspan` object or in the
    original `vector` will change it in both locations due to the referential relationship
    between the two. For example, modification of the last element of the vector
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: éœ€è¦å°å¿ƒçš„ä¸€ç‚¹æ˜¯ä¿®æ”¹`mdspan`å¯¹è±¡æˆ–åŸå§‹`vector`ä¸­çš„æ•°æ®å°†ç”±äºä¸¤è€…ä¹‹é—´çš„å¼•ç”¨å…³ç³»è€ŒåŒæ—¶æ›´æ”¹ã€‚ä¾‹å¦‚ï¼Œä¿®æ”¹å‘é‡çš„æœ€åä¸€ä¸ªå…ƒç´ 
- en: '[PRE97]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: will show up in both of the `mdspan` objects. `mds1` becomes
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: å°†æ˜¾ç¤ºåœ¨ä¸¤ä¸ª`mdspan`å¯¹è±¡ä¸­ã€‚`mds1`å˜æˆ
- en: '[PRE98]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: and `mds2` is now
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: å’Œ`mds2`ç°åœ¨æ˜¯
- en: '[PRE99]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Likewise, changing the value of an element in `mds2` will be reflected in both
    `mds1` and the vector `v`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: åŒæ ·ï¼Œæ›´æ”¹`mds2`ä¸­çš„å…ƒç´ å€¼å°†åæ˜ åœ¨`mds1`å’Œå‘é‡`v`ä¸­ã€‚
- en: In quant finance applications, it will often be the case where the fixed number
    of rows and columns are not known at compile time. Suppose `m` and `n` are the
    numbers of rows and columns to be determined at runtime. These dimensions can
    be set dynamically by replacing the fixed settings of 2 and 3 in the previous
    example
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨é‡åŒ–é‡‘èåº”ç”¨ä¸­ï¼Œå¾€å¾€æƒ…å†µæ˜¯åœ¨ç¼–è¯‘æ—¶ä¸çŸ¥é“å›ºå®šçš„è¡Œæ•°å’Œåˆ—æ•°ã€‚å‡è®¾`m`å’Œ`n`æ˜¯åœ¨è¿è¡Œæ—¶ç¡®å®šçš„è¡Œå’Œåˆ—æ•°ã€‚è¿™äº›ç»´åº¦å¯ä»¥é€šè¿‡åœ¨å‰é¢ç¤ºä¾‹ä¸­çš„å›ºå®šè®¾ç½®2å’Œ3å¤„åŠ¨æ€è®¾ç½®æ¥åŠ¨æ€è®¾ç½®
- en: '[PRE100]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'with the `std::extents{m, n}` object, as shown in the `mdspan` definition here:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: ç”¨`std::extents{m, n}`å¯¹è±¡è¡¨ç¤ºï¼Œå¦‚æ­¤å¤„`mdspan`å®šä¹‰æ‰€ç¤ºï¼š
- en: '[PRE101]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The `std::extents{m, n}` parameter represents the number of elements in each
    extentâ€‰â€”â€‰ie in each row (`m`) and column (`n`)â€‰â€”â€‰which are determined dynamically
    at runtime.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::extents{m, n}`å‚æ•°è¡¨ç¤ºæ¯ä¸ªextentï¼ˆå³æ¯è¡Œï¼ˆ`m`ï¼‰å’Œåˆ—ï¼ˆ`n`ï¼‰ï¼‰ä¸­çš„å…ƒç´ æ•°é‡ï¼Œè¿™äº›åœ¨è¿è¡Œæ—¶åŠ¨æ€ç¡®å®šã€‚'
- en: 'Pretend we have the following data set at runtime:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬åœ¨è¿è¡Œæ—¶æœ‰ä»¥ä¸‹æ•°æ®é›†ï¼š
- en: '[PRE102]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Using these as inputs to the `dynamic_mdspan(.)` function above will then generate
    a 3 <math alttext="times"><mo>Ã—</mo></math> 2 `mdspan` matrix:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™äº›ä½œä¸º`dynamic_mdspan(.)`å‡½æ•°çš„è¾“å…¥ï¼Œç„¶åå°†ç”Ÿæˆä¸€ä¸ª3 <math alttext="times"><mo>Ã—</mo></math>
    2 `mdspan`çŸ©é˜µï¼š
- en: '[PRE103]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Note
  id: totrans-376
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: æ³¨æ„
- en: The above examples make use of *Class Template Auto Deduction*, commonly referred
    to as *CTAD*. Both `mdspan` and `extents` are class templates, but because `w`
    in the example just above is a `vector` of `double` types, and the size of the
    `vector` being of type `size_t`, when substituted in for `vec` in the `dynamic_mdspan`
    function, the compiler will deduce that the `mdspan` and `extents` objects are
    to use `double` and `size_t` as template parameters.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šé¢çš„ä¾‹å­åˆ©ç”¨äº†*ç±»æ¨¡æ¿è‡ªåŠ¨æ¨å¯¼*ï¼ˆCTADï¼‰ã€‚`mdspan`å’Œ`extents`éƒ½æ˜¯ç±»æ¨¡æ¿ï¼Œä½†æ˜¯å› ä¸ºä¸Šé¢ç¤ºä¾‹ä¸­çš„`w`æ˜¯`vector`çš„`double`ç±»å‹ï¼Œè€Œ`vector`çš„å¤§å°æ˜¯`size_t`ç±»å‹ï¼Œå½“æ›¿æ¢ä¸º`dynamic_mdspan`å‡½æ•°ä¸­çš„`vec`æ—¶ï¼Œç¼–è¯‘å™¨å°†æ¨æ–­`mdspan`å’Œ`extents`å¯¹è±¡è¦ä½¿ç”¨`double`å’Œ`size_t`ä½œä¸ºæ¨¡æ¿å‚æ•°ã€‚
- en: 'Without CTAD, the function would be written something like:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: æ²¡æœ‰CTADï¼Œå‡½æ•°å°†å†™æˆå¦‚ä¸‹å½¢å¼ï¼š
- en: '[PRE104]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The discussion in this chapter will rely on CTAD, but in cases where more generality
    is required, it will be necessary to to write out the template arguments in full.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ç« çš„è®¨è®ºå°†ä¾èµ–äºCTADï¼Œä½†åœ¨éœ€è¦æ›´ä¸€èˆ¬æ€§çš„æƒ…å†µä¸‹ï¼Œå°†éœ€è¦å®Œå…¨ä¹¦å†™æ¨¡æ¿å‚æ•°ã€‚
- en: 'One more thing to note is in each of the examples so far, `mdspan` will arrange
    the data in row-major order by default. Arranging it in column-major order requires
    defining a `layout_left` policy *mapping*, in this case called `col_major`, as
    shown here:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: è¿˜æœ‰ä¸€ä»¶äº‹è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨è¿„ä»Šä¸ºæ­¢çš„æ¯ä¸ªä¾‹å­ä¸­ï¼Œ`mdspan`å°†é»˜è®¤æŒ‰è¡Œä¸»é¡ºåºæ’åˆ—æ•°æ®ã€‚é€šè¿‡å®šä¹‰ä¸€ä¸ª`layout_left`ç­–ç•¥*æ˜ å°„*ï¼Œåœ¨æœ¬ä¾‹ä¸­ç§°ä¸º`col_major`ï¼Œå¯ä»¥å°†å…¶æ’åˆ—ä¸ºåˆ—ä¸»é¡ºåºï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE105]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The corresponding column-major matrix can then be defined by substituting this
    mapping in the extents argument in the `mdspan` constructor.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åå¯ä»¥é€šè¿‡åœ¨`mdspan`æ„é€ å‡½æ•°çš„extentså‚æ•°ä¸­æ›¿æ¢æ­¤æ˜ å°„æ¥å®šä¹‰ç›¸åº”çš„åˆ—ä¸»çŸ©é˜µã€‚
- en: '[PRE106]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The result is the column-major version of the matrix:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æœæ˜¯çŸ©é˜µçš„åˆ—ä¸»ç‰ˆæœ¬ï¼š
- en: '[PRE107]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Note
  id: totrans-387
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: æ³¨æ„
- en: Row-major order can also be set explicitly with the `std::layout_right` mapping.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: å¯ä»¥ä½¿ç”¨`std::layout_right`æ˜ å°„æ¥æ˜ç¡®è®¾ç½®è¡Œä¸»é¡ºåºã€‚
- en: The `mdspan` proposal also includes a â€œslicingâ€ function called `submdspan(.)`
    to return a reference to an individual row or column from a matrix represented
    by an mdspan. More generally, this would extend to subsets of higher-dimensional
    arrays.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`mdspan`ææ¡ˆè¿˜åŒ…æ‹¬ä¸€ä¸ªåä¸º`submdspan(.)`çš„â€œåˆ‡ç‰‡â€å‡½æ•°ï¼Œç”¨äºè¿”å›ç”±mdspanè¡¨ç¤ºçš„çŸ©é˜µçš„å•ä¸ªè¡Œæˆ–åˆ—çš„å¼•ç”¨ã€‚æ›´ä¸€èˆ¬åœ°è¯´ï¼Œè¿™å°†æ‰©å±•åˆ°æ›´é«˜ç»´æ•°ç»„çš„å­é›†ã€‚'
- en: 'Returning to the row-major integer 3 <math alttext="times"><mo>Ã—</mo></math>
    2 `mds1` example, if we wanted to extract a reference to the first row (index
    0), it could be obtained as follows, with the index in the first extent (row)
    argument of `submdspan`:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: è¿”å›åˆ°è¡Œä¸»æ•´æ•°3 <math alttext="times"><mo>Ã—</mo></math> 2 `mds1`ç¤ºä¾‹ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦æå–å¯¹ç¬¬ä¸€è¡Œï¼ˆç´¢å¼•0ï¼‰çš„å¼•ç”¨ï¼Œå¯ä»¥å¦‚ä¸‹è·å¾—ï¼Œä½¿ç”¨`submdspan`ä¸­çš„ç¬¬ä¸€ä¸ªextentï¼ˆè¡Œï¼‰å‚æ•°ä¸­çš„ç´¢å¼•ï¼š
- en: '[PRE108]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'This would give us:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°†ç»™æˆ‘ä»¬ï¼š
- en: '[PRE109]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Rows 2 and 3 could also be referenced by replacing the `0` with `1` and `2`,
    respectively.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ 2 å’Œç¬¬ 3 è¡Œä¹Ÿå¯ä»¥é€šè¿‡å°† `0` æ›¿æ¢ä¸º `1` å’Œ `2` è¿›è¡Œå¼•ç”¨ã€‚
- en: 'By explicitly setting the second (column) extent argument to the column size
    less 1, we could also access the last column:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡å°†ç¬¬äºŒä¸ªï¼ˆåˆ—ï¼‰èŒƒå›´å‚æ•°æ˜¾å¼è®¾ç½®ä¸ºåˆ—å¤§å°å‡ 1ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥è®¿é—®æœ€åä¸€åˆ—ï¼š
- en: '[PRE110]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'This would then be comprised of:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°†åŒ…æ‹¬ï¼š
- en: '[PRE111]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: As `submdspan` is a reference (view) to an `mdspan` containing a row or column,
    it will obviate generating an additional `mdspan`, in contrast to the issue with
    a `slice_array` taken from a `valarray`. Any public member function on `mdspan`
    can be applied to a `submdspan`. On the downside, this would not include the vectorized
    mathematical operators or functions that are provided with `valarray`, although
    a different approach to the operators will be provided in `P1673`, to be discussed
    in the next section.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸º `submdspan` æ˜¯æŒ‡å‘åŒ…å«è¡Œæˆ–åˆ—çš„ `mdspan` çš„å¼•ç”¨ï¼ˆè§†å›¾ï¼‰ï¼Œæ‰€ä»¥ä¸éœ€è¦ç”Ÿæˆé¢å¤–çš„ `mdspan`ï¼Œä¸ä» `valarray`
    ä¸­å–å¾—çš„ `slice_array` ä¸åŒã€‚å¯ä»¥å¯¹ `submdspan` åº”ç”¨åœ¨ `mdspan` ä¸Šçš„ä»»ä½•å…¬å…±æˆå‘˜å‡½æ•°ã€‚ç„¶è€Œï¼Œç”±äºå…¶å¼•ç”¨æ€§è´¨ï¼Œä¸åŒ…æ‹¬æä¾›ç»™
    `valarray` çš„å‘é‡åŒ–æ•°å­¦è¿ç®—ç¬¦æˆ–å‡½æ•°ï¼Œå°½ç®¡åœ¨ `P1673` ä¸­å°†æä¾›è¿ç®—ç¬¦çš„å¦ä¸€ç§æ–¹æ³•ï¼Œè¯¥æ–¹æ³•å°†åœ¨ä¸‹ä¸€èŠ‚è®¨è®ºã€‚
- en: 'On the flip side, also because it is a reference, modifying an element of a
    `submdspan` will also modify the underlying `mdspan` object. Suppose the last
    element in `col_last` is reset:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€æ–¹é¢ï¼Œç”±äºå…¶æ˜¯ä¸€ä¸ªå¼•ç”¨ï¼Œä¿®æ”¹ `submdspan` çš„å…ƒç´ ä¹Ÿä¼šä¿®æ”¹åº•å±‚çš„ `mdspan` å¯¹è±¡ã€‚å‡è®¾é‡ç½® `col_last` ä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼š
- en: '[PRE112]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The original `mds1` would then become:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶ååŸå§‹çš„ `mds1` å°†å˜ä¸ºï¼š
- en: '[PRE113]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: One final remark is a proposal for a multi-dimensional array (P1684), called
    `mdarray`, is also in review. As noted in the [proposal](https://wg21.link/p1684)
    **{31}**, "`mdarray` is as similar as possible to mdspan, except with container
    semantics instead of reference semanticsâ€. In other words, an `mdarray` object
    â€œownsâ€ its dataâ€‰â€”â€‰similar to a `vector`â€‰â€”â€‰as opposed to existing as a reference
    to data â€œownedâ€ by another container as in the case of `mdspan`. The earliest
    it would be released is also C++26.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åä¸€ç‚¹æ˜¯å…³äºå¤šç»´æ•°ç»„ï¼ˆP1684ï¼‰çš„æè®®ï¼Œç§°ä¸º `mdarray`ï¼Œä¹Ÿæ­£åœ¨å®¡æ ¸ä¸­ã€‚å¦‚åœ¨ [æè®®](https://wg21.link/p1684) **{31}**
    ä¸­æ‰€è¿°ï¼Œâ€œ`mdarray` å°½å¯èƒ½ä¸ `mdspan` ç›¸ä¼¼ï¼Œä½†å…¶å…·æœ‰å®¹å™¨è¯­ä¹‰è€Œä¸æ˜¯å¼•ç”¨è¯­ä¹‰â€ã€‚æ¢å¥è¯è¯´ï¼Œ`mdarray` å¯¹è±¡â€œæ‹¥æœ‰â€å…¶æ•°æ®ï¼Œç±»ä¼¼äº
    `vector`ï¼Œè€Œä¸æ˜¯åƒ `mdspan` é‚£æ ·ä½œä¸ºå¯¹å¦ä¸€ä¸ªå®¹å™¨æ‹¥æœ‰çš„æ•°æ®çš„å¼•ç”¨ã€‚å®ƒå¯èƒ½æœ€æ—©ä¼šåœ¨ C++26 ä¸­å‘å¸ƒã€‚
- en: Note
  id: totrans-405
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: æ³¨æ„
- en: The code examples for `mdspan` above can be compiled in C++20 using the working
    code currently available on the [P1673 GitHub site](https://github.com/kokkos/mdspan/blob/stable/include/experimental/__p0009_bits/mdspan.hpp)
    **{31}**. Installation and building instructions are included with the repository,
    but two particular items to know are first, the code is currently under the namespace
    `std::experimental`, and second, as the square bracket operator for multiple indices
    is set for C++23, you can replace it with the round bracket operator for C++20
    and earlier; viz,
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šè¿° `mdspan` çš„ä»£ç ç¤ºä¾‹å¯ä»¥åœ¨ C++20 ä¸­ä½¿ç”¨å½“å‰åœ¨ [P1673 GitHub ç«™ç‚¹](https://github.com/kokkos/mdspan/blob/stable/include/experimental/__p0009_bits/mdspan.hpp)
    **{31}** ä¸Šå¯ç”¨çš„å·¥ä½œä»£ç ç¼–è¯‘ã€‚å®‰è£…å’Œæ„å»ºè¯´æ˜åŒ…å«åœ¨å­˜å‚¨åº“ä¸­ï¼Œä½†éœ€è¦äº†è§£çš„ä¸¤ä¸ªç‰¹å®šé¡¹æ˜¯ï¼Œé¦–å…ˆï¼Œè¯¥ä»£ç ç›®å‰ä½äºå‘½åç©ºé—´ `std::experimental`
    ä¸‹ï¼Œå…¶æ¬¡ï¼Œç”±äºå¤šé‡ç´¢å¼•çš„æ–¹æ‹¬å·è¿ç®—ç¬¦è®¾ç½®ä¸º C++23ï¼Œæ‚¨å¯ä»¥åœ¨ C++20 åŠæ›´æ—©ç‰ˆæœ¬ä¸­ç”¨åœ†æ‹¬å·è¿ç®—ç¬¦æ›¿æ¢å®ƒï¼›å³ï¼Œ
- en: _
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: _
- en: '[PRE114]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: BLAS Interface (P1673)
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BLAS æ¥å£ï¼ˆP1673ï¼‰
- en: This proposal is for â€œa C++ Standard Library dense linear algebra interface
    based on the dense Basic Linear Algebra Subroutines (BLAS)â€ {op cit 29}, also
    simply referred to as â€œstdBLASâ€. BLAS libraries date back a number of decades
    and were originally written in Fortran, but it evolved into a standard in the
    early 2000â€™s, with implementations in other languages such as C (OpenBLAS) and
    CUDA C++ (NVIDIA) now available, as well as C bindings to Fortran.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤æè®®æ˜¯å…³äºåŸºäºå¯†é›†åŸºæœ¬çº¿æ€§ä»£æ•°å­ç¨‹åºï¼ˆBLASï¼‰çš„ C++ æ ‡å‡†åº“ç¨ å¯†çº¿æ€§ä»£æ•°æ¥å£çš„ææ¡ˆ {è§å¼•ç”¨ 29}ï¼Œä¹Ÿç®€ç§°ä¸ºâ€œstdBLASâ€ã€‚BLAS åº“å¯ä»¥è¿½æº¯åˆ°å‡ åå¹´å‰ï¼Œæœ€åˆæ˜¯ç”¨
    Fortran ç¼–å†™çš„ï¼Œä½†åœ¨ 2000 å¹´åˆå‘å±•ä¸ºæ ‡å‡†ï¼Œç°åœ¨æœ‰å…¶ä»–è¯­è¨€çš„å®ç°ï¼Œå¦‚ Cï¼ˆOpenBLASï¼‰å’Œ CUDA C++ï¼ˆNVIDIAï¼‰ï¼ŒåŒæ—¶è¿˜æœ‰ç”¨äº
    Fortran çš„ C ç»‘å®šã€‚
- en: 'Fortran BLAS distributions support four numerical types : `FLOAT`, `DOUBLE`,
    `COMPLEX`, and `DOUBLE COMPLEX`. The C++ equivalents are `float`, `double`, `std::complex<float>`,
    and `std::complex<double>`. BLAS libraries contain several matrix formats (standard,
    symmetric, upper/lower triangular), matrix and vector operations such as element-by-element
    addition and matrix/vector multiplication.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: Fortran BLAS åˆ†å‘æ”¯æŒå››ç§æ•°å€¼ç±»å‹ï¼š`FLOAT`, `DOUBLE`, `COMPLEX`, å’Œ `DOUBLE COMPLEX`ã€‚å…¶ C++
    ç­‰æ•ˆç±»å‹ä¸º `float`, `double`, `std::complex<float>`, å’Œ `std::complex<double>`ã€‚BLAS
    åº“åŒ…å«å¤šç§çŸ©é˜µæ ¼å¼ï¼ˆæ ‡å‡†ã€å¯¹ç§°ã€ä¸Š/ä¸‹ä¸‰è§’å½¢ï¼‰ã€çŸ©é˜µå’Œå‘é‡æ“ä½œï¼Œå¦‚é€å…ƒç´ åŠ æ³•å’ŒçŸ©é˜µ/å‘é‡ä¹˜æ³•ã€‚
- en: With implementation of this proposal, it would be possible to apply the same
    C++ code base to any compatible library containing BLAS functionality, provided
    an interface has been made available, presumably by the library vendor. This will
    allow for portable code, independent of the underlying library being used. It
    remains to be seen at this stage which vendors will eventually come on board,
    but one major development is NVIDIAâ€™s implementation both of `mdspan` and stdBLAS,
    now available in their [HPC SDK](https://developer.nvidia.com/hpc-sdk) **{33}**.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨æ­¤æè®®çš„å®ç°ï¼Œå¯ä»¥å°†ç›¸åŒçš„ C++ ä»£ç åº“åº”ç”¨äºä»»ä½•åŒ…å« BLAS åŠŸèƒ½çš„å…¼å®¹åº“ï¼Œå‰ææ˜¯åº“ä¾›åº”å•†å·²ç»æä¾›äº†æ¥å£ã€‚è¿™å°†å…è®¸å¯ç§»æ¤çš„ä»£ç ï¼Œç‹¬ç«‹äºæ‰€ä½¿ç”¨çš„åŸºç¡€åº“ã€‚åœ¨è¿™ä¸ªé˜¶æ®µï¼Œå°šä¸æ¸…æ¥šå“ªäº›ä¾›åº”å•†æœ€ç»ˆä¼šå‚ä¸ï¼Œä½†
    NVIDIA çš„å®ç°æ˜¯ä¸€ä¸ªé‡è¦çš„è¿›å±•ï¼ŒåŒ…æ‹¬å®ƒä»¬çš„ [HPC SDK](https://developer.nvidia.com/hpc-sdk) **{33}**ã€‚
- en: It should be noted stdBLAS itself would only provide access to a particular
    subset of matrix operationsâ€‰â€”â€‰to be discussed nextâ€‰â€”â€‰even if the underlying library
    provides additional features such as matrix decompositions, linear and least squares
    solvers, etc.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå³ä½¿åº•å±‚åº“æä¾›é¢å¤–çš„åŠŸèƒ½å¦‚çŸ©é˜µåˆ†è§£ã€çº¿æ€§å’Œæœ€å°äºŒä¹˜æ±‚è§£å™¨ç­‰ï¼ŒstdBLAS æœ¬èº«ä¹Ÿåªæä¾›å¯¹ç‰¹å®šçŸ©é˜µæ“ä½œçš„è®¿é—®æƒé™â€‰â€”â€‰ä¸‹ä¸€æ­¥å°†è¿›è¡Œè®¨è®ºâ€‰â€”â€‰ã€‚
- en: BLAS functions are preceded by the type contained in the matrix and/or vector
    to which they are applied. For example, the function for multiplication of a matrix
    by a vector is of the form
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: BLAS å‡½æ•°æ ¹æ®å®ƒä»¬åº”ç”¨çš„çŸ©é˜µå’Œ/æˆ–å‘é‡ä¸­åŒ…å«çš„ç±»å‹è¿›è¡Œå‰ç½®ã€‚ä¾‹å¦‚ï¼ŒçŸ©é˜µä¹˜ä»¥å‘é‡çš„ä¹˜æ³•å‡½æ•°çš„å½¢å¼å¦‚ä¸‹
- en: '[PRE115]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: where the `x` can be `S`, `D`, `C`, or `Z`, meaning single precision (`REAL`
    in Fortran), double precision (`DOUBLE`), complex (`COMPLEX`), and double precision
    complex (`DOUBLE COMPLEX`) respectively.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­ `x` å¯ä»¥æ˜¯ `S`ã€`D`ã€`C` æˆ– `Z`ï¼Œåˆ†åˆ«è¡¨ç¤ºå•ç²¾åº¦ (`REAL` åœ¨ Fortran ä¸­)ã€åŒç²¾åº¦ (`DOUBLE`)ã€å¤æ•°
    (`COMPLEX`) å’ŒåŒç²¾åº¦å¤æ•° (`DOUBLE COMPLEX`)ã€‚
- en: The C++ equivalent in the proposal, `matrix_vector_product` would instead take
    in `mdspan` objects representing a matrix and a vector. For example, we can look
    at a case involving `double` values, using `m` and `n` for the number of rows
    and columns as before.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æè®®ä¸­çš„ C++ ç­‰æ•ˆå‡½æ•° `matrix_vector_product` å–ä»£äº†ä»¥å‰ä½¿ç”¨çš„ `mdspan` å¯¹è±¡è¡¨ç¤ºçŸ©é˜µå’Œå‘é‡ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥æŸ¥çœ‹ä¸€ä¸ªæ¶‰åŠ
    `double` å€¼çš„æ¡ˆä¾‹ï¼Œä½¿ç”¨ `m` å’Œ `n` è¡¨ç¤ºè¡Œæ•°å’Œåˆ—æ•°ã€‚
- en: '[PRE116]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Then, performing the multiplication, the vector product is stored in `y`:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œè¿›è¡Œä¹˜æ³•è¿ç®—ï¼Œå‘é‡ç§¯å­˜å‚¨åœ¨ `y` ä¸­ï¼š
- en: '[PRE117]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The following table provides a subset of BLAS functions proposed in P1673 that
    should be useful in financial programming. The BLAS functions are assumed to be
    double precision, and any given matrix/vector expressions can be assumed to be
    of appropriate dimensions.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹è¡¨æä¾›äº†åœ¨é‡‘èç¼–ç¨‹ä¸­å¯èƒ½æœ‰ç”¨çš„ P1673 ä¸­çš„ BLAS å‡½æ•°å­é›†ã€‚å‡è®¾ BLAS å‡½æ•°ä¸ºåŒç²¾åº¦ï¼Œå¹¶ä¸”ä»»ä½•ç»™å®šçš„çŸ©é˜µ/å‘é‡è¡¨è¾¾å¼å‡ä¸ºé€‚å½“çš„ç»´åº¦ã€‚
- en: Table 5-1\. Selected BLAS Functions in Proposal P1673
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: è¡¨ 5-1\. æè®® P1673 ä¸­é€‰æ‹©çš„ BLAS å‡½æ•°
- en: '| BLAS Function | P1673 Function | Description |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| BLAS å‡½æ•° | P1673 å‡½æ•° | æè¿° |'
- en: '| --- | --- | --- |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| DSCAL | `scale` | Scalar multiplication of a vector |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| DSCAL | `scale` | å‘é‡çš„æ ‡é‡ä¹˜æ³• |'
- en: '| DCOPY | `copy` | Copy a vector into another |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| DCOPY | `copy` | å°†ä¸€ä¸ªå‘é‡å¤åˆ¶åˆ°å¦ä¸€ä¸ªå‘é‡ |'
- en: '| DAXPY | `add` | Calculates <math alttext="alpha bold x plus bold y"><mrow><mi>Î±</mi>
    <mi>ğ±</mi> <mo>+</mo> <mi>ğ²</mi></mrow></math> , vectors <math alttext="bold x"><mi>ğ±</mi></math>
    & <math alttext="bold y"><mi>ğ²</mi></math> , scalar <math alttext="alpha"><mi>Î±</mi></math>
    |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| DAXPY | `add` | è®¡ç®— <math alttext="alpha bold x plus bold y"><mrow><mi>Î±</mi>
    <mi>ğ±</mi> <mo>+</mo> <mi>ğ²</mi></mrow></math>ï¼Œå‘é‡ <math alttext="bold x"><mi>ğ±</mi></math>
    å’Œ <math alttext="bold y"><mi>ğ²</mi></math>ï¼Œæ ‡é‡ <math alttext="alpha"><mi>Î±</mi></math>
    |'
- en: '| DDOT | `dot` | Dot product of two vectors |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| DDOT | `dot` | ä¸¤ä¸ªå‘é‡çš„ç‚¹ç§¯ |'
- en: '| DNRM2 | `vector_norm2` | Euclidean norm of a vector |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| DNRM2 | `vector_norm2` | å‘é‡çš„æ¬§å‡ é‡Œå¾·èŒƒæ•° |'
- en: '| DGEMV | `matrix_vector_product` | Calculates <math alttext="alpha bold upper
    A bold x plus beta bold y"><mrow><mi>Î±</mi> <mi>ğ€ğ±</mi> <mo>+</mo> <mi>Î²</mi>
    <mi>ğ²</mi></mrow></math> , matrix <math alttext="bold upper A"><mi>ğ€</mi></math>
    , vector <math alttext="bold y"><mi>ğ²</mi></math> , scalars <math alttext="alpha"><mi>Î±</mi></math>
    & <math alttext="beta"><mi>Î²</mi></math> |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| DGEMV | `matrix_vector_product` | è®¡ç®— <math alttext="alpha bold upper A bold
    x plus beta bold y"><mrow><mi>Î±</mi> <mi>ğ€ğ±</mi> <mo>+</mo> <mi>Î²</mi> <mi>ğ²</mi></mrow></math>ï¼ŒçŸ©é˜µ
    <math alttext="bold upper A"><mi>ğ€</mi></math>ï¼Œå‘é‡ <math alttext="bold y"><mi>ğ²</mi></math>ï¼Œæ ‡é‡
    <math alttext="alpha"><mi>Î±</mi></math> å’Œ <math alttext="beta"><mi>Î²</mi></math>
    |'
- en: '| DSYMV | `symmetric_matrix_vector_product` | Same as DGEMV (`matrix_vector_product`)
    but where <math alttext="bold upper A"><mi>ğ€</mi></math> is symmetric |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| DSYMV | `symmetric_matrix_vector_product` | ä¸ DGEMV (`matrix_vector_product`)
    ç›¸åŒï¼Œä½†çŸ©é˜µ <math alttext="bold upper A"><mi>ğ€</mi></math> æ˜¯å¯¹ç§°çš„ |'
- en: '| DGEMM | `matrix_product` | Calculates <math alttext="alpha bold upper A bold
    upper B plus beta bold upper C"><mrow><mi>Î±</mi> <mi>ğ€ğ</mi> <mo>+</mo> <mi>Î²</mi>
    <mi>ğ‚</mi></mrow></math> , for matrices <math alttext="bold upper A"><mi>ğ€</mi></math>
    , <math alttext="bold upper B"><mi>ğ</mi></math> , & <math alttext="bold upper
    C"><mi>ğ‚</mi></math> , and scalars <math alttext="alpha"><mi>Î±</mi></math> & <math
    alttext="beta"><mi>Î²</mi></math> |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| DGEMM | `matrix_product` | è®¡ç®—<math alttext="alpha bold upper A bold upper
    B plus beta bold upper C"><mrow><mi>Î±</mi> <mi>ğ€ğ</mi> <mo>+</mo> <mi>Î²</mi> <mi>ğ‚</mi></mrow></math>ï¼Œå¯¹äºçŸ©é˜µ<math
    alttext="bold upper A"><mi>ğ€</mi></math>ï¼Œ<math alttext="bold upper B"><mi>ğ</mi></math>å’Œ<math
    alttext="bold upper C"><mi>ğ‚</mi></math>ï¼Œä»¥åŠæ ‡é‡<math alttext="alpha"><mi>Î±</mi></math>å’Œ<math
    alttext="beta"><mi>Î²</mi></math> |'
- en: Linear Algebra (P1385)
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: çº¿æ€§ä»£æ•°ï¼ˆP1385ï¼‰
- en: The authors of this proposal specifically recognized the importance of linear
    algebra in financial modeling, along with other applications such as medical imaging,
    machine learning, and high performance computing. {op cit 28}.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ææ¡ˆçš„ä½œè€…ç‰¹åˆ«è®¤è¯†åˆ°çº¿æ€§ä»£æ•°åœ¨é‡‘èå»ºæ¨¡ä¸­çš„é‡è¦æ€§ï¼Œä»¥åŠåœ¨åŒ»å­¦æˆåƒã€æœºå™¨å­¦ä¹ å’Œé«˜æ€§èƒ½è®¡ç®—ç­‰å…¶ä»–åº”ç”¨ä¸­çš„é‡è¦æ€§ã€‚{å¼•ç”¨ 28}ã€‚
- en: 'Initial technical requirements for a linear algebra library in C++ were outlined
    in a [preceding proposal (P1166)](https://wg21.link/p1166) **{34}**, directly
    quoted here (in italics):'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: C++ä¸­çº¿æ€§ä»£æ•°åº“çš„åˆå§‹æŠ€æœ¯è¦æ±‚åœ¨[ä¹‹å‰çš„ææ¡ˆï¼ˆP1166ï¼‰](https://wg21.link/p1166) **{34}** ä¸­æ¦‚è¿°ï¼Œè¿™é‡Œç›´æ¥å¼•ç”¨ï¼ˆæ–œä½“ï¼‰ï¼š
- en: '*The set of types and functions should be the minimal set required to perform
    functions in finite dimensional spaces. This includes*:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '*ç±»å‹å’Œå‡½æ•°çš„é›†åˆåº”è¯¥æ˜¯åœ¨æœ‰é™ç»´ç©ºé—´ä¸­æ‰§è¡Œå‡½æ•°æ‰€éœ€çš„æœ€å°é›†åˆã€‚è¿™åŒ…æ‹¬*ï¼š'
- en: '*A matrix template*'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*çŸ©é˜µæ¨¡æ¿*'
- en: '*Binary operations for addition, subtraction and multiplication of matrices*'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*çŸ©é˜µåŠ æ³•ã€å‡æ³•å’Œä¹˜æ³•çš„äºŒå…ƒè¿ç®—*'
- en: '*Binary operations for scalar multiplication and division of matrices*'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*æ ‡é‡ä¹˜æ³•å’ŒçŸ©é˜µé™¤æ³•çš„äºŒå…ƒè¿ç®—*'
- en: Building on this, the P1385 proposal states two primary goals, namely that the
    library should be easy to use, with â€œrun-time computational performance that is
    close to what {users} could obtain with an equivalent sequence of function calls
    to a more â€œtraditionalâ€ linear algebra library, such as LAPACK, Blaze, Eigen,
    etc.â€ {op cit 30}
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ­¤åŸºç¡€ä¸Šï¼ŒP1385ææ¡ˆè§„å®šäº†ä¸¤ä¸ªä¸»è¦ç›®æ ‡ï¼Œå³åº“åº”è¯¥æ˜“äºä½¿ç”¨ï¼Œå¹¶ä¸”â€œè¿è¡Œæ—¶è®¡ç®—æ€§èƒ½æ¥è¿‘äºç”¨æˆ·é€šè¿‡ç­‰æ•ˆçš„å‡½æ•°è°ƒç”¨åºåˆ—è·å¾—çš„ä¼ ç»Ÿçº¿æ€§ä»£æ•°åº“ï¼ˆå¦‚LAPACKã€Blazeã€Eigenç­‰ï¼‰â€ã€‚{å¼•ç”¨
    30}
- en: At a high level, a matrix is generically represented by a *MathObj* type, and
    an *engine* â€œis an implementation type that manages the resources associated with
    a *MathObj* instance.â€ Discussions are ongoing over the details, but â€œa *MathObj*
    might own the memory in which it stores its elements, or it might employ some
    non-owning view type, like `mdspan`, to manipulate elements owned by some other
    objectâ€. {ibid}. An *engine* object is proposed to be a private member on a *MathObj*,
    and a *MathObj* may have either fixed or dynamic dimensions.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: ä»é«˜å±‚æ¬¡æ¥çœ‹ï¼ŒçŸ©é˜µé€šå¸¸ç”±*MathObj*ç±»å‹æ³›åŒ–è¡¨ç¤ºï¼Œè€Œ*engine*â€œæ˜¯ä¸€ä¸ªç®¡ç†ä¸*MathObj*å®ä¾‹ç›¸å…³èµ„æºçš„å®ç°ç±»å‹ã€‚â€è®¨è®ºä»åœ¨è¿›è¡Œä¸­ï¼Œä½†â€œ*MathObj*å¯èƒ½æ‹¥æœ‰å­˜å‚¨å…¶å…ƒç´ çš„å†…å­˜ï¼Œæˆ–è€…å®ƒå¯èƒ½ä½¿ç”¨ä¸€äº›éæ‹¥æœ‰è§†å›¾ç±»å‹ï¼Œå¦‚`mdspan`ï¼Œæ¥æ“ä½œç”±å…¶ä»–å¯¹è±¡æ‹¥æœ‰çš„å…ƒç´ â€ã€‚{åŒä¸Š}ã€‚*engine*å¯¹è±¡è¢«å»ºè®®ä½œä¸º*MathObj*çš„ç§æœ‰æˆå‘˜ï¼Œå¹¶ä¸”*MathObj*å¯ä»¥å…·æœ‰å›ºå®šæˆ–åŠ¨æ€ç»´åº¦ã€‚
- en: More details should emerge over the next few years on the form the P1385 linear
    albegra library will assume, but for now, this hopefully provides an initial high-level
    glimpse of something that should be a very welcome addition to C++ for financial
    software developers.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœªæ¥å‡ å¹´å†…ï¼Œå…³äºP1385çº¿æ€§ä»£æ•°åº“çš„å½¢å¼åº”è¯¥ä¼šæœ‰æ›´å¤šç»†èŠ‚æµ®å‡ºæ°´é¢ï¼Œä½†ç›®å‰ï¼Œè¿™å¸Œæœ›ä¸ºé‡‘èè½¯ä»¶å¼€å‘äººå‘˜æä¾›ä¸€ä¸ªåˆæ­¥çš„é«˜å±‚æ¬¡é¢„è§ˆï¼Œè¿™åº”è¯¥æ˜¯C++ä¸­éå¸¸å—æ¬¢è¿çš„ä¸€ä¸ªè¡¥å……ã€‚
- en: Summary (Linear Algebra Proposals)
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æ‘˜è¦ï¼ˆçº¿æ€§ä»£æ•°ææ¡ˆï¼‰
- en: Recalling the results we saw with `valarray`, with the above proposals in place,
    some of the same convenient functionality should be in place by C++26, this time
    with rigorous, efficient, and consistent specifications that should avoid the
    problems that plagued `valarray`. While `mdspan` differs from `valarray` as a
    non-owning reference, it will still allow array storage, such as a `vector`, to
    be adapted to a matrix proxy by specifiying the number of rows and columns. `submdspan`
    will assume a similar role as a `valarray` slice, but without the performance
    penalty due to object copy. P1673 will provide a common interface to libraries
    containing BLAS functions, and function naming, as as with `matrix_vector_product`,
    will be more expressive than their cryptic Fortran equivalents such as `DGEMV(.)`.
    And, the `+`, `-`, and `*` operators in P1385 will provide the ability to to implement
    linear algebra expressions in a natural mathematical format similar to the results
    we saw with `valarray`.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: å›é¡¾æˆ‘ä»¬åœ¨`valarray`ä¸­çœ‹åˆ°çš„ç»“æœï¼Œæœ‰äº†ä¸Šè¿°ææ¡ˆï¼ŒåŒæ ·æ–¹ä¾¿çš„åŠŸèƒ½åº”è¯¥åœ¨C++26ä¸­å¾—ä»¥å®ç°ï¼Œè¿™ä¸€æ¬¡å°†æœ‰ä¸¥æ ¼ã€é«˜æ•ˆå’Œä¸€è‡´çš„è§„èŒƒï¼Œé¿å…äº†`valarray`å›°æ‰°çš„é—®é¢˜ã€‚è™½ç„¶`mdspan`ä½œä¸ºéæ‹¥æœ‰å¼•ç”¨ä¸`valarray`ä¸åŒï¼Œä½†å®ƒä»å…è®¸æ•°ç»„å­˜å‚¨ï¼ˆå¦‚`vector`ï¼‰é€šè¿‡æŒ‡å®šè¡Œæ•°å’Œåˆ—æ•°æ¥é€‚åº”çŸ©é˜µä»£ç†ã€‚`submdspan`å°†æ‰¿æ‹…ç±»ä¼¼äº`valarray`åˆ‡ç‰‡çš„è§’è‰²ï¼Œä½†ä¸ä¼šå› å¯¹è±¡å¤åˆ¶è€Œå¸¦æ¥æ€§èƒ½æŸå¤±ã€‚P1673å°†ä¸ºåŒ…å«BLASå‡½æ•°çš„åº“æä¾›ä¸€ä¸ªå…¬å…±æ¥å£ï¼Œå‡½æ•°å‘½åï¼Œä¾‹å¦‚`matrix_vector_product`ï¼Œå°†æ¯”å®ƒä»¬çš„Fortranç­‰ä»·ç‰©ï¼ˆå¦‚`DGEMV(.)`ï¼‰æ›´å…·è¡¨è¾¾æ€§ã€‚è€ŒP1385ä¸­çš„`+`ã€`-`å’Œ`*`è¿ç®—ç¬¦å°†æä¾›åœ¨è‡ªç„¶æ•°å­¦æ ¼å¼ä¸­å®ç°çº¿æ€§ä»£æ•°è¡¨è¾¾å¼çš„èƒ½åŠ›ï¼Œè¿™ä¸æˆ‘ä»¬åœ¨`valarray`ä¸­çœ‹åˆ°çš„ç»“æœç±»ä¼¼ã€‚
- en: This is an exciting development that will finally provide efficient and reliable
    methods for implementing basic matrix calculations that are long overdue for C++.
    Hopefully we will also eventually see implementations of P1673 BLAS interfaces
    for popular open source libraries such as Eigen and others mentioned above, but
    as of the time of this writing, this remains to be seen.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªä»¤äººå…´å¥‹çš„å‘å±•ï¼Œå°†æœ€ç»ˆä¸ºC++å®ç°é•¿æœŸä»¥æ¥æœŸå¾…çš„åŸºæœ¬çŸ©é˜µè®¡ç®—æä¾›é«˜æ•ˆå¯é çš„æ–¹æ³•ã€‚å¸Œæœ›æˆ‘ä»¬æœ€ç»ˆä¹Ÿèƒ½çœ‹åˆ°P1673 BLASæ¥å£åœ¨Eigenç­‰æµè¡Œçš„å¼€æºåº“ä¸­çš„å®ç°ï¼Œä½†åœ¨æ’°å†™æœ¬æ–‡æ—¶ï¼Œè¿™ä»æ˜¯æœªçŸ¥æ•°ã€‚
- en: Chapter Summary
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç« èŠ‚æ€»ç»“
- en: This chapter has examined the past, present, and expected future of two-dimensional
    array management and linear algebra in C++. `valarray`, dating back to C++98,
    offered matrix-like capabilities for which quantitative developers certainly would
    have found ample use cases. It is unforunate it never received the attention and
    support of the Committee and community, even as C++ was being touted in the late
    1990â€™s as the language of the future for computational finance. For specific compilers,
    it might remain a viable option, but given the inconsistency of its implementations
    across Standard Library vendors, it can limit code reuse across different platforms.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ç« æ¢è®¨äº†C++ä¸­äºŒç»´æ•°ç»„ç®¡ç†å’Œçº¿æ€§ä»£æ•°çš„è¿‡å»ã€ç°åœ¨å’Œé¢„æœŸæœªæ¥ã€‚`valarray` è‡ªC++98èµ·æä¾›äº†ç±»ä¼¼çŸ©é˜µçš„åŠŸèƒ½ï¼Œå¯¹é‡åŒ–å¼€å‘è€…æ¥è¯´åº”è¯¥æœ‰å¤§é‡ä½¿ç”¨æ¡ˆä¾‹ã€‚ä¸å¹¸çš„æ˜¯ï¼Œå°½ç®¡åœ¨20ä¸–çºª90å¹´ä»£æœ«C++è¢«å®£ä¼ ä¸ºè®¡ç®—é‡‘èçš„æœªæ¥è¯­è¨€ï¼Œä½†å®ƒä»æœªå¾—åˆ°å§”å‘˜ä¼šå’Œç¤¾åŒºçš„å…³æ³¨å’Œæ”¯æŒã€‚å¯¹äºç‰¹å®šçš„ç¼–è¯‘å™¨æ¥è¯´ï¼Œå®ƒå¯èƒ½ä»ç„¶æ˜¯ä¸€ä¸ªå¯è¡Œçš„é€‰æ‹©ï¼Œä½†ç”±äºå…¶åœ¨æ ‡å‡†åº“ä¾›åº”å•†ä¸­å®ç°çš„ä¸ä¸€è‡´æ€§ï¼Œå®ƒä¼šé™åˆ¶åœ¨ä¸åŒå¹³å°ä¸Šçš„ä»£ç å¤ç”¨ã€‚
- en: In the late 2000â€™s, high quality open-source linear algebra libraries such as
    Eigen and Armadillo came on the scene and were well-received by the financial
    quant C++ programming community. In the present day, these libraries contain not
    only much of the same functionality found in the BLAS standard, but also a plethora
    of matrix decompositions that are frequently used in financial applications.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨2000å¹´ä»£æœ«ï¼ŒåƒEigenå’ŒArmadilloè¿™æ ·çš„é«˜è´¨é‡å¼€æºçº¿æ€§ä»£æ•°åº“å‡ºç°äº†ï¼Œå¹¶å—åˆ°é‡‘èé‡åŒ–C++ç¼–ç¨‹ç¤¾åŒºçš„å¥½è¯„ã€‚å¦‚ä»Šï¼Œè¿™äº›åº“ä¸ä»…åŒ…å«BLASæ ‡å‡†ä¸­çš„è®¸å¤šåŠŸèƒ½ï¼Œè¿˜åŒ…æ‹¬åœ¨é‡‘èåº”ç”¨ä¸­ç»å¸¸ä½¿ç”¨çš„å¤§é‡çŸ©é˜µåˆ†è§£åŠŸèƒ½ã€‚
- en: Finally, the future also looks brighter for ISO C++ with the three proposalsâ€‰â€”â€‰`mdspan`
    (P0009), BLAS interface (P1673), and linear algebra library (P1385)â€‰â€”â€‰slated for
    inclusion in the Standard Library within the next three years. These are arguably
    features that are long overdue, but they will provide a big step in satisfying
    demand not just from the financial industry, but also other computationally intensive
    domains.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€ç»ˆï¼ŒISO C++ çš„æœªæ¥çœ‹èµ·æ¥æ›´åŠ å…‰æ˜ï¼Œå› ä¸ºä¸‰ä¸ªææ¡ˆâ€”â€”`mdspan`ï¼ˆP0009ï¼‰ã€BLAS æ¥å£ï¼ˆP1673ï¼‰ã€çº¿æ€§ä»£æ•°åº“ï¼ˆP1385ï¼‰â€”â€”è®¡åˆ’åœ¨æ¥ä¸‹æ¥çš„ä¸‰å¹´å†…è¢«çº³å…¥æ ‡å‡†åº“ä¸­ã€‚è¿™äº›åŠŸèƒ½å¯ä»¥è¯´æ˜¯æ—©å°±åº”è¯¥æœ‰çš„ï¼Œä½†å®ƒä»¬å°†å¤§æ­¥æ»¡è¶³ä¸ä»…æ¥è‡ªé‡‘èè¡Œä¸šï¼Œè¿˜åŒ…æ‹¬å…¶ä»–è®¡ç®—å¯†é›†å‹é¢†åŸŸçš„éœ€æ±‚ã€‚
- en: References
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å‚è€ƒæ–‡çŒ®
- en: US Daily Treasury Par Yield Curve Rates [*https://home.treasury.gov/resource-center/data-chart-center/interest-rates/TextView?type=daily_treasury_yield_curve&field_tdr_date_value_month=202211*](https://home.treasury.gov/resource-center/data-chart-center/interest-rates/TextView?type=daily_treasury_yield_curve&field_tdr_date_value_month=202211)
    _
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: ç¾å›½æ¯æ—¥è´¢æ”¿éƒ¨åˆ©ç‡æ›²çº¿æ”¶ç›Šç‡ [*https://home.treasury.gov/resource-center/data-chart-center/interest-rates/TextView?type=daily_treasury_yield_curve&field_tdr_date_value_month=202211*](https://home.treasury.gov/resource-center/data-chart-center/interest-rates/TextView?type=daily_treasury_yield_curve&field_tdr_date_value_month=202211)
    _
- en: '[Supplemental Chapter, _The C++ Standard Library, 2E](http://www.cppstdlib.com/cppstdlib_supplementary.pdf)'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '[é™„åŠ ç« èŠ‚ï¼Œ_C++æ ‡å‡†åº“ï¼Œç¬¬2ç‰ˆ_](http://www.cppstdlib.com/cppstdlib_supplementary.pdf)'
- en: '{2.5} Stroustrup, *A Tour of C++* (2E, but now in 3E)'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '{2.5} Stroustrupï¼Œ*C++ä¹‹æ—…*ï¼ˆç¬¬2ç‰ˆï¼Œç°åœ¨æ˜¯ç¬¬3ç‰ˆï¼‰'
- en: Quantstart article on Eigen [*https://www.quantstart.com/articles/Eigen-Library-for-Matrix-Algebra-in-C/*](https://www.quantstart.com/articles/Eigen-Library-for-Matrix-Algebra-in-C/)
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: Quantstartå…³äºEigençš„æ–‡ç«  [*https://www.quantstart.com/articles/Eigen-Library-for-Matrix-Algebra-in-C/*](https://www.quantstart.com/articles/Eigen-Library-for-Matrix-Algebra-in-C/)
- en: Gottschling _Discovering Modern C++
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: Gottschling _å‘ç°ç°ä»£C++
- en: Bowie Owens, CppCon 2019, [*https://www.youtube.com/watch?v=4IUCBx5fIv0*](https://www.youtube.com/watch?v=4IUCBx5fIv0)
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: Bowie Owensï¼ŒCppCon 2019ï¼Œ[*https://www.youtube.com/watch?v=4IUCBx5fIv0*](https://www.youtube.com/watch?v=4IUCBx5fIv0)
- en: 'More information on the Jacobi and Bidiagonal Divide and Conquer SVD classes:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: å…³äºé›…å¯æ¯”å’ŒåŒå¯¹è§’åˆ†è§£SVDç±»çš„æ›´å¤šä¿¡æ¯ï¼š
- en: '[Two-sided Jacobi SVD decomposition of a rectangular matrix](https://eigen.tuxfamily.org/dox-devel/classEigen_1_1JacobiSVD.html)'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '[çŸ©å½¢çŸ©é˜µçš„åŒè¾¹é›…å¯æ¯”SVDåˆ†è§£](https://eigen.tuxfamily.org/dox-devel/classEigen_1_1JacobiSVD.html)'
- en: '[Bidiagonal Divide and Conquer SVD](https://eigen.tuxfamily.org/dox-devel/classEigen_1_1BDCSVD.html)'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '[åŒå¯¹è§’åˆ†è§£SVD](https://eigen.tuxfamily.org/dox-devel/classEigen_1_1BDCSVD.html)'
- en: asciidoctor-latex -b html Ch10_v10_Split_LinearAlgebraOnly.adoc
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: asciidoctor-latex -b html Ch10_v10_Split_LinearAlgebraOnly.adoc
- en: '{5} Rcpp Packages:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '{5} RcppåŒ…ï¼š'
- en: '[RcppEigen](https://cran.r-project.org/web/packages/RcppEigen/vignettes/RcppEigen-Introduction.pdf)'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '[RcppEigen](https://cran.r-project.org/web/packages/RcppEigen/vignettes/RcppEigen-Introduction.pdf)'
- en: '[RcppArmadillo](https://cran.r-project.org/web/packages/RcppArmadillo/vignettes/RcppArmadillo-intro.pdf)'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '[RcppArmadillo](https://cran.r-project.org/web/packages/RcppArmadillo/vignettes/RcppArmadillo-intro.pdf)'
- en: '[RcppBlaze3](https://github.com/ChingChuan-Chen/RcppBlaze3)'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '[RcppBlaze3](https://github.com/ChingChuan-Chen/RcppBlaze3)'
- en: '[Boost Headers, including uBLAS](https://www.rdocumentation.org/packages/BH/versions/1.78.0-0)'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '[Boost Headersï¼ŒåŒ…æ‹¬uBLAS](https://www.rdocumentation.org/packages/BH/versions/1.78.0-0)'
