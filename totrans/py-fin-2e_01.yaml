- en: Chapter 2\. Python Infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In building a house, there is the problem of the selection of wood.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is essential that the carpenter’s aim be to carry equipment that will cut
    well and, when he has time, to sharpen that equipment.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Miyamoto Musashi (The Book of Five Rings)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For someone new to Python, Python deployment might seem all but straightforward.
    The same holds true for the wealth of libraries and packages that can be installed
    optionally. First of all, there is not only *one* Python. Python comes in many
    different flavors, like CPython, Jython, IronPython or PyPy. Then there is still
    the divide between Python 2.7 and the 3.x world.^([1](ch02.html#idm140277702866800))
    In what follows, the chapter focuses on *CPython*, the by far most popular version
    of the Python programming language, and here on *version 3.6*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even when focusing on CPython 3.6 (henceforth just "`Python`“), deployment
    is made difficult due to a number of additional reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: the interpreter (a standard CPython installation) only comes with the so-called
    *standard library* (e.g. covering typical mathematical functions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: optional Python packages need to be installed separately — and there are hundreds
    of them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: compiling/building such non-standard packages on your own can be tricky due
    to dependencies and operating system-specific requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: taking care of such dependencies and of version consistency over time (i.e.
    maintenance) is often tedious and time consuming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: updates and upgrades for certain packages might cause the need for re-compiling
    a multitude of other packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: changing or replacing one package might cause trouble in (many) other places
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fortunately, there are tools and strategies available that help with the Python
    deployment issue. This chapter covers the following types of technologies that
    help with Python deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**package manager**: package managers like [`pip`](https://pypi.python.org/pypi/pip)
    or [`conda`](http://conda.pydata.org/docs/intro.html) help with the installing,
    updating and removing of Python packages; they also help with version consistency
    of different packages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**virtual environment manager**: a virtual environment manager like [`virtualenv`](https://pypi.python.org/pypi/virtualenv)
    or `conda` allows to manage multiple Python installations in parallel (e.g. to
    have both a Python 2.7 and 3.6 install on a single machine or to test the most
    recent development version of a fancy Python package without risk)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**container**: [Docker](http://docker.com) containers represent complete file
    systems containing all pieces of a system needed to run a certain software, like
    code, runtime or system tools; for example, you can run an Ubuntu 16.04 operating
    system with a Python 3.6 install and the respective Python codes in a Docker container
    hosted on a machine running Mac OS or Windows 10, for example'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**cloud instance**: deploying Python code for algorithmic trading generally
    requires high availability, security and also performance; these requirements
    can typically only be met by the use of professional compute and storage infrastructure
    that is nowadays available at attractive conditions in the form of fairly small
    to really large and powerful cloud instances; one benefit of a cloud instance,
    i.e. a virtual server, compared to a dedicated server rented longer term, is that
    users generally get charged only for the hours of actual usage; another advantage
    is that such cloud instances are available literally in a minute or two if needed
    which helps agile development and also with scalability'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The structure of this chapter is as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[“Conda as a Package Manager”](#conda_package)'
  prefs: []
  type: TYPE_NORMAL
- en: This section introduces `conda` as a package manager for Python.
  prefs: []
  type: TYPE_NORMAL
- en: '[“Conda as a Virtual Environment Manager”](#conda_environment)'
  prefs: []
  type: TYPE_NORMAL
- en: This section focuses on `conda`’s capabilities as a virtual environment manager.
  prefs: []
  type: TYPE_NORMAL
- en: '[“Using Docker Containerization”](#docker_container)'
  prefs: []
  type: TYPE_NORMAL
- en: This section gives a brief overview of Docker as a containerization technology
    and focuses on the building of a Ubuntu-based container with Python 3.6 installation.
  prefs: []
  type: TYPE_NORMAL
- en: '[“Using Cloud Instances”](#cloud_instance)'
  prefs: []
  type: TYPE_NORMAL
- en: The section shows how to deploy Python and Jupyter Notebook — as a powerful,
    browser-based tool suite — for Python development in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this chapter is to have a proper Python installation with the most
    important numerical and data analysis packages available on a professional infrastructure.
    This combination then serves as the backbone for implementing and deploying the
    Python codes in later chapter, be it interactive financial analytics code or code
    in the form of scripts and modules.
  prefs: []
  type: TYPE_NORMAL
- en: Conda as a Package Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although `conda` can be installed stand alone, an efficient way of doing it
    is via Miniconda, a minimal Python distribution including `conda` as a package
    and virtual environment manager.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Miniconda 3.6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can download the different versions of Miniconda on the [Miniconda page](http://conda.pydata.org/miniconda.html).
    In what follows, the Python 3.6 64-bit version is assumed which is available for
    Linux, Windows and Mac OS. The main example in this sub-section is a session in
    a Ubuntu-based Docker container which downloads the Linux 64-bit installer via
    `wget` and then installs Miniconda. The code as shown should work without modification
    on any other Linux-based or Mac OS-based machine as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Simply pressing the `ENTER` key starts the installation process. After reviewing
    the license agreement, approve the terms by answering `yes`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: After you have agreed to the licensing terms and have confirmed the install
    location you should allow Miniconda to prepend the new Miniconda install location
    to the `PATH` environment variable by answering `yes` once again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After this rather simple installation procedure, there are now both a basic
    Python install as well as `conda` available. The basic Python install comes already
    with some nice batteries included like the [`SQLite3`](https://sqlite.org) database
    engine. You might try out whether you can start Python in a *new shell instance*
    or after *appending the relevant path* to the respective environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Basic Operations with Conda
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Conda` can be used to efficiently handle, among others, the installing, updating
    and removing of Python packages. The following list provides an overview of the
    major functions.'
  prefs: []
  type: TYPE_NORMAL
- en: installing Python x.x
  prefs: []
  type: TYPE_NORMAL
- en: '`conda install python=x.x`'
  prefs: []
  type: TYPE_NORMAL
- en: updating Python
  prefs: []
  type: TYPE_NORMAL
- en: '`conda update python`'
  prefs: []
  type: TYPE_NORMAL
- en: installing a package
  prefs: []
  type: TYPE_NORMAL
- en: '`conda install $PACKAGE_NAME`'
  prefs: []
  type: TYPE_NORMAL
- en: updating a package
  prefs: []
  type: TYPE_NORMAL
- en: '`conda update $PACKAGE_NAME`'
  prefs: []
  type: TYPE_NORMAL
- en: removing a package
  prefs: []
  type: TYPE_NORMAL
- en: '`conda remove $PACKAGE_NAME`'
  prefs: []
  type: TYPE_NORMAL
- en: updating conda itself
  prefs: []
  type: TYPE_NORMAL
- en: '`conda update conda`'
  prefs: []
  type: TYPE_NORMAL
- en: searching for packages
  prefs: []
  type: TYPE_NORMAL
- en: '`conda search $SEARCH_TERM`'
  prefs: []
  type: TYPE_NORMAL
- en: listing installed packages
  prefs: []
  type: TYPE_NORMAL
- en: '`conda list`'
  prefs: []
  type: TYPE_NORMAL
- en: Given these capabilities, installing, for example, `NumPy` — as one of the most
    important libraries of the so-called scientific stack — is a single command only.
    When the installation takes place on a machine with Intel processor, the procedure
    automatically installs the [Intel Math Kernel Library `mkl`](https://docs.continuum.io/mkl-optimizations/)
    which speeds up numerical operations not only for `NumPy` on Intel machines but
    also for a few other scientific Python packages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Multiple packages can also be installed at once. The `-y` flag indicates that
    all (potential) questions shall be answered with `yes`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: After the resulting installation procedure, some of the most important libraries
    for financial analytics are available in addition to the standard ones.
  prefs: []
  type: TYPE_NORMAL
- en: '[IPython](http://ipython.org)'
  prefs: []
  type: TYPE_NORMAL
- en: an improved interactive Python shell
  prefs: []
  type: TYPE_NORMAL
- en: '[matplotlib](http://matplotlib.org)'
  prefs: []
  type: TYPE_NORMAL
- en: the standard plotting library in Python
  prefs: []
  type: TYPE_NORMAL
- en: '[NumPy](http://numpy.org)'
  prefs: []
  type: TYPE_NORMAL
- en: efficient handling of numerical arrays
  prefs: []
  type: TYPE_NORMAL
- en: '[pandas](http://pandas.pydata.org)'
  prefs: []
  type: TYPE_NORMAL
- en: management of tabular data, like financial time series data
  prefs: []
  type: TYPE_NORMAL
- en: '[PyTables](http://pytables.org)'
  prefs: []
  type: TYPE_NORMAL
- en: a Python wrapper for the [HDF5](http://hdfgroup.org) library
  prefs: []
  type: TYPE_NORMAL
- en: '[SciPy](http://scipy.org)'
  prefs: []
  type: TYPE_NORMAL
- en: a collection of scientific classes and functions (installed as a dependency)
  prefs: []
  type: TYPE_NORMAL
- en: '[Seaborn](http://seaborn.pydata.org)'
  prefs: []
  type: TYPE_NORMAL
- en: a plotting library adding statistical capabilities and nice plotting defaults
  prefs: []
  type: TYPE_NORMAL
- en: This provides a basic tool set for data analysis in general and financial analytics
    in particular. The next example uses `IPython` and draws a set of pseudo-random
    numbers with `NumPy`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Executing `conda list` verifies which packages are installed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In case a package is not needed anymore, it is efficiently removed with `conda
    remove`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`conda` as a package manager is already quite useful. However, its full power
    only becomes evident when adding virtual environment management to the mix.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`conda` as a package manager makes installing, updating and removing of Python
    packages a pleasant experience. There is no need to take care of building and
    compiling packages on your own anymore — which can be tricky sometimes given the
    list of dependencies a package specifies and given the specifics to be considered
    on different operating systems.'
  prefs: []
  type: TYPE_NORMAL
- en: Conda as a Virtual Environment Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having installed Miniconda with `conda` included provides a default Python installation
    depending on what version of Miniconda has been chosen. The virtual environment
    management capabilities of `conda` allow, for example, to add to a Python 3.6
    default installation a completely separated installation of Python 2.7.x. To this
    end, `conda` offers the following functionality.
  prefs: []
  type: TYPE_NORMAL
- en: creating a virtual environment
  prefs: []
  type: TYPE_NORMAL
- en: '`conda create --name $ENVIRONMENT_NAME`'
  prefs: []
  type: TYPE_NORMAL
- en: activating an environment
  prefs: []
  type: TYPE_NORMAL
- en: '`source activate $ENVIRONMENT_NAME`'
  prefs: []
  type: TYPE_NORMAL
- en: deactivating an environment
  prefs: []
  type: TYPE_NORMAL
- en: '`source deactivate $ENVIRONMENT_NAME`'
  prefs: []
  type: TYPE_NORMAL
- en: removing an environment
  prefs: []
  type: TYPE_NORMAL
- en: '`conda-env remove --name $ENVIRONMENT_NAME`'
  prefs: []
  type: TYPE_NORMAL
- en: export to an environment file
  prefs: []
  type: TYPE_NORMAL
- en: '`conda env export > $FILE_NAME`'
  prefs: []
  type: TYPE_NORMAL
- en: creating an environment from file
  prefs: []
  type: TYPE_NORMAL
- en: '`conda env create -f $FILE_NAME`'
  prefs: []
  type: TYPE_NORMAL
- en: listing all environments
  prefs: []
  type: TYPE_NORMAL
- en: '`conda info --envs`'
  prefs: []
  type: TYPE_NORMAL
- en: As a simple illustration, the example code that follows creates an environment
    called `py27`, installs `IPython` and executes a line of Python 2.7.x code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the prompt changes to include `(py27)` after the activation of the
    environment.^([2](ch02.html#idm140277702388192))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Finally, using `IPython` with Python 2.7 syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As this example demonstrates, `conda` as a virtual environment manager allows
    to install different Python versions alongside each other. It also allows to install
    different versions of certain packages. The default Python install is not influenced
    by such a procedure, nor are other environments which might exist on the same
    machine. All available environments can be shown via `conda info --envs`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes it is necessary to share environment information with others or to
    use environment information on multiple machines, for instance. To this end, one
    can export the installed packages list to a file with `conda env export`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Often, virtual environments, which are technically not that much more than a
    certain (sub-)folder structure, are created to do some quick tests.^([3](ch02.html#idm140277702377552))
    In such a case, an environment is easily removed after deactivation via `conda
    env remove`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the overview of `conda` as a virtual environment manager.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`conda` does not only help with managing packages, it is also a virtual environment
    manager for Python. It simplifies the creation of different Python environments,
    allowing to have multiple versions of Python and optional packages available on
    the same machine without them influencing each other in any way. `conda` also
    allows to export environment information to easily replicate it on multiple machines
    or to share it with others.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker Containerization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker containers have taken over the IT world by storm. Although the technology
    is still quite young, it has established itself as one of the benchmarks for the
    efficient development and deployment of almost any kind of software application.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes it suffices to think of a Docker container as a separated (“containerized”)
    file system that includes an operating system (e.g. Ubuntu 16.04\. for server),
    a (Python) runtime, additional system and development tools as well as further
    (Python) libraries and packages as needed. Such a Docker container might run on
    a local machine with Windows 10 or on a cloud instance with a Linux operating
    system, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: This section does not allow to go into the exciting details of Docker containers.
    It is rather a concise illustration of what the Docker technology can do in the
    context of Python deployment.^([4](ch02.html#idm140277702366912))
  prefs: []
  type: TYPE_NORMAL
- en: Docker Images and Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: However, before moving on to the illustration, two fundamental terms need to
    be distinguished when talking about Docker. The first is a *Docker image* which
    can be compared to a Python class. The second is a *Docker container* which can
    be compared to an instance of the respective Python class.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a more technical level, you find the following definition for a *Docker
    image* in the [Docker glossary](https://docs.docker.com/engine/reference/glossary/):'
  prefs: []
  type: TYPE_NORMAL
- en: Docker images are the basis of containers. An Image is an ordered collection
    of root filesystem changes and the corresponding execution parameters for use
    within a container runtime. An image typically contains a union of layered filesystems
    stacked on top of each other. An image does not have state and it never changes.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Similarly, you find the following definition for a *Docker container* in the
    [Docker glossary](https://docs.docker.com/engine/reference/glossary/) which makes
    the analogy to Python classes and instances of such classes transparent:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A container is a runtime instance of a Docker image. A Docker container consists
    of: a Docker image, an execution environment and a standard set of instructions.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Depending on the operating system, the installation of Docker is somewhat different.
    That is why this section does not go into the respective details. Detailed information
    is found on the [Install Docker Engine page](https://docs.docker.com/engine/installation/).
  prefs: []
  type: TYPE_NORMAL
- en: Building an Ubuntu & Python Docker Image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This sub-section illustrates the building of a Docker image based on the latest
    version of Ubuntu that includes Miniconda as well as a few important Python packages.
    In addition, it also does some Linux housekeeping by updating the Linux packages
    index, upgrading packages if required and installing certain, additional system
    tools. To this end, two scripts are needed. One is a `bash` script doing all the
    work on the Linux level.^([5](ch02.html#idm140277702354096)) The other is a so-called
    `Dockerfile` which controls the building procedure for the image itself.
  prefs: []
  type: TYPE_NORMAL
- en: The `bash` script in [Example 2-1](#docker_install) which does the installing
    consists of three major parts. The first part handles the Linux housekeeping.
    The second part installs Miniconda while the third part installs optional Python
    packages. There are also more detailed comments inline.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-1\. Script installing Python and optional packages
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `Dockerfile` in [Example 2-2](#docker_file) uses the `bash` script in [Example 2-1](#docker_install)
    to build a new Docker image. It also has its major parts commented inline.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-2\. Dockerfile to build the image
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If these two files are in a single folder and Docker is installed, then the
    building of the new Docker image is straightforward. Here, the tag `ubuntupython`
    is used for the image. This tag is needed to reference the image, for example,
    when running a container based on it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Existing Docker images can be listed via `docker images`. The new image should
    be on top of the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Having built the `ubuntupython` image successfully allows to run a respective
    Docker container with `docker run`. The parameter combination `-ti` is needed
    for interactive processes running within a Docker container, like a shell process
    (see the [Docker Run Reference page](https://docs.docker.com/engine/reference/run/)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Exiting `IPython` will exit the container as well since it is *the only* application
    run within the container. However, you can detach from a container via
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After having detached from the container, the `docker ps` command shows the
    running container (and maybe other currently running containers):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Attaching to the Docker container is accomplished by `docker attach $CONTAINER_ID`
    (notice that a few letters of the `CONTAINER ID` are enough):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `exit` command terminates `IPython` and therewith the Docker container as
    well. It can be removed by `docker rm`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, the Docker image `ubuntupython` can be removed via `docker rmi` if
    not needed any longer. While containers are relatively light weight, single images
    might consume quite a bit of storage. In the case of the `py4fi:basic` image,
    the size is above 1 GB. That is why you might want to regularly clean up the list
    of Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Of course, there is much more to say about Docker containers and their benefits
    in certain application scenarios. For the purposes of this book and online training
    course, they provide a modern approach to deploy Python, to do Python development
    in a completely separated (containerized) environment and to ship codes for algorithmic
    trading.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you are not yet using Docker containers, you should consider start using
    them. They provide a number of benefits when it comes to Python deployment and
    development efforts, not only when working locally but in particular when working
    with remote cloud instances and servers deploying code for algorithmic trading.
  prefs: []
  type: TYPE_NORMAL
- en: Using Cloud Instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section shows how to set up a full-fledged Python infrastructure on a [DigitalOcean](http://digitalocean.com)
    cloud instance. There are many other cloud providers out there, among them [Amazon
    Web Services](http://aws.amazon.com) (AWS) as the leading provider. However, DigitalOcean
    is well known for its simplicity and also its relatively low rates for their smaller
    cloud instances, which they call *droplet*. The smallest droplet, which is generally
    sufficient for exploration and development purposes, only costs 5 USD per month
    or 0.007 USD per hour. Users get only charged by the hour so that you can easily
    spin up a droplet for 2 hours, destroy it afterwards and get charged just 0.014
    USD. If you do not have an account yet, register for one on this [sign-up page](https://m.do.co/c/fbe512dd3dac)
    that secures you a starting credit of 10 USD.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of this section is to set up a droplet on DigitalOcean that has a
    Python 3.6 installation plus typically needed packages (e.g. `NumPy`, `pandas`)
    in combination with a password-protected and Secure Sockets Layer (SSL)-encrypted
    [Jupyter Notebook](http://jupyter.org) server installation. As a web-based tool
    suite, Jupyter Notebook provides three major tools that can be used via a regular
    browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jupyter Notebook**: this is the by now really popular interactive development
    environment that features a selection of different language kernels like for Python,
    R and Julia'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**terminal**: a system shell implementation accessible via the browser which
    allows for all typical system administration tasks but also for usage of such
    helpful tools like [`Vim`](http://www.vim.org/download.ph) or [`git`](https://git-scm.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**editor**: the third major tool is a browser-based file editor with syntax
    highlighting for many different programming languages and file types as well as
    typical editing capabilities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having Jupyter Notebook installed on a droplet allows to do Python development
    and deployment via the browser, circumventing the need to log in to the cloud
    instance via Secure Shell (SSH) access.
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish the goal of this section, a number of files is needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**server set-up script**: this script orchestrates all steps necessary, like
    for instance copying other files to the droplet and running them on the droplet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python and Jupyter installation script**: this installs Python, additional
    packages, Jupyter Notebook and starts the Jupyter Notebook server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jupyter Notebook configuration file**: this file is for the configuration
    of the Jupyter Notebook server, e.g. with respect to password protection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RSA public and private key files**: these two files are needed for the SSL
    encryption of the Jupyter Notebook server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In what follows, we work backwards through this list of files.
  prefs: []
  type: TYPE_NORMAL
- en: RSA Public and Private Keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to accomplish a secure connection to the Jupyter Notebook server via
    an arbitrary browser, a SSL certificate consisting of RSA public and private keys
    (see [RSA Wikipedia page](https://en.wikipedia.org/wiki/RSA_(cryptosystem))) is
    needed. In general, one would expect that such a certificate comes from a so-called
    Certificate Authority (CA). For the purposes of this book, however, a self-generated
    certificate is "`good enough`“.^([6](ch02.html#idm140277702285376)) A popular
    tool to generate RSA key pairs is [`OpenSSL`](http://openssl.org). The brief interactive
    session to follow generates a certificate appropriate for use with a Jupyter Notebook
    server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The two files `cert.key` and `cert.pem` need to be copied to the droplet and
    need to be referenced by the Jupyter Notebook configuration file. This file is
    presented next.
  prefs: []
  type: TYPE_NORMAL
- en: Jupyter Notebook Configuration File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A public Jupyter Notebook server can be deployed securely as explained on the
    [Running a Notebook Server page](http://jupyter-notebook.readthedocs.io/en/latest/public_server.html).
    Among others, Jupyter Notebook shall be password protected. To this end, there
    is a password hash code-generating function called `passwd` available in `notebook.auth`
    sub-package. The code below generates a password hash code with `jupyter` being
    the password itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This hash code needs to be placed in the Jupyter Notebook configuration file
    as presented in [Example 2-3](#jupyter_config_file). The code assumes that the
    RSA key files have been copied on the droplet to the `/root/.jupyter/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-3\. Jupyter Notebook configuration file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Caution
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Deploying Jupyter Notebook in the cloud principally leads to a number of security
    issues since it is a full-fledged development environment accessible via a web
    browser. It is therefore of paramount importance to use the security measures
    that a Jupyter Notebook server provides by default, like password protection and
    SSL encryption. But this is just the beginning and further security measures might
    be advised depending on what exactly is done on the cloud instance.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to make sure that Python and Jupyter Notebook get installed
    on the droplet.
  prefs: []
  type: TYPE_NORMAL
- en: Installation Script for Python and Jupyter Notebook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The bash script to install Python and Jupyter Notebook is similar to the one
    presented in section [“Using Docker Containerization”](#docker_container) to install
    Python via Miniconda in a Docker container. However, the script here needs to
    start the Jupyter Notebook server as well. All major parts and lines of code are
    commented inline.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-4\. Bash script to install Python and to run the Jupyter Notebook
    server
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This script needs to be copied to the droplet and needs to be started by the
    orchestration script as described in the next sub-section.
  prefs: []
  type: TYPE_NORMAL
- en: Script to Orchestrate the Droplet Set-up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second bash script which sets up the droplet is the shortest one. It mainly
    copies all the other files to the droplet for which the respective IP address
    is expected as a parameter. In the final line, it starts the `install.sh` bash
    script which in turn does the installation itself and starts the Jupyter Notebook
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-5\. `bash` script to setup the droplet
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything now is together to give the set-up code a try. On DigitalOcean,
    create a new droplet with options similar to these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**operating system**: Ubuntu 16.04.3 x64 (the default choice as of 04\. November
    2017)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**size**: 1 core, 512 MB, 20GB SSD (smallest droplet)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**data center region**: Frankfurt (since your author lives in Germany)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SSH key**: add a (new) SSH key for password-less login ^([7](ch02.html#idm140277701971712))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**droplet name**: you can go with the pre-specified name or can choose something
    like `py4fi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, clicking on the `Create` button initiates the droplet creation process
    which generally takes about one minute. The major outcome for proceeding with
    the set-up procedure is the IP address which might be, for instance, 46.101.156.199
    when you have chosen Frankfurt as your data center location. Setting up the droplet
    now is as easy as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting process, however, might take a couple of minutes. It is finished
    when there is a message from the Jupyter Notebook server saying something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In any current browser, visiting the following address accesses the running
    Jupyter Notebook (note the `https` protocol):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: After maybe adding a security exception, the Jupyter Notebook login screen prompting
    for a password (in our case `jupyter`) should appear. Everything is now ready
    to start Python development in the browser via Jupyter Notebook, `IPython` via
    a terminal window or the text file editor. Other file management capabilities
    like file upload, deletion of files or creation of folders are also available.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Cloud instances like those from DigitalOcean and Jupyter Notebook are a powerful
    combination for the algorithmic trader to work on and make use of professional
    compute and storage infrastructure. Professional cloud and data center providers
    make sure that your (virtual) machines are physically secure and highly available.
    Using cloud instances also keeps the exploration and development phase at rather
    low costs since usage generally gets charged by the hour without the need to enter
    long term agreements.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is the programming language and technology platform of choice for this
    book. However, Python deployment can be tricky at best and sometimes even tedious
    and nerve wrecking. Fortunately, technologies are available today — all younger
    than five years — that help with the deployment issue. The open source software
    `conda` helps with both Python package and virtual environment management. Docker
    containers go even further in that complete file systems and runtime environments
    can be easily created in a technically shielded "`sandbox`“, i.e. the container.
    Going even one step further, cloud providers like DigitalOcean offer compute and
    storage capacity in professionally managed and secured data centers within minutes
    and billed by the hour. This in combination with a Python 3.6 installation and
    a secured Jupyter Notebook server installation provides a professional environment
    for Python development and deployment in the context of algorithmic trading projects.
  prefs: []
  type: TYPE_NORMAL
- en: Further Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For *Python package management*, consult the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`pip` package manager page](https://pypi.python.org/pypi/pip)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`conda` package manager page](http://conda.pydata.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[official Installing Packages page](https://packaging.python.org/installing/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For *virtual environment management*, consult these resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`virtualenv` environment manager page](https://pypi.python.org/pypi/virtualenv)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`conda` Managing Environments page](http://conda.pydata.org/docs/using/envs.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Information about *Docker containers* is found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Docker home page](http://docker.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Matthias, Karl and Sean Kane (2015): *Docker: Up and Running.* O’Reilly, Beijing
    et al.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Robbins (2016) provides a concise introduction to and overview of the `bash`
    *scripting language*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Robbins, Arnold (2016): *Bash Pocket Reference*. 2nd ed., O’Reilly, Beijing
    et al.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to run a *public Jupyter Notebook server securely* is explained under [Running
    a Notebook Server](http://jupyter-notebook.readthedocs.io/en/latest/public_server.html).
  prefs: []
  type: TYPE_NORMAL
- en: To sign up on DigitalOcean with a 10 USD starting credit in your new account
    visit this [sign-up page](https://m.do.co/c/fbe512dd3dac). This pays for two months
    of usage of the smallest droplet.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch02.html#idm140277702866800-marker)) At the time of this writing, Python
    3.7beta has just been released.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch02.html#idm140277702388192-marker)) On Windows, the command to activate
    the new environment would only be `activate py27` — dropping the `source`.
  prefs: []
  type: TYPE_NORMAL
- en: '^([3](ch02.html#idm140277702377552-marker)) In the official documentation you
    find the following explanation: "`Python ''Virtual Environments'' allow Python
    packages to be installed in an isolated location for a particular application,
    rather than being installed globally.`" See the [Creating Virtual Environments
    page](https://packaging.python.org/installing/#creating-virtual-environments).'
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch02.html#idm140277702366912-marker)) See the book Matthias and Kane (2015)
    for a comprehensive introduction to the Docker technology.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch02.html#idm140277702354096-marker)) For a concise introduction to and
    quick overview of `bash` scripting consult the book Robbins (2016).
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch02.html#idm140277702285376-marker)) With such a self-generated certificate
    you might need to add a security exception when prompted by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch02.html#idm140277701971712-marker)) If you need assistance, visit the
    [How To Use SSH Keys with DigitalOcean Droplets](https://www.digitalocean.com/community/tutorials/how-to-use-ssh-keys-with-digitalocean-droplets)
    or [How To Use SSH Keys with PuTTY on DigitalOcean Droplets (Windows users)](https://www.digitalocean.com/community/tutorials/how-to-use-ssh-keys-with-putty-on-digitalocean-droplets-windows-users).
  prefs: []
  type: TYPE_NORMAL
